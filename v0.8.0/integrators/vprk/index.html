<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>VPRK · GeometricIntegrators.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GeometricIntegrators.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorial/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../equations/">Equations</a></li><li><span class="tocitem">Integrators</span><ul><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../rk/">Runge-Kutta</a></li><li><a class="tocitem" href="../splitting/">Splitting</a></li><li><a class="tocitem" href="../variational/">Variational</a></li><li class="is-active"><a class="tocitem" href>VPRK</a><ul class="internal"><li><a class="tocitem" href="#Discrete-Action-Princtiple"><span>Discrete Action Princtiple</span></a></li><li><a class="tocitem" href="#Lobatto-Methods"><span>Lobatto Methods</span></a></li><li><a class="tocitem" href="#sec:degenerate-lagrangian-systems"><span>Degenerate Lagrangians</span></a></li><li><a class="tocitem" href="#sec:dirac-constraints"><span>Dirac Constraints</span></a></li><li><a class="tocitem" href="#Projection-Methods"><span>Projection Methods</span></a></li></ul></li><li><a class="tocitem" href="../spark/">SPARK</a></li><li><a class="tocitem" href="../cgvi/">CGVI</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../../modules/equations/">Equations</a></li><li><a class="tocitem" href="../../modules/integrators/">Integrators</a></li><li><a class="tocitem" href="../../modules/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../modules/simulations/">Simulations</a></li><li><a class="tocitem" href="../../modules/solutions/">Solutions</a></li></ul></li><li><span class="tocitem">Tableaus</span><ul><li><a class="tocitem" href="../../tableaus/rungekutta/">Runge-Kutta Methods</a></li><li><a class="tocitem" href="../../tableaus/rungekutta_partitioned/">Partitioned Runge-Kutta Methods</a></li><li><a class="tocitem" href="../../tableaus/splitting/">Splitting Methods</a></li><li><a class="tocitem" href="../../tableaus/vprk/">VPRK Methods</a></li><li><a class="tocitem" href="../../tableaus/spark/">SPARK Methods</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../developer/code_integration/">Code Integration</a></li><li><a class="tocitem" href="../../developer/custom_integrators/">Custom Integrators</a></li></ul></li><li><a class="tocitem" href="../../releasenotes/">Release Notes</a></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Integrators</a></li><li class="is-active"><a href>VPRK</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>VPRK</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGNI/GeometricIntegrators.jl/blob/master/docs/src/integrators/vprk.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Variational-Partitioned-Runge-Kutta-Integrators"><a class="docs-heading-anchor" href="#Variational-Partitioned-Runge-Kutta-Integrators">Variational Partitioned Runge-Kutta Integrators</a><a id="Variational-Partitioned-Runge-Kutta-Integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Variational-Partitioned-Runge-Kutta-Integrators" title="Permalink"></a></h1><p>Variational partitioned Runge-Kutta methods solve Lagranian systems in implicit form, i.e.,</p><p class="math-container">\[\begin{aligned}
p       &amp;= \dfrac{\partial L}{\partial \dot{q}} (q, \dot{q}) , &amp;
\dot{p} &amp;= \dfrac{\partial L}{\partial q}       (q, \dot{q}) , 
\end{aligned}\]</p><p>by the following scheme,</p><p class="math-container">\[\begin{equation}\label{eq:vprk}
\begin{aligned}
P_{n,i} &amp;= \dfrac{\partial L}{\partial v} (Q_{n,i}, V_{n,i}) , &amp;
Q_{n,i} &amp;= q_{n} + h \sum \limits_{j=1}^{s} a_{ij} \, V_{n,j} , &amp;
q_{n+1} &amp;= q_{n} + h \sum \limits_{i=1}^{s} b_{i} \, V_{n,i} , \\
F_{k,i} &amp;= \dfrac{\partial L}{\partial q} (Q_{n,i}, V_{n,i}) , &amp;
P_{n,j} &amp;= p_{n} + h  \sum \limits_{i=1}^{s} \bar{a}_{ij} \, F_{n,j} , &amp;
p_{n+1} &amp;= p_{n} + h \sum \limits_{i=1}^{s} b_{i} \, F_{n,i} .
\end{aligned}
\end{equation}\]</p><p>Here, <span>$s$</span> denotes the number of internal stages, <span>$a_{ij}$</span> and <span>$\bar{a}_{ij}$</span> are the coefficients of the Runge-Kutta method and <span>$b_{i}$</span> and <span>$\bar{b}_{i}$</span> the corresponding weights. If the coefficients satisfy the symplecticity conditions,</p><p class="math-container">\[\begin{aligned}
b_{i} \bar{a}_{ij} + \bar{b}_{j} a_{ji} &amp;= b_{i} \bar{b}_{j} &amp;
&amp; \text{and} &amp;
\bar{b}_{i} &amp;= b_{i} ,
\end{aligned}\]</p><p>these methods correspond to the position-momentum form of the discrete Lagrangian [<a href="../../bibliography/#MarsdenWest:2001">Jerrold E. Marsden , Matthew West  (2001)</a>]</p><p class="math-container">\[\begin{equation}\label{eq:vprk-discrete-lagrangian}
L_{d} (q_{n}, q_{n+1}) = h \sum \limits_{i=1}^{s} b_{i} \, L \big( Q_{n,i}, V_{n,i} \big) .
\end{equation}\]</p><p>While these integrators show favourable properties for systems with regular Lagrangian, they are usually not applicable for degenerate Lagrangian systems, in particular those with Lagrangians of the form <span>$L (q, \dot{q}) = \vartheta(q) \cdot \dot{q} - H(q)$</span>. While variational integrators are still applicable in the case of <span>$\vartheta$</span> being a linear function of <span>$q$</span>, they are often found to be unstable when <span>$\vartheta$</span> is a nonlinear function of <span>$q$</span> as is the case with Lotka-Volterra systems, various nonlinear oscillators, guiding centre dynamics and other reduced charged particle models. To mitigate this problem, projection methods have been developed, which can be used in conjunction with variational integrators. These projected variational integrators provide long-time stable methods for general degenerate Lagrangian systems that maintain conservation of energy and momenta over long integration periods [<a href="../../bibliography/#Kraus:2017">Michael Kraus  (2017)</a>].</p><p>GeometricIntegrators.jl provides the following VPRK methods:</p><table><tr><th style="text-align: left">Integrator</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="../../modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRK"><code>IntegratorVPRK</code></a></td><td style="text-align: left">Variational Partitioned Runge-Kutta (VPRK) integrator without projection</td></tr><tr><td style="text-align: left"><a href="../../modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard"><code>IntegratorVPRKpStandard</code></a></td><td style="text-align: left">VPRK integrator with <a href="#sec:standard-projection">standard projection</a></td></tr><tr><td style="text-align: left"><a href="../../modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymmetric"><code>IntegratorVPRKpSymmetric</code></a></td><td style="text-align: left">VPRK integrator with <a href="#sec:symmetric-projection">symmetric projection</a></td></tr><tr><td style="text-align: left"><a href="../../modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpMidpoint"><code>IntegratorVPRKpMidpoint</code></a></td><td style="text-align: left">VPRK integrator with <a href="#sec:midpoint-projection">midpoint projection</a></td></tr><tr><td style="text-align: left"><a href="../../modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariational"><code>IntegratorVPRKpVariational</code></a></td><td style="text-align: left">VPRK integrator with variational projection (<em>unstable</em>)</td></tr><tr><td style="text-align: left"><a href="../../modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary"><code>IntegratorVPRKpSecondary</code></a></td><td style="text-align: left">VPRK integrator with projection on secondary constraint</td></tr><tr><td style="text-align: left"><a href="../../modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpInternal"><code>IntegratorVPRKpInternal</code></a></td><td style="text-align: left">Gauss-Legendre VPRK integrator with projection on internal stages of Runge-Kutta method</td></tr><tr><td style="text-align: left"><a href="../../modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpTableau"><code>IntegratorVPRKpTableau</code></a></td><td style="text-align: left">Gauss-Legendre VPRK integrator with projection in tableau of Runge-Kutta method</td></tr></table><p>For testing purposes <a href="../../modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard"><code>IntegratorVPRKpStandard</code></a> provides some additional constructors (<em>note that these methods are generally unstable</em>):</p><table><tr><th style="text-align: left">Integrator</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="../../modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalQ-Tuple"><code>IntegratorVPRKpVariationalQ</code></a></td><td style="text-align: left">VPRK integrator with variational projection on <span>$(q_{n}, p_{n+1})$</span></td></tr><tr><td style="text-align: left"><a href="../../modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalP-Tuple"><code>IntegratorVPRKpVariationalP</code></a></td><td style="text-align: left">VPRK integrator with variational projection on <span>$(p_{n}, q_{n+1})$</span></td></tr><tr><td style="text-align: left"><a href="../../modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymplectic-Tuple"><code>IntegratorVPRKpSymplectic</code></a></td><td style="text-align: left">VPRK integrator with <a href="#sec:symplectic-projection">symplectic projection</a></td></tr></table><p>All of the above integrators are applied to either an <a href="../../modules/equations/#GeometricIntegrators.Equations.IODE"><code>IODE</code></a> or <a href="../../modules/equations/#GeometricIntegrators.Equations.LODE"><code>LODE</code></a> and instantiated as follows:</p><pre><code class="language-julia">int = IntegratorVPRK(iode, tab, Δt)</code></pre><p>The only exception is <a href="../../modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary"><code>IntegratorVPRKpSecondary</code></a> which can only be applied to an <a href="../../modules/equations/#GeometricIntegrators.Equations.LODE"><code>LODE</code></a> as it needs some additional functions which are only defined for variational problems.</p><h2 id="Discrete-Action-Princtiple"><a class="docs-heading-anchor" href="#Discrete-Action-Princtiple">Discrete Action Princtiple</a><a id="Discrete-Action-Princtiple-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-Action-Princtiple" title="Permalink"></a></h2><p>Symplectic partitioned Runge-Kutta integrators have been shown to be variational integrators [<a href="../../bibliography/#MarsdenWest:2001">Jerrold E. Marsden , Matthew West  (2001)</a>, <a href="../../bibliography/#HairerLubichWanner:2006">Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006)</a>]. Here, the discrete Lagrangian \eqref{eq:vprk-discrete-lagrangian} has <span>$s$</span> internal points (or stages) located at <span>$t_{n} + h c_{i}$</span> with weights <span>$b_{i}$</span> which are all non-zero and sum up to one. The internal stages <span>$Q_{n,i} \approx q(t_{n} + h c_{i})$</span> are given by</p><p class="math-container">\[Q_{n,i} = q_{n} + h \sum \limits_{j=1}^{s} a_{ij} \, V_{n,j} .\]</p><p>In contrast to the composition methods, we do not require <span>$c_{1} = 0$</span> and <span>$c_{s} = 1$</span>. Instead the discrete action is extremised under the constraints</p><p class="math-container">\[q_{n+1} = q_{n} + h \sum \limits_{i=1}^{s} b_{i} \, V_{n,i} ,\]</p><p>which we add to the action with the Lagrange multiplier <span>$\lambda_{n+1}$</span>, so that we can write</p><p class="math-container">\[\begin{equation}\label{eq:vprk-action-gauss}
\mathcal{A}_{d} = \sum \limits_{n=1}^{N-1} \bigg[ h \sum \limits_{i=1}^{s} b_{i} \, L \big( Q_{n,i}, V_{n,1} \big) + \lambda_{n+1} \cdot \bigg( q_{n+1} - q_{n} - h \sum \limits_{i=1}^{s} b_{i} \, V_{n,i} \bigg) \bigg] .
\end{equation}\]</p><p>Computing variations of the action leads to</p><p class="math-container">\[\begin{aligned}
\delta \mathcal{A}_{d}
&amp;= \sum \limits_{n=1}^{N-1}\left[ h \sum \limits_{i=1}^{s} h b_{i} a_{ij} \, \dfrac{\partial L}{\partial q} (Q_{n,i}, V_{n,i}) 
 + h b_{j} \, \dfrac{\partial L}{\partial v} (Q_{n,j}, V_{n,j})
 - h b_{j} \, \lambda_{n+1} \right] \cdot \delta V_{n,j} \\
&amp;+ \sum \limits_{n=1}^{N-1}\left[ h \sum \limits_{i=1}^{s} b_{i} \, \dfrac{\partial L}{\partial q} (Q_{n,i}, V_{n,i}) 
 - \lambda_{n+1} + \lambda_{n} \right] \cdot \delta q_{n} \\
&amp;+ \sum \limits_{n=1}^{N-1} \bigg[ q_{n+1} - q_{n} - h \sum \limits_{i=1}^{s} b_{i} \, V_{n,i} \bigg] \cdot \delta \lambda_{n+1}
 = 0 .
\end{aligned}\]</p><p>We define discrete forces and momenta as</p><p class="math-container">\[F_{n,i} = \dfrac{\partial L}{\partial q} (Q_{n,i}, V_{n,i})
\hspace{3em}
\text{and}
\hspace{3em}
P_{n,i} = \dfrac{\partial L}{\partial v} (Q_{n,i}, V_{n,i}) ,\]</p><p>so that the terms of the variation which are multiplying <span>$\delta V_{n,j}$</span> become</p><p class="math-container">\[P_{n,j} = \lambda_{n+1} - h \sum \limits_{i=1}^{s} \dfrac{b_{i} a_{ij}}{b_{j}} \, F_{n,i} .\]</p><p>The terms of the variations which are multiplying <span>$\delta q_{n}$</span> become</p><p class="math-container">\[\lambda_{n+1} = \lambda_{n} + h \sum \limits_{i=1}^{s} b_{i} \, F_{n,i} .\]</p><p>Similar to classical <a href="../variational/#variational-integrators">variational integrators</a>, we can use the discrete fibre derivative</p><p class="math-container">\[\begin{equation}\label{eq:discrete-fibre-derivative}
\begin{aligned}
\mathbb{F}^{-} L_{d} : (q_{n}, q_{n+1}) &amp;\mapsto (q_{n},   p_{n})   = \big( q_{n}  , - D_{1} L_{d} (q_{n}, q_{n+1}) \big) , \\
\mathbb{F}^{+} L_{d} : (q_{n}, q_{n+1}) &amp;\mapsto (q_{n+1}, p_{n+1}) = \big( q_{n+1},   D_{2} L_{d} (q_{n}, q_{n+1}) \big) .
\end{aligned}
\end{equation}\]</p><p>to define the position-momentum form of the integrator,</p><p class="math-container">\[\begin{equation}\label{eq:vi-position-momentum-form}
\begin{aligned}
p_{n  }
&amp;=           -  D_{1} L_{d} (q_{n}, q_{n+1})
 = \lambda_{n+1} - h \sum \limits_{i=1}^{s} b_{i} \, F_{n,i} , \\
p_{n+1}
&amp;= \hphantom{-} D_{2} L_{d} (q_{n}, q_{n+1})
 = \lambda_{n+1} .
\end{aligned}
\end{equation}\]</p><p>Replacing <span>$\lambda_{n+1}$</span> in the second equation with its expression obtained from the first equation, we get</p><p class="math-container">\[p_{n+1} = p_{n} + h \sum \limits_{i=1}^{s} v_{i} \, F_{n,i} ,\]</p><p>which states that the second symplecticity condition (<span>$b_{i} = \bar{b}_{i}$</span>) is automatically satisfied. In the same fashion, we obtain</p><p class="math-container">\[P_{n,j} = p_{n} + h \sum \limits_{i=1}^{s} \bar{a}_{ij} \, F_{n,j} ,\]</p><p>with</p><p class="math-container">\[\bar{a}_{ij} = b_{j} - b_{j} a_{ji} / b_{i} ,\]</p><p>such that the first symplecticity condition is also satisfied. In summary, we obtain the variational-partitioned Runge-Kutta integrator \eqref{eq:vprk}. If the fibre derivative is invertible, an equivalent set of equations can be obtained by applying</p><p class="math-container">\[\begin{aligned}
V_{n,i} &amp;=   \dfrac{\partial H}{\partial p} (Q_{n,i}, P_{n,i}) , &amp;
F_{n,i} &amp;= - \dfrac{\partial H}{\partial q} (Q_{n,i}, P_{n,i}) ,
\end{aligned}\]</p><p>to the Hamiltonian <span>$H(q,p)$</span> obtained via the Legendre transform. The interested reader can find more details on this in [<a href="../../bibliography/#HairerLubichWanner:2006">Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006)</a>] and references therein.</p><h2 id="Lobatto-Methods"><a class="docs-heading-anchor" href="#Lobatto-Methods">Lobatto Methods</a><a id="Lobatto-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Lobatto-Methods" title="Permalink"></a></h2><p>Some words of caution are in order. The above derivation works well, if all discrete velocities <span>$V_{n,i}$</span> are linearly independent. This is the case e.g. for Gauss-Legendre Runge-Kutta discretizations but not for Lobatto discretizations (see <a href="../../bibliography/#OberBloebaum:2016">Sina Ober-Blöbaum  (2016)</a> for details). For discretizations of Lobatto-IIIA type, where the first internal stage coincides with the solution at the previous time step, the velocities <span>$V_{n,i}$</span> are not linearly independent and the discrete action \eqref{eq:vprk-action-gauss} needs to be augmented by an additional constraint to take this dependence into account,</p><p class="math-container">\[\begin{equation}\label{eq:vprk-action-lobatto}
\begin{aligned}
\mathcal{A}_{d} =
\sum \limits_{n=0}^{N-1} \Bigg\lgroup
h \sum \limits_{i=1}^{s} b_{i} \, \bigg[ L \big( Q_{n,i}, V_{n,i} \big)
+ F_{n,i} \cdot \bigg( Q_{n,i} - q_{n} - h \sum \limits_{j=1}^{s} a_{ij} \, V_{n,j} \bigg) \bigg] \\
- p_{n+1} \cdot \bigg( q_{n+1} - q_{n} - h \sum \limits_{i=1}^{s} b_{i} \, V_{n,i} \bigg)
+ \mu_{n} \cdot \bigg( \sum \limits_{i=1}^{s} d_{i} V_{n,i} \bigg)
\Bigg\rgroup .
\end{aligned}
\end{equation}\]</p><p>Requiring stationarity of \eqref{eq:vprk-action-lobatto}, we obtain a modified system of equations,</p><p class="math-container">\[\begin{equation}\label{eq:vprk-lobatto}
\begin{aligned}
P_{n,i} &amp;= \dfrac{\partial L}{\partial v} (Q_{n,i}, V_{n,i}) , &amp;
F_{n,i} &amp;= \dfrac{\partial L}{\partial q} (Q_{n,i}, V_{n,i}) , \\
Q_{n,i} &amp;= q_{n} + h \sum \limits_{j=1}^{s} a_{ij} \, V_{n,j} , &amp;
P_{n,i} &amp;= p_{n} + h \sum \limits_{j=1}^{s} \bar{a}_{ij} \, F_{n,j} - \mu_{n} \dfrac{d_{i}}{b_{i}} , \\
q_{n+1} &amp;= q_{n} + h \sum \limits_{i=1}^{s} b_{i}  \, V_{n,i} , &amp;
p_{n+1} &amp;= p_{n} + h \sum \limits_{i=1}^{s} \bar{b}_{i}  \, F_{n,i} , \\
0 &amp;= \sum \limits_{i=1}^{s} d_{i} V_{n,i} ,
\end{aligned}
\end{equation}\]</p><p>accounting for the linear dependence of the <span>$\dot{Q}_{n,i}$</span> and consequently also of the <span>$P_{n,i}$</span>. The particular values of <span>$d_{i}$</span> depend on the number of stages <span>$s$</span> and the definition of the <span>$q_{n,i}$</span> [<a href="../../bibliography/#OberBloebaum:2016">Sina Ober-Blöbaum  (2016)</a>]. For two stages, we have <span>$d_{1} = - d_{2}$</span>, so that we can choose, for example, <span>$d = (+1, -1)$</span>, and \eqref{eq:vprk-lobatto} becomes equivalent to the variational integrator of the trapezoidal Lagrangian. For three stages, we can choose <span>$d = (\tfrac{1}{2}, -1, \tfrac{1}{2})$</span>, and for four stages we can use <span>$d = (+1, -\sqrt{5}, +\sqrt{5}, -1)$</span>. In GeometricIntegrators, these vectors can be obtained via the function <a href="../../tableaus/rungekutta/#RungeKutta.Tableaus.get_lobatto_nullvector-Union{Tuple{T}, Tuple{Type{T},Any}} where T"><code>get_lobatto_nullvector</code></a> from <a href="https://github.com/JuliaGNI/RungeKutta.jl">RungeKutta.jl</a>.</p><p>Another approach that always works is to use directly compute the position-momentum form \eqref{eq:vi-position-momentum-form} of the variational integrator for the discrete Lagrangian \eqref{eq:vprk-discrete-lagrangian} instead of applying the discrete action principle. Such subtleties, which are easily overlooked, can be avoided by starting the discretisation of the action from a more fundamental point of view, namely by approximating the function spaces of the trajectories, which leads us to <a href="../cgvi/#cgvi">Galerkin Variational Integrators</a>.</p><h2 id="sec:degenerate-lagrangian-systems"><a class="docs-heading-anchor" href="#sec:degenerate-lagrangian-systems">Degenerate Lagrangians</a><a id="sec:degenerate-lagrangian-systems-1"></a><a class="docs-heading-anchor-permalink" href="#sec:degenerate-lagrangian-systems" title="Permalink"></a></h2><p>Degenerate Lagrangian systems are relevant for the study of population models, point vortex dynamics or reduced charged particle models like the guiding centre system. Here, we consider degenerate Lagrangian systems characterized by a Lagrangian that is linear or singular in the velocities. In particular, we consider the class of systems whose Lagrangian is of the form</p><p class="math-container">\[\begin{equation}\label{eq:degenerate-lagrangian}
L (q, v) = \vartheta(q) \cdot v - H(q) .
\end{equation}\]</p><p>The Lagrangian <span>$L$</span> is a function on the tangent bundle <span>$\tb{\mf{M}}$</span>,</p><p class="math-container">\[\begin{equation}\label{eq:lagrangian-tangent-bundle}
L : \tb{\mf{M}} \rightarrow \mathbb{R} ,
\end{equation}\]</p><p>where <span>$\mf{M}$</span> denotes the configuration manifold of the system which is assumed to be of dimension <span>$d$</span>. The cotangent bundle of the configuration manifold <span>$\mf{M}$</span> is denoted by <span>$\cb{\mf{M}}$</span>. Further, we denote the coordinates of a point <span>$m \in \mf{M}$</span> by <span>$q(m) = (q^{1} (m), \dotsc, q^{d} (m))$</span> and similarly coordinates of points in <span>$\tb{\mf{M}}$</span> by <span>$(q^{i}, v^{i})$</span> and coordinates of points in <span>$\cb{\mf{M}}$</span> by <span>$(q^{i}, p^{i})$</span>. In the following, we will always assume the existence of a global coordinate chart, so that <span>$\mf{M}$</span> can be identified with the Euclidean space <span>$\mathbb{R}^{d}$</span>. For simplicity, we often use short-hand notation where we write <span>$q$</span> to refer to both a point in <span>$\mf{M}$</span> as well as its coordinates. Similarly, we often denote points in the tangent bundle <span>$\tb{\mf{M}}$</span> by <span>$(q, v)$</span>. In local coordinates, the Lagrangian \eqref{eq:lagrangian-tangent-bundle} is thus written as a map <span>$(q, v) \mapsto L(q, v)$</span>.</p><p>In Equation \eqref{eq:degenerate-lagrangian}, <span>$\vartheta = \vartheta_{i} (q) \, \ext q^{i}$</span> is a differential one-form <span>$\vartheta : \mf{M} \rightarrow \cb{\mf{M}}$</span>, whose components <span>$\vartheta_{i} : \mf{M} \rightarrow \mathbb{R}$</span> are general, possibly nonlinear functions of <span>$q$</span>, some of which (but not all) could be identically zero. For details on differential forms, tangent and cotangent bundles the interested reader may consult any modern book in mathematical physics or differential geometry. We recommend <a href="../../bibliography/#Dray:2014">Tevian Dray  (2014)</a>, <a href="../../bibliography/#BaezMuniain:1994">John Baez , Javier P. Muniain  (1994)</a>, <a href="../../bibliography/#Darling:1994">Richard W. R. Darling  (1994)</a>, <a href="../../bibliography/#Frankel:2011">Theodore Frankel  (2011)</a> for more physics oriented accounts and <a href="../../bibliography/#Lee:2012">John M. Lee  (2012)</a>, <a href="../../bibliography/#Lee:2009">Jeffrey M. Lee  (2009)</a>, <a href="../../bibliography/#Tu:2011">Loring W. Tu  (2011)</a>, <a href="../../bibliography/#Morita:2001">Shigeyuki Morita  (2001)</a> for more mathematics oriented accounts. In the following we assume a basic understanding of these concepts. To see their usefulness for classical mechanics we refer to <a href="../../bibliography/#AbrahamMarsden:1978">Ralph Abraham , Jerrold E. Marsden  (1978)</a>, <a href="../../bibliography/#MarsdenRatiu:2002">Jerrold E. Marsden , Tudor S. Ratiu  (2002)</a>, <a href="../../bibliography/#Holm:2009">Darryl D. Holm , Tanya Schmah , Cristina Stoica  (2009)</a>.</p><h2 id="sec:dirac-constraints"><a class="docs-heading-anchor" href="#sec:dirac-constraints">Dirac Constraints</a><a id="sec:dirac-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#sec:dirac-constraints" title="Permalink"></a></h2><p>Degenerate systems of the form \eqref{eq:degenerate-lagrangian} can also be formulated in terms of the phasespace trajectory <span>$(q, p)$</span> in the cotangent bundle <span>$\cb{\mf{M}}$</span>, subject to a primary constraint in the sense of Dirac, determined by the function <span>$\phi : \cb{\mf{M}} \rightarrow \mathbb{R}^{d}$</span>, given by</p><p class="math-container">\[\begin{equation}\label{eq:dirac_constraint}
\phi (q, p) = p - \vartheta(q) = 0 ,
\end{equation}\]</p><p>and originating from the fibre derivative <span>$\mathbb{F} L : \tb{\mf{M}} \rightarrow \cb{\mf{M}}$</span>,</p><p class="math-container">\[\begin{equation}\label{eq:fibre-derivative-general}
\mathbb{F} L (v_{q}) \cdot w_{q} = \dfrac{d}{d\epsilon} \bigg\vert_{\epsilon=0} L(v_{q} + \epsilon w_{q}) ,
\end{equation}\]</p><p>where <span>$v_{q} = (q, v)$</span> and <span>$w_{q} = (q, w)$</span> denote two points in <span>$\tb{\mf{M}}$</span> which share the same base point <span>$q$</span> and are thus elements of the same fibre of <span>$\tb{\mf{M}}$</span>. By acting point-wise for each <span>$t$</span>, the fibre derivative maps the curve <span>$(q, \dot{q})$</span> in the tangent bundle <span>$\tb{\mf{M}}$</span> into the curve <span>$(q, p)$</span> in the cotangent bundle <span>$\cb{\mf{M}}$</span>,</p><p class="math-container">\[\begin{equation}\label{eq:fibre_derivative}
(q (t), p (t)) = \left( q (t), \dfrac{\partial L}{\partial v} (q (t), \dot{q} (t)) \right) = (q (t), \vartheta (q (t))) ,
\end{equation}\]</p><p>where the last equality follows for Lagrangians of the form \eqref{eq:degenerate-lagrangian}. The Dirac constraint arising from the degenerate Lagrangian restricts the dynamics to the submanifold</p><p class="math-container">\[\begin{equation}\label{eq:constraint-submanifold}
\Delta = \big\{ (q, p) \in \cb{\mf{M}} \, \big\vert \, \phi (q, p) = 0  \big\} \subset \cb{\mf{M}} .
\end{equation}\]</p><p>In the preceding and the following, we assume that the Lagrangian is degenerate in all velocity components, that is, the Lagrangian is either linear or singular in each component of <span>$v$</span>, so that</p><p class="math-container">\[\dfrac{\partial^{2} L}{\partial v^{i} \, \partial v^{j}} = 0
\hspace{3em}
\text{for all $1 \leq i,j \leq d$.}\]</p><p>For instructive reasons, however, assume for a moment that the Lagrangian is degenerate in only <span>$m &lt; d$</span> components of <span>$v$</span> and, e.g., quadratic in the other <span>$d-m$</span> components. That is to say we can write</p><p class="math-container">\[p (t)
= \big( \beta_{1} (q (t), \dot{q} (t)), \dotsc, \beta_{d-m} (q (t), \dot{q} (t)), \, \vartheta_{d-m+1} (q (t)), \dotsc, \vartheta_{d} (q (t)) \big)^{T} ,\]</p><p>where</p><p class="math-container">\[\dfrac{\partial L}{\partial v^{i}} (q (t), \dot{q} (t)) = \begin{cases}
\beta_{i} (q (t), \dot{q} (t)) &amp; 1 \leq i \leq d - m , \\
\vartheta_{i} (q (t)) &amp; d-m+1 \leq i \leq d . \\
\end{cases}\]</p><p>We can then denote coordinates in <span>$\Delta$</span> by <span>$(q^{i}, \pi^{j})$</span> with <span>$1 \leq i \leq d$</span> and <span>$1 \leq j \leq d-m$</span>, where the <span>$\pi^{i}$</span> denote those momenta which are ``free&#39;&#39;, i.e., not determined by the Dirac constraint. The inclusion map <span>$i : \Delta \rightarrow \cb{\mf{M}}$</span> can then be written as</p><p class="math-container">\[\begin{equation}\label{eq:dirac-inclusion_genereal}
i : (q, \pi) \mapsto (q, \pi, \vartheta (q)) .
\end{equation}\]</p><p>In the fully degenerate case, however, we have <span>$m=d$</span>, so that the configuration manifold <span>$\mf{M}$</span> and the constraint submanifold <span>$\Delta$</span> are isomorphic and we can label points in <span>$\Delta$</span> by the same <span>$q$</span> we use to label points in <span>$\mf{M}$</span>. The inclusion map <span>$i : \Delta \rightarrow \cb{\mf{M}}$</span> simplifies accordingly and reads</p><p class="math-container">\[\begin{equation}\label{eq:dirac-inclusion}
i : q \mapsto (q, \vartheta (q)) ,
\end{equation}\]</p><p>where it is important to keep in mind that <span>$q$</span> denotes a point in <span>$\Delta$</span>. The inverse operation is given by the projection <span>$\pi_{\Delta} : \cb{\mf{M}} \rightarrow \Delta$</span>, defined such that <span>$\pi_{\Delta} \circ i = \id$</span>.</p><p>As we are lacking a general framework for constructing structure-preserving numerical algorithms for noncanonical Hamiltonian systems on <span>$\mf{M}$</span>, we will construct such algorithms on <span>$i(\Delta)$</span>. This can be achieved by using canonically symplectic integrators on <span>$\cb{\mf{M}}$</span> and assuring that their solution stays on <span>$i(\Delta)$</span>. To this end we will employ various projection methods.</p><h2 id="Projection-Methods"><a class="docs-heading-anchor" href="#Projection-Methods">Projection Methods</a><a id="Projection-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Projection-Methods" title="Permalink"></a></h2><p>Projection methods are a standard technique for the integration of ordinary differential equations on manifolds [<a href="../../bibliography/#Hairer:2001">Ernst Hairer  (2001)</a>, <a href="../../bibliography/#HairerLubichWanner:2006">Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006)</a>]. The problem of constructing numerical integrators on manifolds with complicated structure is often difficult and thus avoided by embedding the manifold into a larger space with simple, usually Euclidean structure, where standard integrators can be applied. Projection methods are then used to ensure that the solution stays on the correct subspace of the extended solution space, as that is usually not guaranteed by the numerical integrator itself.</p><p>In the standard projection method, a projection is applied after each step of the numerical algorithm. Assuming that the initial condition lies in the manifold, the solution of the projected integrator will stay in the manifold. The problem with this approach is that even though assuming that the numerical integrator is symmetric, the whole algorithm comprised of the integrator and the projection will not be symmetric. This often leads to growing errors in the solution and consequently a drift in the total energy of the system. This can be remedied by symmetrizing the projection [<a href="../../bibliography/#Hairer:2000">Ernst Hairer  (2000)</a>, <a href="../../bibliography/#Hairer:2001">Ernst Hairer  (2001)</a>, <a href="../../bibliography/#Chan:2004">Robert P. K. Chan , Philippe Chartier , Ander Murua  (2004)</a>, <a href="../../bibliography/#HairerLubichWanner:2006">Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006)</a>], where the initial data is first perturbed out of the constraint submanifold, before the numerical integrator is applied, and then projected back to the manifold. This leads to very good long-time stability and improved energy behaviour.</p><p>While such projection methods, both standard and symmetric ones, are standard procedures for conserving energy, as well as holonomic and non-holonomic constraints, not much is known about their application to Dirac constraints.  Some authors consider general differential algebraic systems of index two [<a href="../../bibliography/#HairerLubichRoche:1989">Ernst Hairer , Christian Lubich , Michel Roche  (1989)</a>, <a href="../../bibliography/#Ascher:1991">Uri M. Ascher , Linda R. Petzold  (1991)</a>, <a href="../../bibliography/#Chan:2002">Robert P. K. Chan , Philippe Chartier , Ander Murua  (2002)</a>, <a href="../../bibliography/#Chan:2004">Robert P. K. Chan , Philippe Chartier , Ander Murua  (2004)</a>, <a href="../../bibliography/#Jay:2003">Laurent O. Jay  (2003)</a>, <a href="../../bibliography/#Jay:2006">Laurent O. Jay  (2006)</a>], the class to which the systems considered here belong, but a discussion of symplecticity seems to be mostly lacking from the literature, aside from some remarks on the conservation of quadratic invariants by the post-projection method of [<a href="../../bibliography/#Chan:2002">Robert P. K. Chan , Philippe Chartier , Ander Murua  (2002)</a>].</p><p>In the following, we apply several projection methods (standard, symmetric, symplectic, midpoint) to variational integrators in position-momentum form. As it turns out, both the standard projection and the symmetric projection are not symplectic. The symmetric projection nevertheless shows very good long-time stability, as it can be shown to be pseudo-symplectic. The symplectic projection method, as the name suggests, is indeed symplectic, although in a generalized sense. The midpoint projection method is symplectic in the usual sense but only for particular integrators.</p><p>The general procedure is as follows. We start with initial conditions <span>$q_{n}$</span> on <span>$\Delta$</span> (recall that for the particular Lagrangian \eqref{eq:degenerate-lagrangian} considered here, the configuration manifold <span>$\mf{M}$</span> and the constraint submanifold <span>$\Delta$</span> are isomorphic, so that we can use the same coordinates on <span>$\Delta$</span> as we use on <span>$\mf{M}$</span>). We compute the corresponding momentum <span>$p_{n}$</span> by the continuous fibre derivative \eqref{eq:fibre-derivative-general}, which yields initial conditions <span>$(q_{n}, p_{n} = \vartheta(q_{n}))$</span> on <span>$\cb{\mf{M}}$</span> satisfying the constraint <span>$\phi(q_{n}, p_{n}) = 0$</span>. This corresponds to the inclusion map \eqref{eq:dirac-inclusion}. Then, we may or may not perturb these initial conditions off the constraint submanifold by applying a map <span>$(q_{n}, p_{n}) \mapsto (\bar{q}_{n}, \bar{p}_{n})$</span> which is either the inverse <span>$\mathbb{P}^{-1}$</span> of a projection <span>$\mathbb{P} : \cb{\mf{M}} \rightarrow i(\Delta)$</span> or, in the case of the <a href="#sec:standard-projection">standard projection</a>, just the identity. The perturbation is followed by the application of some canonically symplectic algorithm <span>$\Psi_{h}$</span> on <span>$\cb{\mf{M}}$</span>, namely a variational integrator in position-momentum form \eqref{eq:vi-position-momentum-form} or a variational Runge-Kutta method \eqref{eq:vprk} or \eqref{eq:vprk-lobatto}, in which cases we have that <span>$\Psi_{h} = \big( \mathbb{F}^{+} L_{d} \big) \circ \big( \mathbb{F}^{-} L_{d} \big)^{-1}$</span>. In general, the result of this algorithm, <span>$(\bar{q}_{n+1}, \bar{p}_{n+1}) = \Psi_{h} (\bar{q}_{n}, \bar{p}_{n})$</span>, will not lie on the constraint submanifold \eqref{eq:constraint-submanifold}. Therefore we apply a projection <span>$(\bar{q}_{n+1}, \bar{p}_{n+1}) \mapsto (q_{n+1}, p_{n+1})$</span> which enforces <span>$\phi (q_{n+1}, p_{n+1}) = p_{n+1} - \vartheta(q_{n+1}) = 0$</span>. As this final result is a point in <span>$i(\Delta)$</span> it is completely characterized by the value <span>$q_{n+1}$</span>.</p><p><img src="../images/omega-orthogonal-projection.png" alt/></p><p><em>Gradient of the constraint function <span>$\phi$</span> orthogonal and <span>$\Omega$</span>-orthogonal to constant surfaces of <span>$\phi(q, p) = p - \sqrt{p_{0}^{2} - q^{2}}$</span> for <span>$p_{0} \in \{ 1, 2, 3 \}$</span>.</em></p><p>Let us emphasize that in contrast to standard projection methods, where the solution is projected orthogonal to the constrained submanifold, along the gradient of <span>$\phi$</span>, here the projection has to be <span>$\Omega$</span>-orthogonal, where <span>$\Omega$</span> is the canonical symplectic matrix</p><p class="math-container">\[\begin{equation}\label{eq:canonical-symplectic-matrix}
\Omega = \begin{pmatrix}
\mathbb{0} &amp;           -  \mathbb{1} \\
\mathbb{1} &amp; \hphantom{-} \mathbb{0} 
\end{pmatrix} .
\end{equation}\]</p><p>That is, denoting by <span>$\lambda$</span> the Lagrange multiplier, the projection step is given by <span>$\Omega^{-1} \nabla \phi^{T} \lambda$</span> instead of an orthogonal projection <span>$\nabla \phi^{T} \lambda$</span>.</p><p>Let us also note that, practically speaking, the momenta <span>$p_{n}$</span> and <span>$p_{n+1}$</span> are merely treated as intermediate variables much like the internal stages of a Runge-Kutta method. The Lagrange multiplier <span>$\lambda$</span>, on the other hand, is determined in different ways for the different methods and can be the same or different in the perturbation and the projection. It thus takes the role of an internal variable only for the standard, symmetric projection and midpoint projection, but not for the symplectic projection.</p><h3 id="Geometric-Aside:-Projected-Fibre-Derivatives"><a class="docs-heading-anchor" href="#Geometric-Aside:-Projected-Fibre-Derivatives">Geometric Aside: Projected Fibre Derivatives</a><a id="Geometric-Aside:-Projected-Fibre-Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-Aside:-Projected-Fibre-Derivatives" title="Permalink"></a></h3><p>In the following, we will try to underpin the construction of the various projection methods with some geometric ideas. We already mentioned several times that the position-momentum form of the variational integrator \eqref{eq:vi-position-momentum-form} suffers from the problem that it does not preserve the constraint submanifold <span>$\Delta$</span> defined in \eqref{eq:constraint-submanifold}. That is, even though it is applied to a point in <span>$i(\Delta)$</span>, it usually returns a point in <span>$\cb{\mf{M}}$</span>, but outside of <span>$i(\Delta)$</span>. In order to understand the reason for this, let us define <span>$\Delta_{\mf{M}}^{-}$</span> and <span>$\Delta_{\mf{M}}^{+}$</span> as the subsets of <span>$\mf{M} \times \mf{M}$</span> which are mapped into the constraint submanifold <span>$i(\Delta)$</span> by the discrete fibre derivatives <span>$\mathbb{F}^{-} L_{d}$</span> and <span>$\mathbb{F}^{+} L_{d}$</span>, respectively, i.e.,</p><p class="math-container">\[\begin{equation}\label{eq:constraint-submanifold_QxQ}
\begin{aligned}
\Delta_{\mf{M}}^{-} &amp;= \{ (q_{n}, q_{n+1}) \in \mf{M} \times \mf{M} \, \big\vert \, \mathbb{F}^{-} L_{d} (q_{n}, q_{n+1}) = (q_{n}, p_{n}) \in i(\Delta) \big\} , \\
\Delta_{\mf{M}}^{+} &amp;= \{ (q_{n}, q_{n+1}) \in \mf{M} \times \mf{M} \, \big\vert \, \mathbb{F}^{+} L_{d} (q_{n}, q_{n+1}) = (q_{n+1}, p_{n+1}) \in i(\Delta) \big\} ,
\end{aligned}
\end{equation}\]</p><p>or more explicitly,</p><p class="math-container">\[\begin{equation}\label{eq:constraint-submanifold_QxQ_coordinates}
\begin{aligned}
\Delta_{\mf{M}}^{-} &amp;= \{ (q_{n}, q_{n+1}) \in \mf{M} \times \mf{M} \, \big\vert \, - D_{1} L_{d} (q_{n}, q_{n+1}) = \vartheta(q_{n}) \big\} , \\
\Delta_{\mf{M}}^{+} &amp;= \{ (q_{n}, q_{n+1}) \in \mf{M} \times \mf{M} \, \big\vert \, D_{2} L_{d} (q_{n}, q_{n+1}) = \vartheta(q_{n+1}) \big\} .
\end{aligned}
\end{equation}\]</p><p>A sufficient condition for the position-momentum form of the variational integrator \eqref{eq:vi-position-momentum-form} to preserve the constraint submanifold \eqref{eq:constraint-submanifold} would be that <span>$\Delta_{\mf{M}}^{-}$</span> and <span>$\Delta_{\mf{M}}^{+}$</span> are identical.  In principle, slightly weaker necessary conditions can be formulated, however in practice it is unclear how to prove any of these conditions and in general they are not satisfied.</p><p>In order to construct a modified algorithm which does preserve the constraint submanifold, we compose the discrete fibre derivatives <span>$\mathbb{F}^{\pm}$</span> with appropriate projections <span>$\mathbb{P}^{\pm}$</span>,</p><p class="math-container">\[\begin{equation}\label{eq:position_momentum_projection}
\begin{aligned}
(q_{n}, p_{n  })
&amp;= \big( \mathbb{P}^{-} \circ \mathbb{F}^{-} L_{d} \big) (q_{n}, q_{n+1})
 = \mathbb{P}_{\lambda_{n}^{-}}^{-} \big( q_{n}, -  D_{1} L_{d} (q_{n}, q_{n+1}) \big) , \\
(q_{n+1}, p_{n+1})
&amp;= \big( \mathbb{P}^{+} \circ \mathbb{F}^{+} L_{d} \big) (q_{n}, q_{n+1})
 = \mathbb{P}_{\lambda_{n+1}^{+}}^{+} \big( q_{n+1}, D_{2} L_{d} (q_{n}, q_{n+1}) \big) , 
\end{aligned}
\end{equation}\]</p><p>so that they take any point in <span>$\mf{M} \times \mf{M}$</span> to the constraint submanifold <span>$\Delta$</span>. The Lagrange multiplier <span>$\lambda$</span> is indicated as subscript and implicitly determined by requiring that the constraint <span>$\phi$</span> is satisfied by the projected values of <span>$q$</span> and <span>$p$</span>. These projected fibre derivatives will not be a fibre-preserving map anymore, but they will change both <span>$q$</span> and <span>$p$</span>. Noting that the nullspace of <span>$\mathbb{P}_{\lambda}$</span> is the span of <span>$\Omega^{-1} \nabla \phi$</span>, a natural candidate for the projection <span>$\mathbb{P}_{\lambda}$</span> is given by</p><p class="math-container">\[\begin{equation}\label{eq:projector}
\begin{aligned}
\mathbb{P}_{\lambda}^{\pm} (q, p) : (q, p) &amp;= (q, p) \pm h \, \Omega^{-1} \nabla \phi^{T} (q, p) \lambda , &amp;
0 &amp;= \phi(q, p) ,
\end{aligned}
\end{equation}\]</p><p>so that <span>$( \mathbb{P}^{-} \circ \mathbb{F}^{-} L_{d} ) (q_{n}, q_{n+1})$</span> explicitly reads</p><p class="math-container">\[\begin{aligned}
q_{n} &amp;= q_{n} - h \, \phi_{p}^{T} (q_{n}, p_{n}) \lambda_{n}^{-} , \\
p_{n} &amp;= - D_{1} L_{d} (q_{n}, q_{n+1}) + h \, \phi_{q}^{T} (q_{n}, p_{n}) \lambda_{n}^{-} , \\
0 &amp;= \phi(q_{n}, p_{n}) ,
\end{aligned}\]</p><p>and <span>$( \mathbb{P}^{+} \circ \mathbb{F}^{+} L_{d} ) (q_{n}, q_{n+1})$</span> explicitly reads</p><p class="math-container">\[\begin{aligned}
q_{n+1} &amp;= q_{n+1} + h \, \phi_{p}^{T} (q_{n+1}, p_{n+1}) \lambda_{n+1}^{+} , \\
p_{n+1} &amp;= D_{2} L_{d} (q_{n}, q_{n+1}) - h \, \phi_{q}^{T} (q_{n+1}, p_{n+1}) \lambda_{n+1}^{+} , \\
0 &amp;= \phi(q_{n+1}, p_{n+1}) .
\end{aligned}\]</p><p>The signs in front of the projections have been chosen in correspondence with the signs of the discrete forces in <a href="../../bibliography/#MarsdenWest:2001">Jerrold E. Marsden , Matthew West  (2001)</a>, Chapter 3. With these projections we obtain all of the algorithms introduced in the following sections, except for the midpoint projection, in a similar fashion to the definition of the position-momentum form of the variational integrator \eqref{eq:vi-position-momentum-form}, as a map <span>$\Delta \rightarrow \Delta$</span> which can formally be written as</p><p class="math-container">\[\begin{equation}\label{eq:projection-composition-map}
\Phi_{h} = \big( \pi_{\Delta} \circ \mathbb{P}^{+} \circ \mathbb{F}^{+} L_{d} \big) \circ \big( \pi_{\Delta} \circ \mathbb{P}^{-} \circ \mathbb{F}^{-} L_{d} \big)^{-1} .
\end{equation}\]</p><p>In total, we obtain algorithms which map <span>$q_{n}$</span> into <span>$q_{n+1}$</span> via the steps</p><p class="math-container">\[\Delta
\xrightarrow{\pi_{\Delta}^{-1}}
i(\Delta)
\xrightarrow{(\mathbb{P}^{-})^{-1}}
\cb{\mf{M}}
\xrightarrow{(\mathbb{F}^{-} L_{d})^{-1}}
\mf{M} \times \mf{M}
\xrightarrow{\mathbb{F}^{+} L_{d}}
\cb{\mf{M}}
\xrightarrow{\mathbb{P}^{+}}
i(\Delta)
\xrightarrow{\pi_{\Delta}}
\Delta ,\]</p><p>where <span>$\pi_{\Delta}^{-1}$</span> is identical to the inclusion \eqref{eq:dirac-inclusion}. The difference of the various algorithms lies in the choice of <span>$\lambda_{n}^{-}$</span> and <span>$\lambda_{n+1}^{+}$</span> as follows</p><table><tr><th style="text-align: center">Projection</th><th style="text-align: left"><span>$\lambda_{n}^{-}$</span></th><th style="text-align: left"><span>$\lambda_{n+1}^{+}$</span></th></tr><tr><td style="text-align: center">Standard</td><td style="text-align: left"><span>$0$</span></td><td style="text-align: left"><span>$\lambda_{n+1}$</span></td></tr><tr><td style="text-align: center">Symplectic</td><td style="text-align: left"><span>$\lambda_{n}$</span></td><td style="text-align: left"><span>$R (\infty) \, \lambda_{n+1\hphantom{/2}}$</span></td></tr><tr><td style="text-align: center">Symmetric</td><td style="text-align: left"><span>$\lambda_{n+1/2}$</span></td><td style="text-align: left"><span>$R (\infty) \, \lambda_{n+1/2}$</span></td></tr><tr><td style="text-align: center">Midpoint</td><td style="text-align: left"><span>$\lambda_{n+1/2}$</span></td><td style="text-align: left"><span>$R (\infty) \, \lambda_{n+1/2}$</span></td></tr></table><p>For the symmetric, symplectic and midpoint projections, it is important to adapt the sign in the projection according to the stability function <span>$R(\infty)$</span> of the basic integrator (for details see e.g. <a href="../../bibliography/#Chan:2004">Robert P. K. Chan , Philippe Chartier , Ander Murua  (2004)</a>). For the methods we are interested in, namely Runge-Kutta methods, the stability function is given by <span>$R(z) = 1 + z b^{T} (\identity - zA)^{-1} e$</span> with <span>$e = (1, 1, ..., 1)^{T} \in \mathbb{R}^{s}$</span>, and we have <span>$\abs{R(\infty)}=1$</span> or, more specifically, for Gauss-Legendre methods <span>$R(\infty) = (-1)^{s}$</span> and for partitioned Gauss-Lobatto IIIA-IIIB and IIIB-IIIA methods we have <span>$R(\infty) = (-1)^{s-1}$</span>.</p><p>Let us remark that for the standard projection, the basic integrator and the projection step can be applied independently. Similarly, for the symplectic projection, the three steps, namely perturbation, numerical integrator, and projection, decouple and can be solved consecutively, as we use different Lagrange multipliers <span>$\lambda_{n}$</span> in the perturbation and <span>$\lambda_{n+1}$</span> in the projection. For the symmetric projection and the midpoint projection, however, this is not the case.  There, we used the same Lagrange multiplier <span>$\lambda_{n+1/2}$</span> in both the perturbation and the projection, so that the whole system has to be solved at once, which is more costly. This also implies that for the projection methods where <span>$\lambda_{n}^{-}$</span> and <span>$\lambda_{n+1}^{+}$</span> are the same (possibly up to a sign due to <span>$R(\infty)$</span>), strictly speaking we cannot write the projected algorithm in terms of a composition of two steps as we did in \eqref{eq:projection-composition-map}. Instead the whole algorithm has to be treated as one nonlinear map. The idea of the construction of the methods is still the same, though. Only the <a href="#sec:midpoint-projection">midpoint projection</a> needs special treatment. There, the operator <span>$\mathbb{P}_{\lambda}$</span> is defined in a slightly more complicated way than in \eqref{eq:projector}, using different arguments in the projection step, which does not quite fit the general framework outlined here.</p><h3 id="sec:standard-projection"><a class="docs-heading-anchor" href="#sec:standard-projection">Standard Projection</a><a id="sec:standard-projection-1"></a><a class="docs-heading-anchor-permalink" href="#sec:standard-projection" title="Permalink"></a></h3><p><img src="../images/standard-projection.png" alt="Illustration of the standard projection method"/></p><p><em>Illustration of the standard projection method: The solution is projected to the constraint submanifold <span>$\Delta$</span> after each step of the numerical integrator <span>$\Psi_{h}$</span>.</em></p><p>The standard projection method [<a href="../../bibliography/#HairerLubichWanner:2006">Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006)</a>, Section IV.4] is the simplest projection method. Starting from <span>$q_{n}$</span>, we use the continuous fibre derivative \eqref{eq:fibre-derivative-general} to compute <span>$p_{n} = \vartheta (q_{n})$</span>. Then we apply some symplectic one-step method <span>$\Psi_{h}$</span> to <span>$z_{n} = (q_{n}, p_{n})$</span> to obtain an intermediate solution <span>$z_{n+1}$</span>,</p><p class="math-container">\[\bar{z}_{n+1} = \Psi_{h} (z_{n}) ,\]</p><p>which is projected onto the constraint submanifold \eqref{eq:constraint-submanifold} by</p><p class="math-container">\[\begin{equation}\label{eq:orthogonal_projection}
z_{n+1} = \bar{z}_{n+1} + h \, \Omega^{-1} \nabla \phi^{T} (z_{n+1}) \lambda_{n+1} ,
\end{equation}\]</p><p>enforcing the constraint</p><p class="math-container">\[0 = \phi (z_{n+1}) .\]</p><p>This projection method, combined with the variational integrator in position-momentum form \eqref{eq:vi-position-momentum-form}, is not symmetric, and therefore not reversible. Moreover, it exhibits a drift of the energy, as has been observed before, e.g., for holonomic constraints [<a href="../../bibliography/#Hairer:2000">Ernst Hairer  (2000)</a>, <a href="../../bibliography/#Hairer:2001">Ernst Hairer  (2001)</a>, <a href="../../bibliography/#HairerLubichWanner:2006">Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006)</a>].</p><h3 id="sec:symmetric-projection"><a class="docs-heading-anchor" href="#sec:symmetric-projection">Symmetric Projection</a><a id="sec:symmetric-projection-1"></a><a class="docs-heading-anchor-permalink" href="#sec:symmetric-projection" title="Permalink"></a></h3><p><img src="../images/symmetric-projection-plus.png" alt="Symmetric Projection +"/> <img src="../images/symmetric-projection-minus.png" alt="Symmetric Projection -"/></p><p><em>Illustration of the symmetric projection method: The solution is first perturbed off the constraint submanifold <span>$\Delta$</span>, then one step of the numerical integrator <span>$\Psi_{h}$</span> is performed, and the result is projected back onto <span>$\Delta$</span>.</em></p><p>To overcome the shortcomings of the standard projection, we consider a symmetric projection of the variational Runge-Kutta integrators following <a href="../../bibliography/#Hairer:2000">Ernst Hairer  (2000)</a>, <a href="../../bibliography/#Hairer:2001">Ernst Hairer  (2001)</a> and <a href="../../bibliography/#Chan:2004">Robert P. K. Chan , Philippe Chartier , Ander Murua  (2004)</a>, see also <a href="../../bibliography/#HairerLubichWanner:2006">Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006)</a>, Section V.4.1. Here, one starts again by computing the momentum <span>$p_{n}$</span> as a function of the coordinates <span>$q_{n}$</span> according to the continuous fibre derivative, which can be expressed with the constraint function as</p><p class="math-container">\[\begin{equation}\label{eq:symmetric-symplectic-projection}
0 = \phi (z_{n}) .
\end{equation}\]</p><p>Then the initial value <span>$z_{n}$</span> is first perturbed,</p><p class="math-container">\[\begin{equation}\label{eq:symmetric-projection-pre}
\bar{z}_{n} = z_{n} + h \, \Omega^{-1} \nabla \phi^{T} (z_{n}) \, \lambda_{n+1/2} , 
\end{equation}\]</p><p>followed by the application of some one-step method <span>$\Psi_{h}$</span>,</p><p class="math-container">\[\bar{z}_{n+1} = \Psi_{h} (\bar{z}_{n}) ,\]</p><p>and a projection of the result onto the constraint submanifold,</p><p class="math-container">\[\begin{equation}\label{eq:symmetric_projection_post}
z_{n+1} = \bar{z}_{n+1} + h \, R(\infty) \, \Omega^{-1} \nabla \phi^{T} (z_{n+1}) \lambda_{n+1/2} ,
\end{equation}\]</p><p>which enforces the constraint</p><p class="math-container">\[0 = \phi (z_{n+1}) .\]</p><p>Here, it is important to note that Lagrange multiplier <span>$\lambda_{n+1/2}$</span> is the same in both the perturbation and the projection step, and to account for the stability function <span>$R(\infty)$</span> of the basic integrator, as mentioned before. The algorithm composed of the symmetric projection and some symmetric variational integrator in position-momentum form, constitutes a symmetric map</p><p class="math-container">\[\Phi_{h} : q_{n} \mapsto q_{n+1} ,\]</p><p>where, from a practical point of view, <span>$p_{n}$</span>, <span>$p_{n+1}$</span> and <span>$\lambda_{n+1/2}$</span> are treated as intermediate variables. Unfortunately, the method is not symplectic but instead satisfies the relation</p><p class="math-container">\[\begin{multline}\label{eq:symmetric-projection-symplecticity-condition}
   \dfrac{1}{2} \bar{\Omega}_{ij} (q_{n}) \, \big( \ext q_{n}^{i} \wedge \ext q_{n}^{j}
 - h^{2} \, \ext \lambda_{n+1/2}^{i} \wedge \ext \lambda_{n+1/2}^{j} \big)
 - h^{2} \lambda_{n+1/2}^{k} \vartheta_{k,ij} (q_{n}) \, \ext q_{n}^{i} \wedge \ext \lambda_{n+1/2}^{j} = \\
 = \dfrac{1}{2} \bar{\Omega}_{ij} (q_{n+1}) \, \big( \ext q_{n+1}^{i} \wedge \ext q_{n+1}^{j}
 - h^{2} \, \ext \lambda_{n+1/2}^{i} \wedge \ext \lambda_{n+1/2}^{j} \big)
 - h^{2} \lambda_{n+1/2}^{k} \vartheta_{k,ij} (q_{n+1}) \, \ext q_{n+1}^{i} \wedge \ext \lambda_{n+1/2}^{j} .
\end{multline}\]</p><p>For certain systems, this method can even be shown to be symplectic. In general, though, it is not symplectic. Nevertheless, it tends to perform very well in long-time simulations.</p><h3 id="sec:symplectic-projection"><a class="docs-heading-anchor" href="#sec:symplectic-projection">Symplectic Projection</a><a id="sec:symplectic-projection-1"></a><a class="docs-heading-anchor-permalink" href="#sec:symplectic-projection" title="Permalink"></a></h3><p><img src="../images/post-projection.png" alt/></p><p><em>Illustration of the post projection method. Starting on the constraint submanifold <span>$\Delta$</span>, the numerical integrator <span>$\Psi_{h}$</span> moves the solution away from <span>$\Delta$</span> in the first step. After each step, the solution is projected back onto <span>$\Delta$</span>, but the perturbation at the beginning of each consecutive step is exactly the inverse of the previous projection, so that, practically speaking, the solution is projected back onto <span>$\Delta$</span> only for output purposes.</em></p><p>In the symplectic projection, we modify the perturbation \eqref{eq:symmetric-projection-pre} to use the Lagrange multiplier at the previous time step, <span>$\lambda_{n}$</span>, instead of <span>$\lambda_{n+1}$</span>. As before, we assum the initial condition <span>$z_{n}$</span> satisfies the constraint,</p><p class="math-container">\[\begin{equation}\label{eq:symplectic-projection-pre-constraint}
0 = \phi (z_{n}) .
\end{equation}\]</p><p>The initial condition is perturbed, using the Lagrange multiplier <span>$\lambda_{n}$</span>,</p><p class="math-container">\[\begin{equation}\label{eq:symplectic-projection-pre}
\bar{z}_{n} = z_{n} + h \, \Omega^{-1} \nabla \phi^{T} (z_{n}) \, \lambda_{n} .
\end{equation}\]</p><p>Then the usual one-step method <span>$\Psi_{h}$</span> is applied,</p><p class="math-container">\[\bar{z}_{n+1} = \Psi_{h} (\bar{z}_{n}) ,\]</p><p>and the result is projected onto the constraint submanifold using the Lagrange multiplier <span>$\lambda_{n+1}$</span>,</p><p class="math-container">\[\begin{equation}\label{eq:symplectic-projection-post}
z_{n+1} = \bar{z}_{n+1} + h \, R(\infty) \, \Omega^{-1} \nabla \phi^{T} (z_{n+1}) \lambda_{n+1} ,
\end{equation}\]</p><p>in order to enforce the constraint</p><p class="math-container">\[\begin{equation}\label{eq:symplectic-projection-post-constraint}
0 = \phi (z_{n+1}) .
\end{equation}\]</p><p>The symplecticity condition \eqref{eq:symmetric-projection-symplecticity-condition} is modified as follows,</p><p class="math-container">\[\begin{multline}\label{eq:symplectic_projection_symplecticity_condition}
   \dfrac{1}{2} \bar{\Omega}_{ij} (q_{n}) \, \big( \ext q_{n}^{i} \wedge \ext q_{n}^{j}
 - h^{2} \, \ext \lambda_{n}^{i} \wedge \ext \lambda_{n}^{j} \big)
 - h^{2} \lambda_{n}^{k} \vartheta_{k,ij} (q_{n}) \, \ext q_{n}^{i} \wedge \ext \lambda_{n}^{j} = \\
 = \dfrac{1}{2} \bar{\Omega}_{ij} (q_{n+1}) \, \big( \ext q_{n+1}^{i} \wedge \ext q_{n+1}^{j}
 - h^{2} \, \ext \lambda_{n+1}^{i} \wedge \ext \lambda_{n+1}^{j} \big) \\
 - h^{2} \lambda_{n+1/2}^{k} \vartheta_{k,ij} (q_{n+1}) \, \ext q_{n+1}^{i} \wedge \ext \lambda_{n+1}^{j} ,
\end{multline}\]</p><p>implying the conservation of a modified symplectic form <span>$\omega_{\lambda}$</span> defined on an extended phasespace <span>$\mf{M} \times \mathbb{R}^{d}$</span> with coordinates <span>$(q, \lambda)$</span> by</p><p class="math-container">\[\begin{equation}\label{eq:symplectic_projection_two_form}
\omega_{\lambda}
 = \dfrac{1}{2} \bar{\Omega}_{ij} (q) \, \ext q^{i} \wedge \ext q^{j}
 - \dfrac{h^{2}}{2} \bar{\Omega}_{ij} (q) \, \ext \lambda^{i} \wedge \ext \lambda^{j}
 - h^{2} \lambda^{k} \vartheta_{k,ij} (q) \, \ext q^{i} \wedge \ext \lambda^{j} ,
\end{equation}\]</p><p>with matrix representation</p><p class="math-container">\[\Omega_{\lambda} =
\begin{pmatrix}
\bar{\Omega} &amp; - h^{2} \lambda \cdot \vartheta_{qq} \\
h^{2} \lambda \cdot \vartheta_{qq} &amp; - h^{2} \bar{\Omega} \\
\end{pmatrix} .\]</p><p>This corresponds to a modified one-form <span>$\vartheta_{\lambda}$</span>, such that <span>$\omega_{\lambda} = \ext \vartheta_{\lambda}$</span>, given by</p><p class="math-container">\[\begin{equation}\label{eq:symplectic_projection_one_form}
\vartheta_{\lambda} = ( \vartheta_{i} (q) - h \, \lambda^{k} \vartheta_{k,i} (q) ) \, ( \ext q^{i} - h \, \ext \lambda^{i} )
\end{equation}\]</p><p>As noted by <a href="../../bibliography/#Chan:2004">Robert P. K. Chan , Philippe Chartier , Ander Murua  (2004)</a>, the modified perturbation \eqref{eq:symplectic-projection-pre-constraint}-\eqref{eq:symplectic-projection-pre} can be viewed as a change of variables from <span>$(q, \lambda)$</span> on <span>$\mf{M} \times \mathbb{R}^{d}$</span> to <span>$(q, p)$</span> on <span>$\cb{\mf{M}}$</span>, and the projection \eqref{eq:symplectic-projection-post}-\eqref{eq:symplectic-projection-post-constraint} as a change of variables back from <span>$(q, p)$</span> to <span>$(q, \lambda)$</span>. The symplectic form <span>$\omega_{\lambda}$</span> on <span>$\mf{M} \times \mathbb{R}^{d}$</span> thus corresponds to the pullback of the canonical symplectic form <span>$\omega$</span> on <span>$\cb{\mf{M}}$</span> by this variable transformation.</p><p>Let us note that the sign in in front of the projection in \eqref{eq:symplectic-projection-post}, given by the stability function of the basic integrator, has very important implications on the nature of the algorithm. If it is the same as in \eqref{eq:symplectic-projection-pre}, the character of the method is very similar to the symmetric projection method described before. If the sign is the opposite of the one in \eqref{eq:symplectic-projection-pre}, like for Gauss-Legendre Runge-Kutta methods with an odd number of stages, the perturbation reverses the projection of the previous step, so that we effectively apply the post-projection method of <a href="../../bibliography/#Chan:2002">Robert P. K. Chan , Philippe Chartier , Ander Murua  (2002)</a>. That is, the projected integrator <span>$\Phi_{h}$</span> is conjugate to the unprojected integrator <span>$\Psi_{h}$</span> by</p><p class="math-container">\[\Phi_{h} = \mathbb{P}^{-1} \circ \Psi_{h} \circ \mathbb{P} ,\]</p><p>so that the following diagram commutes</p><p><img src="../images/commuting-diagram.png" alt="Commuting Diagram"/></p><p>and the projection is effectively only applied for the output of the solution, but the actual advancement of the solution in time happens outside of the constraint submanifold. In other words, applying <span>$n$</span> times the algorithm <span>$\Phi_{h}$</span> to a point <span>$(q_{0}, 0)$</span> is equivalent to applying the perturbation <span>$\mathbb{P}^{-1}$</span>, then applying <span>$n$</span> times the algorithm <span>$\Psi_{h}$</span> and projecting the result with <span>$\mathbb{P}$</span>.</p><p>Potentially, this might degrade the performance of the algorithm. If the accumulated global error drives the solution too far away from the constraint submanifold, the projection step might not have a solution anymore. Interestingly, however, post-projected Gauss-Legendre Runge-Kutta methods retain their optimal order of <span>$2s$</span> [<a href="../../bibliography/#Chan:2002">Robert P. K. Chan , Philippe Chartier , Ander Murua  (2002)</a>]. Moreover, for methods with an odd number of stages, the global error of the unprojected solution is <span>$\mathcal{O}(h^{s+1})$</span>, compared to <span>$\mathcal{O}(h^{s})$</span> for methods with an even number of stages. In practice this seems to be at least part of the reason of the good long-time stability of these methods.</p><h3 id="sec:midpoint-projection"><a class="docs-heading-anchor" href="#sec:midpoint-projection">Midpoint Projection</a><a id="sec:midpoint-projection-1"></a><a class="docs-heading-anchor-permalink" href="#sec:midpoint-projection" title="Permalink"></a></h3><p>For certain variational Runge-Kutta methods, we can also modify the symmetric projection in a different way in order to obtain a symplectic projection, namely by evaluating the projection at the midpoint</p><p class="math-container">\[\begin{aligned}
\bar{z}_{n+1/2} &amp;= (\bar{q}_{n+1/2}, \bar{p}_{n+1/2}) , &amp;
\bar{q}_{n+1/2} &amp;= \tfrac{1}{2} \big( \bar{q}_{n} + \bar{q}_{n+1} \big) , &amp;
\bar{p}_{n+1/2} &amp;= \tfrac{1}{2} \big( \bar{p}_{n} + \bar{p}_{n+1} \big) ,
\end{aligned}\]</p><p>so that the projection algorithm is modified as follows. As always, the initial condition is expected to satisfy the constraint,</p><p class="math-container">\[\begin{equation}\label{eq:midpoint_projection_pre_constraint}
0 = \phi (z_{n}) .
\end{equation}\]</p><p>For the perturbation of the initial condition,</p><p class="math-container">\[\begin{equation}\label{eq:midpoint_projection_pre}
\bar{z}_{n} = z_{n} + h \, \Omega^{-1} \nabla \phi^{T} (\bar{z}_{n+1/2}) \, \lambda_{n+1/2} ,
\end{equation}\]</p><p>the gradient of the constraint is evaluated at the midpoint <span>$\bar{z}_{n+1/2}$</span>. A one step method is applied,</p><p class="math-container">\[\bar{z}_{n+1} = \Psi_{h} (z_{\bar{z}}) ,\]</p><p>and the result is projected, again evaluating the gradient of <span>$\phi$</span> at the midpoint <span>$\bar{z}_{n+1/2}$</span>,</p><p class="math-container">\[\begin{equation}\label{eq:midpoint_projection_post}
z_{n+1} = \bar{z}_{n+1} + h \, R(\infty) \, \Omega^{-1} \nabla \phi^{T} (z_{n+1/2}) \lambda_{n+1/2} ,
\end{equation}\]</p><p>in order to force the solution to satisfy the constraint,</p><p class="math-container">\[\begin{equation}\label{eq:symplectic_projection_midpoint_post_constraint}
0 = \phi (z_{n+1}) .
\end{equation}\]</p><p>For certain systems, this method can be shown to be symplectic with respect to the original noncanonical symplectic form on <span>$\mf{M}$</span> if the integrator <span>$\Psi_{h}$</span> is a symmetric, symplectic Runge-Kutta method with an odd number of stages <span>$s$</span>, for which the central stage with index <span>$(s+1)/2$</span> corresponds to <span>$z_{n+1/2}$</span>. This is obviously the case for the implicit midpoint rule, that is the Gauss-Legendre Runge-Kutta method with <span>$s=1$</span>, but unfortunately not for higher-order Gauss-Legendre or for Gauss-Lobatto methods. However, following <a href="../../bibliography/#OevelSofroniou:1997">Walter Oevel , Mark Sofroniou  (1997)</a> and <a href="../../bibliography/#Zhao:2014">Shan Zhao , Guo-Wei Wei  (2014)</a>, higher-order methods similar to Gauss-Legendre methods but satisfying the requested property can be obtained. See for example the method with three stages, implemented as <a href="../../tableaus/rungekutta/#RungeKutta.Tableaus.TableauSRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauSRK3</code></a>.</p><h3 id="sec:internal-stage-projection"><a class="docs-heading-anchor" href="#sec:internal-stage-projection">Internal Stage Projection</a><a id="sec:internal-stage-projection-1"></a><a class="docs-heading-anchor-permalink" href="#sec:internal-stage-projection" title="Permalink"></a></h3><p><strong>TODO</strong></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variational/">« Variational</a><a class="docs-footer-nextpage" href="../spark/">SPARK »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 4 March 2021 20:41">Thursday 4 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
