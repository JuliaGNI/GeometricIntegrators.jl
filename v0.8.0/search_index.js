var documenterSearchIndex = {"docs":
[{"location":"integrators/","page":"Overview","title":"Overview","text":"CurrentModule = GeometricIntegrators","category":"page"},{"location":"integrators/#Integrators","page":"Overview","title":"Integrators","text":"","category":"section"},{"location":"integrators/","page":"Overview","title":"Overview","text":"GeometricIntegrators.jl provides a plethora of geometric and non-geometric integrators. Most integrators are specified by a tableau, that is a Butcher tableau for Runge-Kutta methods, a pair of tableaus for partitioned Runge-Kutta and VPRK methods, or generalizations thereof for SPARK methods. Other integrators, such as Galerkin variational integrators require the specification of a basis and a quadrature rule.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"In many cases, the correct integrator is automatically selected based on the tableau and equation types by calling","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"Integrator(equation, tableau, Δt)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"where Δt is the time step.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"As an example, consider an ODE like the harmonic oscillator, which is included in GeometricProblems.jl:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"ode = harmonic_oscillator_ode()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"Create an explicit Euler tableau:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"tab = TableauExplicitEuler()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"And now create an Integrator with the general Integrator constructor:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"int = Integrator(ode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"We see that we obtained an IntegratorERK, i.e., an explicit Runge-Kutta integrator. If instead we choose the implicit Euler tableau:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"tab = TableauImplicitEuler()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"the general Integrator constructor creates a different integrator:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"int = Integrator(ode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"namely an IntegratorFIRK, i.e., a fully implicit Runge-Kutta integrator.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"This is possible because most integrators come with a dedicated tableau type, so that Integrator can dispatch on that.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"In some cases, in particular the VPRK integrators, the integrator has to be explicitly specified as there are different integrators that use the same tableau type and operate on the same equation type, here TableauVPRK and IODE. Consider again the harmonic oscillator:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"iode = harmonic_oscillator_iode()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"Create a VPRK tableau that uses Gauss-Legendre Runge-Kutta coefficients with two stages:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"tab = TableauVPGLRK(2)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"If we just call the Integrator constructor,","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"int = Integrator(iode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"we obtain a plain IntegratorVPRK. If we want to use any of the projection methods, we have to explicitly specify the corresponding integrator type:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"using GeometricIntegrators.Integrators.VPRK\nint = IntegratorVPRKpStandard(iode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"or","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"int = IntegratorVPRKpSymmetric(iode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"Once an integrator is obtained, we can just call the function","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"integrate(equation, integrator, ntime)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"to perform the actual integration steps, where ntime defines the number of steps to integrate:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator\node = harmonic_oscillator_ode()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"tab = TableauExplicitEuler()\nint = Integrator(ode, tab, 0.1)\nsol = integrate(ode, int, 100)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"The integrate function returns a solution object that stores the solution for each of the ntime time steps. There is also a convenience function that combines all of the above steps in one single call, namely","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"integrate(equation, tableau, Δt, ntime)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"If the solution object is created manually, there exists a function","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"integrate!(integrator, solution)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"that operates on an existing solution.","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"CurrentModule = GeometricIntegrators.Integrators.SPARK","category":"page"},{"location":"integrators/spark/#Special-Partitioned-Additive-Runge-Kutta-Integrators","page":"SPARK","title":"Special Partitioned Additive Runge-Kutta Integrators","text":"","category":"section"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"SPARK or Special Partitioned Additive Runge-Kutta Integrators are a family of integrators that have been introduced by Laurent O. Jay for the integration of differential algebraic equations and in particular systems subject to holonomic and nonholonomic constraints [Laurent O. Jay  (1998), Laurent O. Jay  (2003), Laurent O. Jay  (2006), Laurent O. Jay  (2007), Laurent O. Jay  (2007)]. Recently, the idea of SPARK methods has been generalized and adapted to facilitate the integration of degenerate Lagrangian systems as well as Hamiltonian systems subject to Dirac constraints [Michael Kraus  (2020)].","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"GeometricIntegrators.jl provides several flavours of such SPARK methods (some are still experimental):","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"Integrator Description\nIntegratorHPARK Partitioned additive methods for Hamiltonian system subject to a general constraint phi(qp) = 0\nIntegratorVPARK Partitioned additive methods for Lagrangian system subject to a general constraint phi(qp) = 0\nIntegratorSPARK SPARK methods for general index-two differential algebraic equations\nIntegratorHSPARK Hamiltonian system subject to a general constraint phi(qp) = 0\nIntegratorHSPARKprimary Hamiltonian system subject primary constraint in the sense of Dirac\nIntegratorHSPARKsecondary Hamiltonian system enforcing primary & secondary Dirac constraint\nIntegratorVSPARK Lagrangian system in implicit form subject to a general constraint phi(qp) = 0\nIntegratorVSPARKprimary Degenerate Lagrangian system subject primary constraint in the sense of Dirac\nIntegratorVSPARKsecondary Degenerate Lagrangian system enforcing primary & secondary Dirac constraint","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"These integrators are applied to either an IDAE, HDAE or LDAE.","category":"page"},{"location":"tableaus/rungekutta/#Runge-Kutta-Tableaus","page":"Runge-Kutta Methods","title":"Runge-Kutta Tableaus","text":"","category":"section"},{"location":"tableaus/rungekutta/","page":"Runge-Kutta Methods","title":"Runge-Kutta Methods","text":"Modules = [RungeKutta.Tableaus]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauBackwardEuler","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauBackwardEuler","text":"Alias for TableauImplicitEuler\n\n\n\n\n\n","category":"function"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauCrankNicolson-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauCrankNicolson","text":"Tableau of Crank-Nicolson two-stage, 2nd order method\n\nTableauCrankNicolson(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJ. Crank and P. Nicolson.\nA practical method for numerical evaluation of solutions of partial differential equations of the heat-conduction type.\nMathematical Proceedings of the Cambridge Philosophical Society, Volume 43, Issue 1, Pages 50-67, 1947.\ndoi: 10.1017/S0305004100023197\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauCrouzeix-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauCrouzeix","text":"Tableau of Crouzeix's two-stage, 3rd order method\n\nTableauCrouzeix(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nM.Crouzeix.\nSur L'approximation des équations différentielles opérationelles linéaires par des méthodes de Runge-Kutta.\nThesis. Université de Paris, 1975.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauExplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauExplicitEuler","text":"Tableau of one-stage, 1st order explicit (forward) Euler method\n\nTableauExplicitEuler(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nLeonhard Euler.\nInstitutiones calculi differentialis cum eius vsu in analysi finitorum ac doctrina serierum.\nImp. Acad. Imper. Scient. Petropolitanae, Opera Omnia, Vol.X, [I.6], 1755.\nIn: Opera Omnia, 1st Series, Volume 11, Institutiones Calculi Integralis. Teubner, Leipzig, Pages 424-434, 1913.\nSectio secunda. Caput VII. De integratione aequationum differentialium per approximationem. Problema 85.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauExplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauExplicitMidpoint","text":"Tableau of explicit two-stage, 2nd order midpoint method\n\nTableauExplicitMidpoint(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nCarl Runge.\nÜber die numerische Auflösung von Differentialgleichungen.\nMathematische Annalen, Volume 46, Pages 167-178, 1895.\ndoi: 10.1007/BF01446807.\nEquation (2)\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauForwardEuler","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauForwardEuler","text":"Alias for TableauExplicitEuler\n\n\n\n\n\n","category":"function"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauGauss-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauGauss","text":"Gauss tableau with s stages\n\nTableauGauss(::Type{T}, s)\nTableauGauss(s) = TableauGauss(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nJohn C. Butcher.\nImplicit Runge-Kutta processes.\nMathematics of Computation, Volume 18, Pages 50-64, 1964.\ndoi: 10.1090/S0025-5718-1964-0159424-9.\n\nJohn C. Butcher.\nGauss Methods. \nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_115.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauHeun2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauHeun2","text":"Tableau of Heun's two-stage, 2nd order method\n\nTableauHeun2(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nKarl Heun.\nNeue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.\nZeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.\nAlgorithm II.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauHeun3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauHeun3","text":"Tableau of Heun's three-stage, 3rd order method\n\nTableauHeun3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nKarl Heun.\nNeue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.\nZeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.\nAlgorithm VI.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauImplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauImplicitEuler","text":"Tableau of one-stage, 1st order implicit (backward) Euler method\n\nTableauImplicitEuler(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAugustin-Louis Cauchy.\nÉquations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.\nEd. Christian Gilain, Etudes Vivantes, 1981.\nPage 102, Equation (5), Θ=1.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauImplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauImplicitMidpoint","text":"Tableau of two-stage, 2nd order implicit midpoint method\n\nTableauImplicitMidpoint(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAugustin-Louis Cauchy.\nÉquations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.\nEd. Christian Gilain, Etudes Vivantes, 1981.\nPage 102, Equation (5), Θ=1/2.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauKraaijevangerSpijker-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauKraaijevangerSpijker","text":"Tableau of Kraaijevanger and Spijker's two-stage, 2nd order method\n\nTableauKraaijevangerSpijker(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJ. F. B. M. Kraaijevanger and M. N. Spijker.\nAlgebraic stability and error propagation in Runge-Kutta methods.\nApplied Numerical Mathematics, Volume 5, Issues 1-2, Pages 71-87, 1989.\ndoi: 10.1016/0168-9274(89)90025-1\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauKutta-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauKutta","text":"Tableau of Kutta's three-stage, 3rd order method\n\nTableauKutta(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435–453, 1901.\nPage 440\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauKutta3","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauKutta3","text":"Alias for TableauKutta\n\n\n\n\n\n","category":"function"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauLobattoIIIA","text":"Lobatto IIIA tableau with s stages\n\nTableauLobattoIIIA(::Type{T}, s)\nTableauLobattoIIIA(s) = TableauLobattoIIIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauLobattoIIIB","text":"Lobatto IIIB tableau with s stages\n\nTableauLobattoIIIB(::Type{T}, s)\nTableauLobattoIIIB(s) = TableauLobattoIIIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle.\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIC-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauLobattoIIIC","text":"Lobatto IIIC tableau with s stages\n\nTableauLobattoIIIC(::Type{T}, s)\nTableauLobattoIIIC(s) = TableauLobattoIIIC(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nF. H. Chipman.\nA-stable Runge-Kutta processes.\nBIT, Volume 11, Pages 384-388, 1971.\ndoi: 10.1007/BF01939406.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIC̄-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauLobattoIIIC̄","text":"Lobatto IIIC̄ tableau with s stages\n\nTableauLobattoIIIC̄(::Type{T}, s)\nTableauLobattoIIIC̄(s) = TableauLobattoIIIC̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nJohn C. Butcher.\nIntegration processes based on Radau quadrature formulas\nMathematics of Computation, Volume 18, Pages 233-244, 1964.\ndoi: 10.1090/S0025-5718-1964-0165693-1.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIID-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauLobattoIIID","text":"Lobatto IIID tableau with s stages\n\nTableauLobattoIIID(::Type{T}, s)\nTableauLobattoIIID(s) = TableauLobattoIIID(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nR.P.K. Chan.\nOn symmetric Runge-Kutta methods of high order.\nComputing, Volume 45, Pages 301-309, 1990.\ndoi: 10.1007/BF02238798\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIE-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauLobattoIIIE","text":"Lobatto IIIE tableau with s stages\n\nTableauLobattoIIIE(::Type{T}, s)\nTableauLobattoIIIE(s) = TableauLobattoIIIE(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nR.P.K. Chan.\nOn symmetric Runge-Kutta methods of high order.\nComputing, Volume 45, Pages 301-309, 1990.\ndoi: 10.1007/BF02238798\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauLobattoIIIF","text":"Lobatto IIIF tableau with s stages\n\nTableauLobattoIIIF(::Type{T}, s)\nTableauLobattoIIIF(s) = TableauLobattoIIIF(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nWang Fangzong and Liao Xiaobing.\nA Class of Lobatto Methods of Order 2s.\nJournal of Applied Mathematics, Volume 46, Pages 6-10, 2016.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIG-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauLobattoIIIG","text":"Lobatto IIIG tableau with s stages\n\nTableauLobattoIIIG(::Type{T}, s)\nTableauLobattoIIIG(s) = TableauLobattoIIIG(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nSymplectizied algorithm for TableauLobattoIIIF\n\nCoefficients are taken as a^G = frac12 ( a^F + bara^F ) where the coefficients bara^F are computed such that the symplecticity conditions b_i bara_ij + barb_j a_ji = b_i barb_j and b_i = barb_i hold for all 1 le ij le s.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauQinZhang-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauQinZhang","text":"Tableau of Qin and Zhang's symplectic two-stage, 2nd order method\n\nTableauQinZhang(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nM.-Z. Qin and M.-Q. Zhang.\nSymplectic Runge-Kutta algorithms for Hamilton systems.\nJournal of Computational Mathematics, Supplementary Issue, Pages 205-215, 1992.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauRK4","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauRK4","text":"Alias for TableauRK416\n\n\n\n\n\n","category":"function"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauRK416-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauRK416","text":"Tableau of explicit Runge-Kutta method of order four (1/6 rule)\n\nTableauRK416(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435–453, 1901.\nPage 443\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauRK438-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauRK438","text":"Tableau of explicit Runge-Kutta method of order four (3/8 rule)\n\nTableauRK438(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435–453, 1901.\nPage 441\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauRadauIA-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauRadauIA","text":"Radau IA tableau with s stages\n\nTableauRadauIA(::Type{T}, s)\nTableauRadauIA(s) = TableauRadauIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauRadauIB-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauRadauIB","text":"Radau IB tableau with s stages\n\nTableauRadauIB(::Type{T}, s)\nTableauRadauIB(s) = TableauRadauIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nCoefficients are taken as a^B = frac12 ( a^A + bara^A ) where a^A are the coefficients of the Radau IA method and bara^A are computed such that the symplecticity conditions b_i bara_ij + barb_j a_ji = b_i barb_j and b_i = barb_i hold for all 1 le ij le s.\n\nReference:\n\nSun Geng\nConstruction of high order symplectic Runge-Kutta methods\nJournal of Computational Mathematics, Volume 11, Pages 250-260, 1993.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauRadauIIA-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauRadauIIA","text":"Radau IIA tableau with s stages\n\nTableauRadauIIA(::Type{T}, s)\nTableauRadauIIA(s) = TableauRadauIIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nOwe Axelsson.\nA class of A-stable methods.\nBIT, Volume 9, Pages 185-199, 1969.\ndoi: 10.1007/BF01946812.\n\nErnst Hairer and Gerhard Wanner.\nRadau Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_139.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauRadauIIB-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauRadauIIB","text":"Radau IIB tableau with s stages\n\nTableauRadauIIB(::Type{T}, s)\nTableauRadauIIB(s) = TableauRadauIIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nCoefficients are taken as a^B = frac12 ( a^A + bara^A ) where a^A are the coefficients of the Radau IIA method and bara^A are computed such that the symplecticity conditions b_i bara_ij + barb_j a_ji = b_i barb_j and b_i = barb_i hold for all 1 le ij le s.\n\nReference:\n\nSun Geng\nConstruction of high order symplectic Runge-Kutta methods\nJournal of Computational Mathematics, Volume 11, Pages 250-260, 1993.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauRalston2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauRalston2","text":"Tableau of Ralston's two-stage, 2nd order method\n\nTableauRalston2(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAnthony Ralston.\nRunge-Kutta Methods with Minimum Error Bounds.\nMathematics of Computation, Volume 16, Pages 431-437, 1962.\ndoi: 10.1090/S0025-5718-1962-0150954-0.\nEquation (3.5)\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauRalston3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauRalston3","text":"Tableau of Ralston's three-stage, 3rd order method\n\nTableauRalston3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAnthony Ralston.\nRunge-Kutta Methods with Minimum Error Bounds.\nMathematics of Computation, Volume 16, Pages 431-437, 1962.\ndoi: 10.1090/S0025-5718-1962-0150954-0.\nEquation (4.10)\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauRunge-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauRunge","text":"Tableau of Runge's two-stage, 2nd order method\n\nTableauRunge(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nCarl Runge\nÜber die numerische Auflösung von Differentialgleichungen.\nMathematische Annalen, Volume 46, Pages 167-178, 1895.\ndoi: 10.1007/BF01446807.\nEquation (3)\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauRunge2","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauRunge2","text":"Alias for TableauRunge\n\n\n\n\n\n","category":"function"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauSRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauSRK3","text":"Tableau of symmetric and symplectic three-stage, 4th order Runge-Kutta method\n\nTableauSRK3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nShan Zhao and Guo-Wei Wei.\nA unified discontinuous Galerkin framework for time integration.\nMathematical Methods in the Applied Sciences, Volume 37, Issue 7, Pages 1042-1071, 2014.\ndoi: 10.1002/mma.2863.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauSSPRK2","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauSSPRK2","text":"Tableau of 2rd order Strong Stability Preserving method with two stages and CFL ≤ 1\n\nAlias for TableauHeun2\n\nTableauSSPRK2(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nChi-Wang Shu, Stanley Osher.\nEfficient implementation of essentially non-oscillatory shock-capturing schemes.\nJournal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.\ndoi: 10.1016/0021-9991(88)90177-5.\nEquation (2.16)\n\n\n\n\n\n","category":"function"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.TableauSSPRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.TableauSSPRK3","text":"Tableau of 3rd order Strong Stability Preserving method with three stages and CFL ≤ 1\n\nTableauSSPRK3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nChi-Wang Shu, Stanley Osher.\nEfficient implementation of essentially non-oscillatory shock-capturing schemes.\nJournal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.\ndoi: 10.1016/0021-9991(88)90177-5.\nEquation (2.18)\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_gauss_coefficients-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_gauss_coefficients","text":"The Gauss coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_gauss_nodes-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_gauss_nodes","text":"The Gauss nodes are given by the roots of the shifted Legendre polynomial P_s (2x-1) with s the number of stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_gauss_weights-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_gauss_weights","text":"The Gauss weights are given by the following integrals\n\nb_i = bigg( fracdPdx (c_i) bigg)^-2 int limits_0^1 bigg( fracP(x)x - c_i bigg)^2 dx \n\nwhere P(x) denotes the shifted Legendre polynomial P(x) = P_s (2x-1) with s the number of stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_lobatto_a_coefficients-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_lobatto_a_coefficients","text":"The Lobatto IIIA coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_lobatto_b_coefficients-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_lobatto_b_coefficients","text":"The Lobatto IIIB coefficients are implicitly given by the so-called simplifying assumption D(s):\n\nsum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k)  qquad j = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_lobatto_c_coefficients-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_lobatto_c_coefficients","text":"The Lobatto IIIC coefficients are determined by setting a_i1 = b_1 and solving the so-called simplifying assumption C(s-1), given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s-1 \n\nfor a_ij with i = 1  s and j = 2  s.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_lobatto_c̄_coefficients-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_lobatto_c̄_coefficients","text":"The Lobatto IIIC̄ coefficients are determined by setting a_is = 0 and solving the so-called simplifying assumption C(s-1), given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s-1 \n\nfor a_ij with i = 1  s and j = 1  s-1.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_lobatto_nodes-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_lobatto_nodes","text":"The s-stage Lobatto nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-2dx^s-2 big( (x - x^2)^s-1 big) \n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_lobatto_nullvector-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_lobatto_nullvector","text":"get_lobatto_nullvector(::Type, s; normalize=false)\nget_lobatto_nullvector(s; kwargs...)\n\nComputes the nullvector of the matrix containing the derivatives of the Lagrange basis on the s Lobatto nodes evaluated on these nodes.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_lobatto_weights-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_lobatto_weights","text":"The Lobatto weights can be explicitly computed by the formula\n\nb_j = frac1s (s-1) P_s-1(2 c_j - 1)^2 qquad j = 1      s \n\nwhere P_k is the kth Legendre polynomial, given by\n\nP_k (x) = frac1k 2^k big( fracd^kdx^k (x^2 - 1)^k big) \n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_radau_1_coefficients-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_radau_1_coefficients","text":"The Radau IA coefficients are implicitly given by the so-called simplifying assumption D(s):\n\nsum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k)  qquad j = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_radau_1_nodes-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_radau_1_nodes","text":"The s-stage Radau IA nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-1dx^s-1 big( x^s (x - 1)^s-1 big) \n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_radau_1_weights-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_radau_1_weights","text":"The Radau IA weights are implicitly given by the so-called simplifying assumption B(s):\n\nsum limits_j=1^s b_j c_j^k-1 = frac1k  qquad k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_radau_2_coefficients-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_radau_2_coefficients","text":"The Radau IIA coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_radau_2_nodes-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_radau_2_nodes","text":"The s-stage Radau IIA nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-1dx^s-1 big( x^s-1 (x - 1)^s big) \n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta/#RungeKutta.Tableaus.get_radau_2_weights-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"Runge-Kutta Methods","title":"RungeKutta.Tableaus.get_radau_2_weights","text":"The Radau IIA weights are implicitly given by the so-called simplifying assumption B(s):\n\nsum limits_j=1^s b_j c_j^k-1 = frac1k  qquad k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"CurrentModule = GeometricIntegrators.Tableaus","category":"page"},{"location":"integrators/rk/#Runge-Kutta-Methods","page":"Runge-Kutta","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Runge-Kutta methods exploit the Fundamental Theorem of Calculus, which states that the solution of an initial-value problem","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\ndotx (t) = f(t x(t))  \nx(t_n) = x_n \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"at time t_n+1 is given by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"x (t_n+1) = x (t_n) + int limits_t_n^t_n+1 dotx (t)  dt ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Runge-Kutta methods are constructed by approximating the integral by some quadrature formula with s nodes c_i and corresponding weights b_i to obtain x_n+1 approx x (t_n+1) by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nx_n+1 = x_n + h sum limits_i=1^s b_i dotX_ni  \ndotX_ni = f(t_n + c_i h X_ni) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"where the internal stage values X_ni approx x(t_n + c_i h) for i = 1  s are determined by another quadrature formula, approximating the integral","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"x(t_n + c_i h) = x (t_n) + int limits_t_n^t_n + c_i h dotx (t)  dt ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"namely","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"X_ni = x_n + h sum limits_j=1^s a_ij dotX_nj ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"with the same vector field values dotX_nj used for the computation of x_n+1.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Definition: Runge-Kutta methods are numerical one-step methods","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nX_ni = x_n + h sum limits_j=1^s a_ij  f(t_n + c_j h X_nj)  \nx_n+1 = x_n + h sum limits_j=1^s b_j   f(t_n + c_j h X_nj) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"defined by a set of nodes c_i, weights b_i and coefficients a_ij with ij = 1  s, summarized in the Butcher tableau","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginarraycc\nc  a     \nhline\n   b^T \nendarray\n=\nbeginarrayccccc\nc_1   a_11  a_12  dots  a_1s \nc_2   a_21  a_22  dots  a_2s \nvdots  vdots  vdots  ddots  vdots \nc_s   a_s1  a_s2  dots  a_ss \nhline\n        b_1   b_2   dots  b_s  \nendarray","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Most properties of the methods, such as order or stability, can be analysed just by posing conditions on the Butcher tableau.","category":"page"},{"location":"integrators/rk/#Common-Runge-Kutta-Methods","page":"Runge-Kutta","title":"Common Runge-Kutta Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"GeometricIntegrators.jl provides various explicit and implicit (both diagonally and fully implicit) Runge-Kutta methods. For many methods, tabulated coefficients are included, namely","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Function and Aliases Stages Order\nExplicit Methods  \nTableauExplicitEuler, TableauForwardEuler 1 1\nTableauExplicitMidpoint 2 2\nTableauHeun2 2 2\nTableauHeun3 3 3\nTableauKutta, TableauKutta3 3 3\nTableauRalston2 2 2\nTableauRalston3 3 3\nTableauRunge, TableauRunge2 2 2\nTableauRK416, TableauRK4 4 4\nTableauRK438 4 4\nTableauSSPRK3 3 3\nDiagonally Implicit Methods  \nTableauCrankNicolson 2 2\nTableauCrouzeix 2 3\nTableauKraaijevangerSpijker 2 2\nTableauQinZhang 2 2\nFully Implicit Methods  \nTableauImplicitEuler, TableauBackwardEuler 1 1\nTableauImplicitMidpoint 2 2\nTableauSRK3 3 4","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The coefficients of other methods are computed on-the-fly as described in the following.","category":"page"},{"location":"integrators/rk/#Simplifying-Assumptions","page":"Runge-Kutta","title":"Simplifying Assumptions","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The construction of many Runge-Kutte methods, in particular the Gauß, Lobatto and Radau methods, relies on the so-called simplifying assumptions:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nB(sigma)  sum limits_i=1^s b_i c_i^k-1 = frac1k  \nk = 1      sigma  \n\nC(eta)  sum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  \ni = 1     s   k = 1      eta  \n\nD(zeta)  sum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k )  \nj = 1     s   k = 1      zeta \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"These assumptions provide order conditions for a Runge-Kutta method given by (a_ij b_i c_i). The condition B(p) implies that the quadrature rule (b_i c_i) is of order p. Furthermore, the following theorem holds:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Theorem (Butcher 1964): If the coefficients (a_ij b_i c_i) of a Runge-Kutta method satisfy B(sigma), C(eta), D(zeta) with sigma le eta + zeta + 1 and sigma le 2 eta + 2, then the method is of order sigma.","category":"page"},{"location":"integrators/rk/#Gauß,-Lobatto-and-Radau-Methods","page":"Runge-Kutta","title":"Gauß, Lobatto and Radau Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Gauß methods are collocation methods using the nodes and weights of Gaußian quadrature formulas. The nodes are the zeros of the shifted Legendre polynomials of degree s,","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"fracd^sdx^s big( x^s (x-1)^s big) ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"In a similar fashion, the nodes of the Radau I and II and the Lobatto III methods are defined as the roots of the polynomials","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\n fracd^s-1dx^s-1 big( x^s (x-1)^s-1 big)      text(Radau I)  \n fracd^s-1dx^s-1 big( x^s-1 (x-1)^s big)      text(Radau II)  \n fracd^s-2dx^s-2 big( x^s-1 (x-1)^s-1 big)  text(Lobatto III) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The weights b_1  b_s are chosen such that the methods satisfy B(sigma), that is B(s), for the Gauß methods, B(s-1) for the Radau methods, and B(s-2) for the Lobatto methods.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The coefficients a_ij for ij = 1  s are obtained by the simplifying assumption C(s) for the Gauß, Radau IIA and Lobatto IIIA methods, and by the simplifying assumption D(s) for the Radau IA and Lobatto IIIB methods. The coefficients of the Lobatto IIIC methods are determined by setting a_i1 = b_1 for i = 1  s and solving the simplifying assumption C(s-1), while the coefficients of the Lobatto IIIC̄ methods are determined by setting a_is = 0 and solving C(s-1). Note that the Lobatto IIIC̄ methods are sometimes also called Lobatto III or Lobatto III*. For reasons of code symmetry we chose to stick with the less common name Lobatto IIIC̄. The Lobatto IIID and IIIE methods are obtained by combining the tableaus of the Lobatto IIIC and IIIC̄ and the Lobatto IIIA and IIIB methods, respectively, i.e., ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\na_ij^D = tfrac12 ( a_ij^C + a_ij^C ) \n textand \na_ij^E = tfrac12 ( a_ij^A + a_ij^B ) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"While the Lobatto IIIA, IIIB, IIIC and IIIC̄ methods are not symplectic on their own (although the Lobatto IIIA-IIIB and IIIC-IIIC̄ pairs constitute symplectic partitioned Runge-Kutta methods), the Lobatto IIID and IIIE methods are each symplectic by themselves.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The Gauß methods are of order 2s, the Radau methods or order 2s-1 and the Lobatto methods are of order 2s-2, with the exception of the Lobatto IIIF method. This method has been specifically constructed to be of order 2s as described in [Wang Fangzong , Liao Xiaobing  (2016)]. The Lobatto IIIG method is constructed in a similar fashion as the Lobatto IIID and IIIE methods by averaging the coefficients of the Lobatto IIIF method with its symplectic complement, i.e.,","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"a_ij^G = tfrac12 ( a_ij^F + bara_ij^F ) ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"where the coffiecients bara_ij^F are determined by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nb_i bara^F_ij + barb_j a^F_ji = b_i barb_j  \n textand \nbarb_i = b_i \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The tableaus of all of the above methods can be computed for an arbitrary number of stages s and thus to arbitrary order.","category":"page"},{"location":"integrators/rk/#Constructors","page":"Runge-Kutta","title":"Constructors","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The following methods are provided for the construction of the tableaus for the previously described methods:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Function Method\nTableauGauss(s, T=Float64) Gauß-Legendre with s stages\nTableauLobattoIIIA(s, T=Float64) Lobatto IIIA with s stages\nTableauLobattoIIIB(s, T=Float64) Lobatto IIIB with s stages\nTableauLobattoIIIC(s, T=Float64) Lobatto IIIC with s stages\nTableauLobattoIIIC̄(s, T=Float64) Lobatto IIIC̄ with s stages\nTableauLobattoIIID(s, T=Float64) Lobatto IIID with s stages\nTableauLobattoIIIE(s, T=Float64) Lobatto IIIE with s stages\nTableauLobattoIIIF(s, T=Float64) Lobatto IIIF with s stages\nTableauLobattoIIIG(s, T=Float64) Lobatto IIIG with s stages\nTableauRadauIA(s, T=Float64) Radau IA with s stages\nTableauRadauIB(s, T=Float64) Radau IB with s stages\nTableauRadauIIA(s, T=Float64) Radau IIA with s stages\nTableauRadauIIB(s, T=Float64) Radau IIB with s stages","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The first argument s refers to the number of stages (s ge 1 for Gauß and s ge 2 for all other methods). The second argument specifies the number type of the coefficients. Internally, all coefficients are computed using BigFloat and then converted to the requested number type, defaulting to Float64.","category":"page"},{"location":"integrators/rk/#Implicit-Equations","page":"Runge-Kutta","title":"Implicit Equations","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"TODO","category":"page"},{"location":"modules/integrators/#Integrators","page":"Integrators","title":"Integrators","text":"","category":"section"},{"location":"modules/integrators/#Common","page":"Integrators","title":"Common","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/abstract_coefficients.jl\",\n           \"integrators/abstract_integrator.jl\",\n           \"integrators/abstract_tableau.jl\",\n           \"integrators/integrator_cache.jl\",\n           \"integrators/integrators_common.jl\",\n           \"integrators/integrators.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.get_internal_variables-Tuple{Integrator}","page":"Integrators","title":"GeometricIntegrators.Integrators.get_internal_variables","text":"get_internal_variables(::Integrator) = NamedTuple()\n\nReturns a NamedTuple containing all internal variables of an integrator that shall be stored in an AtomicSolution. If there is no method for a specific integrator implemented an empty NamedTuple() is returned.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Tuple{Integrator,AtomicSolution}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Performs one time step with a given integrator.\n\nintegrate_step!(integrator::Integrator, asol::AtomicSolution)\n\nThe function accepts two arguments: an integrator and an appropriate AtomicSolution, which contains the state of the system at the beginning and the end of the time step and possibly additional information like solver output or the solution at internal stages of a Runge-Kutta method.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableau","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableau","text":"Holds the information for the various methods' tableaus.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_matrix-NTuple{4,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_matrix","text":"Create a vector of S solution matrices of type DT to store the solution of S internal stages for a problem with DxM dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector-Tuple{Any,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector","text":"Create a vector of S solution vectors of type DT to store the solution of S internal stages for a problem with D dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero-NTuple{4,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero","text":"Create a vector of (S,M+1) solution vectors of type DT to store the solution of S internal stages and M random processes for a problem with D dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero-Tuple{Any,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero","text":"Create a vector of S+1 solution vectors of type DT to store the solution of S internal stages and the solution of the previous timestep for a problem with D     dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_nonlinear_solver","page":"Integrators","title":"GeometricIntegrators.Integrators.create_nonlinear_solver","text":"Create nonlinear solver object for a system of N equations with data type DT. The function f(x)=0 to be solved for is determined by a julia function function_stages!(x, b, params), where x is the current solution and b is the output vector, s.th. b = f(x). params are a set of parameters depending on the equation and integrator that is used. The solver type is obtained from the config dictionary (:nls_solver).\n\n\n\n\n\n","category":"function"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Integrator(equation, tableau, Δt)\n\nUniversal constructor for Runge-Kutta (standard, partitioned, variational), SPARK and splitting integrators that automatically selects the appropriate integrator based on the equation and tableau types.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorConstructor","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorConstructor","text":"IntegratorConstructor(DT, D)\nIntegratorConstructor(DT, D, tableau)\n\nReturns a closure for various integrator constructors that is needed for composition methods based on the tableau type. If not tableau is provided, a closure for the constructor of an exact solution is returned.\n\nDT: data type of the solution / state vector\nD: dimension of the state vector\n\n\n\n\n\n","category":"function"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate","text":"integrate(equation, integrator, ntime; kwargs...)\nintegrate(equation, tableau, Δt, ntime; kwargs...)\n\nIntegrate an equation with integrator for ntime time steps and return the solution. If a tableau and a time step Δt is passed instead of an integrator, the appropriate integrator is created automatically.\n\nSome convenience methods exist for the integration of ODEs,\n\nintegrate(v, x₀, tableau, Δt, ntime; t₀=0., kwargs...)\n\nwhere v is the function for the vector field, x₀ the initial condition and t₀ the initial time, and for PODEs\n\nintegrate(v, f, q₀, p₀, tableau, Δt, ntime; t₀=0., kwargs...)\n\nwith vector fields v and f and initial conditions q₀ and p₀.\n\n\n\n\n\n","category":"function"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate!","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate!","text":"integrate!(integrator, solution)\n\nPerform the actual integration for a given integrator and solution. Solve all time steps for all initial conditions.\n\nintegrate!(integrator, solution, m₁, m₂)\n\nSolve all time steps for initial conditions m with m₁ ≤ m ≤ m₂.\n\nintegrate!(integrator, solution, m₁, m₂, n₁, n₂)\n\nSolve time steps n with n₁ ≤ n ≤ n₂ for initial conditions m with m₁ ≤ m ≤ m₂.\n\nintegrate!(integrator, solution, atomic_solution, m, n)\n\nSolve one time step n for one initial condition m.\n\n\n\n\n\n","category":"function"},{"location":"modules/integrators/#Initial-Guesses","page":"Integrators","title":"Initial Guesses","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/initial_guess/extrapolation.jl\",\n           \"integrators/initial_guess/initial_guess_ode.jl\",\n           \"integrators/initial_guess/initial_guess_pode.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.aitken_neville-Union{Tuple{TT}, Tuple{Array{TT,1},Array{T,2} where T,TT,Array{T,1} where T}} where TT","page":"Integrators","title":"GeometricIntegrators.Integrators.aitken_neville","text":"Compute p(x) where p is the unique polynomial of degree length(xi), such that p(x[i]) = y[i]) for all i.\n\nti: interpolation nodes\nxi: interpolation values\nt:  evaluation point\nx:  evaluation value\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.euler_extrapolation-Union{Tuple{TT}, Tuple{Function,TT,TT,Array{T,1} where T,Array{T,1} where T,Int64}} where TT","page":"Integrators","title":"GeometricIntegrators.Integrators.euler_extrapolation","text":"Euler extrapolation method with arbitrary order p.\n\nv:  function to compute vector field\nt₀: initial time\nt₁: final   time\nx₀: initial value\nx₁: final   value\ns:  number of interpolations (order p=s+1)\n\nTODO This is probably broken!\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.midpoint_extrapolation-Union{Tuple{DT}, Tuple{TT}, Tuple{Function,Function,TT,TT,Array{DT,1},Array{DT,1},Array{DT,1},Array{DT,1},Int64}} where DT where TT","page":"Integrators","title":"GeometricIntegrators.Integrators.midpoint_extrapolation","text":"Midpoint extrapolation method with arbitrary order p.\n\nv:  function to compute vector field\nf:  function to compute force  field\nt₀: initial time\nt₁: final   time\nq₀: initial positions\np₀: initial momenta\nq₁: final   positions\np₁: final   momenta\ns:  number of interpolations (order p=2s+2)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.midpoint_extrapolation-Union{Tuple{TT}, Tuple{DT}, Tuple{Function,TT,TT,Array{DT,1},Array{DT,1},Int64}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.midpoint_extrapolation","text":"Midpoint extrapolation method with arbitrary order p.\n\nv:  function to compute vector field\nt₀: initial time\nt₁: final   time\nx₀: initial value\nx₁: final   value\ns:  number of interpolations (order p=2s+2)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.InitialGuessODE","page":"Integrators","title":"GeometricIntegrators.Integrators.InitialGuessODE","text":"InitialGuessODE: Initial guess for ordinary differential equations\n\nFields\n\nint: interpolation structure\nv:   vector  field\nΔt:  time step\ns:   number of extrapolation stages (for initialisation)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initialize!-Union{Tuple{TT}, Tuple{DT}, Tuple{InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT,TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}}}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.initialize!","text":"Initialise initial guess, i.e., given t₀, t₁, q₁ compute q₀, v₀, v₁.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.update_vector_fields!-Union{Tuple{TT}, Tuple{DT}, Tuple{InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT,TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Array{DT,1}}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.update_vector_fields!","text":"compute vector field of new solution\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.InitialGuessPODE","page":"Integrators","title":"GeometricIntegrators.Integrators.InitialGuessPODE","text":"InitialGuessPODE: Initial guess for partitioned ordinary differential equations\n\nFields\n\nint: interpolation structure\nv:   vector field for q\nf:   vector field for p\nΔt:  time step\ns:   number of extrapolation stages (for initialisation)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initialize!-Union{Tuple{TT}, Tuple{DT}, Tuple{InitialGuessPODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT,TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}}}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.initialize!","text":"Initialise initial guess, i.e., given t₀, t₁, q₁ compute q₀, v₀, v₁.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Splitting-Methods","page":"Integrators","title":"Splitting Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/splitting/integrators_composition.jl\",\n           \"integrators/splitting/integrators_splitting.jl\",\n           \"integrators/splitting/integrators_exact_ode.jl\",\n           \"integrators/splitting/splitting_tableau.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorComposition","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorComposition","text":"Composition integrator for the solution of initial value problems\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwhose vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nIntegratorComposition has three constructors:\n\nIntegratorComposition{DT,D}(integrators::Tuple, Δt)\nIntegratorComposition(equation::SODE, constructors::Tuple, tableau::AbstractTableauSplitting, Δt)\nIntegratorComposition(equation::SODE, tableau::AbstractTableauSplitting, Δt)\n\nIn the first constructor, DT is the data type of the state vector and D the dimension of the system. In the second and third constructor, this information is extracted from the equation.  The tuple integrators contains the integrators for each substep. Each integrator is instantiated with appropriately scaled time step size Delta t = c_i tau to match the corresponding splitting scheme. In the second constructor, the tuple constructors contains constructors for the integrators of each step of the composition. The integrators are constructed according to the tableau and time step \\Delta t and passed to the first constructor. The third constructor assumes that the exact solution is used for each splitting step. It thus constructs a composition method that is equivalent to a plain IntegratorSplitting.\n\nIn order to include exact solutions in the composition, the IntegratorExactODE implements the general integrator interface.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorSplitting","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorSplitting","text":"Splitting integrator for the solution of initial value problems\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwhose vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nIntegratorSplitting has two constructors:\n\nIntegratorSplitting{DT,D}(solutions::Tuple, f::Vector{Int}, c::Vector, Δt)\nIntegratorSplitting(equation::SODE, tableau::AbstractTableauSplitting, Δt)\n\nIn the first constructor, DT is the data type of the state vector and D the dimension of the system. In the second constructor, this information is extracted from the equation.  The tuple solutions contains functions implementing the flow (exact solution) of the vector fields v_i. The vectors f and c define the actual splitting method: f is a vector of indices of the flows in the split equation to be solved and c is a vector of the same size f that contains the coefficients for each splitting step, i.e., the resulting integrator has the form\n\nvarphi_tau = phi_cs tau^v_fs circ dotsc circ phi_c2 tau^v_f2 circ phi_c1 tau^v_f1 \n\nIn the second constructor, these vectors are constructed from the tableau and the equation.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorExactODE","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorExactODE","text":"Exact solution of an ODE.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauSplitting","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauSplitting","text":"Tableau for general splitting methods for vector fields with two components A and B.\n\nIntegrator:\n\nvarphi_tau = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauSplittingGS","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauSplittingGS","text":"Tableau for symmetric splitting methods with general stages.     See McLachlan, Quispel, 2003, Equ. (4.11).\n\nBasic method: Lie composition\n\nbeginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1\nendaligned\n\nIntegrator:\n\nvarphi_tau^GS = varphi_a_1 tau^A circ varphi_b_1 tau^B circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauSplittingNS","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauSplittingNS","text":"Tableau for non-symmetric splitting methods.     See McLachlan, Quispel, 2003, Equ. (4.10).     The methods A and B are the composition of all vector fields in the SODE     and its adjoint, respectively.\n\nBasic method: Lie composition\n\nbeginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1\nendaligned\n\nIntegrator:\n\nvarphi_tau^NS = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauSplittingSS","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauSplittingSS","text":"Tableau for symmetric splitting methods with symmetric stages.     See McLachlan, Quispel, 2003, Equ. (4.6).\n\nBasic method: symmetric Strang composition\n\nvarphi_tau^A = varphi_tau2^v_1 circ varphi_tau2^v_2 circ dotsc circ varphi_tau2^v_r-1 circ varphi_tau2^v_r circ varphi_tau2^v_r circ varphi_tau2^v_r-1 circ dotsc circ varphi_tau2^v_2 circ varphi_tau2^v_1\n\nIntegrator:\n\nvarphi_tau^SS = varphi_a_1 tau^A circ varphi_a_2 tau^A circ dotsc circ varphi_a_s tau^A circ dotsc circ varphi_a_2 tau^A circ varphi_a_1 tau^A\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Runge-Kutta-Methods","page":"Integrators","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/rk/bstract_integrator_rk.jl\",\n           \"integrators/rk/coefficients.jl\",\n           \"integrators/rk/tableaus.jl\",\n           \"integrators/rk/integrators_erk.jl\",\n           \"integrators/rk/integrators_dirk.jl\",\n           \"integrators/rk/integrators_firk.jl\",\n           \"integrators/rk/integrators_eprk.jl\",\n           \"integrators/rk/integrators_iprk.jl\",\n           \"integrators/rk/integrators_flrk.jl\",\n           \"integrators/rk/integrators_pglrk.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableauPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableauPRK","text":"Holds the tableau of a partitioned Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableauRK","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableauRK","text":"Holds the tableau of a Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheERK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheERK","text":"Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorERK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorERK","text":"Explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersERK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersERK","text":"Parameters for right-hand side function of explicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheDIRK","text":"Diagonally implicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorDIRK","text":"Diagonally implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersDIRK","text":"Parameters for right-hand side function of diagonally implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict,Int64}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initial_guess!-Union{Tuple{DT}, Tuple{IntegratorDIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT) where ST where PT<:(GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D where TT,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N) where TT<:Real}, Tuple{IntegratorDIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT) where ST where PT<:(GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D where TT,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N) where TT<:Real,GeometricIntegrators.Integrators.IntegratorCacheDIRK{DT,D,S} where S where D}} where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.initial_guess!","text":"Compute initial guess for internal stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initialize!-Tuple{IntegratorDIRK,GeometricIntegrators.Integrators.IntegratorCacheDIRK}","page":"Integrators","title":"GeometricIntegrators.Integrators.initialize!","text":"Initialise initial guess\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheFIRK","text":"Fully implicit Runge-Kutta integrator cache.\n\nFields\n\nq̃: initial guess of solution\nṽ: initial guess of vector field\ns̃: holds shift due to periodicity of solution\nQ: internal stages of solution\nV: internal stages of vector field\nY: vector field of internal stages\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorFIRK","text":"Fully implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersFIRK","text":"Parameters for right-hand side function of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersFIRK{DT,TT,D,S,ET,FT,JT} where JT where FT where ET<:NamedTuple where S,GeometricIntegrators.Integrators.CacheDict}} where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.jacobian!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{Array{DT,1},Array{DT,2},GeometricIntegrators.Integrators.IntegratorCacheFIRK{DT,D,S},GeometricIntegrators.Integrators.ParametersFIRK{DT,TT,D,S,ET,FT,JT} where JT where FT where ET<:NamedTuple}} where S where D where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.jacobian!","text":"Compute stages of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheEPRK","text":"Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorEPRK","text":"Explicit partitioned Runge-Kutta integrator solving the system\n\nbeginaligned\nV_ni = v (Q_ni P_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = f (Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nUsually we are interested in Hamiltonian systems, where\n\nbeginaligned\nV_ni = dfracpartial Hpartial p (Q_ni P_ni)  \nF_ni = - dfracpartial Hpartial q (Q_ni P_ni)  \nendaligned\n\nand tableaus satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersEPRK","text":"Parameters for right-hand side function of explicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.computeStageP!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorEPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D,GeometricIntegrators.Integrators.IntegratorCacheEPRK{DT,D,S} where S where D,Int64,Int64,TT}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.computeStageP!","text":"Compute P stages of explicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.computeStageQ!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorEPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D,GeometricIntegrators.Integrators.IntegratorCacheEPRK{DT,D,S} where S where D,Int64,Int64,TT}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.computeStageQ!","text":"Compute Q stages of explicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheIPRK","text":"Implicit partitioned Runge-Kutta integrator cache.\n\nFields\n\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: vector field of internal stages of q\nZ: vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorIPRK","text":"Implicit partitioned Runge-Kutta integrator solving the system\n\nbeginaligned\nV_ni = v (Q_ni P_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = f (Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nUsually we are interested in Hamiltonian systems, where\n\nbeginaligned\nV_ni = dfracpartial Hpartial p (Q_ni P_ni)  \nF_ni = - dfracpartial Hpartial q (Q_ni P_ni)  \nendaligned\n\nand tableaus satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersIPRK","text":"Parameters for right-hand side function of implicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersIPRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of implicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorFLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorFLRK","text":"Formal Lagrangian Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersFLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersFLRK","text":"Parameters for right-hand side function of formal Lagrangian Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersFLRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of formal Lagrangian Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.CoefficientsPGLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.CoefficientsPGLRK","text":"Holds the coefficients of a projected Gauss-Legendre Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorPGLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorPGLRK","text":"Projected Gauss-Legendre Runge-Kutta integrator.\n\nReference: LUIGI BRUGNANO, FELICE IAVERNARO, AND DONATO TRIGIANTE.\n    ENERGY- AND QUADRATIC INVARIANTS–PRESERVING INTEGRATORS BASED\n    UPON GAUSS COLLOCATION FORMULAE.\n    SIAM J. NUMER. ANAL. Vol. 50, No. 6, pp. 2897–2916, 2012.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersPGLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersPGLRK","text":"Parameters for right-hand side function of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Base.show-Tuple{IO,CoefficientsPGLRK}","page":"Integrators","title":"Base.show","text":"Print Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,IntegratorPGLRK}","page":"Integrators","title":"Base.show","text":"Print Projected Gauss-Legendre Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersPGLRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#SPARK-Methods","page":"Integrators","title":"SPARK Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators.SPARK]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK","text":"Parameters for right-hand side function of Specialised Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsARK","text":"Holds the coefficients of an additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsIRK","text":"Holds the coefficients of an additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsMRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsMRK","text":"Holds the multiplier Runge-Kutta coefficients.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsPRK","text":"Holds the coefficients of a projective Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsSPARK","text":"Holds the coefficients of a SPARK method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorCacheSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorCacheSPARK","text":"Cache of a Specialised Partitioned Additive Runge-Kutta integrator.\n\nFields\n\nn: time step number\nt: time of current time step\nt̄: time of previous time step\nq: current solution of q\nq̄: previous solution of q\np: current solution of p\np̄: previous solution of p\nv: vector field of q\nv̄: vector field of q̄\nf: vector field of p\nf̄: vector field of p̄\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: vector field of internal stages of q\nZ: vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHPARK","text":"Partitioned Additive Runge-Kutta integrator for Hamiltonian systems subject to Dirac constraints EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \ntildePhi_ni = 0   i = 1  r \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKprimary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKprimary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKsecondary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems subject to Dirac constraints with projection on secondary constraint EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorSLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorSLRK","text":"Specialised Partitioned Additive Runge-Kutta integrator for degenerate variational systems with projection on secondary constraint.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a^1_ij V_nj + h sum limits_j=1^sigma a^2_ij tildeLambda_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s bara^1_ij F^1_nj + h sum limits_j=1^s bara^2_ij F^2_nj + h sum limits_j=1^sigma bara^3_ij tildeF^3_nj   i = 1  s  \n0 = Phi_ni   i = 1  s \nendaligned\n\nthe projective stages\n\nbeginaligned\ntildeQ_ni = q_n + h sum limits_j=1^s alpha^1_ij tildeV_nj + h sum limits_j=1^sigma alpha^2_ij tildeLambda_nj   i = 1  sigma  \ntildeP_ni = p_n + h sum limits_j=1^s baralpha^1_ij F^1_nj + h sum limits_j=1^s baralpha^2_ij tildeF^2_nj + h sum limits_j=1^sigma baralpha^3_ij tildeF^3_nj   i = 1  sigma  \n0 = tildePhi_ni   i = 1  sigma  \n0 = sum limits_j=1^sigma omega_ij tildePsi_ni   i = 1  sigma-1 \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b^1_i V_ni + h sum limits_i=1^sigma b^2_i tildeLambda_ni  \np_n+1 = p_n + h sum limits_i=1^s b^1_i F^1_ni + h sum limits_i=1^s b^2_i F^2_ni + h sum limits_i=1^sigma b^3_i tildeF^3_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nwith definitions\n\nbeginaligned\nF^1_ni = nabla H (Q_ni)   i = 1  s  \nF^2_ni = nabla vartheta (Q_ni) cdot V_ni   i = 1  s  \ntildeF^3_ni = nabla phi (tildeQ_ni tildeP_ni) cdot tildeLambda_ni   i = 1  sigma  \nPhi_ni = phi (Q_ni P_ni) = P_ni - vartheta (Q_ni)   i = 1  s  \ntildePhi_ni = phi (tildeQ_ni tildeP_ni) = tildeP_ni - vartheta (tildeQ_ni)   i = 1  sigma  \ntildePsi_ni = psi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla vartheta (tildeQ_ni)   i = 1  sigma \nendaligned\n\nso that\n\nbeginaligned\nF^1_ni + F^2_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nphi (Q_ni P_ni) = P_ni - fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \npsi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla fracpartial Lpartial v (tildeQ_ni tildeV_ni)   i = 1  sigma \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for index-two DAE systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVPARK","text":"Variational partitioned additive Runge-Kutta integrator.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \ntildePhi_ni = 0   i = 1  r \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for Variational systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKprimary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKprimary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Variational systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1  \n0 = sum limits_i=1^r tilded_i  Lambda_ni \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKsecondary","text":"Specialised Partitioned Additive Runge-Kutta integrator for degenerate variational systems with projection on secondary constraint.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a^1_ij V_nj + h sum limits_j=1^sigma a^2_ij tildeLambda_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s bara^1_ij F^1_nj + h sum limits_j=1^s bara^2_ij F^2_nj + h sum limits_j=1^sigma bara^3_ij tildeF^3_nj   i = 1  s  \n0 = Phi_ni   i = 1  s \nendaligned\n\nthe projective stages\n\nbeginaligned\ntildeQ_ni = q_n + h sum limits_j=1^s alpha^1_ij tildeV_nj + h sum limits_j=1^sigma alpha^2_ij tildeLambda_nj   i = 1  sigma  \ntildeP_ni = p_n + h sum limits_j=1^s baralpha^1_ij F^1_nj + h sum limits_j=1^s baralpha^2_ij tildeF^2_nj + h sum limits_j=1^sigma baralpha^3_ij tildeF^3_nj   i = 1  sigma  \n0 = tildePhi_ni   i = 1  sigma  \n0 = sum limits_j=1^sigma omega_ij tildePsi_ni   i = 1  sigma-1 \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b^1_i V_ni + h sum limits_i=1^sigma b^2_i tildeLambda_ni  \np_n+1 = p_n + h sum limits_i=1^s b^1_i F^1_ni + h sum limits_i=1^s b^2_i F^2_ni + h sum limits_i=1^sigma b^3_i tildeF^3_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nwith definitions\n\nbeginaligned\nF^1_ni = nabla H (Q_ni)   i = 1  s  \nF^2_ni = nabla vartheta (Q_ni) cdot V_ni   i = 1  s  \ntildeF^3_ni = nabla phi (tildeQ_ni tildeP_ni) cdot tildeLambda_ni   i = 1  sigma  \nPhi_ni = phi (Q_ni P_ni) = P_ni - vartheta (Q_ni)   i = 1  s  \ntildePhi_ni = phi (tildeQ_ni tildeP_ni) = tildeP_ni - vartheta (tildeQ_ni)   i = 1  sigma  \ntildePsi_ni = psi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla vartheta (tildeQ_ni)   i = 1  sigma \nendaligned\n\nso that\n\nbeginaligned\nF^1_ni + F^2_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nphi (Q_ni P_ni) = P_ni - fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \npsi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla fracpartial Lpartial v (tildeQ_ni tildeV_ni)   i = 1  sigma \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersHPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersHPARK","text":"Parameters for right-hand side function of Hamiltonian Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersSLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersSLRK","text":"Parameters for right-hand side function of Specialised Partitioned Additive Runge-Kutta methods for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersVPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersVPARK","text":"Parameters for right-hand side function of Variational Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersVSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersVSPARKsecondary","text":"Parameters for right-hand side function of Specialised Partitioned Additive Runge-Kutta methods for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauHPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauHPARK","text":"Holds the tableau of a Hamiltonian Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauSLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauSLRK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauSPARK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauVPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauVPARK","text":"Holds the tableau of an Variational Partitioned Additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauVSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauVSPARKsecondary","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsARK}","page":"Integrators","title":"Base.show","text":"Print additive Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsIRK}","page":"Integrators","title":"Base.show","text":"Print additive Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsMRK}","page":"Integrators","title":"Base.show","text":"Print multiplier Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsPRK}","page":"Integrators","title":"Base.show","text":"Print projective Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsSPARK}","page":"Integrators","title":"Base.show","text":"Print SPARK coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hspark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hspark_primary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:spark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vspark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vspark_primary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hpark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned additive Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hspark_secondary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vpark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned additive Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vspark_secondary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:slrk,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P where R,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#VPRK-Methods","page":"Integrators","title":"VPRK Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators.VPRK]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK","text":"Parameters for right-hand side function of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK","text":"Variational partitioned Runge-Kutta integrator cache.\n\nFields\n\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: integral of vector field of internal stages of q\nZ: integral of vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRK","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKdegenerate","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKdegenerate","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpInternal","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpInternal","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpLegendre","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpLegendre","text":"Variational special partitioned additive Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpMidpoint","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpMidpoint","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary","text":"Variational partitioned Runge-Kutta integrator with projection on secondary constraint.\n\nThe VPRK integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  big( V_nj + Lambda_nj big)  \nP_ni = p_n + h sum limits_i=1^s bara_ij  big( F_nj + nabla vartheta (Q_nj)^T cdot Lambda_nj big) - d_i lambda  \n0 = sum limits_i=1^s d_i V_i  \n0 = sum limits_j=1^s omega_ij Psi_nj \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nPsi_ni = psi(Q_ni V_ni P_ni F_ni) \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i  big( V_ni + Lambda_ni big)  \np_n+1 = p_n + h sum limits_i=1^s barb_i  big( F_ni + nabla vartheta (Q_nj)^T cdot Lambda_nj big)  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nsatisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\nthe primary constraint,\n\nbeginaligned\nphi(qp) = p - vartheta (q) = 0 \nendaligned\n\nat the final solution (q_n+1 p_n+1), and super positions of the secondary constraints,\n\nbeginaligned\npsi(qdotqpdotp)\n= dotp - dotq cdot nabla vartheta (q)\n= big( nabla vartheta (q) - nabla vartheta^T (q) big) cdot dotq - nabla H (q)\n= 0\nendaligned\n\nwhich, evaluated at the internal stages, read\n\nbeginaligned\nPsi_nj = big( nabla vartheta (Q_nj) - nabla vartheta^T (Q_nj) big) cdot V_nj - nabla H (Q_nj) \nendaligned\n\nHere, omega is a (s-1) times s matrix, chosen such that the resulting method has optimal order. The vector d is zero for Gauss-Legendre methods and needs to be chosen appropriately for Gauss-Lobatto methods (for details see documentation of VPRK methods).\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard-Tuple","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard","text":"Variational partitioned Runge-Kutta integrator with standard projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymmetric","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymmetric","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpTableau","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpTableau","text":"Projected Variational Gauss-Legendre Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariational","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariational","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRK","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKdegenerate","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKdegenerate","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpInternal","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpInternal","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpLegendre","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpLegendre","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpMidpoint","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpMidpoint","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSecondary","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpStandard","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpStandard","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSymmetric","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSymmetric","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau","text":"Parameters for right-hand side function of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpVariational","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpVariational","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.TableauVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.TableauVPRK","text":"TableauVPRK: Tableau of a Variational Partitioned Runge-Kutta method\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nP_ni = p_n + h sum limits_i=1^s bara_ij  F_nj - d_i lambda  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni  \n\n0 = sum limits_i=1^s d_i V_i  \nendaligned\n\nsatisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + b_j a_ji = b_i b_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymplectic-Tuple","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymplectic","text":"Variational partitioned Runge-Kutta integrator with symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalP-Tuple","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalP","text":"Variational partitioned Runge-Kutta integrator with variational projection on (p_n q_n+1).\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalQ-Tuple","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalQ","text":"Variational partitioned Runge-Kutta integrator with variational projection on (q_n p_n+1).\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_degenerate,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute solution of degenerate symplectic partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pinternal,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_plegendre,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational special partitioned additive Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pmidpoint,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psecondary,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pstandard,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psymmetric,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pvariational,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Galerkin-Variational-Integrators","page":"Integrators","title":"Galerkin Variational Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/cgvi/integrators_cgvi.jl\",\n           \"integrators/dgvi/integrators_dgvi.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCGVI","text":"Continuous Galerkin Variational Integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersCGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersCGVI","text":"ParametersCGVI: Parameters for right-hand side function of continuous Galerkin variational Integrator.\n\nParameters\n\nΘ: function of the noncanonical one-form (∂L/∂v)\nf: function of the force (∂L/∂q)\nΔt: time step\nb: weights of the quadrature rule\nc: nodes of the quadrature rule\nx: nodes of the basis\nm: mass matrix\na: derivative matrix\nr₀: reconstruction coefficients at the beginning of the interval\nr₁: reconstruction coefficients at the end of the interval\nt: initial time\nq: solution of q at time t\np: solution of p at time t\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersCGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheDGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheDGVI","text":"Nonlinear function cache for Discontinuous Galerkin Variational Integrator.\n\nParameters\n\nST: data type\nD: number of dimensions\nS: number of degrees of freedom\nR: number of nodes of quadrature formula\n\nFields\n\nX: degrees of freedom\nQ: solution at quadrature nodes\nV: velocity at quadrature nodes\nP: one-form at quadrature nodes\nF: forces at quadrature nodes\nq:  current solution of q_n\nq⁻: current solution of q_n^-\nq⁺: current solution of q_n^+\nq̄:  current solution of q_n+1\nq̄⁻: current solution of q_n+1^-\nq̄⁺: current solution of q_n+1^+\nϕ:  average of the solution at t_n\nϕ̅:  average of the solution at t_n+1\nλ:  jump of the solution at t_n\nλ̄:  jump of the solution at t_n+1\nθ:  one-form evaluated across at t_n\nΘ̅:  one-form evaluated across at t_n+1\ng:  projection evaluated across at t_n\nḡ:  projection evaluated across at t_n+1\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorDGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorDGVI","text":"IntegratorDGVI: Discontinuous Galerkin Variational Integrator.\n\nThe DGVI integrators arise from the discretization of the action integral\n\nmathcalA q = int limits_0^T L(q(t) dotq(t))  dt \n\nwith L a fully degenerate Lagrangian of the form\n\nL(q dotq) = vartheta (q) cdot dotq - H(q) \n\nwhere vartheta (q) denotes the Cartan one-form and H(q) the Hamiltonian, which is usually given by the total energy of the system.\n\nDiscretization\n\nWithin each interval (t_n t_n+1) a piecewise-polynomial approximation q_h of the trajectory q is constructed using S basis functions varphi_i,\n\nq_h(t) vert_(t_n t_n+1) = sum limits_i=1^S x_ni  barvarphi_ni (t) \n\nwhere barvarphi_ni (t) is a rescaled basis function, defined by\n\nbarvarphi_ni (t) = varphi_i bigg( fract - t_nt_n+1 - t_n bigg) \n\nand it is assumed that varphi_i is compactly supported on 01. These approximations q_h(t) are not assumed to be continuous across interval boundaries t_n but usuaslly have jumps.\n\nThe integral over (t_n t_n+1) is approximated by a quadrature rule with R nodes c_i and weights b_i. Denote by m and a mass and derivative matrices, respectively, whose elements  are given by\n\nm_ij = varphi_j (c_i) \nqquad\na_ij = varphi_j (c_i) \nqquad\ni = 1  R \n\nj = 1  S \n\nWith that, the solution and its time derivative at the quadrature points can be written as\n\nQ_ni equiv q_h(t_n + c_i h) = m_ij x_nj \nqquad\nV_ni equiv dotq_h (t_n + c_i h) = a_ij x_nj \n\nwhere\n\nx_n = ( x_n1  x_nS )^T\n\nis the vector containing the degrees of freedom of q_h vert_t_n t_n+1. The limits of q_h(t) at t_n and t_n+1 are given by\n\nq_n^+ = lim limits_t downarrow t_n q_h(t) = sum limits_j=1^S r^+_j delta x_nj \nhspace3em\nq_n+1^- = lim limits_t uparrow t_n+1 q_h(t) = sum limits_j=1^S r^-_j delta x_nj \n\nThe discrete action reads\n\nmathcalA_d x_d = h sum limits_n=0^N-1 bigg\n     sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big \n     + fracvartheta (q_n) + vartheta (q_n^+)2 cdot (q_n^+ - q_n)\n     + fracvartheta (q_n+1^-) + vartheta (q_n+1)2 cdot (q_n+1 - q_n+1^-)\nbigg \n\nso that using the relations\n\ndelta Q_ni = m_ij delta x_nj \nqquad\ndelta V_ni = fraca_ijh delta x_nj \nqquad\ndelta q_n^- = r^-_j delta x_n-1j \nqquad\ndelta q_n^+ = r^+_j delta x_nj \n\nthe discrete action principle leads to the discrete equations of motion,\n\n0 = sum limits_i=1^R b_i big h m_ij nabla vartheta (Q_ni) cdot V_ni + a_ij vartheta (Q_ni) - h m_ij nabla H(Q_ni) big \n+ r^+_j  frac vartheta ( q_n     ) + vartheta( q_n  ^+ ) 2\n- r^-_j  frac vartheta ( q_n+1^- ) + vartheta( q_n+1   ) 2\n   big \n+ h r^+_j  nabla vartheta (q_n  ^+) cdot (q_n  ^+ - q_n    )\n+ h r^-_j  nabla vartheta (q_n+1^-) cdot (q_n+1   - q_n+1^-) \n\nand\n\nvartheta(q_n^+) = vartheta (q_n^-) + nabla vartheta (q_n) cdot (q_n^+ - q_n^-) \n\nfor all n and all j. Let us introduce the variable p_n as\n\np_n = vartheta (q_n^-) + nabla vartheta (q_n) cdot (q_n - q_n^-) \n\nso that\n\nvartheta(q_n^+) = p_n + nabla vartheta (q_n) cdot (q_n^+ - q_n) \n\nThen the above equations provide a map (q_n p_n) mapsto (q_n+1 p_n+1). In order to solve these equations, initial conditions q_0 and p_0 = vartheta(q_0) have to be prescribed.\n\nFields\n\nequation: Implicit Ordinary Differential Equation\nbasis: piecewise polynomial basis\nquadrature: numerical quadrature rule\nΔt: time step\nparams: ParametersDGVI\nsolver: nonlinear solver\niguess: initial guess\nq: current solution vector for trajectory\np: current solution vector for one-form\ncache: temporary variables for nonlinear solver\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersDGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersDGVI","text":"ParametersDGVI: Parameters for right-hand side function of Discontinuous Galerkin Variational Integrator.\n\nParameters\n\nDT: data type\nTT: parameter type\nD: dimension of the system\nS: number of basis nodes\nR: number of quadrature nodes\n\nFields\n\nΘ:  function of the noncanonical one-form (∂L/∂v)\nf:  function of the force (∂L/∂q)\ng:  function of the projection ∇ϑ(q)⋅v\nΔt: time step\nb:  quadrature weights\nc:  quadrature nodes\nm:  mass matrix\na:  derivative matrix\nr⁻: reconstruction coefficients, jump lhs value\nr⁺: reconstruction coefficients, jump rhs value\nt:  initial time\nq:  solution of q  at time t\nq⁻: solution of q⁻ at time t\nq⁺: solution of q⁺ at time t\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.compute_stages_p!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{GeometricIntegrators.Integrators.IntegratorCacheDGVI{ST,D,S,R},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.compute_stages_p!","text":"Compute one-form and forces at quadrature nodes.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.compute_stages_q!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{GeometricIntegrators.Integrators.IntegratorCacheDGVI{ST,D,S,R},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.compute_stages_q!","text":"Compute solution at quadrature nodes and across jump.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.compute_stages_v!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{GeometricIntegrators.Integrators.IntegratorCacheDGVI{ST,D,S,R},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.compute_stages_v!","text":"Compute velocities at quadrature nodes.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"integrators/dgvi/#dgvi","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Discontinuous Galerkin Variational Integrators (DGVIs) are a family of integrators for degenerate Lagrangian systems and for Hamiltonian systems subject to Dirac constraints. For integrators for non-degenerate (regular) Lagrangian and unconstrained Hamiltonian systems see Hamilton-Pontryagin-Galerkin (HPG) Integrators.","category":"page"},{"location":"integrators/dgvi/#Degenerate-Lagrangian-Systems","page":"Discontinuous Galerkin Variational Integrators","title":"Degenerate Lagrangian Systems","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Consider a fully degenerate Lagrangian system of the form","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"L(q dotq) = vartheta (q) cdot dotq - H(q) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where vartheta (q) denotes the Cartan one-form and H(q) the Hamiltonian, that is usually given by the total energy of the system.","category":"page"},{"location":"integrators/dgvi/#Discrete-Trajectories-and-Numerical-Quadrature","page":"Discontinuous Galerkin Variational Integrators","title":"Discrete Trajectories and Numerical Quadrature","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The first step in the derivation of variational integrators is the discretization of the action integral","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q = int limits_0^T L(q(t) dotq(t))  dt ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"To this end, the interval 0T is split into N sub-intervals t_n t_n+1 with t_n = nh and h the time step size, so that t_N = T and the action can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q = sum limits_n=0^N-1 int limits_t_n t_n+1 L(q(t) dotq(t))  dt ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Within each interval (t_n t_n+1) a piecewise-polynomial approximation q_h of the trajectory q is constructed using S basis functions varphi_i,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_h(t) vert_(t_n t_n+1) = sum limits_i=1^S x_ni  barvarphi_ni (t) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where barvarphi_ni (t) is a rescaled basis function, defined by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"barvarphi_ni (t) = varphi_i bigg( fract - t_nt_n+1 - t_n bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and it is assumed that varphi_i is compactly supported on 01. These approximations q_h(t) do not need to be continuous across interval boundaries but are indeed allowed to have jumps. Replacing the continuous trajectory q in the action with q_h, we obtain","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q_h = sum limits_n=0^N-1 int limits_(t_n t_n+1) big vartheta (q_h (t)) cdot dotq_h (t) - H(q_h (t)) big  dt\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n  ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The integral of the Hamiltonian H(q_h) over the interval boundaries does not contribute to the integral, differently from the term vartheta (q_h) cdot dotq_h, which will determine the numerical flux  cdot _n at t_n of the Discontinuous Galerkin method. The approximation of this term will be discussed below. In order to obtain a fully discrete action, a numerical quadrature rule with R nodes c_i and weights b_i is introduced for the approximation of the integral,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (q_h(t_n + c_i h)) cdot dotq_h (t_n + c_i h) - H(q_h(t_n + c_i h)) big\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Here, x_d denotes the vector of all the degrees of freedom, i.e.,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"x_d = ( x_01  x_0S  x_11  x_N-2S  x_N-11  x_N-1S )^T ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In order to write the discrete action in a more explicit form, mass and derivative matrices m and a are introduced, whose elements are given by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"m_ij = varphi_j (c_i) \nqquad\na_ij = varphi_j (c_i) \nqquad\ni = 1  R \n\nj = 1  S ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"so that the solution and its time derivative at the quadrature points can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Q_ni equiv q_h(t_n + c_i h) = m_ij x_nj \nqquad\nV_ni equiv dotq_h (t_n + c_i h) = a_ij x_nj ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"x_n = ( x_n1  x_nS )^T","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"is the vector containing the degrees of freedom of q_h vert_t_n t_n+1. Using these definitions, the discrete action can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n ","category":"page"},{"location":"integrators/dgvi/#Numerical-Fluxes","page":"Discontinuous Galerkin Variational Integrators","title":"Numerical Fluxes","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In the following, the solution values \"left\" and \"right\" of the jump will be needed. This will be denoted by q_n^- and q_n^+, respectively. Usually, these just correspond to the polynomials on the left and right, evaluated at t_n, i.e.,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_n^- = lim_t uparrow t_n q_h (t) = q_h vert_t_n-1 t_n (t_n) \nqquad\nq_n^+ = lim_t downarrow t_n q_h (t) = q_h vert_t_n t_n+1 (t_n) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In principle, however, more general reconstructions of the solution could be used. In the following, it will be assumed, that q_n^- is given by some linear combinations of the degrees of freedom of the polynomial on the left interval and correspondingly that q_n^+ is given by some linear combinations of the degrees of freedom of the polynomial on the right interval, specifically","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_n^- = r^- cdot x_n \nqquad\nq_n^+ = r^+ cdot x_n+1 ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where r^pm are appropriate coefficient vectors.","category":"page"},{"location":"integrators/dgvi/#Gauge-Terms","page":"Discontinuous Galerkin Variational Integrators","title":"Gauge Terms","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The Lagrangian L can be augmented with any total time derivative without changing the (continuous) Euler-Lagrange equations. In particular, one can consider the modified Lagrangian","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"L(q dotq) = vartheta (q) cdot dotq - H(q) - nu dfracddt bigg( vartheta (q) cdot q bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"While this gauge term vanishes in the continuous case, it takes a finite value across jumps of the discontinuous discrete solution, so that the modified discrete action reads","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big\n+ sum limits_n=1^N-1 biggbigg vartheta (q_h (t)) cdot dotq_h (t) - nu dfracddt bigg( vartheta (q) cdot q bigg) biggbigg_t=t_n ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In the following, only the modified Lagrangian and action will be considered, in order to obtain a sufficiently general framework for constructing numerical fluxes. For brevity of notation, the prime will be dropped.","category":"page"},{"location":"integrators/dgvi/#Total-Time-Derivatives-Across-Jumps","page":"Discontinuous Galerkin Variational Integrators","title":"Total Time Derivatives Across Jumps","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The computation of the total time derivative in the gauge term is simple, at least in the distributional sense. Even though both, vartheta (q_h) and q_h have a jump, the jump occurs at the same position in time, so that the derivative can be computed as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"dfracddt bigg( vartheta (q_h) cdot q_h bigg) biggvert_t=t_n\n= dfracddt bigg( vartheta (q_n^-) cdot q_n^-  Theta (t_n - t) + vartheta (q_n^+) cdot q_n^+  Theta (t - t_n) bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where Theta denotes the Heaviside function. This can be explicitly computed as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"dfracddt bigg( vartheta (q_h) cdot q_h bigg) biggvert_t=t_n\n= - vartheta (q_n^-) cdot q_n^-  delta (t_n) + vartheta (q_n^+) cdot q_n^+  delta (t_n)\n=  vartheta (q_h) cdot q_h _t=t_n  delta (t_n) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"with delta (t_n) the Dirac delta-function at t_n.","category":"page"},{"location":"integrators/dgvi/#Non-conservative-Products","page":"Discontinuous Galerkin Variational Integrators","title":"Non-conservative Products","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Simple means for integrating the Lagrangian across jumps are provided by discretisations of the integral","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"int limits_0^1 vartheta (Phi(tau q^- q^+)) cdot dfracd Phi(tau q^- q^+)dtau  dtau ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where Phi is a path connecting the solution values q^- and q^+ on the left and the right of the jump. Upon picking a quadrature rule with sigma nodes gamma_i and corresponding weights beta_i, the discrete product takes the form","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"sum limits_i=1^sigma beta_i  vartheta big( Phi (gamma_i q_n^-  q_n^+) big) cdot dfracdPhidtau (gamma_i q_n^-  q_n^+) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"For a compact notation, \"mass\" and \"derivative\" vectors mu^pm and alpha^pm are introduced, so that","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Phi (gamma_i q_n^-  q_n^+) = mu^-_i q_n^- + mu^+_i q_n^+\nqquad\nPhi (gamma_i q_n^-  q_n^+) = alpha^-_i q_n^- + alpha^+_i q_n^+ ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and the discrete product can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"sum limits_i=1^sigma beta_i  vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Providing the path Phi by two functions phi^pm(tau), so that","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"phi(tau q^- q^+) = q^- phi^-(tau) + q^+ phi^+(tau) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"the components of the \"mass\" and \"derivative\" vectors are given by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mu^-_i = phi^- (gamma_i) \nqquad\nmu^+_i = phi^+ (gamma_i) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"alpha^-_i = fracdphi^-dtau (gamma_i) \nqquad\nalpha^+_i = fracdphi^+dtau (gamma_i) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"respectively.","category":"page"},{"location":"integrators/dgvi/#Discrete-Variational-Principle","page":"Discontinuous Galerkin Variational Integrators","title":"Discrete Variational Principle","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Using the construction of the previous sections, the discrete action reads","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma beta_i  vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ )\n- nu big vartheta (q_n^+) cdot q_n^+ - vartheta (q_n^-) cdot q_n^- big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The discrete Euler-Lagrange equations are obtained by applying Hamilton's principle of stationary action to mathcalA_d x_d, that is requiring that delta mathcalA_d x_d = 0. The variations of the discrete action are computed as follows,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta mathcalA_d x_d\n= h sum limits_n=0^N-1 sum limits_i=1^R b_i big delta Q_ni cdot nabla vartheta (Q_ni) cdot V_ni + vartheta (Q_ni) cdot delta V_ni - delta Q_ni cdot nabla H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma beta_i  big ( mu^-_i delta q_n^- + mu^+_i delta q_n^+ ) cdot nabla vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) + vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i delta q_n^- + alpha^+_i delta q_n^+ ) big \n- nu big delta q_n^+ cdot nabla vartheta (q_n^+) cdot q_n^+  + vartheta (q_n^+) cdot delta q_n^+ - delta q_n^- cdot nabla vartheta (q_n^-) cdot q_n^- - vartheta (q_n^-) cdot delta q_n^- big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Using the relations","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta Q_ni = m_ij delta x_nj \nqquad\ndelta V_ni = fraca_ijh delta x_nj \nqquad\ndelta q_n^- = r^-_j delta x_n-1j \nqquad\ndelta q_n^+ = r^+_j delta x_nj ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"the variations of the discrete action become","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta mathcalA_d x_d\n= sum limits_n=0^N-1 sum limits_i=1^R sum limits_j=1^S b_i big h m_ij delta x_nj cdot nabla vartheta (Q_ni) cdot V_ni + vartheta (Q_ni) cdot a_ij delta x_nj - h m_ij delta x_nj cdot nabla H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma sum limits_j=1^S beta_i  big ( mu^-_i r^-_j delta x_n-1j + mu^+_i r^+_j delta x_nj ) cdot nabla vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) + vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i r^-_j delta x_n-1j + alpha^+_i r^+_j delta x_nj ) big \n- nu big r^+_j delta x_nj cdot nabla vartheta (q_n^+) cdot q_n^+  + vartheta (q_n^+) cdot r^+_j delta x_nj - r^-_j delta x_n-1j cdot nabla vartheta (q_n^-) cdot q_n^- - vartheta (q_n^-) cdot r^-_j delta x_n-1j big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Requiring the variation of the discrete action to vanish yields the discrete equations of motion,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"0 = sum limits_i=1^R b_i big h m_ij nabla vartheta (Q_ni) cdot V_ni + a_ij vartheta (Q_ni) - h m_ij nabla H(Q_ni) big \n+ bigg sum limits_i=1^sigma beta_i  big\n   mu^-_i r^-_j nabla vartheta ( mu^-_i q_n+1^- + mu^+_i q_n+1^+ ) cdot ( alpha^-_i q_n+1^- + alpha^+_i q_n+1^+ )\n + mu^+_i r^+_j nabla vartheta ( mu^-_i q_n  ^- + mu^+_i q_n  ^+ ) cdot ( alpha^-_i q_n  ^- + alpha^+_i q_n  ^+ ) \n + vartheta ( mu^-_i q_n+1^- + mu^+_i q_n+1^+ ) alpha^-_i r^-_j\n + vartheta ( mu^-_i q_n  ^- + mu^+_i q_n  ^+ ) alpha^+_i r^+_j\n   big \n - nu big\n     r^+_j nabla vartheta (q_n  ^+) cdot q_n  ^+ + r^+_j vartheta (q_n  ^+)\n   - r^-_j nabla vartheta (q_n+1^-) cdot q_n+1^- - r^-_j vartheta (q_n+1^-)\n   big\n bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"for all n and all j.","category":"page"},{"location":"modules/solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"modules/solutions/","page":"Solutions","title":"Solutions","text":"Modules = [GeometricIntegrators.Solutions]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Abstract atomistic or single-step solution.\n\nConstructors:\n\nAtomicSolution(equation)\nAtomicSolution(solution)\nAtomicSolution(solution, integrator)\n\nAutomatically construct the appropriate atomistic solution based on the  given equation or solution type. If an integrator is provided as, the internal field of the atomic solution is constructed according to the internal state of the integrator as obtained from the function get_internal_variables.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionDAE","text":"Atomic solution for an DAE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̄: time of previous time step\nq: current solution of q\nq̄: previous solution of q\nq̃: compensated summation error of q\nλ: current solution of λ\nλ̄: previous solution of λ\nv: vector field of q\nv̄: vector field of q̄\nu: projective vector field of q\nū: projective vector field of q̄\ninternal: internal variables of the integrator (e.g., internal stages of a Runge-Kutta methods or solver output)\n\nConstructors\n\nAtomicSolutionDAE{DT,TT,AT,IT}(nd, nm, internal::IT)\nAtomicSolutionDAE{DT,TT,AT,IT}(t::TT, q::AT, λ::AT, internal::IT)\nAtomicSolutionDAE(DT, TT, AT, nd, nm, internal::IT=NamedTuple())\nAtomicSolutionDAE(t::TT, q::AT, λ::AT, internal::IT=NamedTuple())\n\nnd: dimension of the state vector\nnm: dimension of the constraint\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionODE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionODE","text":"Atomic solution for an ODE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̄: time of previous time step\nq: current solution of q\nq̄: previous solution of q\nq̃: compensated summation error of q\nv: vector field of q\nv̄: vector field of q̄\ninternal: internal variables of the integrator (e.g., internal stages of a Runge-Kutta methods or solver output)\n\nConstructors\n\nAtomicSolutionODE{DT,TT,AT,IT}(nd, internal::IT)\nAtomicSolutionODE{DT,TT,AT,IT}(t::TT, q::AT, internal::IT)\nAtomicSolutionODE(DT, TT, AT, nd, internal::IT=NamedTuple())\nAtomicSolutionODE(t::TT, q::AT, internal::IT=NamedTuple())\n\nnd: dimension of the state vector\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionPDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionPDAE","text":"Atomic solution for an PDAE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̄: time of previous time step\nq: current solution of q\nq̄: previous solution of q\nq̃: compensated summation error of q\np: current solution of p\np̄: previous solution of p\np̃: compensated summation error of p\nλ: current solution of λ\nλ̄: previous solution of λ\nv: vector field of q\nv̄: vector field of q̄\nf: vector field of p\nf̄: vector field of p̄\nu: projective vector field of q\nū: projective vector field of q̄\ng: projective vector field of p\nḡ: projective vector field of p̄\ninternal: internal variables of the integrator (e.g., internal stages of a Runge-Kutta methods or solver output)\n\nConstructors\n\nAtomicSolutionPDAE{DT,TT,AT,IT}(nd, nm, internal::IT)\nAtomicSolutionPDAE{DT,TT,AT,IT}(t::TT, q::AT, p::AT, λ::AT, internal::IT)\nAtomicSolutionPDAE(DT, TT, AT, nd, nm, internal::IT=NamedTuple())\nAtomicSolutionPDAE(t::TT, q::AT, p::AT, λ::AT, internal::IT=NamedTuple())\n\nnd: dimension of the state vector\nnm: dimension of the constraint\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionPODE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionPODE","text":"Atomic solution for an PODE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̄: time of previous time step\nq: current solution of q\nq̄: previous solution of q\nq̃: compensated summation error of q\np: current solution of p\np̄: previous solution of p\np̃: compensated summation error of p\nv: vector field of q\nv̄: vector field of q̄\nf: vector field of p\nf̄: vector field of p̄\ninternal: internal variables of the integrator (e.g., internal stages of a Runge-Kutta methods or solver output)\n\nConstructors\n\nAtomicSolutionPODE{DT,TT,AT,IT}(nd, internal::IT)\nAtomicSolutionPODE{DT,TT,AT,IT}(t::TT, q::AT, p::AT, internal::IT)\nAtomicSolutionPODE(DT, TT, AT, nd, internal::IT=NamedTuple())\nAtomicSolutionPODE(t::TT, q::AT, p::AT, internal::IT=NamedTuple())\n\nnd: dimension of the state vector\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Solution(equation, Δt, ntime; kwargs...)\n\nCreate the appropriate Solution for the given equation type for a simulation with ntime time steps of step size Δt.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionDAE","text":"SolutionDAE: Solution of a differential algebraic equation\n\nContains all fields necessary to store the solution of an DAE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnm: dimension of the constraint submanifold\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\nλ:  Lagrange multiplier λ[nd, nt+1, ni]\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\nConstructors\n\nSSolutionDAE(equation, Δt, ntimesteps; nsave=DEFAULT_NSAVE, nwrite=DEFAULT_NWRITE, filename=nothing)\nSSolutionDAE(t::TimeSeries, q::SDataSeries, λ::SDataSeries, ntimesteps)\nSSolutionDAE(file::String)\nPSolutionDAE(equation, Δt, ntimesteps; nsave=DEFAULT_NSAVE, nwrite=DEFAULT_NWRITE, filename=nothing)\nPSolutionDAE(t::TimeSeries, q::PDataSeries, λ::PDataSeries, ntimesteps)\nPSolutionDAE(file::String)\n\nThe constructors SSolutionDAE create a SolutionDAE with internal data structures for serial simulations (i.e., standard arrays), while the constructors PSolutionDAE create a SolutionDAE with internal data structures for parallel simulations (i.e., shared arrays).\n\nThe usual way to initialise a Solution is by passing an equation, which for SolutionDAE has to be an DAE, a time step Δt and the number of time steps ntimesteps. The optional parameters nsave and nwrite determine the intervals for storing the solution and writing to file, i.e., if nsave > 1 only every nsave'th solution is actually stored, and every nwrite'th time step the solution is stored to disk.\n\nThe other constructors, either passing a TimeSeries and two DataSeries or a filename are used to read data from previous simulations.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionODE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionODE","text":"SolutionODE: Solution of an ordinary differential equation\n\nContains all fields necessary to store the solution of an ODE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\nConstructors\n\nSSolutionODE(equation, Δt, ntimesteps; nsave=DEFAULT_NSAVE, nwrite=DEFAULT_NWRITE, filename=nothing)\nSSolutionODE(t::TimeSeries, q::SDataSeries, ntimesteps)\nSSolutionODE(file::String)\nPSolutionODE(equation, Δt, ntimesteps; nsave=DEFAULT_NSAVE, nwrite=DEFAULT_NWRITE, filename=nothing)\nPSolutionODE(t::TimeSeries, q::PDataSeries, ntimesteps)\nPSolutionODE(file::String)\n\nThe constructors SSolutionODE create a SolutionODE with internal data structures for serial simulations (i.e., standard arrays), while the constructors PSolutionODE create a SolutionODE with internal data structures for parallel simulations (i.e., shared arrays).\n\nThe usual way to initialise a Solution is by passing an equation, which for SolutionODE has to be an ODE or SODE, a time step Δt and the number of time steps ntimesteps. The optional parameters nsave and nwrite determine the intervals for storing the solution and writing to file, i.e., if nsave > 1 only every nsave'th solution is actually stored, and every nwrite'th time step the solution is stored to disk.\n\nThe other constructors, either passing a TimeSeries and a DataSeries or a filename are used to read data from previous simulations.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionPDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionPDAE","text":"SolutionPDAE: Solution of a partitioned differential algebraic equation\n\nContains all fields necessary to store the solution of an PDAE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnm: dimension of the constraint submanifold\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\np:  solution p[nd, nt+1, ni] with p[:,0,:] the initial conditions\nλ:  Lagrange multiplier λ[nd, nt+1, ni]\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\nConstructors\n\nSSolutionPDAE(equation, Δt, ntimesteps; nsave=DEFAULT_NSAVE, nwrite=DEFAULT_NWRITE, filename=nothing)\nSSolutionPDAE(t::TimeSeries, q::SDataSeries, p::SDataSeries, λ::SDataSeries, ntimesteps)\nSSolutionPDAE(file::String)\nPSolutionPDAE(equation, Δt, ntimesteps; nsave=DEFAULT_NSAVE, nwrite=DEFAULT_NWRITE, filename=nothing)\nPSolutionPDAE(t::TimeSeries, q::PDataSeries, p::PDataSeries, λ::PDataSeries, ntimesteps)\nPSolutionPDAE(file::String)\n\nThe constructors SSolutionPDAE create a SolutionPDAE with internal data structures for serial simulations (i.e., standard arrays), while the constructors PSolutionPDAE create a SolutionPDAE with internal data structures for parallel simulations (i.e., shared arrays).\n\nThe usual way to initialise a Solution is by passing an equation, which for SolutionPDAE has to be an PDAE, HDAE, IDAE or LDAE, a time step Δt and the number of time steps ntimesteps. The optional parameters nsave and nwrite determine the intervals for storing the solution and writing to file, i.e., if nsave > 1 only every nsave'th solution is actually stored, and every nwrite'th time step the solution is stored to disk.\n\nThe other constructors, either passing a TimeSeries and three DataSeries or a filename are used to read data from previous simulations.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionPODE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionPODE","text":"SolutionPODE: Solution of a partitioned ordinary differential equation\n\nContains all fields necessary to store the solution of an PODE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\np:  solution p[nd, nt+1, ni] with p[:,0,:] the initial conditions\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\nConstructors\n\nSSolutionPODE(equation, Δt, ntimesteps; nsave=DEFAULT_NSAVE, nwrite=DEFAULT_NWRITE, filename=nothing)\nSSolutionPODE(t::TimeSeries, q::SDataSeries, p::SDataSeries, ntimesteps)\nSSolutionPODE(file::String)\nPSolutionPODE(equation, Δt, ntimesteps; nsave=DEFAULT_NSAVE, nwrite=DEFAULT_NWRITE, filename=nothing)\nPSolutionPODE(t::TimeSeries, q::PDataSeries, p::PDataSeries, ntimesteps)\nPSolutionPODE(file::String)\n\nThe constructors SSolutionPODE create a SolutionPODE with internal data structures for serial simulations (i.e., standard arrays), while the constructors PSolutionPODE create a SolutionPODE with internal data structures for parallel simulations (i.e., shared arrays).\n\nThe usual way to initialise a Solution is by passing an equation, which for SolutionPODE has to be an PODE, HODE, IODE or LODE, a time step Δt and the number of time steps ntimesteps. The optional parameters nsave and nwrite determine the intervals for storing the solution and writing to file, i.e., if nsave > 1 only every nsave'th solution is actually stored, and every nwrite'th time step the solution is stored to disk.\n\nThe other constructors, either passing a TimeSeries and two DataSeries or a filename are used to read data from previous simulations.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Common.write_to_hdf5","page":"Solutions","title":"GeometricIntegrators.Common.write_to_hdf5","text":"Append solution to HDF5 file.\n\n\n\n\n\n","category":"function"},{"location":"modules/solutions/#GeometricIntegrators.Common.write_to_hdf5-2","page":"Solutions","title":"GeometricIntegrators.Common.write_to_hdf5","text":"Append solution to HDF5 file.\n\n\n\n\n\n","category":"function"},{"location":"modules/solutions/#GeometricIntegrators.Common.write_to_hdf5-Tuple{Solution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Common.write_to_hdf5","text":"Creates HDF5 file, writes solution to file, and closes file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Common.write_to_hdf5-Tuple{Solution}","page":"Solutions","title":"GeometricIntegrators.Common.write_to_hdf5","text":"writetohdf5: Wrapper for saving Solution to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"ParallelSolution(equation, Δt, ntime; kwargs...)\n\nCreate the appropriate ParallelSolution for the given equation type for a simulation with ntime time steps of step size Δt.\n\n\n\n\n\n","category":"function"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.copy_solution!-Tuple{Solution,AtomicSolution,Any,Any}","page":"Solutions","title":"GeometricIntegrators.Solutions.copy_solution!","text":"copy_solution!(solution, atomic_solution, n, m)\n\nCopy solution for time step n and initial condition m from atomic solution to solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.createHDF5-Tuple{Solution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.createHDF5","text":"createHDF5: Creates or opens HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.create_hdf5!-Tuple{Solution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.create_hdf5!","text":"Creates HDF5 file and initialises datasets for solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.create_hdf5-Tuple{DeterministicSolution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.create_hdf5","text":"Creates HDF5 file and initialises datasets for deterministic solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.save_attributes-Tuple{DeterministicSolution,HDF5.File}","page":"Solutions","title":"GeometricIntegrators.Solutions.save_attributes","text":"save_attributes: Saves attributes of Deterministic Solutions to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.save_attributes-Tuple{Solution}","page":"Solutions","title":"GeometricIntegrators.Solutions.save_attributes","text":"save_attributes: Saves common attributes of Solution to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#Splitting-Tableaus","page":"Splitting Methods","title":"Splitting Tableaus","text":"","category":"section"},{"location":"tableaus/splitting/","page":"Splitting Methods","title":"Splitting Methods","text":"Modules = [GeometricIntegrators.Tableaus]\nPages   = [\"tableaus/tableaus_splitting.jl\"]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauLieA-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauLieA","text":"Lie-Trotter Splitting A\n\nFor a vector field dotx = f_1 (tx) +  f_2 (tx), the splitting reads\n\nPhi_Delta t = varphi^2_Delta t circ varphi^1_Delta t\n\nReference:\n\nH. F. Trotter.\nOn the product of semi-groups of operators.\nProceedings of the American Mathematical Society, Volume 10, Pages 545-551, 1959.\ndoi: 10.1090/S0002-9939-1959-0108732-6.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauLieB-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauLieB","text":"Lie-Trotter Splitting B\n\nFor a vector field dotx = f_1 (tx) +  f_2 (tx), the splitting reads\n\nPhi_Delta t = varphi^1_Delta t circ varphi^2_Delta t\n\nReference:\n\nH. F. Trotter.\nOn the product of semi-groups of operators.\nProceedings of the American Mathematical Society, Volume 10, Pages 545-551, 1959.\ndoi: 10.1090/S0002-9939-1959-0108732-6.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauMarchuk","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauMarchuk","text":"Alias for TableauStrang\n\n\n\n\n\n","category":"function"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauMcLachlan2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauMcLachlan2","text":"McLachlan's 2nd order symmetric, minimum error composition method\n\nThe composition reads\n\nPhi_Delta t = varphi_alpha Delta t circ varphi^*_(12 - alpha) Delta t circ varphi_(12 - alpha) Delta t circ varphi^*_alpha Delta t \n\nwhere the parameter alpha can be optimized, e.g., to minimize the solution error. McLachlan arrives at alpha  = 01932 as a generally useful value.\n\nReference:\n\nRobert I. McLachlan.\nOn the Numerical Integration of Ordinary Differential Equations by Symmetric Composition Methods\nSIAM Journal on Scientific Computing, Volume 16, Pages 151-168, 1995.\ndoi: 10.1137/0916010.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauMcLachlan4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauMcLachlan4","text":"McLachlan's 4th order symmetric, minimum error composition method\n\nThe composition reads\n\nPhi_Delta t = varphi_alpha_5 Delta t circ varphi^*_beta_5 Delta t circ dotsc circ varphi_alpha_2 Delta t circ varphi^*_beta_2 Delta t circ varphi_alpha_1 Delta t circ varphi^*_beta_1 Delta t \n\nwith\n\nbeginaligned\nbeta_1 = alpha_5 = frac14 - sqrt19108  \nalpha_1 = beta_5 = frac146 + 5 sqrt19540    \nbeta_2 = alpha_4 = frac- 23 - 20 sqrt19270  \nalpha_2 = beta_4 = frac-2 + 10 sqrt19135   \nbeta_3 = alpha_3 = frac15 \nendaligned\n\nThe coefficients are optimised to provide an integrator with minimal solution error.\n\nReference:\n\nRobert I. McLachlan.\nOn the Numerical Integration of Ordinary Differential Equations by Symmetric Composition Methods\nSIAM Journal on Scientific Computing, Volume 16, Pages 151-168, 1995.\ndoi: 10.1137/0916010.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauStrang-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauStrang","text":"Strang Splitting\n\nFor a vector field dotx = f_1 (tx) + f_2 (tx), the splitting reads\n\nPhi_Delta t = varphi^1_Delta t  2 circ varphi^2_Delta t  2 circ varphi^2_Delta t  2 circ varphi^1_Delta t  2\n\nFor vector fields with two components, this is not the most efficient implementation. For such cases TableauStrangA or TableauStrangB should be used instead.\n\nReferences:\n\nGilbert Strang.\nOn the construction and comparison of difference schemes.\nSIAM Journal on Numerical Analysis, Volume 5, Pages 506-517, 1968.\ndoi: 10.1137/0705041.\n\nGurij Ivanovich Marchuk.\nSome applications of splitting-up methods to the solution of mathematical physics problems.\nAplikace Matematiky, Volume 13, Pages 103-132, 1968.\ndoi: 10.21136/AM.1968.103142.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauStrangA-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauStrangA","text":"Strang Splitting A for a vector field dotx = f_1 (tx) + f_2 (tx).\n\nThe splitting reads\n\nPhi_Delta t = varphi^1_Delta t  2 circ varphi^2_Delta t circ varphi^1_Delta t  2\n\nReferences:\n\nGilbert Strang.\nOn the construction and comparison of difference schemes.\nSIAM Journal on Numerical Analysis, Volume 5, Pages 506-517, 1968.\ndoi: 10.1137/0705041.\n\nGurij Ivanovich Marchuk.\nSome applications of splitting-up methods to the solution of mathematical physics problems.\nAplikace Matematiky, Volume 13, Pages 103-132, 1968.\ndoi: 10.21136/AM.1968.103142.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauStrangB-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauStrangB","text":"Strang Splitting B for a vector field dotx = f_1 (tx) + f_2 (tx)\n\nThe splitting reads\n\nPhi_Delta t = varphi^2_Delta t  2 circ varphi^1_Delta t circ varphi^2_Delta t  2\n\nReferences:\n\nGilbert Strang.\nOn the construction and comparison of difference schemes.\nSIAM Journal on Numerical Analysis, Volume 5, Pages 506-517, 1968.\ndoi: 10.1137/0705041.\n\nGurij Ivanovich Marchuk.\nSome applications of splitting-up methods to the solution of mathematical physics problems.\nAplikace Matematiky, Volume 13, Pages 103-132, 1968.\ndoi: 10.21136/AM.1968.103142.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauSuzukiFractal-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauSuzukiFractal","text":"Suzuki's 4th order \"fractal\" composition method\n\nThe composition reads\n\nPhi_Delta t = varphi_gamma_5 Delta t circ varphi_gamma_4 Delta t circ varphi_gamma_3 Delta t circ varphi_gamma_2 Delta t circ varphi_gamma_1 Delta t\n\nwith\n\ngamma_1 = gamma_2 = gamma_4 = gamma_5 = frac14 - 4^1(p+1)  qquad\ngamma_3 = - frac4^1(p+1)4 - 4^1(p+1) \n\nReference:\n\nMasuo Suzuki\nFractal decomposition of exponential operators with applications to many-body theories and Monte Carlo simulations.\nPhysics Letters A, Volume 146, Pages 319-323, 1990.\ndoi: 10.1016/0375-9601(90)90962-N\n\n\n\n\n\n","category":"method"},{"location":"tableaus/splitting/#GeometricIntegrators.Tableaus.TableauTripleJump-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Splitting Methods","title":"GeometricIntegrators.Tableaus.TableauTripleJump","text":"4th order \"Triple Jump\" composition method.\n\nThe composition reads\n\nPhi_Delta t = varphi_gamma_3 Delta t circ varphi_gamma_2 Delta t circ varphi_gamma_1 Delta t\n\nwith\n\ngamma_1 = gamma_3 = frac12 - 2^1(p+1)  qquad\ngamma_2 = - frac2^1(p+1)2 - 2^1(p+1) \n\nReferences:\n\nMichael Creutz and Andreas Gocksch.\nHigher-order hybrid Monte Carlo algorithms.\nPhysical Review Letters, Volume 63, Pages 9-12, 1989.\ndoi: 10.1103/PhysRevLett.63.9.\n\nEtienne Forest.\nCanonical integrators as tracking codes (or how to integrate perturbation theory with tracking).\nAIP Conference Proceedings, Volume 184, Pages 1106-1136, 1989.\ndoi: 10.1063/1.38062.\n\nMasuo Suzuki\nFractal decomposition of exponential operators with applications to many-body theories and Monte Carlo simulations.\nPhysics Letters A, Volume 146, Pages 319-323, 1990.\ndoi: 10.1016/0375-9601(90)90962-N\n\nHaruo Yoshida.\nConstruction of higher order symplectic integrators.\nPhysics Letters A, Volume 150, Pages 262-268, 1990.\ndoi: 10.1016/0375-9601(90)90092-3\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#Variational-Partitioned-Runge-Kutta-Tableaus","page":"VPRK Methods","title":"Variational Partitioned Runge-Kutta Tableaus","text":"","category":"section"},{"location":"tableaus/vprk/","page":"VPRK Methods","title":"VPRK Methods","text":"Modules = [GeometricIntegrators.Tableaus]\nPages   = [\"tableaus/tableaus_vprk.jl\"]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPGLRK-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPGLRK","text":"Tableau for variational Gauss-Legendre method with s stages\n\nUses Gauss coefficients for both a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIA-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIA","text":"Tableau for variational Lobatto IIIA method with s stages\n\nUses Lobatto IIIA for the coefficients a_ij and its symplectic conjugate, Lobatto IIIB, for the coefficients bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIAIIIA-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIAIIIA","text":"Tableau for an implicit partitioned Lobatto IIIA Runge-Kutta method with s stages\n\nUses Lobatto IIIA for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIB-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIB","text":"Tableau for variational Lobatto IIIB method with s stages\n\nUses Lobatto IIIB for the coefficients a_ij and its symplectic conjugate, Lobatto IIIA, for the coefficients bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIBIIIB-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIBIIIB","text":"Tableau for an implicit partitioned Lobatto IIIB Runge-Kutta method with s stages\n\nUses Lobatto IIIB for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIC-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIC","text":"Tableau for variational Lobatto IIIC method with s stages\n\nUses Lobatto IIIC for the coefficients a_ij and its symplectic conjugate, Lobatto IIIC̄, for the coefficients bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIC̄-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIC̄","text":"Tableau for variational Lobatto IIIC̄ method with s stages\n\nUses Lobatto IIIC̄ for the coefficients a_ij and its symplectic conjugate, Lobatto IIIC, for the coefficients bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIID-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIID","text":"Tableau for variational Lobatto IIID method with s stages\n\nUses Lobatto IIID for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIE-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIE","text":"Tableau for variational Lobatto IIIE method with s stages\n\nUses Lobatto IIIE for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIF-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIF","text":"Tableau for variational Lobatto IIIF method with s stages\n\nUses Lobatto IIIF for the coefficients a_ij and its symplectic conjugate for the coefficients bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIG-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIG","text":"Tableau for variational Lobatto IIIG method with s stages\n\nUses Lobatto IIIG for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPRadauIIAIIA-Tuple{Any}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPRadauIIAIIA","text":"Tableau for an implicit partitioned Radau IIA Runge-Kutta method with s stages\n\nUses Radau IIA for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/vprk/#GeometricIntegrators.Tableaus.TableauVPSRK3-Tuple{}","page":"VPRK Methods","title":"GeometricIntegrators.Tableaus.TableauVPSRK3","text":"Tableau for variational symmetric Runge-Kutta method with 3 stages\n\nUses SRK3 coefficients for both a_ij and bara_ij.\n\n\n\n\n\n","category":"method"},{"location":"modules/discontinuities/#Discontinuities","page":"Discontinuities","title":"Discontinuities","text":"","category":"section"},{"location":"modules/discontinuities/","page":"Discontinuities","title":"Discontinuities","text":"Modules = [GeometricIntegrators.Discontinuities]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/discontinuities/#GeometricIntegrators.Discontinuities.PathIntegralLinear","page":"Discontinuities","title":"GeometricIntegrators.Discontinuities.PathIntegralLinear","text":"PathIntegralLinear is a path integral along a linear path\n\nphi (tau q^- q^+) = (1-tau) q^- + tau q^+ \n\n\n\n\n\n","category":"type"},{"location":"modules/discontinuities/#GeometricIntegrators.Discontinuities.PathIntegralTrigonometric","page":"Discontinuities","title":"GeometricIntegrators.Discontinuities.PathIntegralTrigonometric","text":"PathIntegralTrigonometric is a path integral along a cos^2/sin^2 path\n\nphi (tau q^- q^+) = cos^2 (pi tau  2) q^- + sin^2 (pi tau  2) q^+ \n\n\n\n\n\n","category":"type"},{"location":"integrators/stochastic/#Stochastic-Integrators","page":"Stochastic Integrators","title":"Stochastic Integrators","text":"","category":"section"},{"location":"modules/interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"modules/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [GeometricIntegrators.Interpolation]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/interpolation/#GeometricIntegrators.Interpolation.HermiteInterpolation","page":"Interpolation","title":"GeometricIntegrators.Interpolation.HermiteInterpolation","text":"Hermite's Interpolating Polynomials\n\nHere, we implement a two point Hermite interpolation function which passes through the function and its first derivative for the interval 01. The polynomial is determined by four constraint equations, matching the function and its derivative at the points 0 and 1.\n\nStart by defining the 3rd degree polynomial and its derivative by\n\nbeginaligned\ng(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3  \ng(x) = a_1 + 2 a_2 x + 3 a_3 x^2 \nendaligned\n\nand apply the constraints\n\nbeginaligned\ng(0) = f_0   Rightarrow  a_0 = f_0  \ng(1) = f_1   Rightarrow  a_0 + a_1 + a_2 + a_3 = f_1  \ng(0) = f_0   Rightarrow  a_1 = f_0  \ng(1) = f_1   Rightarrow  a_1 + 2 a_2 + 3 a_3 = f_1  \nendaligned\n\nSolving for a_0 a_1 a_2 a_3 leads to\n\nbeginaligned\na_0 = f_0  \na_1 = f_0  \na_2 = - 3 f_0 + 3 f_1 - 2 f_0 - f_1  \na_3 = 2 f_0 - 2 f_1 + f_0 + f_1 \nendaligned\n\nso that the polynomial g(x) reads\n\ng(x) = f_0 + f_0 x + (- 3 f_0 + 3 f_1 - 2 f_0 - f_1) x^2 + (2 f_0 - 2 f_1 + f_0 + f_1) x^3 \n\nThe function and derivative values can be factored out, so that g(x) can be rewritten as\n\ng(x) = f_0 (1 - 3 x^2 + 2 x^3) + f_1 (3 x^2 - 2 x^3) + f_0 (x - 2 x^2 + x^3) + f_1 (- x^2 + x^3) \n\nor in generic form as\n\ng(x) = f_0 a_0(x) + f_1 a_1(x) + f_0 b_0(x) + f_1 b_1(x) \n\nwith basis functions\n\nbeginaligned\na_0 (x) = 1 - 3 x^2 + 2 x^3  \nb_0 (x) = x - 2 x^2 + x^3  \na_1 (x) = 3 x^2 - 2 x^3  \nb_1 (x) = - x^2 + x^3 \nendaligned\n\nThe derivative g(x) accordingly reads\n\ng(x) = f_0 a_0(x) + f_1 a_1(x) + f_0 b_0(x) + f_1 b_1(x) \n\nwith\n\nbeginaligned\na_0 (x) = - 6 x + 6 x^2  \nb_0 (x) = 1 - 4 x + 3 x^2  \na_1 (x) = 6 x - 6 x^2  \nb_1 (x) = - 2 x + 3 x^2 \nendaligned\n\nThe basis functions a_0and a_1 are associated with the function values at x_0 and x_1, respectively, while the basis functions b_0 and b_1 are associated with the derivative values at x_0 and x_1. The basis functions satisfy the following relations,\n\nbeginaligned\na_i (x_j) = delta_ij  \nb_i (x_j) = 0  \na_i (x_j) = 0  \nb_i (x_j) = delta_ij  \nij = 0 1 \nendaligned\n\nwhere delta_ij denotes the Kronecker-delta, so that\n\nbeginaligned\ng(0) = f_0  \ng(1) = f_1  \ng(0) = f_0  \ng(1) = f_1 \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/#Modules","page":"Modules","title":"Modules","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Pages = [\"modules/discontinuities.md\",\n         \"modules/equations.md\",\n         \"modules/solutions.md\",\n         \"modules/integrators.md\",\n         \"modules/interpolation.md\",\n         \"modules/simulations.md\",\n         \"modules/tableaus.md\",\n         \"modules/rungekutta.md\"]\nDepth = 3","category":"page"},{"location":"releasenotes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"releasenotes/#.8.0","page":"Release Notes","title":"0.8.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Use RungeKutta.jl for most tableaus and coefficients\nMove stochastic integrators to separate package\nRewrite of most equation types\nRename VODE and VDAE to LODE and LDAE for consistency with HODE and HDAE\nAdd optional fields for the secondary constraint to all *DAE equations","category":"page"},{"location":"releasenotes/#New-Features","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Allow for arbitrary data structures as states (still experimental and not fully supported)\nAdd convert methods for PODE and HODE to ODE and SODE","category":"page"},{"location":"releasenotes/#Fixes","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Countless minor bugfixes","category":"page"},{"location":"releasenotes/#Documentation","page":"Release Notes","title":"Documentation","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Add theoretical background for variational integrators, Runge-Kutta and splitting methods\nAdd references for most methods","category":"page"},{"location":"releasenotes/#.7.0","page":"Release Notes","title":"0.7.0","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Use CompactBasisFunctions.jl instead of BasisFunctions submodule\nUse QuadratureRules.jl instead of Quadratures submodule\nUse SimpleSolvers.jl instead of Solvers submodule\nUse GeometricProblems.jl instead of TestProblems submodule","category":"page"},{"location":"releasenotes/#.6.2","page":"Release Notes","title":"0.6.2","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bugfix release","category":"page"},{"location":"releasenotes/#.6.1","page":"Release Notes","title":"0.6.1","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bugfix release","category":"page"},{"location":"releasenotes/#.6.0","page":"Release Notes","title":"0.6.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes-2","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Revise tableaus: align constructor names with RungeKutta.jl","category":"page"},{"location":"releasenotes/#New-Features-2","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Add new Runge-Kutta tableaus\nGeneralise Lobatto and Radau tableaus to arbitrary number of stages\nExtend documentation on integrators and tableaus","category":"page"},{"location":"releasenotes/#.5.1","page":"Release Notes","title":"0.5.1","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Update documentation\nFix HDF5 v0.14 deprecations","category":"page"},{"location":"releasenotes/#.5.0","page":"Release Notes","title":"0.5.0","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Moved repository to JuliaGNI\nMoved CI from Travis to GitHub","category":"page"},{"location":"releasenotes/#Breaking-Changes-3","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Functions for initial guesses are now called v̄ and f̄ and can be prescribed separately from v and f in PDAE, HDAE, etc.\nRename SPARK tableau constructors and unify distinct constructors for Lobatto tableaus with different number of stages","category":"page"},{"location":"releasenotes/#New-Features-3","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Implement SPARK integrator for index-two DAEs\nImplement infrastructure for storing internal variables and solver output to atomic solutions\nStore internal variables of SPARK and VPRK integrators in atomic solution\nAdd various five-stage Lobatto tableaus\nAdd and clean up SPARK tableaus and add docstrings\nAdd functions for checking symplecticity conditions of SPARK tableaus\nAdd Aqua.jl tests","category":"page"},{"location":"releasenotes/#Fixes-2","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Fix initial guess warnings in tests by prescribing proper functions for v̄ and f̄ in example problems\nFix update_multiplier() method for SPARK integrators","category":"page"},{"location":"releasenotes/#.4.1","page":"Release Notes","title":"0.4.1","text":"","category":"section"},{"location":"releasenotes/#New-Features-4","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Atomic solutions can now store a NamedTuple of internal variables of the integrator, including nonlinear solver output\nOutput of internal variables has been added to VPRK integrators\nAdd Gauss-Legendre tableaus for implicit partitioned Runge-Kutta methods","category":"page"},{"location":"releasenotes/#Fixes-3","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Revision of integrator type hierarchy","category":"page"},{"location":"releasenotes/#.4.0","page":"Release Notes","title":"0.4.0","text":"","category":"section"},{"location":"releasenotes/#New-Integrators","page":"Release Notes","title":"New Integrators","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Runge-Kutta integrators for implicit ODEs (FIRKimplicit and SRKimplicit)\nVariational Partitioned Runge-Kutta integrator with projection based on internal stages","category":"page"},{"location":"releasenotes/#Fixes-4","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Computation of initial guess in all implicit integrators","category":"page"},{"location":"integrators/hpg/#hpg","page":"Hamilton-Pontryagin-Galerkin Integrators","title":"Hamilton-Pontryagin-Galerkin Integrators","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = GeometricIntegrators","category":"page"},{"location":"tutorial/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we try to give an overview of the basic usage of GeometricIntegrators and its main components.","category":"page"},{"location":"tutorial/tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"GeometricIntegrators.jl can be installed using Julia's built-in package manager in the command line interface by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ]\n(v1.5) pkg> add GeometricIntegrators","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In a Jupyter notebook, GeometricIntegrators.jl can be installed by explicitly using the Pkg module as","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg\nPkg.add(\"GeometricIntegrators\")","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"This will install the library itself as well as all dependencies.","category":"page"},{"location":"tutorial/tutorial/#Basic-usage","page":"Tutorial","title":"Basic usage","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In the simplest cases, the use of GeometricIntegrators.jl requires the construction of two objects, an equation and an integrator. For many standard methods, the integrator is implicitly selected by specifying an equation and a tableau.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Before any use, we need to load GeometricIntegrators,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeometricIntegrators","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Then we can create an ODE object for the equation dotx (t) = x(t) with initial condition x(0) = 1,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ode = ODE((t, x, ẋ) -> ẋ[1] = x[1], [1.0]);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"create an integrator for this ODE, using the tableau for the explicit Euler method and a time step of Delta t = 01,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(ode, TableauExplicitEuler(), 0.1);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"and compute the solution for n_t = 10 time steps,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = integrate(ode, int, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Plot and compare with the exact solution","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplot(xlims=[0,1], xlab=\"t\", ylab=\"x(t)\", legend=:bottomright)\nplot!(sol.t, sol.q[1,:], label=\"numeric\")\nplot!(sol.t, exp.(sol.t), label=\"exact\")","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#Equations","page":"Tutorial","title":"Equations","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In GeometricIntegrators.jl we distinguish between three basic types of equations:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ordinary differential equations (ODEs),\ndifferential algebraic equations (DAEs),\nstochastic differential equations (SDEs).","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"For each type, there are several subtypes","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"standard equations (ODE, DAE, SDE),\nimplicit equations (IODE, IDAE),\npartitioned equations (PODE, PDAE, PSDE),\nHamiltonian equations (HODE, HDAE),\nLagrangian equations (LODE, LDAE),\nsplit equations (SODE, SPDAE).","category":"page"},{"location":"tutorial/tutorial/#Ordinary-differential-equations","page":"Tutorial","title":"Ordinary differential equations","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Consider an ODE of the form","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"dotx (t) = f(t x(t)) ","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"where dotx denotes the derivative of x and f the vector field of the equation, which is assumed to depend on both t and x. In the following, we will solve the mathematical pendulum, whose equations are given by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"beginpmatrix\ndotx_1 \ndotx_2 \nendpmatrix\n=\nbeginpmatrix\nx_2 \nsin (x_1) \nendpmatrix ","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Creating an ODE object requires the prescription of a function that computes the vector field f, e.g.,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"function ẋ(t, x, v)\n    v[1] = x[2]\n    v[2] = sin(x[1])\nend","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ẋ (generic function with 1 method)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"which has to take three arguments, the current time t, the current solution vector x and the output vector f. Moreover, we need a set of initial conditions,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"x₀ = [acos(0.4), 0.0]","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"2-element Array{Float64,1}:\n 1.1592794807274085\n 0.0","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"An ODE object is than instantiated by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ODE(<vector field>, <initial conditions>; kwargs...)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"specifically,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ode = ODE(ẋ, x₀);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The initial time, ode.t₀ is assumed to be 0 be default. It can also be specified explicitly by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"t₀  = 1.0\node = ODE(ẋ, t₀, x₀);","category":"page"},{"location":"tutorial/tutorial/#Partitioned-ordinary-differential-equations","page":"Tutorial","title":"Partitioned ordinary differential equations","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The pendulum problem is a Hamiltonian system that can also be expressed as","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"dotq = fracpartial Hpartial p = p \nhspace3em\ndotp = - fracpartial Hpartial q = sin (q) \nhspace3em\nH (qp) = frac12 p^2 + cos (q) ","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"This structure, namely the partitioning into two sets of variables (qp) instead of x, can be exploited for more efficient integration. Such equations can be defined in terms of a partitioned ODE, where the vector fields are specified separately,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"function q̇(t, q, p, v)\n    v[1] = p[1]\nend\n\nfunction ṗ(t, q, p, f)\n    f[1] = sin(q[1])\nend\n\npode = PODE(q̇, ṗ, [acos(0.4)], [0.0]);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The first two arguments to the PODE constructor are the functions that determine the vector fields of the equations dotq (t) = v(t q(t) p(t)) and dotp (t) = f(t q(t) p(t)). The third and fourth argument determines the initial conditions of q and p, respectively. The functions defining the vector field have to take four arguments, the current time t, the current solution vectors q and p and the output vector v or f.","category":"page"},{"location":"tutorial/tutorial/#Integrators","page":"Tutorial","title":"Integrators","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"We support a number of standard integrators (geometric and non-geometric) like explicit, implicit and partitioned Runge-Kutta methods, splitting methods and general linear methods (planned).","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to instantiate many of the standard integrators, one needs to specify an ODE, a tableau and a timestep, e.g.,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(ode, TableauExplicitEuler(), 0.1);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to run the integrator, the integrate() functions is called, passing an integrator object and the number of time steps to integrate:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = integrate(ode, int, 250);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The integrate function automatically creates an appropriate solution object, that contains the result of the integration.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sol.q[1,:], sol.q[2,:], xlab=\"x(t)\", ylab=\"y(t)\", legend=:none)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Observe that the explicit Euler method is not well suited for integrating this system. The solutions drifts away although it should follow closed orbits.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"For a Hamiltonian system, defined as a PODE, a different tableau might be more appropriate, for example a symplectic Euler method,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(pode, TableauLobattoIIIAIIIB(2), 0.1)\nsol = integrate(pode, int, 250);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"This creates a different integrator, which exploits the partitioned structure of the system. The solution return by the integrate step will also be a different solution, adapted to the partitioned system.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sol.q[1,:], sol.p[1,:], xlab=\"q(t)\", ylab=\"p(t)\", legend=:none)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Moreover, this method respects the Hamiltonian structure of the system, resulting in closed orbits following the contours of the system's energy.","category":"page"},{"location":"tutorial/tutorial/#Tableaus","page":"Tutorial","title":"Tableaus","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Many tableaus for Runge-Kutta methods are predefined and can easily be used like outlined above. In particular, this includes the following methods:","category":"page"},{"location":"tutorial/tutorial/#Explicit-Runge-Kutta-Methods","page":"Tutorial","title":"Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauExplicitEuler 1 Explicit / Forward Euler\nTableauExplicitMidpoint 2 Explicit Midpoint\nTableauHeun2 2 Heun's Method of order two\nTableauHeun3 3 Heun's Method of order three\nTableauRalston2 2 Ralston's Method of order two\nTableauRalston3 3 Ralston's Method of order three\nTableauRunge 2 Runge's Method\nTableauKutta 3 Kutta's Method\nTableauRK416 4 Explicit 4th order Runge-Kutta (1/6 rule)\nTableauRK438 4 Explicit 4th order Runge-Kutta (3/8 rule)","category":"page"},{"location":"tutorial/tutorial/#Diagonally-Implicit-Runge-Kutta-Methods","page":"Tutorial","title":"Diagonally Implicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauCrankNicolson 3 Crank-Nicholson Method\nTableauKraaijevangerSpijker 3 Kraaijevanger & Spijker's Method\nTableauQinZhang 3 Qin & Zhang's Method\nTableauCrouzeix 3 Crouzeix's Method","category":"page"},{"location":"tutorial/tutorial/#Fully-Implicit-Runge-Kutta-Methods","page":"Tutorial","title":"Fully Implicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauImplicitEuler 1 Implicit / Backward Euler\nTableauImplicitMidpoint 2 Implicit Midpoint\nTableauSRK3 4 Symmetric Runge-Kutta s=3","category":"page"},{"location":"tutorial/tutorial/#Gauß,-Radau-and-Lobatto-Methods","page":"Tutorial","title":"Gauß, Radau and Lobatto Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauGauss) 2s Gauss-Legendre\nTableauRadauIA 2s-1 Radau-IA\nTableauRadauIB 2s-1 Radau-IB\nTableauRadauIIA 2s-1 Radau-IIA\nTableauRadauIIB 2s-1 Radau-IIB\nTableauLobattoIIIA 2s-2 Lobatto-IIIA\nTableauLobattoIIIB 2s-2 Lobatto-IIIB\nTableauLobattoIIIC 2s-2 Lobatto-IIIC\nTableauLobattoIIIC̄ 2s-2 Lobatto-IIIC̄\nTableauLobattoIIID 2s-2 Lobatto-IIID\nTableauLobattoIIIE 2s-2 Lobatto-IIIE\nTableauLobattoIIIF 2s Lobatto-IIIF\nTableauLobattoIIIG 2s Lobatto-IIIG","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"All of these tableaus are generated on the fly and take the number of stages s as parameter.","category":"page"},{"location":"tutorial/tutorial/#Partitioned-Runge-Kutta-Methods","page":"Tutorial","title":"Partitioned Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauLobattoIIIAIIIB 2s-2 Lobatto-IIIA-IIIB\nTableauLobattoIIIBIIIA 2s-2 Lobatto-IIIB-IIIA\nTableauLobattoIIICIIIC̄ 2s-2 Lobatto-IIIC-IIIC̄\nTableauLobattoIIIC̄IIIC 2s-2 Lobatto-IIIC̄-IIIC","category":"page"},{"location":"tutorial/tutorial/#Custom-Tableaus","page":"Tutorial","title":"Custom Tableaus","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"If required, it is straight-forward to create a custom tableau. The tableau of Heun's method, for example, is defined as follows:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"a = [[0.0 0.0]\n     [1.0 0.0]]\nb = [0.5, 0.5]\nc = [0.0, 1.0]\no = 2\n\ntab = Tableau(:heun, o, a, b, c)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Runge-Kutta Tableau heun with 2 stages and order 2:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"  beginarrayrrr\n    00  00  00 \n    10  10  00 hline\n      05  05 \n  endarray","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, o is the order of the method, a are the coefficients, b the weights and c the nodes. For partitioned Runge-Kutta tableaus, PartitionedTableau can be used. The first parameter of the constructor of each tableau assigns a name to the tableau. Such custom tableaus can be used in exactly the same as standard tableaus, e.g., by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(ode, tab, 0.1)\nsol = integrate(ode, int, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"making it very easy to implement and test new methods.","category":"page"},{"location":"tutorial/tutorial/#Solutions","page":"Tutorial","title":"Solutions","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In what we have seen so far, the solution was always automatically created by the integrate() function. While this is often convenient, it is sometimes not performant, e.g., when carrying out long-time simulations with intermediate saving of the solution. In such cases, it is better to preallocate a solution object by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = Solution(ode, 0.1, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"where the first argument is an equation, the second argument is the time step and the third argument is the number of time steps that will be computed in one integration step. The call to the integrator is then made via","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"integrate!(int, sol)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"If several integration cycles shall be performed, the reset!() function can be used to copy the solution of the last time step to the initial conditions of the solution,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"for i in 1:10\n    # integrate!(int, sol)\n    #\n    # save or process solution\n    #\n    # reset!(sol)\nend","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"All solutions have a t field holding the series of time steps that has been computed in addition to several data fields, for example q for an ODE solution, q and p for a PODE solution, qand λ for a DAE solution, and q, p and λ for a PDAE solution.","category":"page"},{"location":"equations/#Equations","page":"Equations","title":"Equations","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"In GeometricIntegrators.jl we support three basic types of equations:","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"ordinary differential equations (ODEs),\ndifferential algebraic equations (DAEs),\nstochastic differential equations (SDEs).","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"For each type, there are several subtypes","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"standard equations (ODE, DAE, SDE),\nimplicit equations (IODE, IDAE),\npartitioned equations (PODE, PDAE, PSDE),\nHamiltonian equations (HODE, HDAE),\nLagrangian equations (LODE, LDAE),\nsplit equations (SODE, SPDAE), SPSDE).","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Each equation holds a number of functions determining the vector field, constraints, initial conditions, and possibly additional information like parameters, periodicity, invariants and the Hamiltonian or Lagrangian.","category":"page"},{"location":"modules/equations/#Equations","page":"Equations","title":"Equations","text":"","category":"section"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"Modules = [GeometricIntegrators.Equations]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/equations/#GeometricIntegrators.Equations.DAE","page":"Equations","title":"GeometricIntegrators.Equations.DAE","text":"DAE: Differential Algebraic Equation\n\nDefines a differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))   q(t_0) = q_0  \n0 = phi (t q(t) lambda(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector field v, projection u, algebraic constraint phi=0, initial conditions q_0 and lambda_0, the dynamical variable q taking values in mathbbR^m and the algebraic variable lambda taking values in mathbbR^n.\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nvType <: Function: type of v\nuType <: Function: type of u\nūType <: OptionalFunction: type of ū\nϕType <: Function: type of ϕ\nψType <: OptionalFunction: type of ψ\nv̄Type <: Function: type of v̄\ninvType <: OptionalNamedTuple: invariants type\nparType <: OptionalNamedTuple: parameters type\nperType <: OptionalArray{AT}: periodicity type\n\nFields\n\nd: dimension of dynamical variable q and the vector field v\nm: dimension of algebraic variable lambda and the constraint phi\nv: function computing the vector field\nu: function computing the projection\nū: function computing the secondary projection field baru (optional)\nϕ: algebraic constraint\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (defaults to v)\nt₀: initial time\nq₀: initial condition for dynamical variable q\nλ₀: initial condition for algebraic variable lambda\nμ₀: initial condition for algebraic variable μ (optional)\ninvariants: either a NamedTuple containing the equation's invariants or nothing\nparameters: either a NamedTuple containing the equation's parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nThe function v, providing the vector field, takes three arguments, v(t, q, v), the functions u and ϕ, providing the projection and the algebraic constraint take four arguments, u(t, q, λ, u) and ϕ(t, q, λ, ϕ), where t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nConstructors\n\nDAE(v, u, ū, ϕ, ψ, v̄, t₀, q₀, λ₀, invariants, parameters, periodicity)\n\nDAE(v, u, ϕ, t₀, q₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nDAE(v, u, ϕ, q₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nDAE(v, u, ϕ, t₀, q₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\nDAE(v, u, ϕ, q₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\n\nDAE(v, u, ū, ϕ, ψ, t₀, q₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nDAE(v, u, ū, ϕ, ψ, q₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nDAE(v, u, ū, ϕ, ψ, t₀, q₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\nDAE(v, u, ū, ϕ, ψ, q₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\n\nExample\n\n    function v(t, q, v)\n        v[1] = q[1]\n        v[2] = q[2]\n    end\n\n    function u(t, q, λ, u)\n        u[1] = +λ[1]\n        u[2] = -λ[1]\n    end\n\n    function ϕ(t, q, λ, ϕ)\n        ϕ[1] = q[2] - q[1]\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ₀ = [0.]\n\n    dae = DAE(v, u, ϕ, t₀, q₀, λ₀)\n\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.HDAE","page":"Equations","title":"GeometricIntegrators.Equations.HDAE","text":"HDAE: Hamiltonian Differential Algebraic Equation EXPERIMENTAL\n\nDefines a Hamiltonian differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + barg(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barf(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qplambda)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^n times mathbbR^d.\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nvType <: Function: type of v\nfType <: Function: type of f\nuType <: Function: type of u\ngType <: Function: type of g\nϕType <: Function: type of ϕ\nūType <: Function: type of ū\nḡType <: Function: type of ḡ\nψType <: Function: type of ψ\nPType <: Function: type of P\nv̄Type <: Function: type of v̄\nf̄Type <: Function: type of f̄\nhamType <: Function: Hamiltonian type\ninvType <: OptionalNamedTuple: invariants type\nparType <: OptionalNamedTuple: parameters type\nperType <: OptionalArray{AT}: periodicity type\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nm: dimension of algebraic variables lambda and gamma and the constraints phi and psi\nv: function computing the Hamiltonian vector field v\nf: function computing the Hamiltonian vector field f\nu: function computing the projection for q\ng: function computing the primary projection field g\nϕ: primary constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nP: function computing the Poisson matrix P\nv̄: function computing an initial guess for the velocity field v(optional, defaults tov`)\nf̄: function computing an initial guess for the force field f (optional, defaults to f)\nt₀: initial time (optional)\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable λ\nμ₀: initial condition for algebraic variable μ (optional)\nhamiltonian: function computing the Hamiltonian H\ninvariants: either a NamedTuple containing the equation's invariants or nothing\nparameters: either a NamedTuple containing the equation's parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nConstructors\n\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, P, t₀, q₀, p₀, λ₀, hamiltonian, invariants, parameters, periodicity)\n\nHDAE(v, f, u, g, ϕ, h, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nHDAE(v, f, u, g, ϕ, h, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nHDAE(v, f, u, g, ϕ, h, t₀, q₀::State, p₀::State, λ₀::State; kwargs...)\nHDAE(v, f, u, g, ϕ, h, q₀::State, p₀::State, λ₀::State; kwargs...)\n\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, t₀, q₀::State, p₀::State, λ₀::State; kwargs...)\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, q₀::State, p₀::State, λ₀::State; kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.HODE","page":"Equations","title":"GeometricIntegrators.Equations.HODE","text":"HODE: Hamiltonian Ordinary Differential Equation EXPERIMENTAL\n\nDefines a Hamiltonian ordinary differential initial value problem, that is a canonical Hamiltonian system of equations,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))   p(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, given by\n\nbeginaligned\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendaligned\n\ninitial conditions (q_0 p_0) and the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d.\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nvType <: Function: type of v\nfType <: Function: type of f\nPType <: Function: type of P\nhamType <: Function: Hamiltonian type\ninvType <: OptionalNamedTuple: invariants type\nparType <: OptionalNamedTuple: parameters type\nperType <: OptionalArray{AT}: periodicity type\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nv: function computing the vector field v\nf: function computing the vector field f\nP: function computing the Poisson matrix P\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nhamiltonian: function computing the Hamiltonian H\ninvariants: either a NamedTuple containing the equation's invariants or nothing\nparameters: either a NamedTuple containing the equation's parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nConstructors\n\nHODE(v, f, poisson, t₀, q₀, p₀, hamiltonian, invariants, parameters, periodicity)\n\nHODE(v, f, h, t₀, q₀::StateVector, p₀::StateVector; kwargs...)\nHODE(v, f, h, q₀::StateVector, p₀::StateVector; kwargs...)\nHODE(v, f, h, t₀, q₀::State, p₀::State; kwargs...)\nHODE(v, f, h, q₀::State, p₀::State; kwargs...)\n\nKeyword arguments:\n\npoisson = symplectic_matrix\ninvariants = nothing\nparameters = nothing\nperiodicity = nothing\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.IDAE","page":"Equations","title":"GeometricIntegrators.Equations.IDAE","text":"IDAE: Implicit Differential Algebraic Equation\n\nDefines a partitioned differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + r(t q(t) p(t) lambda(t))   p(t_0) = p_0  \np(t) = p(t q(t) v(t))   \n0 = phi (t q(t) p(t) lambda(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector field f, the momentum defined by p, projection u and r, algebraic constraint phi=0, conditions (q_0 p_0) and lambda_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variable lambda taking values in mathbbR^n.\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nϑType <: Function: type of ϑ\nfType <: Function: type of f\nuType <: Function: type of u\ngType <: Function: type of g\nϕType <: Function: type of ϕ\nūType <: Function: type of ū\nḡType <: Function: type of ḡ\nψType <: Function: type of ψ\nv̄Type <: Function: type of v̄\nf̄Type <: Function: type of f̄\ninvType <: OptionalNamedTuple: invariants type\nparType <: OptionalNamedTuple: parameters type\nperType <: OptionalArray{AT}: periodicity type\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nm: dimension of algebraic variable lambda and the constraint phi\nϑ: function determining the momentum\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nt₀: initial time (optional)\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable λ\nμ₀: initial condition for algebraic variable μ (optional)\ninvariants: either a NamedTuple containing the equation's invariants or nothing\nparameters: either a NamedTuple containing the equation's parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nConstructors\n\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, t₀, q₀, p₀, λ₀, μ₀, invariants, parameters, periodicity)\n\nIDAE(ϑ, f, u, g, ϕ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nIDAE(ϑ, f, u, g, ϕ, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nIDAE(ϑ, f, u, g, ϕ, t₀, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\nIDAE(ϑ, f, u, g, ϕ, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\n\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, t₀, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\n\nKeyword arguments\n\nv̄ = (t,q,v) -> nothing\nf̄ = f\ninvariants = nothing\nparameters = nothing\nperiodicity = nothing\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.IODE","page":"Equations","title":"GeometricIntegrators.Equations.IODE","text":"IODE: Implicit Ordinary Differential Equation\n\nDefines an implicit initial value problem\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith vector field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v.\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nϑType <: Function: type of ϑ\nfType <: Function: type of f\ngType <: Function: type of g\nv̄Type <: Function: type of v̄\nf̄Type <: Function: type of f̄\nhType <: OptionalFunction: type of h\npType <: Union{NamedTuple,Nothing}: parameters type\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (q) cdot lambda\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nh: function computing the Hamiltonian (optional)\nt₀: initial time (optional)\nq₀: initial condition for q\np₀: initial condition for p\nparameters: either a NamedTuple containing the equations parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(t, q, v, p)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. In addition, the functions g, v̄ and f̄ are specified by\n\n    function g(t, q, λ, g)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\n    function v̄(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n    function f̄(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers.\n\nConstructors\n\nIODE(ϑ, f, v̄, f̄, t₀, q₀, p₀, λ₀, invariants, parameters, periodicity)\n\nIODE(ϑ, f, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector=zero(q₀); kwargs...)\nIODE(ϑ, f, q₀::StateVector, p₀::StateVector, λ₀::StateVector=zero(q₀); kwargs...)\nIODE(ϑ, f, t₀, q₀::State, p₀::State, λ₀::StateVector=zero(q₀); kwargs...)\nIODE(ϑ, f, q₀::State, p₀::State, λ₀::StateVector=zero(q₀); kwargs...)\n\nKeyword arguments\n\nv̄ = (t,q,v) -> nothing\nf̄ = f\ninvariants = nothing\nparameters = nothing\nperiodicity = nothing\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.LDAE","page":"Equations","title":"GeometricIntegrators.Equations.LDAE","text":"LDAE: Variational Differential Algebraic Equation EXPERIMENTAL\n\nDefines an implicit initial value problem\n\nbeginaligned\ndotq (t) = v(t) + lambda(t) \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) lambda(t)) + barg (t q(t) mu(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (v lambda mu) taking values in mathbbR^d times mathbbR^d times mathbbR^m. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and mu.\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nϑType <: Function: type of ϑ\nfType <: Function: type of f\nuType <: Function: type of u\ngType <: Function: type of g\nϕType <: Function: type of ϕ\nūType <: Function: type of ū\nḡType <: Function: type of ḡ\nψType <: Function: type of ψ\nωType <: Function: type of ω\nv̄Type <: Function: type of v̄\nf̄Type <: Function: type of f̄\nlagType <: Function: Lagrangian type\ninvType <: OptionalNamedTuple: invariants type\nparType <: OptionalNamedTuple: parameters type\nperType <: OptionalArray{AT}: periodicity type\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nϑ: function determining the momentum\nf: function computing the vector field\nu: function computing the projection for q, for a degenerate system given by lambda\ng: function computing the projection for p, for a degenerate system given by nabla vartheta (q) cdot lambda\nϕ: primary constraints, for a degenerate system given by p - vartheta (q)\nū: function computing the secondary projection field baru, for a degenerate system given by lambda (optional)\nḡ: function computing the secondary projection field barg, for a degenerate system given by lambda cdot nabla vartheta (q) (optional)\nψ: secondary constraints, for a degenerate system given by dotp - dotq cdot nabla vartheta (q) (optional)\nω: function computing the symplectic matrix\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nt₀: initial time (optional)\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable λ\nμ₀: initial condition for algebraic variable μ (optional)\nlagrangian: function computing the Lagrangian L\ninvariants: either a NamedTuple containing the equation's invariants or nothing\nparameters: either a NamedTuple containing the equation's parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(t, q, v, p)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\n    function g(t, q, λ, g)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\n    function v̄(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n    function f̄(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nConstructors\n\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, v̄, f̄, t₀, q₀, p₀, λ₀, μ₀, lagrangian, invariants, parameters, periodicity)\n\nLDAE(ϑ, f, u, g, ϕ, l, ω, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nLDAE(ϑ, f, u, g, ϕ, l, ω, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nLDAE(ϑ, f, u, g, ϕ, l, ω, t₀, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\nLDAE(ϑ, f, u, g, ϕ, l, ω, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\n\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, l, ω, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, l, ω, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, l, ω, t₀, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, l, ω, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\n\nKeyword arguments\n\nv̄ = (t,q,v) -> nothing\nf̄ = f\ninvariants = nothing\nparameters = nothing\nperiodicity = nothing\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.LODE","page":"Equations","title":"GeometricIntegrators.Equations.LODE","text":"LODE: Variational Ordinary Differential Equation EXPERIMENTAL\n\nDefines an implicit initial value problem\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith vector field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v.\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nϑType <: Function: type of ϑ\nfType <: Function: type of f\ngType <: Function: type of g\nωType <: Function: type of ω\nv̄Type <: Function: type of v̄\nf̄Type <: Function: type of f̄\nlagType <: Function: Lagrangian type\ninvType <: OptionalNamedTuple: invariants type\nparType <: OptionalNamedTuple: parameters type\nperType <: OptionalArray{AT}: periodicity type\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (q) cdot lambda\nω: function computing the symplectic matrix\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nt₀: initial time (optional)\nq₀: initial condition for q\np₀: initial condition for p\nλ₀: initial condition for λ (optional)\nlagrangian: function computing the Lagrangian L\ninvariants: either a NamedTuple containing the equation's invariants or nothing\nparameters: either a NamedTuple containing the equation's parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(t, q, v, p)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g and v are specified by\n\n    function g(t, q, λ, g)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\nand\n\n    function v(t, q, p, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nConstructors\n\nLODE(ϑ, f, ω, v̄, f̄, t₀, q₀, p₀, λ₀, lagrangian, invariants, parameters, periodicity)\n\nLODE(ϑ, f, l, ω, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector=zero(q₀); kwargs...)\nLODE(ϑ, f, l, ω, q₀::StateVector, p₀::StateVector, λ₀::StateVector=zero(q₀); kwargs...)\nLODE(ϑ, f, l, ω, t₀, q₀::State, p₀::State, λ₀::StateVector=zero(q₀); kwargs...)\nLODE(ϑ, f, l, ω, q₀::State, p₀::State, λ₀::StateVector=zero(q₀); kwargs...)\n\nKeyword arguments\n\nv̄ = (t,q,v) -> nothing\nf̄ = f\ninvariants = nothing\nparameters = nothing\nperiodicity = nothing\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.ODE","page":"Equations","title":"GeometricIntegrators.Equations.ODE","text":"ODE: Ordinary Differential Equation\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d.\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nvType <: Function: type of v\ninvType <: OptionalNamedTuple: invariants type\nparType <: OptionalNamedTuple: parameters type\nperType <: OptionalArray{AT}: periodicity type\n\nFields\n\nd: dimension of dynamical variable q and the vector field v\nv: function computing the vector field\nt₀: initial time\nq₀: initial condition\ninvariants: either a NamedTuple containing the equation's invariants or nothing\nparameters: either a NamedTuple containing the equation's parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nThe function v providing the vector field must have the interface\n\n    function v(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, and v is the vector which holds the result of evaluating the vector field v on t and q.\n\nConstructors\n\nODE(v, t₀, q₀, invariants, parameters, periodicity)\n\nODE(v, t₀, q₀::StateVector; kwargs...)\nODE(v, q₀::StateVector; kwargs...)\nODE(v, t₀, q₀::State; kwargs...)\nODE(v, q₀::State; kwargs...)\n\nKeyword arguments:\n\ninvariants = nothing\nparameters = nothing\nperiodicity = nothing\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.PDAE","page":"Equations","title":"GeometricIntegrators.Equations.PDAE","text":"PDAE: Partitioned Differential Algebraic Equation\n\nDefines a partitioned differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + r(t q(t) p(t) lambda(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t) lambda(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector fields v and f, projection u and r, algebraic constraint phi=0, conditions (q_0 p_0) and lambda_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variable lambda taking values in mathbbR^n.\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nvType <: Function: type of v\nfType <: Function: type of f\nuType <: Function: type of u\ngType <: Function: type of g\nϕType <: Function: type of ϕ\nūType <: Function: type of ū\nḡType <: Function: type of ḡ\nψType <: Function: type of ψ\nv̄Type <: Function: type of v̄\nf̄Type <: Function: type of f̄\ninvType <: OptionalNamedTuple: invariants type\nparType <: OptionalNamedTuple: parameters type\nperType <: OptionalArray{AT}: periodicity type\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nm: dimension of algebraic variable lambda and the constraint phi\nv: function computing the vector field v\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable lambda\nμ₀: initial condition for algebraic variable μ (optional)\ninvariants: either a NamedTuple containing the equation's invariants or nothing\nparameters: either a NamedTuple containing the equation's parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nConstructors\n\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, t₀, q₀, p₀, λ₀, invariants, parameters, periodicity)\n\nPDAE(v, f, u, g, ϕ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nPDAE(v, f, u, g, ϕ, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nPDAE(v, f, u, g, ϕ, t₀, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\nPDAE(v, f, u, g, ϕ, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\n\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ, t₀, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.PODE","page":"Equations","title":"GeometricIntegrators.Equations.PODE","text":"PODE: Partitioned Ordinary Differential Equation\n\nDefines a partitioned initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))  \np(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d.\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nvType <: Function: type of v\nfType <: Function: type of f\ninvType <: OptionalNamedTuple: invariants type\nparType <: OptionalNamedTuple: parameters type\nperType <: OptionalArray{AT}: periodicity type\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nv: function computing the vector field v\nf: function computing the vector field f\nt₀: initial time\nq₀: initial condition for q\np₀: initial condition for p\ninvariants: either a NamedTuple containing the equation's invariants or nothing\nparameters: either a NamedTuple containing the equation's parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nThe functions v and f must have the interface\n\n    function v(t, q, p, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, p, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q and p are the current solution vectors and v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p.\n\nConstructors\n\nPODE(v, f, t₀, q₀, p₀, invariants, parameters, periodicity)\n\nPODE(v, f, h, t₀, q₀::StateVector, p₀::StateVector; kwargs...)\nPODE(v, f, q₀::StateVector, p₀::StateVector; kwargs...)\nPODE(v, f, t₀, q₀::State, p₀::State; kwargs...)\nPODE(v, f, q₀::State, p₀::State; kwargs...)\n\nKeyword arguments:\n\ninvariants = nothing\nparameters = nothing\nperiodicity = nothing\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.PSDE","page":"Equations","title":"GeometricIntegrators.Equations.PSDE","text":"PSDE: Stratonovich Partitioned Stochastic Differential Equation\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0  \ndp (t) = f(t q(t))  dt + G(t q(t)) circ dW   p(t_0) = p_0\nendaligned\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nvType <: Function: type of v\nfType <: Function: type of f\nBType <: Function: type of B\nGType <: Function: type of G\npType <: Union{NamedTuple,Nothing}: parameters type\n\nFields\n\nd:  dimension of dynamical variable q and the vector field v\nm:  dimension of the Wiener process\nns: number of sample paths\nv:  function computing the drift vector field for the position variable q\nf:  function computing the drift vector field for the momentum variable p\nB:  function computing the d x m diffusion matrix for the position variable q\nG:  function computing the d x m diffusion matrix for the momentum variable p\nt₀: initial time\nq₀: initial condition for dynamical variable q (may be a random variable itself)\np₀: initial condition for dynamical variable p (may be a random variable itself)\nparameters: either a NamedTuple containing the equations parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, take four arguments, v(t, q, p, v), f(t, q, p, f), B(t, q, p,  B) and G(t, q, p, G), where t is the current time, (q, p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p).\n\nConstructors\n\nPSDE(m, ns, v, f, B, G, t₀, q₀, p₀; parameters=nothing, periodicity=zero(q₀[begin]))\nPSDE(m, ns, v, f, B, G, q₀::StateVector, p₀::StateVector; kwargs...) = PSDE(m, ns, v, f, B, G, 0.0, q₀, p₀; kwargs...)\nPSDE(m, ns, v, f, B, G, t₀, q₀::State, p₀::State; kwargs...) = PSDE(m, ns, v, f, B, G, t₀, [q₀], [p₀]; kwargs...)\nPSDE(m, ns, v, f, B, G, q₀::State, p₀::State; kwargs...) = PSDE(m, ns, v, f, B, G, 0.0, q₀, p₀; kwargs...)\n\nExample\n\n    function v(λ, t, q, v)\n        v[1] = λ*q[1]\n        v[2] = λ*q[2]\n    end\n\n    function B(μ, t, q, B)\n        B[1] = μ*q[1]\n        B[2] = μ*q[2]\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ  = 2.\n    μ  = 1.\n\n    v_sde = (t, q, v) -> v(λ, t, q, v)\n    B_sde = (t, q, B) -> B(μ, t, q, B)\n\n    sde = SDE(v_sde, B_sde, t₀, q₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SDE","page":"Equations","title":"GeometricIntegrators.Equations.SDE","text":"SDE: Stratonovich Stochastic Differential Equation\n\nDefines a stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendaligned\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nvType <: Function: type of v\nBType <: Function: type of B\npType <: Union{NamedTuple,Nothing}: parameters type\n\nFields\n\nd:  dimension of dynamical variable q and the vector field v\nm:  dimension of the Wiener process\nns: number of sample paths\nv:  function computing the deterministic vector field\nB:  function computing the d x m diffusion matrix\nt₀: initial time\nq₀: initial condition for dynamical variable q (may be a random variable itself)\nparameters: either a NamedTuple containing the equations parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nThe functions v and B, providing the drift vector field and diffusion matrix, v(t, q, v) and B(t, q, B, col=0), where t is the current time, q is the current solution vector, and v and B are the variables which hold the result of evaluating the vector field v and the matrix B on t and q (if col==0), or the column col of the matrix B (if col>0).\n\nConstructors\n\nSDE(m, ns, v, B, t₀, q₀; parameters=nothing, periodicity=zero(q₀[begin]))\nSDE(m, ns, v, B, q₀::StateVector; kwargs...) = SDE(m, ns, v, B, 0.0, q₀; kwargs...)\nSDE(m, ns, v, B, t₀, q₀::State; kwargs...) = SDE(m, ns, v, B, t₀, [q₀]; kwargs...)\nSDE(m, ns, v, B, q₀::State; kwargs...) = SDE(m, ns, v, B, 0.0, q₀; kwargs...)\n\nExample\n\n    function v(t, q, v, p)\n        λ = p[:λ]\n        v[1] = λ*q[1]\n        v[2] = λ*q[2]\n    end\n\n    function B(t, q, B, p, col=0)\n        μ = p[:μ]\n        if col==0 #whole matrix\n            B[1,1] = μ*q[1]\n            B[2,1] = μ*q[2]\n        elseif col==1\n            #just first column\n        end\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ  = 2.\n    μ  = 1.\n    p = (λ=λ, μ=μ)\n\n    sde = SDE(v, B, t₀, q₀; parameters=p)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SODE","page":"Equations","title":"GeometricIntegrators.Equations.SODE","text":"SODE: Split Ordinary Differential Equation\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nvType <: Union{Tuple,Nothing}: type of v\nqType <: Union{Tuple,Nothing}: type of q\ninvType <: OptionalNamedTuple: invariants type\nparType <: OptionalNamedTuple: parameters type\nperType <: OptionalArray{AT}: periodicity type\n\nFields\n\nd: dimension of dynamical variable q and the vector field v\nv: tuple of functions computing the vector field\nq: tuple of functions computing the solution\nt₀: initial time\nq₀: initial condition\ninvariants: either a NamedTuple containing the equation's invariants or nothing\nparameters: either a NamedTuple containing the equation's parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nThe functions v_i providing the vector field must have the interface\n\n    function v_i(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nand the functions q_i providing the solutions must have the interface\n\n    function q_i(t, q₀, q₁, h)\n        q₁[1] = q₀[1] + ...\n        q₁[2] = q₀[2] + ...\n        ...\n    end\n\nwhere t is the current time, q₀ is the current solution vector, q₁ is the new solution vector which holds the result of computing one substep with the vector field v_i on t and q₀, and h is the (sub-)timestep to compute the update for.\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps.\n\nConstructors\n\nSODE(v, q, t₀, q₀, invariants, parameters, periodicity)\n\nSODE(v, q::Union{Tuple,Nothing}, t₀::Real, q₀::StateVector; kwargs...)\nSODE(v, q::Union{Tuple,Nothing}, t₀::Real, q₀::State; kwargs...)\nSODE(v, q::Union{Tuple,Nothing}, q₀::StateVector; kwargs...)\nSODE(v, q::Union{Tuple,Nothing}, q₀::State; kwargs...)\n\nSODE(v, t₀::Real, q₀::StateVector; kwargs...)\nSODE(v, t₀::Real, q₀::State; kwargs...)\nSODE(v, q₀::StateVector; kwargs...)\nSODE(v, q₀::State; kwargs...)\n\nKeyword arguments:\n\ninvariants = nothing\nparameters = nothing\nperiodicity = nothing\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SPDAE","page":"Equations","title":"GeometricIntegrators.Equations.SPDAE","text":"SPDAE: Split Partitioned Differential Algebraic Equation EXPERIMENTAL\n\nDefines a split differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v_1(t q(t) p(t)) + v_2(t q(t) p(t) lambda(t)) + v_3(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f_1(t q(t) p(t)) + f_2(t q(t) p(t) lambda(t)) + f_3(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v_i and f_i for i = 1  3, primary constraint phi(qp)=0 and secondary constraint psi(qplambda)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^n times mathbbR^d.\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nvType <: Function: type of v\nfType <: Function: type of f\nϕType <: Function: type of ϕ\nψType <: Function: type of ψ\ninvType <: OptionalNamedTuple: invariants type\nparType <: OptionalNamedTuple: parameters type\nperType <: OptionalArray{AT}: periodicity type\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nm: dimension of algebraic variables lambda and gamma and the constraints phi and psi\nv: tuple of functions computing the vector fields v_i, i = 1  3\nf: tuple of functions computing the vector fields f_i, i = 1  3\nϕ: primary constraints\nψ: secondary constraints\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable λ\nμ₀: initial condition for algebraic variable μ (optional)\ninvariants: either a NamedTuple containing the equation's invariants or nothing\nparameters: either a NamedTuple containing the equation's parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nConstructors\n\nSPDAE(v, f, ϕ, ψ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nSPDAE(v, f, ϕ, ψ, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nSPDAE(v, f, ϕ, ψ, t₀, q₀::State, p₀::State, λ₀::State=zero(q₀); kwargs...)\nSPDAE(v, f, ϕ, ψ, q₀::State, p₀::State, λ₀::State=zero(q₀); kwargs...)\n\nKeyword arguments:\n\ninvariants = nothing\nparameters = nothing\nperiodicity = nothing\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SPSDE","page":"Equations","title":"GeometricIntegrators.Equations.SPSDE","text":"SPSDE: Stratonovich Split Partitioned Stochastic Differential Equation\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) =   v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0  \ndp (t) =  f_1(t q(t)) + f_2(t q(t))   dt +  G_1(t q(t)) + G_2(t q(t))  circ dW   p(t_0) = p_0 \nendaligned\n\nwith the drift vector fields v and f_i, diffusion matrices B and G_i, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type\nvType <: Function: type of v\nf1Type <: Function: type of f1\nf2Type <: Function: type of f2\nBType <: Function: type of B\nG1Type <: Function: type of G1\nG2Type <: Function: type of G2\npType <: Union{NamedTuple,Nothing}: parameters type\n\nFields\n\nd:  dimension of dynamical variable q and the vector fields vi\nm:  dimension of the Wiener process\nni: number of initial conditions\nns: number of sample paths\nv :  function computing the drift vector field for the position variable q\nf1:  function computing the drift vector field for the momentum variable p\nf2:  function computing the drift vector field for the momentum variable p\nB :  function computing the d x m diffusion matrix for the position variable q\nG1:  function computing the d x m diffusion matrix for the momentum variable p\nG2:  function computing the d x m diffusion matrix for the momentum variable p\nt₀: initial time\nq₀: initial condition for dynamical variable q (may be a random variable itself)\np₀: initial condition for dynamical variable p (may be a random variable itself)\nparameters: either a NamedTuple containing the equations parameters or nothing\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, take four arguments, v(t, q, p, v), f(t, q, p, f), B(t, q, p,  B) and G(t, q, p, G), where t is the current time, (q, p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p).\n\nConstructors\n\nSPSDE(m, ns, v, f1, f2, B, G1, G2, t₀, q₀, p₀; parameters=nothing, periodicity=zero(q₀[begin]))\nSPSDE(m, ns, v, f1, f2, B, G1, G2, q₀::StateVector, p₀::StateVector; kwargs...) = SPSDE(m, ns, v, f1, f2, B, G1, G2, 0.0, q₀, p₀; kwargs...)\nSPSDE(m, ns, v, f1, f2, B, G1, G2, t₀, q₀::State, p₀::State; kwargs...) = SPSDE(m, ns, v, f1, f2, B, G1, G2, t₀, [q₀], [p₀]; kwargs...)\nSPSDE(m, ns, v, f1, f2, B, G1, G2, q₀::State, p₀::State; kwargs...) = SPSDE(m, ns, v, f1, f2, B, G1, G2, 0.0, q₀, p₀; kwargs...)\n\nExample\n\n    function v(λ, t, q, v)\n        v[1] = λ*q[1]\n        v[2] = λ*q[2]\n    end\n\n    function B(μ, t, q, B)\n        B[1] = μ*q[1]\n        B[2] = μ*q[2]\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ  = 2.\n    μ  = 1.\n\n    v_sde = (t, q, v) -> v(λ, t, q, v)\n    B_sde = (t, q, B) -> B(μ, t, q, B)\n\n    sde = SDE(v_sde, B_sde, t₀, q₀)\n\n\n\n\n\n","category":"type"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"CurrentModule = GeometricIntegrators.Integrators.VPRK","category":"page"},{"location":"integrators/vprk/#Variational-Partitioned-Runge-Kutta-Integrators","page":"VPRK","title":"Variational Partitioned Runge-Kutta Integrators","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Variational partitioned Runge-Kutta methods solve Lagranian systems in implicit form, i.e.,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\np       = dfracpartial Lpartial dotq (q dotq)  \ndotp = dfracpartial Lpartial q       (q dotq)  \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"by the following scheme,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ki = dfracpartial Lpartial q (Q_ni V_ni)  \nP_nj = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s b_i  F_ni \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Here, s denotes the number of internal stages, a_ij and bara_ij are the coefficients of the Runge-Kutta method and b_i and barb_i the corresponding weights. If the coefficients satisfy the symplecticity conditions,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j \n textand \nbarb_i = b_i \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"these methods correspond to the position-momentum form of the discrete Lagrangian [Jerrold E. Marsden , Matthew West  (2001)]","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk-discrete-lagrangian\nL_d (q_n q_n+1) = h sum limits_i=1^s b_i  L big( Q_ni V_ni big) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"While these integrators show favourable properties for systems with regular Lagrangian, they are usually not applicable for degenerate Lagrangian systems, in particular those with Lagrangians of the form L (q dotq) = vartheta(q) cdot dotq - H(q). While variational integrators are still applicable in the case of vartheta being a linear function of q, they are often found to be unstable when vartheta is a nonlinear function of q as is the case with Lotka-Volterra systems, various nonlinear oscillators, guiding centre dynamics and other reduced charged particle models. To mitigate this problem, projection methods have been developed, which can be used in conjunction with variational integrators. These projected variational integrators provide long-time stable methods for general degenerate Lagrangian systems that maintain conservation of energy and momenta over long integration periods [Michael Kraus  (2017)].","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"GeometricIntegrators.jl provides the following VPRK methods:","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Integrator Description\nIntegratorVPRK Variational Partitioned Runge-Kutta (VPRK) integrator without projection\nIntegratorVPRKpStandard VPRK integrator with standard projection\nIntegratorVPRKpSymmetric VPRK integrator with symmetric projection\nIntegratorVPRKpMidpoint VPRK integrator with midpoint projection\nIntegratorVPRKpVariational VPRK integrator with variational projection (unstable)\nIntegratorVPRKpSecondary VPRK integrator with projection on secondary constraint\nIntegratorVPRKpInternal Gauss-Legendre VPRK integrator with projection on internal stages of Runge-Kutta method\nIntegratorVPRKpTableau Gauss-Legendre VPRK integrator with projection in tableau of Runge-Kutta method","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For testing purposes IntegratorVPRKpStandard provides some additional constructors (note that these methods are generally unstable):","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Integrator Description\nIntegratorVPRKpVariationalQ VPRK integrator with variational projection on (q_n p_n+1)\nIntegratorVPRKpVariationalP VPRK integrator with variational projection on (p_n q_n+1)\nIntegratorVPRKpSymplectic VPRK integrator with symplectic projection","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"All of the above integrators are applied to either an IODE or LODE and instantiated as follows:","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"int = IntegratorVPRK(iode, tab, Δt)","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The only exception is IntegratorVPRKpSecondary which can only be applied to an LODE as it needs some additional functions which are only defined for variational problems.","category":"page"},{"location":"integrators/vprk/#Discrete-Action-Princtiple","page":"VPRK","title":"Discrete Action Princtiple","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Symplectic partitioned Runge-Kutta integrators have been shown to be variational integrators [Jerrold E. Marsden , Matthew West  (2001), Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006)]. Here, the discrete Lagrangian \\eqref{eq:vprk-discrete-lagrangian} has s internal points (or stages) located at t_n + h c_i with weights b_i which are all non-zero and sum up to one. The internal stages Q_ni approx q(t_n + h c_i) are given by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Q_ni = q_n + h sum limits_j=1^s a_ij  V_nj ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In contrast to the composition methods, we do not require c_1 = 0 and c_s = 1. Instead the discrete action is extremised under the constraints","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"q_n+1 = q_n + h sum limits_i=1^s b_i  V_ni ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"which we add to the action with the Lagrange multiplier lambda_n+1, so that we can write","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk-action-gauss\nmathcalA_d = sum limits_n=1^N-1 bigg h sum limits_i=1^s b_i  L big( Q_ni V_n1 big) + lambda_n+1 cdot bigg( q_n+1 - q_n - h sum limits_i=1^s b_i  V_ni bigg) bigg \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Computing variations of the action leads to","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\ndelta mathcalA_d\n= sum limits_n=1^N-1left h sum limits_i=1^s h b_i a_ij  dfracpartial Lpartial q (Q_ni V_ni) \n + h b_j  dfracpartial Lpartial v (Q_nj V_nj)\n - h b_j  lambda_n+1 right cdot delta V_nj \n+ sum limits_n=1^N-1left h sum limits_i=1^s b_i  dfracpartial Lpartial q (Q_ni V_ni) \n - lambda_n+1 + lambda_n right cdot delta q_n \n+ sum limits_n=1^N-1 bigg q_n+1 - q_n - h sum limits_i=1^s b_i  V_ni bigg cdot delta lambda_n+1\n = 0 \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"We define discrete forces and momenta as","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"F_ni = dfracpartial Lpartial q (Q_ni V_ni)\nhspace3em\ntextand\nhspace3em\nP_ni = dfracpartial Lpartial v (Q_ni V_ni) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that the terms of the variation which are multiplying delta V_nj become","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"P_nj = lambda_n+1 - h sum limits_i=1^s dfracb_i a_ijb_j  F_ni ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The terms of the variations which are multiplying delta q_n become","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"lambda_n+1 = lambda_n + h sum limits_i=1^s b_i  F_ni ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Similar to classical variational integrators, we can use the discrete fibre derivative","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdiscrete-fibre-derivative\nbeginaligned\nmathbbF^- L_d  (q_n q_n+1) mapsto (q_n   p_n)   = big( q_n   - D_1 L_d (q_n q_n+1) big)  \nmathbbF^+ L_d  (q_n q_n+1) mapsto (q_n+1 p_n+1) = big( q_n+1   D_2 L_d (q_n q_n+1) big) \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"to define the position-momentum form of the integrator,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvi-position-momentum-form\nbeginaligned\np_n  \n=           -  D_1 L_d (q_n q_n+1)\n = lambda_n+1 - h sum limits_i=1^s b_i  F_ni  \np_n+1\n= hphantom- D_2 L_d (q_n q_n+1)\n = lambda_n+1 \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Replacing lambda_n+1 in the second equation with its expression obtained from the first equation, we get","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"p_n+1 = p_n + h sum limits_i=1^s v_i  F_ni ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"which states that the second symplecticity condition (b_i = barb_i) is automatically satisfied. In the same fashion, we obtain","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"P_nj = p_n + h sum limits_i=1^s bara_ij  F_nj ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"with","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"bara_ij = b_j - b_j a_ji  b_i ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"such that the first symplecticity condition is also satisfied. In summary, we obtain the variational-partitioned Runge-Kutta integrator \\eqref{eq:vprk}. If the fibre derivative is invertible, an equivalent set of equations can be obtained by applying","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nV_ni =   dfracpartial Hpartial p (Q_ni P_ni)  \nF_ni = - dfracpartial Hpartial q (Q_ni P_ni) \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"to the Hamiltonian H(qp) obtained via the Legendre transform. The interested reader can find more details on this in [Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006)] and references therein.","category":"page"},{"location":"integrators/vprk/#Lobatto-Methods","page":"VPRK","title":"Lobatto Methods","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Some words of caution are in order. The above derivation works well, if all discrete velocities V_ni are linearly independent. This is the case e.g. for Gauss-Legendre Runge-Kutta discretizations but not for Lobatto discretizations (see Sina Ober-Blöbaum  (2016) for details). For discretizations of Lobatto-IIIA type, where the first internal stage coincides with the solution at the previous time step, the velocities V_ni are not linearly independent and the discrete action \\eqref{eq:vprk-action-gauss} needs to be augmented by an additional constraint to take this dependence into account,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk-action-lobatto\nbeginaligned\nmathcalA_d =\nsum limits_n=0^N-1 Bigglgroup\nh sum limits_i=1^s b_i  bigg L big( Q_ni V_ni big)\n+ F_ni cdot bigg( Q_ni - q_n - h sum limits_j=1^s a_ij  V_nj bigg) bigg \n- p_n+1 cdot bigg( q_n+1 - q_n - h sum limits_i=1^s b_i  V_ni bigg)\n+ mu_n cdot bigg( sum limits_i=1^s d_i V_ni bigg)\nBiggrgroup \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Requiring stationarity of \\eqref{eq:vprk-action-lobatto}, we obtain a modified system of equations,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk-lobatto\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nP_ni = p_n + h sum limits_j=1^s bara_ij  F_nj - mu_n dfracd_ib_i  \nq_n+1 = q_n + h sum limits_i=1^s b_i   V_ni  \np_n+1 = p_n + h sum limits_i=1^s barb_i   F_ni  \n0 = sum limits_i=1^s d_i V_ni \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"accounting for the linear dependence of the dotQ_ni and consequently also of the P_ni. The particular values of d_i depend on the number of stages s and the definition of the q_ni [Sina Ober-Blöbaum  (2016)]. For two stages, we have d_1 = - d_2, so that we can choose, for example, d = (+1 -1), and \\eqref{eq:vprk-lobatto} becomes equivalent to the variational integrator of the trapezoidal Lagrangian. For three stages, we can choose d = (tfrac12 -1 tfrac12), and for four stages we can use d = (+1 -sqrt5 +sqrt5 -1). In GeometricIntegrators, these vectors can be obtained via the function get_lobatto_nullvector from RungeKutta.jl.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Another approach that always works is to use directly compute the position-momentum form \\eqref{eq:vi-position-momentum-form} of the variational integrator for the discrete Lagrangian \\eqref{eq:vprk-discrete-lagrangian} instead of applying the discrete action principle. Such subtleties, which are easily overlooked, can be avoided by starting the discretisation of the action from a more fundamental point of view, namely by approximating the function spaces of the trajectories, which leads us to Galerkin Variational Integrators.","category":"page"},{"location":"integrators/vprk/#sec:degenerate-lagrangian-systems","page":"VPRK","title":"Degenerate Lagrangians","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Degenerate Lagrangian systems are relevant for the study of population models, point vortex dynamics or reduced charged particle models like the guiding centre system. Here, we consider degenerate Lagrangian systems characterized by a Lagrangian that is linear or singular in the velocities. In particular, we consider the class of systems whose Lagrangian is of the form","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdegenerate-lagrangian\nL (q v) = vartheta(q) cdot v - H(q) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The Lagrangian L is a function on the tangent bundle tbmfM,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqlagrangian-tangent-bundle\nL  tbmfM rightarrow mathbbR \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where mfM denotes the configuration manifold of the system which is assumed to be of dimension d. The cotangent bundle of the configuration manifold mfM is denoted by cbmfM. Further, we denote the coordinates of a point m in mfM by q(m) = (q^1 (m) dotsc q^d (m)) and similarly coordinates of points in tbmfM by (q^i v^i) and coordinates of points in cbmfM by (q^i p^i). In the following, we will always assume the existence of a global coordinate chart, so that mfM can be identified with the Euclidean space mathbbR^d. For simplicity, we often use short-hand notation where we write q to refer to both a point in mfM as well as its coordinates. Similarly, we often denote points in the tangent bundle tbmfM by (q v). In local coordinates, the Lagrangian \\eqref{eq:lagrangian-tangent-bundle} is thus written as a map (q v) mapsto L(q v).","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In Equation \\eqref{eq:degenerate-lagrangian}, vartheta = vartheta_i (q)  ext q^i is a differential one-form vartheta  mfM rightarrow cbmfM, whose components vartheta_i  mfM rightarrow mathbbR are general, possibly nonlinear functions of q, some of which (but not all) could be identically zero. For details on differential forms, tangent and cotangent bundles the interested reader may consult any modern book in mathematical physics or differential geometry. We recommend Tevian Dray  (2014), John Baez , Javier P. Muniain  (1994), Richard W. R. Darling  (1994), Theodore Frankel  (2011) for more physics oriented accounts and John M. Lee  (2012), Jeffrey M. Lee  (2009), Loring W. Tu  (2011), Shigeyuki Morita  (2001) for more mathematics oriented accounts. In the following we assume a basic understanding of these concepts. To see their usefulness for classical mechanics we refer to Ralph Abraham , Jerrold E. Marsden  (1978), Jerrold E. Marsden , Tudor S. Ratiu  (2002), Darryl D. Holm , Tanya Schmah , Cristina Stoica  (2009).","category":"page"},{"location":"integrators/vprk/#sec:dirac-constraints","page":"VPRK","title":"Dirac Constraints","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Degenerate systems of the form \\eqref{eq:degenerate-lagrangian} can also be formulated in terms of the phasespace trajectory (q p) in the cotangent bundle cbmfM, subject to a primary constraint in the sense of Dirac, determined by the function phi  cbmfM rightarrow mathbbR^d, given by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdirac_constraint\nphi (q p) = p - vartheta(q) = 0 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and originating from the fibre derivative mathbbF L  tbmfM rightarrow cbmfM,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqfibre-derivative-general\nmathbbF L (v_q) cdot w_q = dfracddepsilon biggvert_epsilon=0 L(v_q + epsilon w_q) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where v_q = (q v) and w_q = (q w) denote two points in tbmfM which share the same base point q and are thus elements of the same fibre of tbmfM. By acting point-wise for each t, the fibre derivative maps the curve (q dotq) in the tangent bundle tbmfM into the curve (q p) in the cotangent bundle cbmfM,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqfibre_derivative\n(q (t) p (t)) = left( q (t) dfracpartial Lpartial v (q (t) dotq (t)) right) = (q (t) vartheta (q (t))) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where the last equality follows for Lagrangians of the form \\eqref{eq:degenerate-lagrangian}. The Dirac constraint arising from the degenerate Lagrangian restricts the dynamics to the submanifold","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqconstraint-submanifold\nDelta = big (q p) in cbmfM  bigvert  phi (q p) = 0  big subset cbmfM \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the preceding and the following, we assume that the Lagrangian is degenerate in all velocity components, that is, the Lagrangian is either linear or singular in each component of v, so that","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"dfracpartial^2 Lpartial v^i  partial v^j = 0\nhspace3em\ntextfor all 1 leq ij leq d","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For instructive reasons, however, assume for a moment that the Lagrangian is degenerate in only m  d components of v and, e.g., quadratic in the other d-m components. That is to say we can write","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"p (t)\n= big( beta_1 (q (t) dotq (t)) dotsc beta_d-m (q (t) dotq (t))  vartheta_d-m+1 (q (t)) dotsc vartheta_d (q (t)) big)^T ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"dfracpartial Lpartial v^i (q (t) dotq (t)) = begincases\nbeta_i (q (t) dotq (t))  1 leq i leq d - m  \nvartheta_i (q (t))  d-m+1 leq i leq d  \nendcases","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"We can then denote coordinates in Delta by (q^i pi^j) with 1 leq i leq d and 1 leq j leq d-m, where the pi^i denote those momenta which are ``free'', i.e., not determined by the Dirac constraint. The inclusion map i  Delta rightarrow cbmfM can then be written as","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdirac-inclusion_genereal\ni  (q pi) mapsto (q pi vartheta (q)) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the fully degenerate case, however, we have m=d, so that the configuration manifold mfM and the constraint submanifold Delta are isomorphic and we can label points in Delta by the same q we use to label points in mfM. The inclusion map i  Delta rightarrow cbmfM simplifies accordingly and reads","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdirac-inclusion\ni  q mapsto (q vartheta (q)) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where it is important to keep in mind that q denotes a point in Delta. The inverse operation is given by the projection pi_Delta  cbmfM rightarrow Delta, defined such that pi_Delta circ i = id.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"As we are lacking a general framework for constructing structure-preserving numerical algorithms for noncanonical Hamiltonian systems on mfM, we will construct such algorithms on i(Delta). This can be achieved by using canonically symplectic integrators on cbmfM and assuring that their solution stays on i(Delta). To this end we will employ various projection methods.","category":"page"},{"location":"integrators/vprk/#Projection-Methods","page":"VPRK","title":"Projection Methods","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Projection methods are a standard technique for the integration of ordinary differential equations on manifolds [Ernst Hairer  (2001), Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006)]. The problem of constructing numerical integrators on manifolds with complicated structure is often difficult and thus avoided by embedding the manifold into a larger space with simple, usually Euclidean structure, where standard integrators can be applied. Projection methods are then used to ensure that the solution stays on the correct subspace of the extended solution space, as that is usually not guaranteed by the numerical integrator itself.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the standard projection method, a projection is applied after each step of the numerical algorithm. Assuming that the initial condition lies in the manifold, the solution of the projected integrator will stay in the manifold. The problem with this approach is that even though assuming that the numerical integrator is symmetric, the whole algorithm comprised of the integrator and the projection will not be symmetric. This often leads to growing errors in the solution and consequently a drift in the total energy of the system. This can be remedied by symmetrizing the projection [Ernst Hairer  (2000), Ernst Hairer  (2001), Robert P. K. Chan , Philippe Chartier , Ander Murua  (2004), Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006)], where the initial data is first perturbed out of the constraint submanifold, before the numerical integrator is applied, and then projected back to the manifold. This leads to very good long-time stability and improved energy behaviour.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"While such projection methods, both standard and symmetric ones, are standard procedures for conserving energy, as well as holonomic and non-holonomic constraints, not much is known about their application to Dirac constraints.  Some authors consider general differential algebraic systems of index two [Ernst Hairer , Christian Lubich , Michel Roche  (1989), Uri M. Ascher , Linda R. Petzold  (1991), Robert P. K. Chan , Philippe Chartier , Ander Murua  (2002), Robert P. K. Chan , Philippe Chartier , Ander Murua  (2004), Laurent O. Jay  (2003), Laurent O. Jay  (2006)], the class to which the systems considered here belong, but a discussion of symplecticity seems to be mostly lacking from the literature, aside from some remarks on the conservation of quadratic invariants by the post-projection method of [Robert P. K. Chan , Philippe Chartier , Ander Murua  (2002)].","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the following, we apply several projection methods (standard, symmetric, symplectic, midpoint) to variational integrators in position-momentum form. As it turns out, both the standard projection and the symmetric projection are not symplectic. The symmetric projection nevertheless shows very good long-time stability, as it can be shown to be pseudo-symplectic. The symplectic projection method, as the name suggests, is indeed symplectic, although in a generalized sense. The midpoint projection method is symplectic in the usual sense but only for particular integrators.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The general procedure is as follows. We start with initial conditions q_n on Delta (recall that for the particular Lagrangian \\eqref{eq:degenerate-lagrangian} considered here, the configuration manifold mfM and the constraint submanifold Delta are isomorphic, so that we can use the same coordinates on Delta as we use on mfM). We compute the corresponding momentum p_n by the continuous fibre derivative \\eqref{eq:fibre-derivative-general}, which yields initial conditions (q_n p_n = vartheta(q_n)) on cbmfM satisfying the constraint phi(q_n p_n) = 0. This corresponds to the inclusion map \\eqref{eq:dirac-inclusion}. Then, we may or may not perturb these initial conditions off the constraint submanifold by applying a map (q_n p_n) mapsto (barq_n barp_n) which is either the inverse mathbbP^-1 of a projection mathbbP  cbmfM rightarrow i(Delta) or, in the case of the standard projection, just the identity. The perturbation is followed by the application of some canonically symplectic algorithm Psi_h on cbmfM, namely a variational integrator in position-momentum form \\eqref{eq:vi-position-momentum-form} or a variational Runge-Kutta method \\eqref{eq:vprk} or \\eqref{eq:vprk-lobatto}, in which cases we have that Psi_h = big( mathbbF^+ L_d big) circ big( mathbbF^- L_d big)^-1. In general, the result of this algorithm, (barq_n+1 barp_n+1) = Psi_h (barq_n barp_n), will not lie on the constraint submanifold \\eqref{eq:constraint-submanifold}. Therefore we apply a projection (barq_n+1 barp_n+1) mapsto (q_n+1 p_n+1) which enforces phi (q_n+1 p_n+1) = p_n+1 - vartheta(q_n+1) = 0. As this final result is a point in i(Delta) it is completely characterized by the value q_n+1.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: )","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Gradient of the constraint function phi orthogonal and Omega-orthogonal to constant surfaces of phi(q p) = p - sqrtp_0^2 - q^2 for p_0 in  1 2 3 .","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Let us emphasize that in contrast to standard projection methods, where the solution is projected orthogonal to the constrained submanifold, along the gradient of phi, here the projection has to be Omega-orthogonal, where Omega is the canonical symplectic matrix","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqcanonical-symplectic-matrix\nOmega = beginpmatrix\nmathbb0            -  mathbb1 \nmathbb1  hphantom- mathbb0 \nendpmatrix \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"That is, denoting by lambda the Lagrange multiplier, the projection step is given by Omega^-1 nabla phi^T lambda instead of an orthogonal projection nabla phi^T lambda.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Let us also note that, practically speaking, the momenta p_n and p_n+1 are merely treated as intermediate variables much like the internal stages of a Runge-Kutta method. The Lagrange multiplier lambda, on the other hand, is determined in different ways for the different methods and can be the same or different in the perturbation and the projection. It thus takes the role of an internal variable only for the standard, symmetric projection and midpoint projection, but not for the symplectic projection.","category":"page"},{"location":"integrators/vprk/#Geometric-Aside:-Projected-Fibre-Derivatives","page":"VPRK","title":"Geometric Aside: Projected Fibre Derivatives","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the following, we will try to underpin the construction of the various projection methods with some geometric ideas. We already mentioned several times that the position-momentum form of the variational integrator \\eqref{eq:vi-position-momentum-form} suffers from the problem that it does not preserve the constraint submanifold Delta defined in \\eqref{eq:constraint-submanifold}. That is, even though it is applied to a point in i(Delta), it usually returns a point in cbmfM, but outside of i(Delta). In order to understand the reason for this, let us define Delta_mfM^- and Delta_mfM^+ as the subsets of mfM times mfM which are mapped into the constraint submanifold i(Delta) by the discrete fibre derivatives mathbbF^- L_d and mathbbF^+ L_d, respectively, i.e.,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqconstraint-submanifold_QxQ\nbeginaligned\nDelta_mfM^- =  (q_n q_n+1) in mfM times mfM  bigvert  mathbbF^- L_d (q_n q_n+1) = (q_n p_n) in i(Delta) big  \nDelta_mfM^+ =  (q_n q_n+1) in mfM times mfM  bigvert  mathbbF^+ L_d (q_n q_n+1) = (q_n+1 p_n+1) in i(Delta) big \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"or more explicitly,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqconstraint-submanifold_QxQ_coordinates\nbeginaligned\nDelta_mfM^- =  (q_n q_n+1) in mfM times mfM  bigvert  - D_1 L_d (q_n q_n+1) = vartheta(q_n) big  \nDelta_mfM^+ =  (q_n q_n+1) in mfM times mfM  bigvert  D_2 L_d (q_n q_n+1) = vartheta(q_n+1) big \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"A sufficient condition for the position-momentum form of the variational integrator \\eqref{eq:vi-position-momentum-form} to preserve the constraint submanifold \\eqref{eq:constraint-submanifold} would be that Delta_mfM^- and Delta_mfM^+ are identical.  In principle, slightly weaker necessary conditions can be formulated, however in practice it is unclear how to prove any of these conditions and in general they are not satisfied.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In order to construct a modified algorithm which does preserve the constraint submanifold, we compose the discrete fibre derivatives mathbbF^pm with appropriate projections mathbbP^pm,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqposition_momentum_projection\nbeginaligned\n(q_n p_n  )\n= big( mathbbP^- circ mathbbF^- L_d big) (q_n q_n+1)\n = mathbbP_lambda_n^-^- big( q_n -  D_1 L_d (q_n q_n+1) big)  \n(q_n+1 p_n+1)\n= big( mathbbP^+ circ mathbbF^+ L_d big) (q_n q_n+1)\n = mathbbP_lambda_n+1^+^+ big( q_n+1 D_2 L_d (q_n q_n+1) big)  \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that they take any point in mfM times mfM to the constraint submanifold Delta. The Lagrange multiplier lambda is indicated as subscript and implicitly determined by requiring that the constraint phi is satisfied by the projected values of q and p. These projected fibre derivatives will not be a fibre-preserving map anymore, but they will change both q and p. Noting that the nullspace of mathbbP_lambda is the span of Omega^-1 nabla phi, a natural candidate for the projection mathbbP_lambda is given by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqprojector\nbeginaligned\nmathbbP_lambda^pm (q p)  (q p) = (q p) pm h  Omega^-1 nabla phi^T (q p) lambda  \n0 = phi(q p) \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that ( mathbbP^- circ mathbbF^- L_d ) (q_n q_n+1) explicitly reads","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nq_n = q_n - h  phi_p^T (q_n p_n) lambda_n^-  \np_n = - D_1 L_d (q_n q_n+1) + h  phi_q^T (q_n p_n) lambda_n^-  \n0 = phi(q_n p_n) \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and ( mathbbP^+ circ mathbbF^+ L_d ) (q_n q_n+1) explicitly reads","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nq_n+1 = q_n+1 + h  phi_p^T (q_n+1 p_n+1) lambda_n+1^+  \np_n+1 = D_2 L_d (q_n q_n+1) - h  phi_q^T (q_n+1 p_n+1) lambda_n+1^+  \n0 = phi(q_n+1 p_n+1) \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The signs in front of the projections have been chosen in correspondence with the signs of the discrete forces in Jerrold E. Marsden , Matthew West  (2001), Chapter 3. With these projections we obtain all of the algorithms introduced in the following sections, except for the midpoint projection, in a similar fashion to the definition of the position-momentum form of the variational integrator \\eqref{eq:vi-position-momentum-form}, as a map Delta rightarrow Delta which can formally be written as","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqprojection-composition-map\nPhi_h = big( pi_Delta circ mathbbP^+ circ mathbbF^+ L_d big) circ big( pi_Delta circ mathbbP^- circ mathbbF^- L_d big)^-1 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In total, we obtain algorithms which map q_n into q_n+1 via the steps","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Delta\nxrightarrowpi_Delta^-1\ni(Delta)\nxrightarrow(mathbbP^-)^-1\ncbmfM\nxrightarrow(mathbbF^- L_d)^-1\nmfM times mfM\nxrightarrowmathbbF^+ L_d\ncbmfM\nxrightarrowmathbbP^+\ni(Delta)\nxrightarrowpi_Delta\nDelta ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where pi_Delta^-1 is identical to the inclusion \\eqref{eq:dirac-inclusion}. The difference of the various algorithms lies in the choice of lambda_n^- and lambda_n+1^+ as follows","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Projection lambda_n^- lambda_n+1^+\nStandard 0 lambda_n+1\nSymplectic lambda_n R (infty)  lambda_n+1hphantom2\nSymmetric lambda_n+12 R (infty)  lambda_n+12\nMidpoint lambda_n+12 R (infty)  lambda_n+12","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For the symmetric, symplectic and midpoint projections, it is important to adapt the sign in the projection according to the stability function R(infty) of the basic integrator (for details see e.g. Robert P. K. Chan , Philippe Chartier , Ander Murua  (2004)). For the methods we are interested in, namely Runge-Kutta methods, the stability function is given by R(z) = 1 + z b^T (identity - zA)^-1 e with e = (1 1  1)^T in mathbbR^s, and we have absR(infty)=1 or, more specifically, for Gauss-Legendre methods R(infty) = (-1)^s and for partitioned Gauss-Lobatto IIIA-IIIB and IIIB-IIIA methods we have R(infty) = (-1)^s-1.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Let us remark that for the standard projection, the basic integrator and the projection step can be applied independently. Similarly, for the symplectic projection, the three steps, namely perturbation, numerical integrator, and projection, decouple and can be solved consecutively, as we use different Lagrange multipliers lambda_n in the perturbation and lambda_n+1 in the projection. For the symmetric projection and the midpoint projection, however, this is not the case.  There, we used the same Lagrange multiplier lambda_n+12 in both the perturbation and the projection, so that the whole system has to be solved at once, which is more costly. This also implies that for the projection methods where lambda_n^- and lambda_n+1^+ are the same (possibly up to a sign due to R(infty)), strictly speaking we cannot write the projected algorithm in terms of a composition of two steps as we did in \\eqref{eq:projection-composition-map}. Instead the whole algorithm has to be treated as one nonlinear map. The idea of the construction of the methods is still the same, though. Only the midpoint projection needs special treatment. There, the operator mathbbP_lambda is defined in a slightly more complicated way than in \\eqref{eq:projector}, using different arguments in the projection step, which does not quite fit the general framework outlined here.","category":"page"},{"location":"integrators/vprk/#sec:standard-projection","page":"VPRK","title":"Standard Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: Illustration of the standard projection method)","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Illustration of the standard projection method: The solution is projected to the constraint submanifold Delta after each step of the numerical integrator Psi_h.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The standard projection method [Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006), Section IV.4] is the simplest projection method. Starting from q_n, we use the continuous fibre derivative \\eqref{eq:fibre-derivative-general} to compute p_n = vartheta (q_n). Then we apply some symplectic one-step method Psi_h to z_n = (q_n p_n) to obtain an intermediate solution z_n+1,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"barz_n+1 = Psi_h (z_n) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"which is projected onto the constraint submanifold \\eqref{eq:constraint-submanifold} by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqorthogonal_projection\nz_n+1 = barz_n+1 + h  Omega^-1 nabla phi^T (z_n+1) lambda_n+1 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"enforcing the constraint","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"0 = phi (z_n+1) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"This projection method, combined with the variational integrator in position-momentum form \\eqref{eq:vi-position-momentum-form}, is not symmetric, and therefore not reversible. Moreover, it exhibits a drift of the energy, as has been observed before, e.g., for holonomic constraints [Ernst Hairer  (2000), Ernst Hairer  (2001), Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006)].","category":"page"},{"location":"integrators/vprk/#sec:symmetric-projection","page":"VPRK","title":"Symmetric Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: Symmetric Projection +) (Image: Symmetric Projection -)","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Illustration of the symmetric projection method: The solution is first perturbed off the constraint submanifold Delta, then one step of the numerical integrator Psi_h is performed, and the result is projected back onto Delta.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"To overcome the shortcomings of the standard projection, we consider a symmetric projection of the variational Runge-Kutta integrators following Ernst Hairer  (2000), Ernst Hairer  (2001) and Robert P. K. Chan , Philippe Chartier , Ander Murua  (2004), see also Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006), Section V.4.1. Here, one starts again by computing the momentum p_n as a function of the coordinates q_n according to the continuous fibre derivative, which can be expressed with the constraint function as","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymmetric-symplectic-projection\n0 = phi (z_n) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Then the initial value z_n is first perturbed,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymmetric-projection-pre\nbarz_n = z_n + h  Omega^-1 nabla phi^T (z_n)  lambda_n+12  \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"followed by the application of some one-step method Psi_h,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"barz_n+1 = Psi_h (barz_n) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and a projection of the result onto the constraint submanifold,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymmetric_projection_post\nz_n+1 = barz_n+1 + h  R(infty)  Omega^-1 nabla phi^T (z_n+1) lambda_n+12 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"which enforces the constraint","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"0 = phi (z_n+1) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Here, it is important to note that Lagrange multiplier lambda_n+12 is the same in both the perturbation and the projection step, and to account for the stability function R(infty) of the basic integrator, as mentioned before. The algorithm composed of the symmetric projection and some symmetric variational integrator in position-momentum form, constitutes a symmetric map","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Phi_h  q_n mapsto q_n+1 ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where, from a practical point of view, p_n, p_n+1 and lambda_n+12 are treated as intermediate variables. Unfortunately, the method is not symplectic but instead satisfies the relation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginmultlinelabeleqsymmetric-projection-symplecticity-condition\n   dfrac12 barOmega_ij (q_n)  big( ext q_n^i wedge ext q_n^j\n - h^2  ext lambda_n+12^i wedge ext lambda_n+12^j big)\n - h^2 lambda_n+12^k vartheta_kij (q_n)  ext q_n^i wedge ext lambda_n+12^j = \n = dfrac12 barOmega_ij (q_n+1)  big( ext q_n+1^i wedge ext q_n+1^j\n - h^2  ext lambda_n+12^i wedge ext lambda_n+12^j big)\n - h^2 lambda_n+12^k vartheta_kij (q_n+1)  ext q_n+1^i wedge ext lambda_n+12^j \nendmultline","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For certain systems, this method can even be shown to be symplectic. In general, though, it is not symplectic. Nevertheless, it tends to perform very well in long-time simulations.","category":"page"},{"location":"integrators/vprk/#sec:symplectic-projection","page":"VPRK","title":"Symplectic Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: )","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Illustration of the post projection method. Starting on the constraint submanifold Delta, the numerical integrator Psi_h moves the solution away from Delta in the first step. After each step, the solution is projected back onto Delta, but the perturbation at the beginning of each consecutive step is exactly the inverse of the previous projection, so that, practically speaking, the solution is projected back onto Delta only for output purposes.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the symplectic projection, we modify the perturbation \\eqref{eq:symmetric-projection-pre} to use the Lagrange multiplier at the previous time step, lambda_n, instead of lambda_n+1. As before, we assum the initial condition z_n satisfies the constraint,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic-projection-pre-constraint\n0 = phi (z_n) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The initial condition is perturbed, using the Lagrange multiplier lambda_n,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic-projection-pre\nbarz_n = z_n + h  Omega^-1 nabla phi^T (z_n)  lambda_n \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Then the usual one-step method Psi_h is applied,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"barz_n+1 = Psi_h (barz_n) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and the result is projected onto the constraint submanifold using the Lagrange multiplier lambda_n+1,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic-projection-post\nz_n+1 = barz_n+1 + h  R(infty)  Omega^-1 nabla phi^T (z_n+1) lambda_n+1 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"in order to enforce the constraint","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic-projection-post-constraint\n0 = phi (z_n+1) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The symplecticity condition \\eqref{eq:symmetric-projection-symplecticity-condition} is modified as follows,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginmultlinelabeleqsymplectic_projection_symplecticity_condition\n   dfrac12 barOmega_ij (q_n)  big( ext q_n^i wedge ext q_n^j\n - h^2  ext lambda_n^i wedge ext lambda_n^j big)\n - h^2 lambda_n^k vartheta_kij (q_n)  ext q_n^i wedge ext lambda_n^j = \n = dfrac12 barOmega_ij (q_n+1)  big( ext q_n+1^i wedge ext q_n+1^j\n - h^2  ext lambda_n+1^i wedge ext lambda_n+1^j big) \n - h^2 lambda_n+12^k vartheta_kij (q_n+1)  ext q_n+1^i wedge ext lambda_n+1^j \nendmultline","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"implying the conservation of a modified symplectic form omega_lambda defined on an extended phasespace mfM times mathbbR^d with coordinates (q lambda) by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic_projection_two_form\nomega_lambda\n = dfrac12 barOmega_ij (q)  ext q^i wedge ext q^j\n - dfrach^22 barOmega_ij (q)  ext lambda^i wedge ext lambda^j\n - h^2 lambda^k vartheta_kij (q)  ext q^i wedge ext lambda^j \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"with matrix representation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Omega_lambda =\nbeginpmatrix\nbarOmega  - h^2 lambda cdot vartheta_qq \nh^2 lambda cdot vartheta_qq  - h^2 barOmega \nendpmatrix ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"This corresponds to a modified one-form vartheta_lambda, such that omega_lambda = ext vartheta_lambda, given by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic_projection_one_form\nvartheta_lambda = ( vartheta_i (q) - h  lambda^k vartheta_ki (q) )  ( ext q^i - h  ext lambda^i )\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"As noted by Robert P. K. Chan , Philippe Chartier , Ander Murua  (2004), the modified perturbation \\eqref{eq:symplectic-projection-pre-constraint}-\\eqref{eq:symplectic-projection-pre} can be viewed as a change of variables from (q lambda) on mfM times mathbbR^d to (q p) on cbmfM, and the projection \\eqref{eq:symplectic-projection-post}-\\eqref{eq:symplectic-projection-post-constraint} as a change of variables back from (q p) to (q lambda). The symplectic form omega_lambda on mfM times mathbbR^d thus corresponds to the pullback of the canonical symplectic form omega on cbmfM by this variable transformation.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Let us note that the sign in in front of the projection in \\eqref{eq:symplectic-projection-post}, given by the stability function of the basic integrator, has very important implications on the nature of the algorithm. If it is the same as in \\eqref{eq:symplectic-projection-pre}, the character of the method is very similar to the symmetric projection method described before. If the sign is the opposite of the one in \\eqref{eq:symplectic-projection-pre}, like for Gauss-Legendre Runge-Kutta methods with an odd number of stages, the perturbation reverses the projection of the previous step, so that we effectively apply the post-projection method of Robert P. K. Chan , Philippe Chartier , Ander Murua  (2002). That is, the projected integrator Phi_h is conjugate to the unprojected integrator Psi_h by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Phi_h = mathbbP^-1 circ Psi_h circ mathbbP ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that the following diagram commutes","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: Commuting Diagram)","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and the projection is effectively only applied for the output of the solution, but the actual advancement of the solution in time happens outside of the constraint submanifold. In other words, applying n times the algorithm Phi_h to a point (q_0 0) is equivalent to applying the perturbation mathbbP^-1, then applying n times the algorithm Psi_h and projecting the result with mathbbP.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Potentially, this might degrade the performance of the algorithm. If the accumulated global error drives the solution too far away from the constraint submanifold, the projection step might not have a solution anymore. Interestingly, however, post-projected Gauss-Legendre Runge-Kutta methods retain their optimal order of 2s [Robert P. K. Chan , Philippe Chartier , Ander Murua  (2002)]. Moreover, for methods with an odd number of stages, the global error of the unprojected solution is mathcalO(h^s+1), compared to mathcalO(h^s) for methods with an even number of stages. In practice this seems to be at least part of the reason of the good long-time stability of these methods.","category":"page"},{"location":"integrators/vprk/#sec:midpoint-projection","page":"VPRK","title":"Midpoint Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For certain variational Runge-Kutta methods, we can also modify the symmetric projection in a different way in order to obtain a symplectic projection, namely by evaluating the projection at the midpoint","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nbarz_n+12 = (barq_n+12 barp_n+12)  \nbarq_n+12 = tfrac12 big( barq_n + barq_n+1 big)  \nbarp_n+12 = tfrac12 big( barp_n + barp_n+1 big) \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that the projection algorithm is modified as follows. As always, the initial condition is expected to satisfy the constraint,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqmidpoint_projection_pre_constraint\n0 = phi (z_n) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For the perturbation of the initial condition,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqmidpoint_projection_pre\nbarz_n = z_n + h  Omega^-1 nabla phi^T (barz_n+12)  lambda_n+12 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"the gradient of the constraint is evaluated at the midpoint barz_n+12. A one step method is applied,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"barz_n+1 = Psi_h (z_barz) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and the result is projected, again evaluating the gradient of phi at the midpoint barz_n+12,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqmidpoint_projection_post\nz_n+1 = barz_n+1 + h  R(infty)  Omega^-1 nabla phi^T (z_n+12) lambda_n+12 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"in order to force the solution to satisfy the constraint,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic_projection_midpoint_post_constraint\n0 = phi (z_n+1) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For certain systems, this method can be shown to be symplectic with respect to the original noncanonical symplectic form on mfM if the integrator Psi_h is a symmetric, symplectic Runge-Kutta method with an odd number of stages s, for which the central stage with index (s+1)2 corresponds to z_n+12. This is obviously the case for the implicit midpoint rule, that is the Gauss-Legendre Runge-Kutta method with s=1, but unfortunately not for higher-order Gauss-Legendre or for Gauss-Lobatto methods. However, following Walter Oevel , Mark Sofroniou  (1997) and Shan Zhao , Guo-Wei Wei  (2014), higher-order methods similar to Gauss-Legendre methods but satisfying the requested property can be obtained. See for example the method with three stages, implemented as TableauSRK3.","category":"page"},{"location":"integrators/vprk/#sec:internal-stage-projection","page":"VPRK","title":"Internal Stage Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"TODO","category":"page"},{"location":"integrators/variational/#variational-integrators","page":"Variational","title":"Variational Integrators","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The basic idea of variational integrators is to construct a discrete counterpart to a particular mechanical system instead of directly discretising its equations of motion. This means that the fundamental building blocks of classical mechanics, namely the action functional, the Lagrangian, the variational principle, and the Noether theorem, all have discrete equivalents. The application of the discrete variational principle to the discrete action then leads to discrete Euler-Lagrange equations. The evolution map that corresponds to the discrete Euler-Lagrange equations is what is called a variational integrator. The discrete Noether theorem can be used to relate symmetries of the discretised system to discrete momenta that are in principle exactly preserved by this integrator.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"With standard numerical methods, one approximately solves the exact equations of some system. In a sense, the idea of variational integrators is to exactly solve the equations of an approximate system.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The seminal work in the development of a discrete equivalent of classical mechanics was presented by [Alexander P. Veselov  (1988), Alexander P. Veselov  (1988)]. His method, based on a discrete variational principle, leads to symplectic integration schemes that automatically preserve constants of motion [Jeffrey M. Wendlandt , Jerrold E. Marsden  (1997), Jerrold E. Marsden , Jeffrey M. Wendlandt  (1997)]. A comprehensive review of discrete mechanics can be found in [Jerrold E. Marsden , Matthew West  (2001)], including a thorough account on the historical development. The discrete version of Hamilton's phasespace action principle is presented in [Melvin Leok , Jingjing Zhang  (2011)].","category":"page"},{"location":"integrators/variational/#Discretisation-of-the-Action","page":"Variational","title":"Discretisation of the Action","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The derivation of the discrete theory follows along the lines of the derivation of the continuous theory. The starting point is the discretisation of the space of paths mathcalQ ( mfM ) that connect two points in mfM,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ ( mfM ) = big q  mathcalI rightarrow mfM  bigvert  mathcalI subset mathbbR  textsmooth and bounded big ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Therefore we divide each time interval mathcalI into an equidistant, monotonic sequence  t_n _n=0^N and defined the discrete path space as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ_d ( mfM ) = big q_d   t_n _n=0^N rightarrow mfM big ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The space mathcalQ_d ( mfM ) contains all possible discrete trajectories q_d in mfM and is isomorphic to mfM times  times mfM (N+1 copies),","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ_d ( mfM ) cong bigtimes_N+1 mfM ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Therefore mathcalQ_d ( mfM ) constitutes a finite-dimensional approximation of the infinite-dimensional space mathcalQ ( mfM ). Note that mathcalQ_d is not a subspace of mathcalQ. Fixing an interval 0 T, so that","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":" t_n _n=0^N =  t_n = nh  vert  n = 0  N   Nh = T  subset mathbbR ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"is an increasing sequence of time points and h is the discrete time step, the discrete equivalent of the space of curves from q_0 to q_N,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ ( q_0 q_N 0 T ) = big q  0 T rightarrow mfM  bigvert  q(0) = q_0  q(T) = q_N big subset mathcalQ ( mfM ) ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"is the space that contains all discrete trajectories with fixed endpoints q_0 and q_N, defined as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ_d ( q_0 q_N  t_n _n=0^N ) = big q_d   t_n _n=0^N rightarrow mfM  bigvert  q(t_0) = q_0 q(t_N) = q_N big subset mathcalQ_d ( mfM ) ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete trajectory can be written as q_d =  q_n _n=0^N, where q_n denotes the generalised coordinates at time t_n. The space mathcalQ_d ( q_0 q_N  t_n _n=0^N ) is a finite-dimensional approximation of mathcalQ ( q_0 q_N 0 T ). In the following, we will use piecewise linear Lagrange polynomials to approximate the trajectory q(t), that is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-linear-interpolation\nq_h (t) bigvert_t_n t_n+1 = q_n dfract_n+1 - tt_n+1 - t_n + q_n+1 dfract - t_nt_n+1 - t_n \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The next step is to choose a quadrature rule which determines the discrete action. While the continuous action is a map","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalA  mathcalQ ( q_0 q_N 0 T ) rightarrow mathbbR ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"assigning real values to each path q(t), the discrete action is a map","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalA_d  mathcalQ_d ( q_0 q_N  t_n _n=0^N ) rightarrow mathbbR ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"assigning real values to each discrete path q_d. Once we obtained the discrete action, everything else follows in a straight forward and systematic way from Hamilton's principle of stationary action, so that these choices are determining the form of the discrete equations of motion.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"After we fix the sequence  t_n _n=0^N, the continuous action can be written as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalA q(t) = sum_n=0^N-1 int_t_n^t_n+1 L (q dotq)  dt ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The terms of the sum are called the \\emph{exact discrete Lagrangian},","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"L_d^mathrme (q_n q_n+1) = int_t_n^t_n+1 L big( q_nn+1 (t)  dotq_nn+1 (t) big)  dt ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which is defined as a function of two consecutive points on the discrete trajectory q_d =  q_n _n=0^N. Here, q_nn+1 (t) denotes the solution of the continuous Euler-Lagrange equations in the interval t_n t_n+1  satisfying the boundary conditions q_nn+1 (t_n) = q_n and q_nn+1 (t_n+1) = q_n+1, with q_n denoting the generalised coordinates at time t_n and dotq_n the generalised velocities at time point t_n. In practice, the exact discrete Lagrangian cannot be computed exactly, which means we have to approximate it,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"L_d (q_n q_n+1) approx int_t_n^t_n+1 L big( q_nn+1 (t)  dotq_nn+1 (t) big)  dt ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"That is, we have to approximate the trajectory q(t), the velocity dotq(t) and the integral. This approximation leads to the discrete Lagrangian, given as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-quadrature\nL_d (q_n q_n+1) = h sum limits_i=1^s b_i  L big( q_h (t_n + c_i h)  dotq_h (t_n + c_i h) big) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"where q_n = q_h (t_n) and q_n+1 = q_h (t_n+1). The discrete action thus becomes merely a sum over the time index of discrete Lagrangians","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-action\nmathcalA_d q_d = sum limits_n=0^N-1 L_d (q_n q_n+1) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which defines a map mathcalA_d  mathcalQ_d ( q_0 q_N  t_n _n=0^N ) rightarrow mathbbR. In order to obtain the discrete Lagrangian, the generalised velocities are often discretised by simple finite-difference expressions\\footnote{ In the first term of the trapezoidal rule \\eqref{eq:vi-trapezoidal}, this corresponds to a forward finite-difference, in the second term to a backward finite-difference, and in the midpoint rule \\eqref{eq:vi-midpoint} to a centred finite-difference. }, i.e.,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"dotq (t) approx dfracq_n+1 - q_nh\nhspace3em textfor hspace3em\nt in  t_n  t_n+1   ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"This corresponds to approximating the trajectory q(t) between t_n and t_n+1 by linear interpolation between q_n and q_n+1 like in \\eqref{eq:vi-linear-interpolation} and taking the derivative of q_h (t) with respect to t. The quadrature is most often realised by either the trapezoidal rule (c_1 = 0, c_2 = 1),","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-trapezoidal\nL_d^texttr (q_n q_n+1) = dfrach2  L bigg( q_n dfracq_n+1 - q_nh bigg) + dfrach2  L bigg( q_n+1 dfracq_n+1 - q_nh bigg) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"or the midpoint rule (c_1 = 12),","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-midpoint\nL_d^textmp (q_n q_n+1) = h  L bigg( dfracq_n + q_n+12 dfracq_n+1 - q_nh bigg) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The configuration manifold of the discrete theory is still mfM, but the discrete state space is mfM times mfM instead of tbmfM, such that the discrete Lagrangian L_d is a function","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-discrete_lagrangian\nL_d  mfM times mfM rightarrow mathbbR \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mapping two points on the discrete trajectory into the real numbers.","category":"page"},{"location":"integrators/variational/#Discrete-Euler-Lagrange-Equations","page":"Variational","title":"Discrete Euler-Lagrange Equations","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"(Image: Variations of the discrete trajectory)","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete trajectories q_d =  q_n _n=0^N are required to satisfy a discrete version of Hamilton's principle of stationary action","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"delta mathcalA_d q_d = delta sum limits_n=0^N-1 L_d (q_n q_n+1) = 0 ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"As each point q_n of the discrete trajectory takes continuous values, we consider variations as as one-parameter families of transformations, that is families of paths q_d^epsilon =  q_n^epsilon _n=0^N in mathcalQ_d ( q_0 q_N  t_n _n=0^N ) which contain the solution path q_d for epsilon=0. The variations of q_d are contained in the tangent space tbq_dmathcalQ_d ( q_0 q_N  t_n _n=0^N ) to mathcalQ_d ( q_0 q_N  t_n _n=0^N ) at q_d. It is defined as the set of maps","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\nv_q_d   t_n _n=0^N rightarrow tbmfM \n textsuch that \npi_mfM circ v_q_d = q_d \n textand \nv (t_0) = v (t_N) = 0 \nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"where pi_mfM is the canonical projection pi_mfM  tbmfM rightarrow mfM and local coordinates are given by","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"v_q_d =  (q_n v_n) _n=0^N ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"In particular, a discrete variation v_q_d of the discrete path q_d is defined as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"v_q_d = dfracddepsilon q_d^epsilon biggvert_epsilon=0 ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"By identifying delta equiv d  depsilon bigvert_epsilon=0, we can also denote the variation by v_q_d = delta q_d. In analogy to the continuous setting, the variation of the discrete action can be written as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"delta mathcalA_d q_d = \ndfracddepsilon mathcalA_d q_d^epsilon biggvert_epsilon=0\n= ext mathcalA_d q_d cdot v_q_d ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which explicitly computed becomes","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-variation_01\next mathcalA_d q_d cdot v_q_d = sum limits_n=0^N-1 big D_1  L_d (q_n q_n+1) cdot v_n + D_2  L_d (q_n q_n+1) cdot v_n+1 big \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"where D_i denotes the derivative with respect to to the ith argument (slot derivative). What follows corresponds to a discrete integration by parts, i.e., a reordering of the summation. The n=0 term is separated from the first part of the sum and the n=N-1 term is separated from the second part","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-variation_02\nbeginaligned\next mathcalA_d q_d cdot v_q_d\nnonumber\n = D_1  L_d (q_0 q_1) cdot v_0\n+ sum limits_n=1^N-1 D_1  L_d (q_n q_n+1) cdot v_n \n+ sum limits_n=0^N-2 D_2  L_d (q_n q_n+1) cdot v_n+1\n + D_2  L_d (q_N-1 q_N) cdot v_N\n\nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"As the variations at the endpoints are kept fixed, v_0 = v (t_0) = 0 as well as v_N = v (t_N) = 0, the corresponding terms vanish. At last, the summation range of the second sum is shifted upwards by one with the arguments of the discrete Lagrangian adapted correspondingly","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-variation_03\next mathcalA_d q_d cdot v_q_d\n=  sum limits_n=1^N-1 big D_1  L_d (q_n q_n+1) + D_2  L_d (q_n-1 q_n) big cdot v_n\n\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Hamilton's principle of least action requires the variation of the discrete action delta mathcalA_d to vanish for any choice of v_n. Consequently, the expression in the square brackets has to vanish. This defines the discrete Euler-Lagrange equations","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-deleqs\nD_1  L_d (q_n q_n+1) + D_2  L_d (q_n-1 q_n) = 0\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete Euler-Lagrange equations define an evolution map","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-evolution_map\nvarphi_h\n   mfM times mfM rightarrow mfM times mfM\n   ( q_n-1 q_n ) mapsto ( q_n q_n+1 ) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Starting from two configurations, q_0 approx q (t_0) and q_1 approx q (t_1 = t_0 + h), the successive solution of the discrete Euler-Lagrange equations for q_2, q_3, etc., up to q_N, determines the discrete trajectory  q_n _n=0^N.","category":"page"},{"location":"integrators/variational/#Discrete-Fibre-Derivative","page":"Variational","title":"Discrete Fibre Derivative","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Quite often it is more practical to prescribe an initial position and momentum instead of the configuration of the first two time steps. We therefore want to define the discrete momentum p_n at time step n. In the continuous setting this was done with the help of the fibre derivative. However, in the discrete setting, we have two ways to define discrete fibre derivatives,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathbbF^- L_d   mathbbF^+ L_d  mfM times mfM rightarrow cbmfM ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which map the discrete state space mfM times mfM to the tangent bundle cbmfM. They are given by","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\nmathbbF^- L_d  (q_n q_n+1) mapsto (q_n   p_n)   = big( q_n   - D_1 L_d (q_n q_n+1) big)  \nmathbbF^+ L_d  (q_n q_n+1) mapsto (q_n+1 p_n+1) = big( q_n+1   D_2 L_d (q_n q_n+1) big) \nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete Euler-Lagrange equations can now be rewritten as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathbbF^+ L_d (q_n-1 q_n) = mathbbF^- L_d (q_n q_n+1) ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"that is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-momentum\np_n = D_2 L_d (q_n-1 q_n) = - D_1 L_d (q_n q_n+1) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"TODO: Add composition maps of fibre derivatives and Lagrangian evolution map corresponding to the Hamiltonian evolution map.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Thus the discrete fibre derivatives permit a new interpretation of the discrete Euler–Lagrange equations. The variational integrator can be rewritten in position-momentum form,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-position-momentum\nbeginaligned\np_n   =           -  D_1 L_d (q_n q_n+1)  \np_n+1 = hphantom- D_2 L_d (q_n q_n+1) \nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Given (q_n p_n), the first equation can be solved for q_n+1. This is generally a nonlinearly implicit equation that has to be solved by some iterative technique like Newton's method. The second equation is an explicit function, so to obtain p_n+1 we merely have to plug in q_n and q_n+1. The corresponding Hamiltonian evolution map is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-evolution_map_position_momentum\ntildevarphi_h\n   cbmfM rightarrow cbmfM\n   ( q_n p_n ) mapsto ( q_n+1 p_n+1 ) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Thus, starting with an initial position q_0 and an initial momentum p_0, the repeated solution of tildevarphi_h gives the same discrete trajectory  q_n _n=0^N as the repeated solution of varphi_h. The position-momentum form, as a one-step method, is usually easier to implement than the discrete Euler-Lagrange equations. And for most problems, initial conditions are more naturally prescribed via the position and momentum of the particle at a given point in time, (q_0 p_0). If, however, only the position of the particle at two points in time, (q_0 q_1), is known, the Euler-Lagrange equations are the more natural way of describing the dynamics.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"This of course is just reflecting the difference in the Lagrangian and Hamiltonian point of view. For d degrees of freedom, the variational principle leads to d differential equations of second order. Hamilton's equations, on the other hand, are 2d differential equations of first order. Which form is more convenient to use largely depends on the problem at hand.","category":"page"},{"location":"integrators/variational/#Example:-Point-Particle","page":"Variational","title":"Example: Point Particle","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Consider a particle with mass m, moving in some potential V. Its continuous Lagrangian is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1_lagrangian\nL (q dotq) = dfrac12  m dotq^2 - V(q)\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Approximated by the trapezoidal rule, the discrete Lagrangian reads","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1-lagrangian-trapezoidal\nL_d^texttr (q_n q_n+1) = h  bigg dfracm2 bigg( dfracq_n+1 - q_nh bigg)^2 - dfracV (q_n) + V (q_n+1)2 bigg \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Applying the discrete Euler-Lagrange equations \\eqref{eq:vi-deleqs} to this expression results in discrete equations of motion","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1_deleqs_trapezoidal\nm  dfracq_n+1 - 2  q_n + q_n-1h^2 = - nabla V (q_n)\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which clearly are a discrete version of Newton's second law","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1-newton\nm ddotq = - nabla V = F \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"For comparison, consider also the midpoint approximation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1-lagrangian-midpoint\nL_d^textmp (q_n q_n+1) = h  bigg dfracm2  bigg( dfracq_n+1 - q_nh bigg)^2 - V bigg( dfracq_n + q_n+12 bigg) bigg\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which leads to","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1_deleqs_midpoint\nm  dfracq_n+1 - 2  q_n + q_n-1h^2 = - dfrac12  bigg nabla V bigg( dfracq_n-1 + q_n2 bigg) + nabla V bigg( dfracq_n + q_n+12 bigg) bigg\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"and thus a different discretisation of \\eqref{eq:vi-example1-newton}. The position-momentum form \\eqref{eq:vi-position-momentum} of the trapezoidal Lagrangian \\eqref{eq:vi-example1-lagrangian-trapezoidal} can be written as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\ndfracq_n+1 - q_nh =  dfrac1m  bigg p_n - dfrach2  nabla V (q_n) bigg \ndfracp_n+1 - p_nh = -  dfrac12  bigg nabla V (q_n) + nabla V (q_n+1) bigg\nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"and the one of the midpoint Lagrangian \\eqref{eq:vi-example1-lagrangian-midpoint} reads","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\ndfracq_n+1 - q_nh = dfrac1m  bigg p_n - dfrach2  nabla V bigg( dfracq_n + q_n+12 bigg) bigg \ndfracp_n+1 - p_nh = - nabla V bigg( dfracq_n + q_n+12 bigg) \nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"This bears a close resemblance of Hamilton's equations of motion, where the additional term in the first equations can be interpreted as extrapolating the momentum p_n to t_n+12. As already noted, it is not always so easy to solve the first equation in \\eqref{eq:vi-position-momentum} for q_n+1. In general this is an implicit equation.","category":"page"},{"location":"integrators/variational/#Discrete-Symplectic-Form","page":"Variational","title":"Discrete Symplectic Form","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"As in the continuous case, the discrete one-form is obtained by computing the variation of the action for varying endpoints","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\next mathcalA_d q_d cdot v_d\nnonumber\n= sum limits_n=0^N-1 big D_1  L_d (q_n q_n+1) cdot v_n + D_2  L_d (q_n q_n+1) cdot v_n+1 big \nnonumber\n= sum limits_n=1^N-1 big D_1  L_d (q_n q_n+1) + D_2  L_d (q_n-1 q_n) big cdot v_n \nhspace3em\n+ D_1  L_d (q_0 q_1) cdot v_0 + D_2  L_d (q_N-1 q_N) cdot v_N \nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The two latter terms originate from the variation at the boundaries. They form the discrete counterpart of the Lagrangian one-form. However, there are two boundary terms that define two distinct one-forms on mfM times mfM,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\nbeginarrayll\nTheta_L_d^- ( q_0   q_1 ) cdot ( v_0    v_1 ) equiv           -  D_1 L_d (q_0   q_1) cdot v_0  \nTheta_L_d^+ ( q_N-1 q_N ) cdot ( v_N-1  v_N ) equiv hphantom- D_2 L_d (q_N-1 q_N) cdot v_N \nendarray\nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"In general, these one-forms are defined as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-discrete-one-form\nbeginaligned\nTheta_L_d^- ( q_n  q_n+1 ) equiv           -  D_1 L_d (q_n q_n+1)  ext q_n  \nTheta_L_d^+ ( q_n  q_n+1 ) equiv hphantom- D_2 L_d (q_n q_n+1)  ext q_n+1 \nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"As ext L_d = Theta_L_d^+ - Theta_L_d^- and ext^2 L_d = 0 one observes that","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"ext Theta_L_d^+ = ext Theta_L_d^-","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"such that the exterior derivative of both discrete one-forms defines the same \\emph{discrete Lagrangian two-form} or \\emph{discrete symplectic form}","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-discrete_two_form\nbeginaligned\nomega_L_d\n= ext Theta_L_d^+\n = ext Theta_L_d^-\n = dfracpartial^2 L_d (q_n q_n+1)partial q_n   partial q_n+1  ext q_n wedge ext q_n+1 \n text(no summation over n) \nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Consider the exterior derivative of the discrete action \\eqref{eq:vi-action}. Upon insertion of the discrete Euler-Lagrange equations \\eqref{eq:vi-deleqs} it becomes","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-symplectic-ext-action\next mathcalA_d\n= D_1 L_d (q_0 q_1) cdot ext q_0 + D_2 L_d (q_N-1 q_N) cdot ext q_N\n= Theta_L_d^+ (q_N-1 q_N) - Theta_L_d^- (q_0 q_1) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"On the right hand side we find the just defined Lagrangian one-forms \\eqref{eq:vi-discrete-one-form}. Taking the exterior derivative of \\eqref{eq:vi-symplectic-ext-action} gives","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-symplectic-preservation\nomega_L_d (q_0 q_1) = omega_L_d (q_N-1 q_N) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"where q_N-1 and q_N are connected with q_0 and q_1 through the discrete Euler-Lagrange equations \\eqref{eq:vi-deleqs}. Therefore, \\eqref{eq:vi-symplectic-preservation} implies that the discrete symplectic structure omega_L_d is preserved while the system advances from t=0 to t=Nh according to the discrete equations of motion \\eqref{eq:vi-deleqs}. As the number of time steps N is arbitrary, the discrete symplectic form omega_L_d is preserved at all times of the simulation. Note that this does not automatically imply that the continuous symplectic structure omega_L is preserved under the discrete map varphi_h.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"TODO: show preservation of the canonical symplectic form by the position-momentum-form","category":"page"},{"location":"integrators/variational/#Discrete-Noether-Theorem","page":"Variational","title":"Discrete Noether Theorem","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete Noether theorem, just as the continuous Noether theorem, draws the connection between symmetries of a discrete Lagrangian and quantities that are conserved by the discrete Euler-Lagrange equations or, equivalently, the discrete Lagrangian flow. The continuous theory translates straight forwardly to the discrete case. Therefore, we repeat just the important steps, translated to the discrete setting.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Consider a one parameter group of discrete curves q_d^epsilon =  q_n^epsilon _n=0^N with q_n^epsilon = sigma^epsilon (t_n q_n epsilon) such that q_n^0 (q_n) = q_n, i.e., sigma^0 = id (note that sigma^epsilon is the same function as in the continuous case). The discrete Lagrangian L_d has a symmetry if it is invariant under this transformation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_1\nbeginaligned\nL_d big( q_n^epsilon q_n+1^epsilon big) = L_d big( q_n q_n+1 big) \n textfor all epsilon and n \nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The generating vector field of such a symmetry transformation is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_2\nX_n = dfracpartial sigma^epsilonpartial epsilon biggvert_epsilon = 0\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"such that","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-noether-finite-3\ndfracdd epsilon L_d big( q_n^epsilon q_n+1^epsilon big) biggvert_epsilon = 0\n = D_1 L_d big( q_n q_n+1 big) cdot X_n  \n + D_2 L_d big( q_n q_n+1 big) cdot X_n+1 \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"If  q_n _n=0^N solves the discrete Euler-Lagrange equations \\eqref{eq:vi-deleqs},","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_4\nD_1  L_d (q_n q_n+1) + D_2  L_d (q_n-1 q_n) = 0 \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"we can replace the first term on the right hand side of \\eqref{eq:vi-noether-finite-3} to get","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_5\n0 = - D_2 L_d big( q_n-1 q_n big) cdot X_n\n    + D_2 L_d big( q_n q_n+1 big) cdot X_n+1 \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"This amounts to a discrete conservation law of the form","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_6\nD_2 L_d big( q_n-1 q_n big) cdot X_n = D_2 L_d big( q_n q_n+1 big) cdot X_n+1 \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"It states that solutions  q_n _n=0^N of the discrete Euler-Lagrange equations preserve the components of the momentum p_n = D_2 L_d big( q_n-1 q_n big) in direction X_n.","category":"page"},{"location":"tableaus/rungekutta_partitioned/#Partitioned-Runge-Kutta-Tableaus","page":"Partitioned Runge-Kutta Methods","title":"Partitioned Runge-Kutta Tableaus","text":"","category":"section"},{"location":"tableaus/rungekutta_partitioned/","page":"Partitioned Runge-Kutta Methods","title":"Partitioned Runge-Kutta Methods","text":"Modules = [RungeKutta.PartitionedTableaus]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"tableaus/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.PartitionedTableauGauss-Tuple{Int64}","page":"Partitioned Runge-Kutta Methods","title":"RungeKutta.PartitionedTableaus.PartitionedTableauGauss","text":"Partitioned Gauss-Legendre Runge-Kutta tableau with s stages\n\nPartitionedTableauGauss(::Type{T}, s)\nPartitionedTableauGauss(s) = PartitionedTableauGauss(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis partitioned tableau uses TableauGauss for both coefficients a and ā.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIB-Tuple{Any}","page":"Partitioned Runge-Kutta Methods","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIB","text":"Partitioned Gauss-Lobatto IIIA-IIIB tableau with s stages\n\nTableauLobattoIIIAIIIB(::Type{T}, s)\nTableauLobattoIIIAIIIB(s) = TableauLobattoIIIAIIIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis partitioned tableau uses TableauLobattoIIIA for a and TableauLobattoIIIB for ā.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIA-Tuple{Any}","page":"Partitioned Runge-Kutta Methods","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages\n\nTableauLobattoIIIBIIIA(::Type{T}, s)\nTableauLobattoIIIBIIIA(s) = TableauLobattoIIIBIIIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis partitioned tableau uses TableauLobattoIIIB for a and TableauLobattoIIIA for ā.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIICIIIC̄-Tuple{Any}","page":"Partitioned Runge-Kutta Methods","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIICIIIC̄","text":"Tableau for Gauss-Lobatto IIIC-IIIC̄ method with s stages\n\nTableauLobattoIIICIIIC̄(::Type{T}, s)\nTableauLobattoIIICIIIC̄(s) = TableauLobattoIIICIIIC̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis partitioned tableau uses TableauLobattoIIIC for a and TableauLobattoIIIC̄ for ā.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIC̄IIIC-Tuple{Any}","page":"Partitioned Runge-Kutta Methods","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIC̄IIIC","text":"Tableau for Gauss-Lobatto IIIC̄-IIIC method with s stages\n\nTableauLobattoIIIC̄IIIC(::Type{T}, s)\nTableauLobattoIIIC̄IIIC(s) = TableauLobattoIIIC̄IIIC(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis partitioned tableau uses TableauLobattoIIIC̄ for a and TableauLobattoIIIC for ā.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#SPARK-Tableaus","page":"SPARK Methods","title":"SPARK Tableaus","text":"","category":"section"},{"location":"tableaus/spark/","page":"SPARK Methods","title":"SPARK Methods","text":"Modules = [GeometricIntegrators.Tableaus]\nPages   = [\"tableaus/coefficients_glrk.jl\",\n           \"tableaus/coefficients_lob.jl\",\n           \"tableaus/tableaus_hpark.jl\",\n           \"tableaus/tableaus_hspark_primary.jl\",\n           \"tableaus/tableaus_hspark_secondary.jl\",\n           \"tableaus/tableaus_slrk.jl\",\n           \"tableaus/tableaus_spark.jl\",\n           \"tableaus/tableaus_vpark.jl\",\n           \"tableaus/tableaus_vspark_primary.jl\",\n           \"tableaus/tableaus_vspark_secondary.jl\"]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.get_lobatto_glrk_coefficients","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.get_lobatto_glrk_coefficients","text":"The projective Lobatto-GLRK coefficients are implicitly given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracbarc_i^kk  qquad i = 1      sigma   k = 1      s \n\nwhere c are Gauß-Legendre nodes with s stages and barc are Gauß-Lobatto nodes with sigma stages.\n\n\n\n\n\n","category":"function"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauHPARKGLRK-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauHPARKGLRK","text":"Tableau for Gauss-Legendre HPARK method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauHPARKLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauHPARKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Lobatto IIIA-IIIB HPARK method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauHPARKLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauHPARKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Lobatto IIIB-IIIA  method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauHSPARKGLRKpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauHSPARKGLRKpSymmetric","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauHSPARKLobattoIIIAIIIBpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauHSPARKLobattoIIIAIIIBpSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauHSPARKLobattoIIIBIIIApSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauHSPARKLobattoIIIBIIIApSymmetric","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKGLRK-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKGLRK","text":"SPARK tableau for Gauss-Legendre Runge-Kutta method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKGLRKLobattoIIIAIIIB","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKGLRKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Legendre/Gauss-Lobatto-IIIA-IIIB methods.\n\n\n\n\n\n","category":"function"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKGLRKLobattoIIIBIIIA","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKGLRKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Legendre/Gauss-Lobatto-IIIB-IIIA methods.\n\n\n\n\n\n","category":"function"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKGLVPRK-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKGLVPRK","text":"Tableau for Variational Gauss-Legendre method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKLobABC-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKLobABC","text":"Tableau for Gauss-Lobatto IIIA-IIIB-IIIC method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKLobABD-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKLobABD","text":"Tableau for Gauss-Lobatto IIIA-IIIB-IIID method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKLobatto-Tuple{Any,Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKLobatto","text":"SPARK tableau for Gauss-Lobatto methods.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Lobatto IIIA-IIIB method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Lobatto IIIB-IIIA method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauSPARKVPRK-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauSPARKVPRK","text":"SPARK Tableau for Variational Partitioned Runge-Kutta Methods.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauGausspSymplectic-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauGausspSymplectic","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauLobattoIIIAIIIBpSymplectic-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIAIIIBpSymplectic","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauLobattoIIIBIIIApSymplectic-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIBIIIApSymplectic","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpInternal-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpInternal","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpLobattoIIIAIIIB","text":"Tableau for Gauss-Legendre method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpLobattoIIIBIIIA","text":"Tableau for Gauss-Legendre method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpMidpoint","text":"Tableau for Gauss-Legendre method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedInternal-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedInternal","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedMidpoint","text":"Tableau for Gauss-Legendre method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpSymmetric","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKInternalProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKInternalProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. Use the same tableaus for tildea^1 and tildea^3, so that tildes = s, as well as\n\nbeginaligned\nbeginarrayccc\n tfrac12 b^1 \n vdots \n tfrac12 b^1 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \n vdots \n tfrac12 b^3 \nhline\na^4  \nendarray\n\nbeginarrayccc\n tfrac12 b^1 \nc^1  vdots \n tfrac12 b^1 \nhline\ntildea^2  tfrac12 (1 + R(infty))  b^1 \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \nc^3  vdots \n tfrac12 b^3 \nhline\ntildea^4  tfrac12 (1 + R(infty))  b^3 \nendarray\nendaligned\n\nSet omega = 0  0 1 and\n\ndelta_ij = begincases\n+1  j = i  \n-1  j = tildes  \n 0  textelse \nendcases\n\nso that Lambda_1 = Lambda_2 =  = Lambda_tildes.\n\nThis methods is constructed to satisfy the constraint on the projective stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes. Note, however, that it violates the symplecticity conditions b^1_i b^4_j = b^1_i a^4_ij + b^4_j tildea^1_ji and b^2_i b^3_j = b^2_i tildea^3_ij + b^3_j a^2_ji.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^4 b^4) and (tildea^2 b^2), respectively, and choose tildea^1 and tildea^3 such that the projective stages correspond to the initial condition and the solution, i.e.,\n\nbeginaligned\nbeginarrayccc\n0  0 \n1  b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\n0  tfrac12  0 \n1  tfrac12  0 \nhline\ntildea^2  \nendarray\n\nbeginarrayccc\n0  0 \n1  b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\n0  0  0 \n1  tfrac12  tfrac12 \nhline\ntildea^4  \nendarray\nendaligned\n\nand compute a^2 and a^4 by the symplecticity conditions, that is a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i and a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i. Finally choose omega = 0 0 1 and delta = -1 R_infty, implying that rho = 1. By construction, this method satisfies all symplecticity conditions, but the constraint on the projection stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, is not satisfied exactly, but only approximately, although with bounded error.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpMidpoint","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedMidpoint","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIAProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIAProjection","text":"This methods is the same as TableauVSPARKLobattoIIIAIIIBProjection, except for using Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^2 b^2), and (tildea^4 b^4) respectively, instead of the other way around.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApMidpoint","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedMidpoint","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApSymmetric","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKMidpointProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKMidpointProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 1 and rho = 0, such that tildeQ_n1 = tfrac12 ( q_n + q_n+1), tildeP_n1 = tfrac12 ( p_n + p_n+1), i.e.,\n\nbeginaligned\nbeginarrayccc\n tfrac12 \n vdots \n tfrac12 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 \n vdots \n tfrac12 \nhline\na^4  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^2  tfrac12 (1 + R(infty))\nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^4  tfrac12 (1 + R(infty))\nendarray\nendaligned\n\nThe coefficients tildea^1 and tildea^3 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i, and omega = 0 1.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKModifiedInternalProjection","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKModifiedInternalProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s, and set\n\nbeginaligned\nbeginarrayccc\n tfrac12 b^1 \n vdots \n tfrac12 b^1 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 b^4 \n vdots \n tfrac12 b^4 \nhline\na^4  \nendarray\n\nbeginarrayccc\n tfrac12 b^1 \nc^1  vdots \n tfrac12 b^1 \nhline\ntildea^2  tfrac12 (1 + R(infty))  b^1 \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \nc^3  vdots \n tfrac12 b^3 \nhline\ntildea^4  tfrac12 (1 + R(infty))  b^3 \nendarray\nendaligned\n\nNote that by this definition tildes = s. The coefficients tildea^1 and tildea^3 are determined by the (modified) symplecticity conditions, specifically a^4_ij = b^3_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^1_j ( b^3_i - tildea^3_ji )  b^3_i, where b^2 has been replaced with b^1 and b^4 with b^3, respectively. Set omega = 0  0 1 and\n\ndelta_ij = begincases\n+1  j = i  \n-1  j = tildes  \n 0  textelse \nendcases\n\nso that Lambda_1 = Lambda_2 =  = Lambda_tildes.\n\nNote that this method satisfies the symplecticity conditions b^1_i b^4_j = b^1_i a^4_ij + b^4_j tildea^1_ji and b^2_i b^3_j = b^2_i tildea^3_ij + b^3_j a^2_ji only if R(infty) = 1 due to the definitions of b^2 and b^4. Moreover, it does usually not satisfy the constraint on the projective stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, exactly, but only approximately with bounded error, thus implying a residual in the symplecticity equation even if R(infty) = 1.\n\n\n\n\n\n","category":"function"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKModifiedLobattoIIIAIIIBProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKModifiedLobattoIIIAIIIBProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^4 b^4) and (tildea^2 b^2), respectively.\n\nThe coefficients tildea^1 and tildea^3 are determined by the relations\n\nbeginaligned\nsum limits_j=1^s tildea^1_ij (c_j^1)^k-1 = frac(c_i^2)^kk  qquad \nsum limits_j=1^s tildea^3_ij (c_j^3)^k-1 = frac(c_i^4)^kk  qquad \ni = 1      tildes  qquad \nk = 1      s \nendaligned\n\nThe coefficients a^2 and a^4 by the symplecticity conditions, that is a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i and a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i. Finally choose omega = 0 0 1 and delta = -1 R_infty, implying that rho = 1. By construction, this method satisfies all symplecticity conditions, but the constraint on the projection stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, is not satisfied exactly, but only approximately, although with bounded error.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKModifiedLobattoIIIBIIIAProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKModifiedLobattoIIIBIIIAProjection","text":"This methods is the same as TableauVSPARKModifiedLobattoIIIAIIIBProjection, except for using Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^2 b^2), and (tildea^4 b^4) respectively, instead of the other way around.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKModifiedMidpointProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKModifiedMidpointProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 1 and rho = 0, such that tildeQ_n1 = tfrac12 ( q_n + q_n+1), tildeP_n1 = tfrac12 ( p_n + p_n+1), i.e.,\n\nbeginaligned\nbeginarrayccc\ntfrac12  tfrac12 b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^2  tfrac12 ( 1 + R (infty) ) \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^4  tfrac12 ( 1 + R (infty) ) \nendarray\nendaligned\n\nThe coefficients a^2 and a^4 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i, and omega = 0 1.\n\n\n\n\n\n","category":"method"},{"location":"tableaus/spark/#GeometricIntegrators.Tableaus.TableauVSPARKSymmetricProjection-Union{Tuple{T}, Tuple{Any,Tableau{T},Tableau{T}}, Tuple{Any,Tableau{T},Tableau{T},Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.Tableaus.TableauVSPARKSymmetricProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 2 and rho = 1, such that tildeQ_n1 = q_n, tildeQ_n2 = q_n+1, tildeP_n1 = p_n, tildeP_n2 = p_n+1, i.e.,\n\nbeginaligned\nbeginarrayccc\n0  0 \n1  b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\n 0  0 \n tfrac12  tfrac12 \nhline\ntildea^2  tfrac12  tfrac12 \nendarray\n\nbeginarrayccc\n0  0 \n1  b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\n 0  0 \n tfrac12  tfrac12 \nhline\ntildea^4  tfrac12  tfrac12 \nendarray\nendaligned\n\nThe coefficients a^2 and a^4 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i. Further choose omega = 1 1 0 and delta = -1 R_infty, so that tildeLambda_n1 = R_infty tildeLambda_n2 and\n\ntildeP_n1 - vartheta (tildeQ_n1) + R_infty ( tildeP_n2 - vartheta (tildeQ_n2) ) = 0 \n\nDue to the particular choice of projective stages, this is equivalent to\n\np_n - vartheta (q_n) + R_infty ( p_n+1 - vartheta (q_n+1) ) = 0 \n\nso that the constraint phi(q_n+1 p_n+1) = 0 is satisfied if phi(q_n p_n) = 0. Note that the choice of tildea^2 and tildea^4 violates the symplecticity condition b^2_i b^4_j = b^2_i tildea^4_ij + b^4_j tildea^2_ji.\n\n\n\n\n\n","category":"method"},{"location":"integrators/splitting/#Splitting-and-Composition-Methods","page":"Splitting","title":"Splitting and Composition Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"GeometricIntegrators supports splitting and composition methods, where the solution to an ODE of the form","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"dotx = v_1 (tx) +  + v_r (tx)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"is obtained by consecutively integrating each vector field v_i independently and combining the resulting solutions in an appropriate way. Consider a simple ODE dotx = V where the vector field v can be written as V = sum_i v_i. The flow (exact solution) of this ODE is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"x(t) = phi_t (x(0)) = exp(t V) (x(0)) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and the composition method ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = exp(tau v_1) exp(tau v_2) dotsc exp(tau v_r) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where tau denotes the time step, provides a first-order accurate approximation to the exact flow as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"phi_tau = exp bigg( tau sum_i v_i bigg) + mathcalO (tau^2) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the following, we use \"splitting methods\" to denote integrators that utilize the exact solution of each vector field v_i and \"composition methods\" to denote integrators that utilize some consistent but possibly approximate solution for each of the vector fields v_i, i.e., that solution can be exact or obtained by some other integrator. For reference see the excellent review paper by Robert I. McLachlan , G. Reinout W. Quispel  (2002) or the canonical book on Geometric Numerical Integration by Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006).","category":"page"},{"location":"integrators/splitting/#Splitting-Integrators","page":"Splitting","title":"Splitting Integrators","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In GeometricIntegrators, basic splitting methods are implemented in IntegratorSplitting, which has two constructors:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"IntegratorSplitting{DT,D}(solutions::Tuple, f::Vector{Int}, c::Vector, Δt)\nIntegratorSplitting(equation::SODE, tableau::AbstractTableauSplitting, Δt)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the first constructor, DT is the data type of the state vector and D the dimension of the system. In the second constructor, this information is extracted from the equation.  The tuple solutions contains functions implementing the flow (exact solution) of the vector fields v_i. The vectors f and c define the actual splitting method: f is a vector of indices of the flows in the split equation to be solved and c is a vector of the same size f that contains the coefficients for each splitting step, i.e., the resulting integrator has the form","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_cs tau^v_fs circ dotsc circ phi_c2 tau^v_f2 circ phi_c1 tau^v_f1 ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the second constructor, these vectors are constructed from the tableau and the equation.","category":"page"},{"location":"integrators/splitting/#Composition-Integrators","page":"Splitting","title":"Composition Integrators","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Fully flexible composition methods are implemented in IntegratorComposition, which can use any ODE integrator implemented in GeometricIntegrators to solve the steps of the splitting. For each step, a different integrator can be chosen as well as the exact solution using IntegratorExactODE, which is a simple wrapper around the exact flow of a splitting step, implementing the general integrator interface.","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"IntegratorComposition has three constructors:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"IntegratorComposition{DT,D}(integrators::Tuple, Δt)\nIntegratorComposition(equation::SODE, constructors::Tuple, tableau::AbstractTableauSplitting, Δt)\nIntegratorComposition(equation::SODE, tableau::AbstractTableauSplitting, Δt)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the first constructor, DT is the data type of the state vector and D the dimension of the system. In the second and third constructor, this information is extracted from the equation.  The tuple integrators contains the integrators for each substep. Each integrator is instantiated with appropriately scaled time step size Delta t = c_i tau to match the corresponding splitting scheme. In the second constructor, the tuple constructors contains closures around the constructors for the integrators of each step of the composition, that is functions taking a vector field v_i, the time step Delta t and optional keyword arguments, e.g. for the exact solution or a Runge-Kutta integrator, we have","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"(v::Function, Δt::Number; kwargs...) -> IntegratorExactODE{DT,D}(v, Δt; kwargs...)\n(v::Function, Δt::Number; kwargs...) -> Integrator{DT,D}(v, tableau, Δt; kwargs...)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The integrators are constructed according to the tableau and time step \\Delta t and passed to the first constructor. The third constructor assumes that the exact solution is used for each splitting step. It thus constructs a composition method that is equivalent to a plain IntegratorSplitting.","category":"page"},{"location":"integrators/splitting/#Splitting-of-Hamiltonian-Systems","page":"Splitting","title":"Splitting of Hamiltonian Systems","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"For Hamiltonian systems, splitting is a simple and versatile technique for the construction of symplectic integrators. Suppose that the Hamiltonian H can be split into the sum of r geq 2 Hamiltonians H_i with 1 leq i leq r, i.e.,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"H (z) = sum limits_i=1^r H_i (z) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"with each Hamiltonian vector field","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"dotz = Omega^-T  nabla H_i (z) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"explicitly solvable. The exact solution phi_t^H_i of each subsystem provides a symplectic map. As the composition of symplectic maps yields a symplectic map, a symplectic integrator can be obtained by an appropriate composition of the flow maps of each subsystem. A first-order symplectic integrator is obtained from the Lie-Trotter splitting,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_tau^H_1 circ phi_tau^H_2 circ dotsc circ phi_tau^H_k ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Second-order symplectic integrators are obtained from symmetric splittings,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_h2^H_1 circ phi_h2^H_2 circ dotsc circ phi_h2^H_k-1 circ phi_tau^H_k circ phi_h2^H_k-1 circ dotsc circ phi_h2^H_2 circ phi_h2^H_1 ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"or","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_h2^H_k circ phi_h2^H_k-1 circ dotsc circ phi_h2^H_2 circ phi_tau^H_1 circ phi_h2^H_2 circ dotsc circ phi_h2^H_k-1 circ phi_h2^H_k ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Higher order integrators can be constructed by using the Baker-Campbell-Hausdorff formula.","category":"page"},{"location":"integrators/splitting/#Separable-Hamiltonian-Systems","page":"Splitting","title":"Separable Hamiltonian Systems","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"If we have a Hamiltonian of the form H(pq) = T(p) + U(q), we can consider only the subsystem with Hamiltonian U(q),","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ndotq = 0  \ndotp = - nabla U(q) \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"This system can be solved exactly. The exact flow is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"phi^U_t (qp) = beginpmatrix\nq \np - t nabla U(q)\nendpmatrix ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Next, consider the subsystem with Hamiltonian T(p) = tfrac12 p^T M^-1 p, ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ndotq = M^-1 p  \ndotp = 0  \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"This system can be solved exactly as well. The exact flow is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"phi^T_t (qp) = beginpmatrix\nq + t M^-1 p \np\nendpmatrix ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"As phi^U_t and phi^T_t are exact flows of the respective Hamiltonian, they are both symplectic. We see that the compositions of phi^U_t and phi^T_t correspond to the symplectic Euler methods for separable Hamiltonians,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi^A_tau = phi^U_tau circ phi^T_tau  \nvarphi^B_tau = phi^T_tau circ phi^U_tau \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where varphi^A_tau and varphi^B_tau denote the numerical flows of symplectic Euler-A and symplectic Euler-B, respectively. As the Störmer-Verlet methods are compositions of the symplectic Euler methods, they are also splitting methods, corresponding to the compositions","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau^SV1 = varphi^A_h2 circ varphi^B_h2 = phi^U_h2 circ phi^T_tau circ phi^U_h2  \nvarphi_tau^SV2 = varphi^B_h2 circ varphi^A_h2 = phi^T_h2 circ phi^U_tau circ phi^T_h2 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"respectively. This particular splitting is often referred to as Strang splitting [Gilbert Strang  (1968), see also Gurij Ivanovich Marchuk  (1968)].","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Let us note that not all symplectic integrators can be obtained as splitting methods. For the symplectic Euler methods and the Störmer-Verlet methods, this is only possible for separable Hamiltonian systems. For general Hamiltonians, these methods cannot be obtained from any splitting but are nevertheless symplectic.","category":"page"},{"location":"integrators/splitting/#Fourth-Order-Methods","page":"Splitting","title":"Fourth Order Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The general form of a fourth order symplectic integrator for separable Hamiltonian systems is given by","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nq_1 = q_0 + b_1 tau  T_p (p_0)  \np_1 = p_0 - hatb_1 tau  U_q (q_1)  \nq_2 = q_1 + b_2 tau  T_p (p_1)  \np_2 = p_1 - hatb_2 tau  U_q (q_2)  \nq_3 = q_2 + b_3 tau  T_p (p_2)  \np_3 = p_2 - hatb_3 tau  U_q (q_3)  \nq_4 = q_3 + b_4 tau  T_p (p_3)  \np_4 = p_3 - hatb_4 tau  U_q (q_4) \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The quantities (q_0 p_0) are initial values and (q_4 p_4) are the numerical solution after one time step tau. The whole algorithm can be written as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau = \nvarphi_hatb_4 tau^U\ncirc\nvarphi_b_4 tau^T\ncirc\nvarphi_hatb_3 tau^U\ncirc\nvarphi_b_3 tau^T\ncirc\nvarphi_hatb_2 tau^U\ncirc\nvarphi_b_2 tau^T\ncirc\nvarphi_hatb_1 tau^U\ncirc\nvarphi_b_1 tau^T\nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and is therefore immediately seen to be symplectic. Two methods of fourth order are given by","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nb_1 = b_4 = dfrac12 (2 - gamma)  \nb_2 = b_3 = dfrac1-gamma2 (2 - gamma)  \nhatb_1 = hatb_3 = dfrac12 - gamma  \nhatb_2 = - dfracgamma2 - gamma  \nhatb_4 = 0 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nb_1 = 0  \nb_2 = b_4 = dfrac12 - gamma  \nb_3 = dfrac11 - gamma^2  \nhatb_1 = hatb_4 = tfrac16 (2 + gamma + gamma^-1)  \nhatb_2 = hatb_3 = tfrac16 (2 - gamma - gamma^-1) \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where gamma = 2^13. Both methods are explicit and symmetric as either varphi_hatb_4 tau^U or varphi_b_1 tau^T corresponds to the identity.","category":"page"},{"location":"integrators/splitting/#Higher-Order-Methods-by-Composition","page":"Splitting","title":"Higher Order Methods by Composition","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The composition of a one-step symplectic integrator varphi_tau with different step sizes provides a simple way of obtaining higher order schemes. We assume that the initial scheme varphi_tau is symmetric, that is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau circ varphi_-tau = mathrmid ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"as this simplifies the construction. A symmetric method can always be built by combining a non-symmetric method with its adjoint. If a numerical method varphi_tau is symmetric, it can be used to compose higher order methods by splitting up each timestep into s substeps [Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006), Robert I. McLachlan  (1995), Jerrold E. Marsden , Matthew West  (2001)],","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = varphi_gamma_s tau circ  circ varphi_gamma_i tau circ  circ varphi_gamma_1 tau ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where the careful selection of the gamma_i is crucial for the performance of the resulting scheme. In the following, we present some fourth and sixth order composition methods that can be applied in most situations.","category":"page"},{"location":"integrators/splitting/#Fourth-Order-Composition-Methods","page":"Splitting","title":"Fourth Order Composition Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"If varphi_tau is a method of order r, a method hatvarphi_tau of order r+2 is obtained by the composition [Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006), Section V.3.2]","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nhatvarphi_tau = varphi_gamma tau circ varphi_(1-2gamma) tau circ varphi_gamma tau \n textwith \ngamma = (2 - 2^1(r+1))^-1  \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Hence, if varphi_tau is of second order, the resulting method hatvarphi_tau will be of fourth order. Note that symmetric methods are always of even order. A method of the same order but with generally smaller errors is obtained by considering five steps","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nhatvarphi_tau = varphi_gamma tau circ varphi_gamma tau circ varphi_(1-4gamma) tau circ varphi_gamma tau circ varphi_gamma tau \n textwith \ngamma = (4 - 4^1(r+1))^-1  \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Multiple application of these compositions yields methods of orders higher than four.","category":"page"},{"location":"integrators/splitting/#Sixth-Order-Composition-Methods","page":"Splitting","title":"Sixth Order Composition Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Higher order compositions can also be constructed directly [Ernst Hairer , Christian Lubich , Gerhard Wanner  (2006), Section V.3.2]. A sixth order method with seven substeps is given by","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ngamma_1 = gamma_7 = + 078451361047755726381949763  \ngamma_2 = gamma_6 = + 023557321335935813368479318  \ngamma_3 = gamma_5 = - 117767998417887100694641568  \ngamma_4 = + 131518632068391121888424973 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"but again smaller errors can be achieved by using nine steps","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ngamma_1 = gamma_9 = + 039216144400731413927925056  \ngamma_2 = gamma_8 = + 033259913678935943859974864  \ngamma_3 = gamma_7 = - 070624617255763935980996482  \ngamma_4 = gamma_6 = + 008221359629355080023149045  \ngamma_5 = + 079854399093482996339895035 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The computational effort of these high order methods is quite large. Each step requires the solution of a nonlinear system of equations. Given the outstanding performance already second order symplectic integrators are able to deliver, the necessity for such high order methods is rarely found. Nevertheless, if extremely high accuracy is indispensable, think for example of long-time simulations of the solar system, these methods can be applied. Moreover, there exist special methods optimized for such problems.","category":"page"},{"location":"integrators/splitting/#Splitting-Tableaus","page":"Splitting","title":"Splitting Tableaus","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Actualy splitting methods are usually prescribed in one of the following forms.","category":"page"},{"location":"integrators/splitting/#[TableauSplitting](@ref)","page":"Splitting","title":"TableauSplitting","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for general splitting methods for vector fields with two terms v = v_A + v_B, leading to the following integrator:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A ","category":"page"},{"location":"integrators/splitting/#[TableauSplittingNS](@ref)","page":"Splitting","title":"TableauSplittingNS","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for non-symmetric splitting methods [Robert I. McLachlan , G. Reinout W. Quispel  (2002), Equation (4.10)]. Here, two flows varphi_tau^A and varphi_tau^B are constructed as the Lie composition of all vector fields in the SODE and its adjoint, respectively, i.e..","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r  \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and the integrator is composed as follows:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^NS = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A ","category":"page"},{"location":"integrators/splitting/#[TableauSplittingGS](@ref)","page":"Splitting","title":"TableauSplittingGS","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for symmetric splitting methods with general stages [Robert I. McLachlan , G. Reinout W. Quispel  (2002), Equation (4.11)], where again two flows varphi_tau^A and varphi_tau^B are constructed via Lie composition","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r  \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"but with an integrator composed as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^GS = varphi_a_1 tau^A circ varphi_b_1 tau^B circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A ","category":"page"},{"location":"integrators/splitting/#[TableauSplittingSS](@ref)","page":"Splitting","title":"TableauSplittingSS","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for symmetric splitting methods with symmetric stages [Robert I. McLachlan , G. Reinout W. Quispel  (2002), Equation (4.6)]. Here, only one flow varphi_tau^S is constructed via symmetric Strang composition,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^S = varphi_tau2^v_1 circ varphi_tau2^v_2 circ dotsc circ varphi_tau2^v_r-1 circ varphi_tau2^v_r circ varphi_tau2^v_r circ varphi_tau2^v_r-1 circ dotsc circ varphi_tau2^v_2 circ varphi_tau2^v_1 ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and composed as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^SS = varphi_a_1 tau^S circ varphi_a_2 tau^S circ dotsc circ varphi_a_s tau^S circ dotsc circ varphi_a_2 tau^S circ varphi_a_1 tau^S ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"to obtain an integrator.","category":"page"},{"location":"modules/simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"modules/simulations/","page":"Simulations","title":"Simulations","text":"Modules = [GeometricIntegrators.Simulations]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/simulations/#GeometricIntegrators.Simulations.ParallelSimulation","page":"Simulations","title":"GeometricIntegrators.Simulations.ParallelSimulation","text":"ParallelSimulation: collects all data structures that are necessary for a    simulation run in parallel.\n\nWARNING: Many integrators are not thread-safe at this point!\n\n\n\n\n\n","category":"type"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"","category":"page"},{"location":"integrators/cgvi/#cgvi","page":"CGVI","title":"Continuous Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"In the following, we first present the Galerkin framework for variational integrators [Melvin Leok  (2004), Melvin Leok , Jingjing Zhang  (2011), Cédric M. Campos  (2014), Cédric M. Campos , Sina Ober-Blöbaum , Emmanuel Trélat  (2015), Sina Ober-Blöbaum , Nils Saake  (2014), Sina Ober-Blöbaum  (2016)] where the space of curves mfQ that connect two points in mfM is approximated by a finite-dimensional subspace (Galerkin integrators of 0th kind). We use Lagrange polynomials to approximate the trajectories albeit other choices are possible. Alternatively, we can approximate the generalised velocities  (Galerkin integrators of 1st kind), which leads us to variational-partitioned Runge-Kutta methods. Even though, in some cases correspondences between integrators of 0th kind and integrators of 1st kind might be found, in general they are different.","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"In our treatment we distinguish between integer timesteps, which are the coordinates q_n at time t_n, and internal stages (nodes), which are the coordinates Q_ni located between two integer timesteps q_n and q_n+1 at consecutive points in time t_n and t_n+1. In all of the following we assume that the timestep h is constant.","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"In the discrete variational principle, we have to consider variations at both, the integer timesteps and the internal stages. For Galerkin integrators of 0th kind, the coordinates Q_ni are varied, whereas for the Galerkin integrators of 1st kind, the velocities dotQ_ni are varied. So the independent variables are (q_n Q_ni) and (q_n dotQ_ni), respectively.","category":"page"},{"location":"integrators/cgvi/#Space-of-Discrete-Trajectories","page":"CGVI","title":"Space of Discrete Trajectories","text":"","category":"section"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"In order to construct the discrete space of curves from q_0 to q_N,","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"mfQ_d ( q_0 q_N  t_n _n=0^N ) = big q_d   t_n _n=0^N rightarrow mfM  bigvert  q_d (t_0) = q_0  q_d (t_N) = q_N big subset mfQ_d ( mfM ) ","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"we will construct a finite-dimensional subspace of","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"mfQ ( q_0 q_N 0 T ) = big q  0 T rightarrow mfM  bigvert  q(0) = q_0  q(T) = q_N big subset mfQ ( mfM ) ","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"The subspace mfQ_h ( q_0 q_N 0 T ) is defined by","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"beginequationlabeleqgalerkin-vi-space-of-piecewise-polynomials\nmfQ_h ( q_0 q_N 0 T ) = bigq_h  0 T rightarrow mfM  bigvert  q_h vert_  t_n  t_n+1   in mathbbP_s (t_n t_n+1)    q_h in C^0 (0 T) big \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"where mathbbP_s (t_n t_n+1) is the space of polynomials of degree s in the interval t_n t_n+1 subset 0 T. We see that mfQ_h ( q_0 q_N 0 T ) subset mfQ ( q_0 q_N 0 T ). In order for mfQ_h ( q_0 q_N 0 T ) to be an instance of mfQ_d ( q_0 q_N  t_n _n=0^N ) we have to require in addition to the definition \\eqref{eq:galerkin-vi-space-of-piecewise-polynomials} that  on the sequence  t_n _n=0^N, the curves q_h in mfQ_h ( q_0 q_N 0 T ) satisfy","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"q_h vert_  t_n  t_n+1   (t_n)   = q_n\nqquad textand qquad\nq_h vert_  t_n  t_n+1   (t_n+1) = q_n+1 ","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"where q_n are the points of the discrete trajectories q_d =  q_n _n=0^N. However, it is often more convenient to enforce these continuity constraints weakly in the action rather than building them into the spaces, which implies dropping the condition q_h in C^0 (0 T) in \\eqref{eq:galerkin-vi-space-of-piecewise-polynomials}. This in turn means that the whole of mfQ_h ( q_0 q_N 0 T ) is not a subspace of mfQ ( q_0 q_N 0 T ) anymore.","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"TODO: The role of continuity is not clearly explained and probably not correctly worked out. In practice, we are using broken spaces mfQ_h and enforce continuity only weakly in the action principle.  It should be made clear, that mfQ_d is an approximation of mfQ, but not a subspace of mfQ. mfQ_h, however, is a subspace of mfQ (although it can be broken). The connection between mfQ_h and mfQ_d is made by the continuity constraints (which for Lagrange polynomials and sequences of nodes which include the boundaries, i.e., c_1=0 and c_s=1, is automatically satisfied). In this context we also need to discuss that curves in mfQ(mfM) are assumed to be C^2, which is not required by the curves in mfQ_h.","category":"page"},{"location":"integrators/cgvi/#Piecewise-Polynomials","page":"CGVI","title":"Piecewise Polynomials","text":"","category":"section"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"A basis of mfQ_h ( q_0 q_N 0 T ) can easily be constructed by combining bases of mathbbP_s (t_n t_n+1), e.g., using Lagrange polynomials. We start by specifying the collocation times of the internal stages. Select a set of s points c_i with 0 leq c_i leq 1, which are the nodes of the basis functions. Therefore the basis is built by s functions. The internal stages are then located at t_ni = t_n + h c_i, such that","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"t_n leq t_n1    t_ns leq t_n+1 ","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"and we have","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"Q_ni approx q ( t_ni ) ","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"We will only be concerned with Lagrange polynomials. The j-th Lagrange polynomial of order s is defined by","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"l^si (tau) = prod limits_substack1 leq j leq s j neq i dfractau - c_jc_i - c_j ","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"The c_i are often chosen to be the collocation points of some quadrature rule (e.g., Gauß-Legendre or Gauß-Chebyshew points). Within each subinterval between two consecutive timesteps, t_n and t_n+1, the same Lagrange basis is used, namely","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"spn big varphi_n^sm (t)  bigvert  1 leq m leq s big ","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"with","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"varphi_n^sm (t) = begincases\nl^sm big( (t-t_n)  (t_n+1 - t_n) big)  hspace5em  t_n leq t leq t_n+1  \nhspace8em 0   textelse \nendcases","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"It suffices to specify the basis for one subinterval t_n t_n+1 and then replicate this basis for all subintervals, so that the finite-dimensional subspace of mfQ ( q_0 q_N 0 T ) is given by","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"beginmultline\nmfQ_h ( q_0 q_N 0 T ) \n= Big q_h  0 T rightarrow mfM  Bigvert  q_h bigvert_t_n t_n+1 in spn big varphi_n^sm  bigvert  1 leq m leq s big    textfor  0 leq n leq N-1  \n  q_h (0) = q_0   q_h (T) = q_N Big \nendmultline","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"In order to obtain the discrete space of curves mfQ_d ( q_0 q_N  t_n _n=0^N ) we have to add continuity constraints, connecting the polynomials in each interval with the nodal values q_n, that is","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"beginmultline\nmfQ_d ( q_0 q_N  t_n _n=0^N ) \n= Big q_h in mfQ_h ( q_0 q_N 0 T )  Bigvert  q_h bigvert_t_n t_n+1 (t_n) = q_n   q_h bigvert_t_n t_n+1 (t_n+1) = q_n+1 Big \nendmultline","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"We project the trajectories of the particles onto a Lagrange basis in order to obtain the polynomial approximation of the trajectory in the interval t_n t_n+1, i.e.,","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"beginequationlabeleqparticle-trajectory-position\nq_h (t) bigvert_t_n t_n+1 = sum limits_m=1^s Q_nm  varphi_n^sm (t) \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"The particle velocities are then obtained by differentiating with respect to time,","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"beginequationlabeleqparticle_trajectory_velocity\ndotq_h (t) bigvert_t_n t_n+1 = sum limits_m=1^s Q_nm  dotvarphi_n^sm (t) \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"For s=2, we obtain","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"beginaligned\nq_h (t) bigvert_  t_n  t_n+1   = Q_n1  dfract - t_n+1t_n - t_n+1 + Q_n2  dfract - t_nt_n+1 - t_n  \ndotq_h (t) bigvert_  t_n  t_n+1   = dfracQ_n2 - Q_n1t_n+1 - t_n \nendaligned","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"which is just linear interpolation for q and piecewise constant for dotq.","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"TODO: Discuss other basis functions (e.g. Chebychev polynomials, B-splines) and other quadrature rules (e.g., Chebyshev points, optimised IGA points) and visualise basis functions for different quadrature points.","category":"page"},{"location":"integrators/cgvi/#Numerical-Quadrature","page":"CGVI","title":"Numerical Quadrature","text":"","category":"section"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"In order to numerically compute the definite integral","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"beginequationlabeleqgalerkin-vi-quadrature-integral\nF q = int limits_t_n^t_n+1 f big( t q(t) big)  dt \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"we apply two levels of approximation. As q(t) is unknown, we replace it with the piecewise polynomial approximation q_h (t). Further, we introduce a quadrature formula in which f itself is approximated by a Lagrange polynomial, i.e.,","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"f_h (t q (t)) = sum limits_i=1^s varphi_n^si (t)  f big( t_n + h c_i  q (t_n + h c_i) big) ","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"Together, this gives an approximation of the integral \\eqref{eq:galerkin-vi-quadrature-integral} as follows","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"beginequationlabeleqgalerkin_vi_quadrature_rule\nF_h q\n= int limits_t_n^t_n+1 f_h (t q_h (t))  dt\n= h sum limits_i=1^s b_i  f big( t_n + h c_i  q_h (t_n + h c_i) big) \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"where b_i are the weights or coefficients of the quadrature formula, given by","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"beginequationlabeleqgalerkin_vi_quadrature_weights\nb_i\n= dfrac1h int limits_t_n^t_n+1 varphi_n^si (t)  dt\n= int limits_0^1 l^si (tau)  dtau \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"h = t_n+1 - t_n","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"is the time step, and q_h (t) bigvert_  t_n  t_n+1   is some polynomial approximation to q(t) in the interval t_n t_n+1. %The c_i will also be the collocation points of the quadrature rule that is used to approximate the action integral. We will focus on collocation methods where the nodes c_i of the quadrature rule are also the nodes of the basis functions, so that for \\eqref{eq:particle-trajectory-position}, we have q_h (t_n + h c_i) = Q_ni. It follows that the discrete Lagrangian can be written as","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"L_d (q_n q_n+1) = h sum limits_i=1^s b_i  L big( Q_ni  dotQ_ni big) ","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"Most often, we use Gauss-Legendre quadrature, where the nodes c_i are given by the roots of the Legendre polynomials. The Gauss quadrature rules with s nodes yield exact results when applied to polynomials of order up to 2s.","category":"page"},{"location":"integrators/cgvi/#Galerkin-Variational-Integrators","page":"CGVI","title":"Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"In order to write the discrete Lagrangian in the discrete action in a compact form, we define the nodal coefficients a_ij,","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"a_ij\n= h dfracd varphi_n^sjdt biggvert_t=t_n + h c_i\n= dfracd l^sjdtau biggvert_tau=c_i ","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"so that the velocities can be written as","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"dotQ_ni\n= dotq_h (t_ni)\n= sum limits_j=1^s Q_nj  dotvarphi_n^sj (t_n + h c_i)\n= dfrac1h sum limits_j=1^s a_ij  Q_nj ","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"In order to complete the discrete action, we explicitly add the continuity constraint,","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"beginmultline\nmathcalA_d q_d\n= sum limits_n=0^N-1 bigg\n\tsum limits_i=1^s b_i  L big( Q_ni  dotQ_ni big)\n  + lambda_n cdot big( q_hvert_  t_n  t_n+1   (t_n  ) - q_n   big) \n  + mu_n+1   cdot big( q_hvert_  t_n  t_n+1   (t_n+1) - q_n+1 big)\nbigg \nendmultline","category":"page"},{"location":"integrators/cgvi/","page":"CGVI","title":"CGVI","text":"which ensures that the polynomials in neighbouring intervals, e.g., t_n t_n+1 and t_n+1 t_n+2, have the same value at integer timesteps, e.g., t_n+1.","category":"page"},{"location":"#GeometricIntegrators.jl","page":"Home","title":"GeometricIntegrators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia library of geometric integrators for differential equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: PkgEval Status) (Image: CI) (Image: Build Status) (Image: Coverage Status) (Image: codecov Status) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl is a library of geometric integrators for ordinary differential equations, stochastic differential equations and differential algebraic equations in Julia. Its main purpose is the democratization and proliferation of geometric integrators by providing a comprehensive collection of structure-preserving as well as standard algorithms under a unified interface.  GeometricIntegrators.jl can be used either interactively or as computational core in other codes. It provides both, a high-level interface that requires only very few lines of code to solve an actual problem, and a lean low-level interface that allows for straightforward integration into application codes via the exchange of minimalistic data structures. In both, the library leaves maximum control to the user. While trying to pick sensible defaults, all settings are accessible to and modifiable by the user. Suitable abstraction layers allow to choose between different linear and nonlinear solvers, auto-differentiation packages or custom routines for the computation of Jacobians and the like.","category":"page"},{"location":"#Statement-of-need","page":"Home","title":"Statement of need","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Differential equations are ubiquitous in science and engineering. Many equations possess geometric features or abstract mathematical structures that need to be preserved in the discretisation in order to obtain reliable simulation results, especially for nonlinear problems and long-time simulations. The preservation of such properties improves stability, bounds global error growth and reduces numerical artefacts. Robust, performant and structure-preserving solvers for different types of differential equations are thus needed across many disciplines. GeometricIntegrators.jl provides such solvers and makes them available for both direct use as well as integration into other codes. Furthermore, the implemented algorithms can also be used within the DifferentialEquations.jl ecosystem [Christopher Rackauckas , Qing Nie  (2017)], which is the defacto standard differential equation solver for the Julia programming language [Jeff Bezanson , Alan Edelman , Stefan Karpinski , Viral B. Shah  (2017)].","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl provides a comprehensive library of existing geometric integration as well as non-geometric algorithms, such as explicit, implicit, partitioned and stochastic Runge-Kutta methods, SPARK methods, splitting methods, symplectic methods and variational integrators. Most methods are implemented in an abstract way that allows for the flexible choice of tableaus, approximation spaces, basis functions, quadrature rules, and thus order of convergence. GeometricIntegrators.jl also serves as a testbed for the development and analysis of novel algorithms. Due to the modular structure and the use of the multiple dispatch paradigm, the library can easily be extended, e.g., towards new algorithms or new types of equations. The library is designed to minimize overhead and maximize performance in order to be able to perform simulations with millions or even billions of time steps to facilitate the study of the long-time behaviour of both numerical algorithms and dynamical systems.","category":"page"},{"location":"#Other-Software","page":"Home","title":"Other Software","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package closely related to GeometricIntegrators.jl is DifferentialEquations.jl [Christopher Rackauckas , Qing Nie  (2017)]. However, the scope of the two libraries is rather different. While DifferentialEquations.jl provides a feature-rich ecosystem for the solution of differential equations, the focus of GeometricIntegrators.jl is on algorithms. In fact, GeometricIntegrators.jl can be used as backend for DifferentialEquations.jl via GeometricIntegratorsDiffEq.jl.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"tutorial/tutorial.md\",\n         \"equations.md\",\n         \"integrators.md\",\n]","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"modules/equations.md\",\n         \"modules/integrators.md\",\n         \"modules/interpolation.md\",\n        #\"modules/discontinuities.md\",\n         \"modules/simulations.md\",\n         \"modules/solutions.md\",\n]","category":"page"},{"location":"#Tableaus","page":"Home","title":"Tableaus","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"tableaus/rungekutta.md\",\n         \"tableaus/rungekutta_partitioned.md\",\n         \"tableaus/splitting.md\",\n         \"tableaus/vprk.md\",\n         \"tableaus/spark.md\",\n]","category":"page"},{"location":"#Developer-Documentation","page":"Home","title":"Developer Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"developer/code_integration.md\",\n         \"developer/custom_integrators.md\",\n]","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use GeometricIntegrators.jl in your work, please consider citing it by","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{Kraus:2020:GeometricIntegrators,\n  title={GeometricIntegrators.jl: Geometric Numerical Integration in Julia},\n  author={Kraus, Michael},\n  year={2020},\n  howpublished={\\url{https://github.com/JuliaGNI/GeometricIntegrators.jl}},\n  doi={10.5281/zenodo.3648325}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl contains reference implementation for the methods described in the following articles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Michael Kraus. Projected Variational Integrators for Degenerate Lagrangian Systems. arXiv:1708.07356.\nMichael Kraus and Tomasz M. Tyranowski. Variational Integrators for Stochastic Dissipative Hamiltonian Systems. arXiv:1909.07202, Journal.","category":"page"},{"location":"#Background-Material","page":"Home","title":"Background Material","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ernst Hairer and Christian Lubich. Numerical Solution of Ordinary Differential Equations. The Princeton Companion to Applied Mathematics, 293-305, 2015. Princeton University Press. (Author's Web Site)\nErnst Hairer, Christian Lubich and Gerhard Wanner. Geometric Numerical Integration Illustrated by the Störmer–Verlet Method. Acta Numerica 12, 399-450, 2003. (Journal)\nJohn C. Butcher. Gauss Methods. Encyclopedia of Applied and Computational Mathematics, Pages 583-589, 2015. (Article)\nLaurent O. Jay. Lobatto Methods. Encyclopedia of Applied and Computational Mathematics, Pages 817–826, 2015. (Article)\nErnst Hairer and Gerhard Wanner. Radau Methods. Encyclopedia of Applied and Computational Mathematics, Pages 1213-1216, 2015. (Article)","category":"page"},{"location":"#Books-on-Geometric-Numerical-Integration","page":"Home","title":"Books on Geometric Numerical Integration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sergio Blanes, Fernando Casas. A Concise Introduction to Geometric Numerical Integration. CRC Press, 2016. (eBook)\nErnst Hairer, Christian Lubich and Gerhard Wanner. Geometric Numerical Integration. Springer, 2006. (eBook)\nBenedict Leimkuhler and Sebastian Reich. Simulating Hamiltonian Dynamics. Cambridge University Press, 2005. (eBook)\nJesús Maria Sanz-Serna, Manuel P. Calvo. Numerical Hamiltonian Problems. Chapman Hall, 1994.","category":"page"},{"location":"#Books-on-the-Numerical-Integration-of-Differential-Equations","page":"Home","title":"Books on the Numerical Integration of Differential Equations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ernst Hairer, Syvert P. Nørsett and Gerhard Wanner. Solving Ordinary Differential Equations I: Nonstiff Problems. Springer, 1993. (eBook)\nErnst Hairer and Gerhard Wanner. Solving Ordinary Differential Equations II: Stiff and Differential-Algebraic Problems. Springer, 1996. (eBook)\nErnst Hairer, Christian Lubich, Michel Roche. The Numerical Solution of Differential-Algebraic Systems by Runge-Kutta Methods. Springer, 1989. (eBook)\nPeter Deuflhard, Folkmar Bornemann. Scientific Computing with Ordinary Differential Equations. Springer, 2002. (eBook)\nJohn C. Butcher. Numerical Methods for Ordinary Differential Equations. Wiley, 2016. (eBook)","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Copyright (c) Michael Kraus <michael.kraus@ipp.mpg.de>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"}]
}
