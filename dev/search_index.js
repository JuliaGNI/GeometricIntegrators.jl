var documenterSearchIndex = {"docs":
[{"location":"developer/integrators/#Integrators","page":"Integrators","title":"Integrators","text":"","category":"section"},{"location":"integrators/cgvi/#cgvi","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In the following, we first present the Galerkin framework for variational integrators [[41], [13], [42], [43], [44], [15]] where the space of curves mfQ that connect two points in mfM is approximated by a finite-dimensional subspace (Galerkin integrators of 0th kind). We use Lagrange polynomials to approximate the trajectories albeit other choices are possible. Alternatively, we can approximate the generalised velocities  (Galerkin integrators of 1st kind), which leads us to variational-partitioned Runge-Kutta methods. Even though, in some cases correspondences between integrators of 0th kind and integrators of 1st kind might be found, in general they are different.","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In our treatment we distinguish between integer timesteps, which are the coordinates q_n at time t_n, and internal stages (nodes), which are the coordinates Q_ni located between two integer timesteps q_n and q_n+1 at consecutive points in time t_n and t_n+1. In all of the following we assume that the timestep h is constant.","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In the discrete variational principle, we have to consider variations at both, the integer timesteps and the internal stages. For Galerkin integrators of 0th kind, the coordinates Q_ni are varied, whereas for the Galerkin integrators of 1st kind, the velocities dotQ_ni are varied. So the independent variables are (q_n Q_ni) and (q_n dotQ_ni), respectively.","category":"page"},{"location":"integrators/cgvi/#Space-of-Discrete-Trajectories","page":"Continuous Galerkin Variational Integrators","title":"Space of Discrete Trajectories","text":"","category":"section"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In order to construct the discrete space of curves from q_0 to q_N,","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"mfQ_d ( q_0 q_N  t_n _n=0^N ) = big q_d   t_n _n=0^N rightarrow mfM  bigvert  q_d (t_0) = q_0  q_d (t_N) = q_N big subset mfQ_d ( mfM ) ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"we will construct a finite-dimensional subspace of","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"mfQ ( q_0 q_N 0 T ) = big q  0 T rightarrow mfM  bigvert  q(0) = q_0  q(T) = q_N big subset mfQ ( mfM ) ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"The subspace mfQ_h ( q_0 q_N 0 T ) is defined by","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginequationlabeleqgalerkin-vi-space-of-piecewise-polynomials\nmfQ_h ( q_0 q_N 0 T ) = bigq_h  0 T rightarrow mfM  bigvert  q_h vert_  t_n  t_n+1   in mathbbP_s (t_n t_n+1)    q_h in C^0 (0 T) big \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"where mathbbP_s (t_n t_n+1) is the space of polynomials of degree s in the interval t_n t_n+1 subset 0 T. We see that mfQ_h ( q_0 q_N 0 T ) subset mfQ ( q_0 q_N 0 T ). In order for mfQ_h ( q_0 q_N 0 T ) to be an instance of mfQ_d ( q_0 q_N  t_n _n=0^N ) we have to require in addition to the definition \\eqref{eq:galerkin-vi-space-of-piecewise-polynomials} that  on the sequence  t_n _n=0^N, the curves q_h in mfQ_h ( q_0 q_N 0 T ) satisfy","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"q_h vert_  t_n  t_n+1   (t_n)   = q_n\nqquad textand qquad\nq_h vert_  t_n  t_n+1   (t_n+1) = q_n+1 ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"where q_n are the points of the discrete trajectories q_d =  q_n _n=0^N. However, it is often more convenient to enforce these continuity constraints weakly in the action rather than building them into the spaces, which implies dropping the condition q_h in C^0 (0 T) in \\eqref{eq:galerkin-vi-space-of-piecewise-polynomials}. This in turn means that the whole of mfQ_h ( q_0 q_N 0 T ) is not a subspace of mfQ ( q_0 q_N 0 T ) anymore.","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"TODO: The role of continuity is not clearly explained and probably not correctly worked out. In practice, we are using broken spaces mfQ_h and enforce continuity only weakly in the action principle.  It should be made clear, that mfQ_d is an approximation of mfQ, but not a subspace of mfQ. mfQ_h, however, is a subspace of mfQ (although it can be broken). The connection between mfQ_h and mfQ_d is made by the continuity constraints (which for Lagrange polynomials and sequences of nodes which include the boundaries, i.e., c_1=0 and c_s=1, is automatically satisfied -> this is not true). In this context we also need to discuss that curves in mfQ(mfM) are assumed to be C^2, which is not required by the curves in mfQ_h.","category":"page"},{"location":"integrators/cgvi/#Piecewise-Polynomials","page":"Continuous Galerkin Variational Integrators","title":"Piecewise Polynomials","text":"","category":"section"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"A basis of mfQ_h ( q_0 q_N 0 T ) can easily be constructed by combining bases of mathbbP_s (t_n t_n+1), e.g., using Lagrange polynomials. We start by specifying the collocation times of the internal stages. Select a set of s points c_i with 0 leq c_i leq 1, which are the nodes of the basis functions. Therefore the basis is built by s functions. The internal stages are then located at t_ni = t_n + h c_i, such that","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"t_n leq t_n1    t_ns leq t_n+1 ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"and we have","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"Q_ni approx q ( t_ni ) ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"We will only be concerned with Lagrange polynomials. The j-th Lagrange polynomial of order s is defined by","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"l^si (tau) = prod limits_substack1 leq j leq s j neq i dfractau - c_jc_i - c_j ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"The c_i are often chosen to be the collocation points of some quadrature rule (e.g., Gauß-Legendre or Gauß-Chebyshew points). Within each subinterval between two consecutive timesteps, t_n and t_n+1, the same Lagrange basis is used, namely","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"spn big varphi_n^sm (t)  bigvert  1 leq m leq s big ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"with","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"varphi_n^sm (t) = begincases\nl^sm big( (t-t_n)  (t_n+1 - t_n) big)  hspace5em  t_n leq t leq t_n+1  \nhspace8em 0   textelse \nendcases","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"It suffices to specify the basis for one subinterval t_n t_n+1 and then replicate this basis for all subintervals, so that the finite-dimensional subspace of mfQ ( q_0 q_N 0 T ) is given by","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginmultline\nmfQ_h ( q_0 q_N 0 T ) \n= Big q_h  0 T rightarrow mfM  Bigvert  q_h bigvert_t_n t_n+1 in spn big varphi_n^sm  bigvert  1 leq m leq s big    textfor  0 leq n leq N-1  \n  q_h (0) = q_0   q_h (T) = q_N Big \nendmultline","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In order to obtain the discrete space of curves mfQ_d ( q_0 q_N  t_n _n=0^N ) we have to add continuity constraints, connecting the polynomials in each interval with the nodal values q_n, that is","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginmultline\nmfQ_d ( q_0 q_N  t_n _n=0^N ) \n= Big q_h in mfQ_h ( q_0 q_N 0 T )  Bigvert  q_h bigvert_t_n t_n+1 (t_n) = q_n   q_h bigvert_t_n t_n+1 (t_n+1) = q_n+1 Big \nendmultline","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"We project the trajectories of the particles onto a Lagrange basis in order to obtain the polynomial approximation of the trajectory in the interval t_n t_n+1, i.e.,","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginequationlabeleqparticle-trajectory-position\nq_h (t) bigvert_t_n t_n+1 = sum limits_m=1^s Q_nm  varphi_n^sm (t) \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"The particle velocities are then obtained by differentiating with respect to time,","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginequationlabeleqparticle_trajectory_velocity\ndotq_h (t) bigvert_t_n t_n+1 = sum limits_m=1^s Q_nm  dotvarphi_n^sm (t) \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"For s=2, we obtain","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginaligned\nq_h (t) bigvert_  t_n  t_n+1   = Q_n1  dfract - t_n+1t_n - t_n+1 + Q_n2  dfract - t_nt_n+1 - t_n  \ndotq_h (t) bigvert_  t_n  t_n+1   = dfracQ_n2 - Q_n1t_n+1 - t_n \nendaligned","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"which is just linear interpolation for q and piecewise constant for dotq.","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"TODO: Discuss other basis functions (e.g. Chebychev polynomials, B-splines) and other quadrature rules (e.g., Chebyshev points, optimised IGA points) and visualise basis functions for different quadrature points.","category":"page"},{"location":"integrators/cgvi/#Numerical-Quadrature","page":"Continuous Galerkin Variational Integrators","title":"Numerical Quadrature","text":"","category":"section"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In order to numerically compute the definite integral","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginequationlabeleqgalerkin-vi-quadrature-integral\nF q = int limits_t_n^t_n+1 f big( t q(t) big)  dt \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"we apply two levels of approximation. As q(t) is unknown, we replace it with the piecewise polynomial approximation q_h (t). Further, we introduce a quadrature formula in which f itself is approximated by a Lagrange polynomial, i.e.,","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"f_h (t q (t)) = sum limits_i=1^s varphi_n^si (t)  f big( t_n + h c_i  q (t_n + h c_i) big) ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"Together, this gives an approximation of the integral \\eqref{eq:galerkin-vi-quadrature-integral} as follows","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginequationlabeleqgalerkin_vi_quadrature_rule\nF_h q\n= int limits_t_n^t_n+1 f_h (t q_h (t))  dt\n= h sum limits_i=1^s b_i  f big( t_n + h c_i  q_h (t_n + h c_i) big) \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"where b_i are the weights or coefficients of the quadrature formula, given by","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginequationlabeleqgalerkin_vi_quadrature_weights\nb_i\n= dfrac1h int limits_t_n^t_n+1 varphi_n^si (t)  dt\n= int limits_0^1 l^si (tau)  dtau \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"h = t_n+1 - t_n","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"is the time step, and q_h (t) bigvert_  t_n  t_n+1   is some polynomial approximation to q(t) in the interval t_n t_n+1. %The c_i will also be the collocation points of the quadrature rule that is used to approximate the action integral. We will focus on collocation methods where the nodes c_i of the quadrature rule are also the nodes of the basis functions, so that for \\eqref{eq:particle-trajectory-position}, we have q_h (t_n + h c_i) = Q_ni. It follows that the discrete Lagrangian can be written as","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"L_d (q_n q_n+1) = h sum limits_i=1^s b_i  L big( Q_ni  dotQ_ni big) ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"Most often, we use Gauss-Legendre quadrature, where the nodes c_i are given by the roots of the Legendre polynomials. The Gauss quadrature rules with s nodes yield exact results when applied to polynomials of order up to 2s.","category":"page"},{"location":"integrators/cgvi/#Galerkin-Variational-Integrators","page":"Continuous Galerkin Variational Integrators","title":"Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In order to write the discrete Lagrangian in the discrete action in a compact form, we define the nodal coefficients a_ij,","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"a_ij\n= h dfracd varphi_n^sjdt biggvert_t=t_n + h c_i\n= dfracd l^sjdtau biggvert_tau=c_i ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"so that the velocities can be written as","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"dotQ_ni\n= dotq_h (t_ni)\n= sum limits_j=1^s Q_nj  dotvarphi_n^sj (t_n + h c_i)\n= dfrac1h sum limits_j=1^s a_ij  Q_nj ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In order to complete the discrete action, we explicitly add the continuity constraint,","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginmultline\nmathcalA_d q_d\n= sum limits_n=0^N-1 bigg\n\tsum limits_i=1^s b_i  L big( Q_ni  dotQ_ni big)\n  + lambda_n cdot big( q_hvert_  t_n  t_n+1   (t_n  ) - q_n   big) \n  + mu_n+1   cdot big( q_hvert_  t_n  t_n+1   (t_n+1) - q_n+1 big)\nbigg \nendmultline","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"which ensures that the polynomials in neighbouring intervals, e.g., t_n t_n+1 and t_n+1 t_n+2, have the same value at integer timesteps, e.g., t_n+1.","category":"page"},{"location":"integrators/dvi/#Degenerate-Variational-Integrators","page":"DVI","title":"Degenerate Variational Integrators","text":"","category":"section"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"CurrentModule = GeometricIntegrators.SPARK","category":"page"},{"location":"integrators/spark/#Special-Partitioned-Additive-Runge-Kutta-Integrators","page":"SPARK","title":"Special Partitioned Additive Runge-Kutta Integrators","text":"","category":"section"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"SPARK or Special Partitioned Additive Runge-Kutta Integrators are a family of integrators that have been introduced by Laurent O. Jay for the integration of differential algebraic equations and in particular systems subject to holonomic and nonholonomic constraints [[37], [33], [34], [38], [39]]. Recently, the idea of SPARK methods has been generalized and adapted to facilitate the integration of degenerate Lagrangian systems as well as Hamiltonian systems subject to Dirac constraints [[40]].","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"GeometricIntegrators.jl provides several flavours of such SPARK methods (some are still experimental):","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"Integrator Description\nIntegratorHPARK Partitioned additive methods for Hamiltonian system subject to a general constraint phi(qp) = 0\nIntegratorVPARK Partitioned additive methods for Lagrangian system subject to a general constraint phi(qp) = 0\nIntegratorSPARK SPARK methods for general index-two differential algebraic equations\nIntegratorHSPARK Hamiltonian system subject to a general constraint phi(qp) = 0\nIntegratorHSPARKprimary Hamiltonian system subject primary constraint in the sense of Dirac\nIntegratorHSPARKsecondary Hamiltonian system enforcing primary & secondary Dirac constraint\nIntegratorVSPARK Lagrangian system in implicit form subject to a general constraint phi(qp) = 0\nIntegratorVSPARKprimary Degenerate Lagrangian system subject primary constraint in the sense of Dirac\nIntegratorVSPARKsecondary Degenerate Lagrangian system enforcing primary & secondary Dirac constraint","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"These integrators are applied to either an IDAE, HDAE or LDAE.","category":"page"},{"location":"modules/methods/#Methods","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"modules/methods/","page":"Methods","title":"Methods","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/methods.jl\",\n           \"integrators/method_list.jl\"]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/methods/#GeometricIntegrators.Integrators.GeometricMethod","page":"Methods","title":"GeometricIntegrators.Integrators.GeometricMethod","text":"GeometricMethod is the abstract supertype for all integration methods implemented in GeometricIntegrators.\n\n\n\n\n\n","category":"type"},{"location":"modules/methods/#Base.show-Tuple{IO, GeometricIntegrators.Integrators.MethodList}","page":"Methods","title":"Base.show","text":"Base.show(io::IO, ml::MethodList)\nBase.show(io::IO, ::MIME\"text/markdown\", ml::MethodList)\n\nPretty-print MethodList.\n\n\n\n\n\n","category":"method"},{"location":"modules/simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"modules/simulations/","page":"Simulations","title":"Simulations","text":"Modules = [GeometricIntegrators.Simulations]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"developer/adaptive_time_stepping/#Adaptive-Time-Stepping","page":"Adaptive Time Stepping","title":"Adaptive Time Stepping","text":"","category":"section"},{"location":"developer/adaptive_time_stepping/","page":"Adaptive Time Stepping","title":"Adaptive Time Stepping","text":"GeometricIntegrators.jl does not provide any general infrastructure for adaptive time stepping. The main reason is that adaptive time stepping is not easy to combine with structure-preservation. Most typical applicatons of the GeometricIntegrators developers require the output of solutions at a sequence of time steps with constant step size.","category":"page"},{"location":"developer/adaptive_time_stepping/","page":"Adaptive Time Stepping","title":"Adaptive Time Stepping","text":"Nonetheless, geometric methods with time step adaptation do exist and it is not hard to implement such methods in the GeometricIntegrators framework. Here, the standard infrastructure is used to specify \"target time steps\", at which a solution has to be computed. That means an adaptive integrator is required to compute a solution for every point in the equidistant time series, but in between in adapts as it wishes. Whenever an adaptive time step would step over a \"target time step\", it is reduced to hit that target. For geometric, structure-preserving integrators that often is the only sensible thing to do (and for most practical applications as well).","category":"page"},{"location":"developer/adaptive_time_stepping/","page":"Adaptive Time Stepping","title":"Adaptive Time Stepping","text":"In all of this, the integrator has to take care of the sub-cycling and the rest of GeometricIntegrators doesn't really care about it. If for some reason you want to output the solution at the intermediate irregular time steps, this is relatively easily possible via the (still mostly undocumented) mid-level interface that is used to call the integrators.","category":"page"},{"location":"solutions/#Solutions","page":"-","title":"Solutions","text":"","category":"section"},{"location":"solutions/","page":"-","title":"-","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator\nprob = HarmonicOscillator.odeproblem()","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"In what we have seen so far, the solution was always automatically created by the integrate() function. While this is often convenient, it is sometimes not performant, e.g., when carrying out long-time simulations with intermediate saving of the solution. In such cases, it is better to preallocate a solution object by","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"sol = Solution(prob)","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"where the first argument is an equation, the second argument is the time step and the third argument is the number of time steps that will be computed in one integration step. The call to the integrator is then made via","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"int = GeometricIntegrator(prob, Gauss(1))\nintegrate!(sol, int)","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"If several integration cycles shall be performed, the reset!() function can be used to copy the solution of the last time step to the initial conditions of the solution,","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"for i in 1:10\n    # integrate!(sol, int)\n    #\n    # save or process solution\n    #\n    # reset!(sol)\nend","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"All solutions have a t field holding the series of time steps that has been computed in addition to several data fields, for example q for an ODE solution, q and p for a PODE solution, qand λ for a DAE solution, and q, p and λ for a PDAE solution.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"CurrentModule = GeometricIntegrators","category":"page"},{"location":"integrators/rk/#Runge-Kutta-Methods","page":"Runge-Kutta","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Runge-Kutta methods exploit the Fundamental Theorem of Calculus, which states that the solution of an initial-value problem","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\ndotx (t) = f(t x(t))  \nx(t_n) = x_n \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"at time t_n+1 is given by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"x (t_n+1) = x (t_n) + int limits_t_n^t_n+1 dotx (t)  dt ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Runge-Kutta methods are constructed by approximating the integral by some quadrature formula with s nodes c_i and corresponding weights b_i to obtain x_n+1 approx x (t_n+1) by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nx_n+1 = x_n + h sum limits_i=1^s b_i dotX_ni  \ndotX_ni = f(t_n + c_i h X_ni) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"where the internal stage values X_ni approx x(t_n + c_i h) for i = 1  s are determined by another quadrature formula, approximating the integral","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"x(t_n + c_i h) = x (t_n) + int limits_t_n^t_n + c_i h dotx (t)  dt ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"namely","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"X_ni = x_n + h sum limits_j=1^s a_ij dotX_nj ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"with the same vector field values dotX_nj used for the computation of x_n+1.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Definition: Runge-Kutta methods are numerical one-step methods","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nX_ni = x_n + h sum limits_j=1^s a_ij  f(t_n + c_j h X_nj)  \nx_n+1 = x_n + h sum limits_j=1^s b_j   f(t_n + c_j h X_nj) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"defined by a set of nodes c_i, weights b_i and coefficients a_ij with ij = 1  s, summarized in the Butcher tableau","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginarraycc\nc  a     \nhline\n   b^T \nendarray\n=\nbeginarrayccccc\nc_1   a_11  a_12  dots  a_1s \nc_2   a_21  a_22  dots  a_2s \nvdots  vdots  vdots  ddots  vdots \nc_s   a_s1  a_s2  dots  a_ss \nhline\n        b_1   b_2   dots  b_s  \nendarray","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Most properties of the methods, such as order or stability, can be analysed just by posing conditions on the Butcher tableau.","category":"page"},{"location":"integrators/rk/#Common-Runge-Kutta-Methods","page":"Runge-Kutta","title":"Common Runge-Kutta Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"GeometricIntegrators.jl provides various explicit and implicit (both diagonally and fully implicit) Runge-Kutta methods. For many methods, tabulated coefficients are included, namely","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Function and Aliases Stages Order\nExplicit Methods  \nExplicitEuler, ForwardEuler 1 1\nExplicitMidpoint 2 2\nHeun2 2 2\nHeun3 3 3\nKutta3, Kutta3 3 3\nRalston2 2 2\nRalston3 3 3\nRunge2, Runge2 2 2\nRK416, RK4 4 4\nRK438 4 4\nSSPRK3 3 3\nDiagonally Implicit Methods  \nCrankNicolson 2 2\nCrouzeix 2 3\nKraaijevangerSpijker 2 2\nQinZhang 2 2\nFully Implicit Methods  \nImplicitEuler, BackwardEuler 1 1\nImplicitMidpoint 2 2\nSRK3 3 4","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The coefficients of other methods are computed on-the-fly as described in the following.","category":"page"},{"location":"integrators/rk/#Simplifying-Assumptions","page":"Runge-Kutta","title":"Simplifying Assumptions","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The construction of many Runge-Kutte methods, in particular the Gauß, Lobatto and Radau methods, relies on the so-called simplifying assumptions:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nB(sigma)  sum limits_i=1^s b_i c_i^k-1 = frac1k  \nk = 1      sigma  \n\nC(eta)  sum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  \ni = 1     s   k = 1      eta  \n\nD(zeta)  sum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k )  \nj = 1     s   k = 1      zeta \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"These assumptions provide order conditions for a Runge-Kutta method given by (a_ij b_i c_i). The condition B(p) implies that the quadrature rule (b_i c_i) is of order p. Furthermore, the following theorem holds:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Theorem (Butcher 1964): If the coefficients (a_ij b_i c_i) of a Runge-Kutta method satisfy B(sigma), C(eta), D(zeta) with sigma le eta + zeta + 1 and sigma le 2 eta + 2, then the method is of order sigma.","category":"page"},{"location":"integrators/rk/#Gauß,-Lobatto-and-Radau-Methods","page":"Runge-Kutta","title":"Gauß, Lobatto and Radau Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Gauß methods are collocation methods using the nodes and weights of Gaußian quadrature formulas. The nodes are the zeros of the shifted Legendre polynomials of degree s,","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"fracd^sdx^s big( x^s (x-1)^s big) ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"In a similar fashion, the nodes of the Radau I and II and the Lobatto III methods are defined as the roots of the polynomials","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\n fracd^s-1dx^s-1 big( x^s (x-1)^s-1 big)      text(Radau I)  \n fracd^s-1dx^s-1 big( x^s-1 (x-1)^s big)      text(Radau II)  \n fracd^s-2dx^s-2 big( x^s-1 (x-1)^s-1 big)  text(Lobatto III) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The weights b_1  b_s are chosen such that the methods satisfy B(sigma), that is B(s), for the Gauß methods, B(s-1) for the Radau methods, and B(s-2) for the Lobatto methods.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The coefficients a_ij for ij = 1  s are obtained by the simplifying assumption C(s) for the Gauß, Radau IIA and Lobatto IIIA methods, and by the simplifying assumption D(s) for the Radau IA and Lobatto IIIB methods. The coefficients of the Lobatto IIIC methods are determined by setting a_i1 = b_1 for i = 1  s and solving the simplifying assumption C(s-1), while the coefficients of the Lobatto IIIC̄ methods are determined by setting a_is = 0 and solving C(s-1). Note that the Lobatto IIIC̄ methods are sometimes also called Lobatto III or Lobatto III*. For reasons of code symmetry we chose to stick with the less common name Lobatto IIIC̄. The Lobatto IIID and IIIE methods are obtained by combining the tableaus of the Lobatto IIIC and IIIC̄ and the Lobatto IIIA and IIIB methods, respectively, i.e., ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\na_ij^D = tfrac12 ( a_ij^C + a_ij^C ) \n textand \na_ij^E = tfrac12 ( a_ij^A + a_ij^B ) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"While the Lobatto IIIA, IIIB, IIIC and IIIC̄ methods are not symplectic on their own (although the Lobatto IIIA-IIIB and IIIC-IIIC̄ pairs constitute symplectic partitioned Runge-Kutta methods), the Lobatto IIID and IIIE methods are each symplectic by themselves.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The Gauß methods are of order 2s, the Radau methods or order 2s-1 and the Lobatto methods are of order 2s-2, with the exception of the Lobatto IIIF method. This method has been specifically constructed to be of order 2s as described in [[3]]. The Lobatto IIIG method is constructed in a similar fashion as the Lobatto IIID and IIIE methods by averaging the coefficients of the Lobatto IIIF method with its symplectic complement, i.e.,","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"a_ij^G = tfrac12 ( a_ij^F + bara_ij^F ) ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"where the coffiecients bara_ij^F are determined by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nb_i bara^F_ij + barb_j a^F_ji = b_i barb_j  \n textand \nbarb_i = b_i \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The tableaus of all of the above methods can be computed for an arbitrary number of stages s and thus to arbitrary order.","category":"page"},{"location":"integrators/rk/#Constructors","page":"Runge-Kutta","title":"Constructors","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The following methods are provided for selecting the previously described Runge-Kutta schemes:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Function Method Order\nGauss(s) Gauß-Legendre with s stages 2s\nLobattoIII(s) Lobatto III  with s stages 2s-2\nLobattoIIIA(s) Lobatto IIIA with s stages 2s-2\nLobattoIIIB(s) Lobatto IIIB with s stages 2s-2\nLobattoIIIC(s) Lobatto IIIC with s stages 2s-2\nLobattoIIID(s) Lobatto IIID with s stages 2s-2\nLobattoIIIE(s) Lobatto IIIE with s stages 2s-2\nLobattoIIIF(s) Lobatto IIIF with s stages 2s-2\nLobattoIIIG(s) Lobatto IIIG with s stages 2s-2\nRadauIA(s) Radau IA with s stages 2s-1\nRadauIB(s) Radau IB with s stages 2s-1\nRadauIIA(s) Radau IIA with s stages 2s-1\nRadauIIB(s) Radau IIB with s stages 2s-1","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The first argument s refers to the number of stages (s ge 1 for Gauß and s ge 2 for all other methods). The second argument specifies the number type of the coefficients. Internally, all coefficients are computed using BigFloat and then converted to the requested number type, defaulting to Float64.","category":"page"},{"location":"integrators/rk/#Partitioned-Equations","page":"Runge-Kutta","title":"Partitioned Equations","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Partitioned Runge-Kutta methods consist of two tableaus that solve a partitioned ordinary differential equation,","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\ndotq (t) = v(t q(t) p(t))  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))  \np(t_0) = p_0 \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"in the following way:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  v(t_n + c_j Delta t Q_nj P_nj)  \nq_n+1 = q_n + h sum limits_i=1^s b_i   v(t_n + c_j Delta t Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  f(t_n + c_j Delta t Q_nj P_nj)  \np_n+1 = p_n + h sum limits_i=1^s barb_i    f(t_n + c_j Delta t Q_ni P_ni) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The PartitionedTableau data structure can be used to compose any two Runge-Kutta tableaus into a partitioned Runge-Kutta tableau. A particular interesting family of partitioned Runge-Kutta methods are symplectic Lobatto methods, specifically","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Function Method Order\nLobattoIIIAIIIB(s) Lobatto-IIIA-IIIB 2s-2\nLobattoIIIBIIIA(s) Lobatto-IIIB-IIIA 2s-2\nLobattoIIIAIIIĀ(s) Lobatto-IIIA-IIIĀ 2s-2\nLobattoIIIBIIIB̄(s) Lobatto-IIIB-IIIB̄ 2s-2\nLobattoIIICIIIC̄(s) Lobatto-IIIC-IIIC̄ 2s-2\nLobattoIIIC̄IIIC(s) Lobatto-IIIC̄-IIIC 2s-2\nLobattoIIIDIIID̄(s) Lobatto-IIID-IIID̄ 2s-2\nLobattoIIIEIIIĒ(s) Lobatto-IIIE-IIIĒ 2s-2\nLobattoIIIFIIIF̄(s) Lobatto-IIIF-IIIF̄ 2s\nLobattoIIIF̄IIIF(s) Lobatto-IIIF̄-IIIF 2s\nLobattoIIIGIIIḠ(s) Lobatto-IIIG-IIIḠ 2s","category":"page"},{"location":"integrators/rk/#Implicit-Equations","page":"Runge-Kutta","title":"Implicit Equations","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"An implicit ordinary differential equations is an initial value problem of the form","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t)) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Such problems can be integrated with adapted Runge-Kutta methods, namely","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  v(t_n + c_j Delta t Q_nj P_nj)  \nq_n+1 = q_n + h sum limits_i=1^s b_i   v(t_n + c_j Delta t Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  f(t_n + c_j Delta t Q_nj P_nj)  \np_n+1 = p_n + h sum limits_i=1^s barb_i    f(t_n + c_j Delta t Q_ni P_ni)  \nP_ni = ϑ(t_n + c_j Delta t Q_nj P_nj) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Implicit ODEs can be integrated with any implicit Runge-Kutta or partitioned Runge-Kutta method.","category":"page"},{"location":"integrators/rk/#Custom-Tableaus","page":"Runge-Kutta","title":"Custom Tableaus","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"If required, it is straight-forward to create a custom tableau. The tableau of Heun's method, for example, is defined as follows:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"using GeometricIntegrators # hide\na = [[0.0 0.0]\n     [1.0 0.0]]\nb = [0.5, 0.5]\nc = [0.0, 1.0]\no = 2\n\ntab = Tableau(:heun, o, a, b, c)","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Here, o is the order of the method, a are the coefficients, b the weights and c the nodes. For partitioned Runge-Kutta tableaus, PartitionedTableau can be used. The first parameter of the constructor of each tableau assigns a name to the tableau. Such custom tableaus can be used in exactly the same as standard tableaus, making it very easy to implement and test new Runge-Kutta methods.","category":"page"},{"location":"modules/problems/#Problem-Types","page":"Problems","title":"Problem Types","text":"","category":"section"},{"location":"modules/problems/","page":"Problems","title":"Problems","text":"The following data structures are all implemented in GeometricEquations.jl. Each problem type is derived from EquationProblem.","category":"page"},{"location":"modules/problems/#Geometric-Equation-Problems","page":"Problems","title":"Geometric Equation Problems","text":"","category":"section"},{"location":"modules/problems/","page":"Problems","title":"Problems","text":"GeometricEquations.GeometricProblem\nGeometricEquations.EquationProblem\nGeometricEquations.EnsembleProblem","category":"page"},{"location":"modules/problems/#GeometricEquations.GeometricProblem","page":"Problems","title":"GeometricEquations.GeometricProblem","text":"Abstract type that describes a generic interface for different problem types.\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.EquationProblem","page":"Problems","title":"GeometricEquations.EquationProblem","text":"EquationProblem: stores a GeometricEquation together with initial conditions, parameters, time span and time step size.\n\nParameters\n\nST <: GeometricEquation: super type, used for dispatch\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type of state variable\nequType <: GeometricEquation: equation type\nfunctionsType <: NamedTuple: types of all function methods\nsolutionsType <: NamedTuple: types of all solution methods\nicsType <: NamedTuple: types of all initial conditions \nparType <: OptionalParameters: parameters type\n\nFields\n\nequation: reference to the parent equation object holding the vector fields, etc.\nfunctions: methods for all vector fields, etc., that define the problem\nsolutions: methods for all solutions, etc., if defined\ntspan: time span for problem (t₀,t₁)\ntstep: time step to be used in simulation\nics: NamedTuple containing the initial conditions, must contain one field for each state variable\nparameters: either a NamedTuple containing the equation's parameters or NullParameters indicating that the equation does not have any parameters\n\nSubtypes\n\nThe EquationProblem type has various subtypes for the different equations types, that are defined e.g. via\n\nconst ODEProblem = EquationProblem{ODE}\n\nand provide convenience constructors to construct an equation and the corresponding problem in one step, e.g.,\n\nODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)\nODEProblem(v, tspan, tstep, q₀::StateVariable; kwargs...)\n\nAll problem subtypes take the following keyword arguments:\n\ninvariants = NullInvariants()\nparameters = NullParameters()\nperiodicity = NullPeriodicity()\n\nIf not set to their corresponding Null types, the user needs to pass a NamedTuple whose values are\n\nfunctions for invariants,\narbitrary data structures for parameters, \nthe same data structure as the solution for periodicity.\n\nThe latter should be zero everywhere, except for those components, that are periodic, i.e., whose value are supposed to stay within a range (0, max). Support for ranges starting with other values than zero is currently missing but can be added if demand arises.\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.EnsembleProblem","page":"Problems","title":"GeometricEquations.EnsembleProblem","text":"EnsembleProblem: stores a GeometricEquation together with multiple sets of initial conditions and/or parameters, a time span for integration and a time step size.\n\nAn EnsembleProblem is initialized by providing a GeometricEquation, an integration time span (typically a tuple with two values, start and end time, respectively), a timestep, and one of the three following options:\n\na vector of initial conditions and a vector of parameter sets, with both vectors having the same length,\na vector of initial conditions and a single set of parameters,\na single initial condition and a vector of parameter sets.\n\nEach initial condition is a NamedTuple that contains one field for each state variable. Each parameter set is either a NamedTuple containing the equation's parameters or NullParameters indicating that the equation does not have any parameters.\n\nThe different constructors then generate two vectors, one for the initial conditions and one for the parameters, where each pair of the corresponding entries defines one problem. In the first case, the respective constructor just checks if both vectors are of the same size. In the second case, the respective constructor creates a parameter vector, where each entry holds the same parameter set. In the third case, the respective constructor creates an initial condition vector, where each entry holds the same initial conditions. One may be inclined to think that the first and second constructor lead to a waste of memory, but in reality the respective vectors only hold references to the same initial conditons or parameters. Thus the data is not actually duplicated.\n\nEach pair of initial conditions and parameters is referred to as sample. The methods\n\nlength(::EnsembleProblem)\nnsamples(::EnsembleProblem)\n\nreturn the number of samples in a EnsembleProblem. A single initial condition or parameter set can be retrieved by the methods\n\ninitial_condition(::EnsembleProblem, i)\nparameter(::EnsembleProblem, i)\n\nwhere i is the index of the sample. Typically, however, e.g. when integrating all samples of an EnsembleProblem with GeometricIntegrators, it is more convenient to retrieve the corresponding GeometricProblem via the method\n\nproblem(::EnsembleProblem, i)\n\nThe EnsembleProblem also allows to iterate over all samples, e.g.\n\nfor problem in ensemble\n    # ...\n    # integrate problem\n    # ...\nend\n\nwhere ensemble is an EnsembleProblem and problem is the corresponding GeometricProblem.\n\nParameters\n\nST <: GeometricEquation: super type, used for dispatch\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type of state variable\nequType <: GeometricEquation: equation type\nfunctionsType <: NamedTuple: types of all function methods\nsolutionsType <: NamedTuple: types of all solution methods\nicsType <: AbstractVector{<:NamedTuple}: types of all initial conditions \nparType <: AbstractVector{<:OptionalParameters}: parameters type\n\nFields\n\nequation: reference to the parent equation object holding the vector fields, etc.\nfunctions: methods for all vector fields, etc., that define the problem\nsolutions: methods for all solutions, etc., if defined\ntspan: time span for problem (t₀,t₁)\ntstep: time step to be used in simulation\nics: vector of NamedTuple containing the initial conditions, each NamedTuple must contain one field for each state variable\nparameters: vector of either NamedTuple containing the equation's parameters or NullParameters indicating that the equation does not have any parameters\n\nConstructors\n\nThe EnsembleProblem provides the following constructors:\n\nEnsembleProblem(equ, tspan, tstep, ics::AbstractVector{<:NamedTuple}, parameters::AbstractVector{<:OptionalParameters})\nEnsembleProblem(equ, tspan, tstep, ics::AbstractVector{<:NamedTuple}, parameters::OptionalParameters=NullParameters())\nEnsembleProblem(equ, tspan, tstep, ics::NamedTuple, parameters::AbstractVector{<:OptionalParameters})\nEnsembleProblem(equ, tspan, tstep, ics, ::Nothing) = \n    EnsembleProblem(equ, tspan, tstep, ics, NullParameters())\nEnsembleProblem(equ, tspan, tstep, ics; parameters = NullParameters()) = \n    EnsembleProblem(equ, tspan, tstep, ics, parameters)\n\nequ is a subtype of GeometricEquation\ntspan is a tuple (t₀,t₁) of the integration time span with t₀ the start time and t₁ the end time\ntstep is the time step, typically a value of some AbstractFloat subtype\nics are the initial conditions, either a single set or a vector of multiple sets\nparameters are the static parameters of the problem, either a single set or a vector of multiple sets\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#Ordinary-Differential-Equations","page":"Problems","title":"Ordinary Differential Equations","text":"","category":"section"},{"location":"modules/problems/","page":"Problems","title":"Problems","text":"GeometricEquations.ODEProblem\nGeometricEquations.PODEProblem\nGeometricEquations.HODEProblem\nGeometricEquations.IODEProblem\nGeometricEquations.LODEProblem\nGeometricEquations.SODEProblem","category":"page"},{"location":"modules/problems/#GeometricEquations.ODEProblem","page":"Problems","title":"GeometricEquations.ODEProblem","text":"ODEProblem: Ordinary Differential Equation Problem\n\nOrdinary differential equations define an initial value problem of the form\n\ndotq (t) = v(t q(t)) \n\nwith vector field v.\n\nThe dynamical variables with initial condition q_0 take values in mathbbR^d.\n\nConstructors\n\nODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)\nODEProblem(v, tspan, tstep, q₀::StateVariable; kwargs...)\n\nwhere v is the function computing the vector field,  tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interface of the function v see ODE.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe function v providing the vector field must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params is a NamedTuple of additional parameters on which the vector field may depend.\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.PODEProblem","page":"Problems","title":"GeometricEquations.PODEProblem","text":"PODEProblem: Partitioned Ordinary Differential Equation Problem\n\nA partitioned ordinary differential equation is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \ndotp (t) = f(t q(t) p(t)) \nendaligned\n\nwith vector fields v and f.\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d.\n\nConstructors\n\nPODEProblem(v, f, tspan, tstep, ics; kwargs...)\nPODEProblem(v, f, tspan, tstep, q₀::StateVariable, p₀::StateVariable; kwargs...)\n\nwhere v and f are the function computing the vector fields,  tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v and f see PODE.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v and f must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.HODEProblem","page":"Problems","title":"GeometricEquations.HODEProblem","text":"HODEProblem: Hamiltonian Ordinary Differential Equation Problem\n\nA canonical Hamiltonian system of equations is special case of a partitioned ordinary differential equation,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \ndotp (t) = f(t q(t) p(t)) \nendaligned\n\nwith vector fields v and f, given by\n\nbeginaligned\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in T^* Q simeq mathbbR^d times mathbbR^d.\n\nConstructors\n\nHODEProblem(v, f, hamiltonian, tspan, tstep, ics; kwargs...)\nHODEProblem(v, f, hamiltonian, tspan, tstep, q₀::StateVariable, p₀::StateVariable; kwargs...)\n\nwhere v and f are the function computing the vector fields,  hamiltonian returns the value of the Hamiltonian (i.e. the total energy), tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v, f, poisson and hamiltonian see HODE.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v, f and hamiltonian must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction hamiltonian(t, q, p, params)\n    return ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.IODEProblem","page":"Problems","title":"GeometricEquations.IODEProblem","text":"IODEProblem: Implicit Ordinary Differential Equation Problem\n\nAn implicit ordinary differential equations is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \ndotp (t) = f(t q(t) v(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwith force field f, the momentum defined by p. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMost integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + λ(t)  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) λ(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variable λ with initial condition λ(t_0) = λ_0 takes values in mathbbR^m.\n\nConstructors\n\nIODEProblem(ϑ, f, tspan, tstep, ics; kwargs...)\nIODEProblem(ϑ, f, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\nIODEProblem(ϑ, f, g, tspan, tstep, ics; kwargs...)\nIODEProblem(ϑ, f, g, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\n\nThe functions ϑ, f and g compute the momentum and the vector fields, respectively.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p and λ. The initial conditions q₀ and p₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions ϑ, f and g see IODE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, an IODEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _iode_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. In addition, the functions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, v, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers.\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.LODEProblem","page":"Problems","title":"GeometricEquations.LODEProblem","text":"LODEProblem: Lagrangian Ordinary Differential Equation Problem\n\nA Lagrangian system of equations is a special case of an implicit ordinary differential equations, that is an implicit initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \ndotp (t) = f(t q(t) v(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v  \nf = fracpartial Lpartial q \nendaligned\n\nThis is a special case of an implicit ordinary differential equation, that is defined by a Lagrangian, as well as a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMany integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + lambda(t)  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) lambda(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in T^* Q simeq mathbbR^d times mathbbR^d. The algebraic variable λ with initial condition λ(t_0) = λ_0 takes values in mathbbR^m.\n\nConstructors\n\nLODEProblem(ϑ, f, ω, l, tspan, tstep, ics; kwargs...)\nLODEProblem(ϑ, f, ω, l, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\nLODEProblem(ϑ, f, g, ω, l, tspan, tstep, ics; kwargs...)\nLODEProblem(ϑ, f, g, ω, l, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\n\nwhere ϑ, f and g are the functions computing the momentum and the vector fields, respectively, ω determines the symplectic matrix, and l returns the Lagrangian, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p and λ. The initial conditions q₀, p₀ and λ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}, where λ₀ can also be omitted. For the interfaces of the functions ϑ, f, g, ω and l see LODE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a LODEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _lode_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nand\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers. Finally, the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.SODEProblem","page":"Problems","title":"GeometricEquations.SODEProblem","text":"SODEProblem: Split Ordinary Differential Equation Problem\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nConstructors\n\nSODEProblem(v, q, tspan, tstep, ics::NamedTuple; kwargs...)\nSODEProblem(v, q, tspan, tstep, q₀::StateVariable; kwargs...)\nSODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)\nSODEProblem(v, tspan, tstep, q₀::StateVariable; kwargs...)\n\nwhere v is a tuple of functions computing the vector fields for each substep,  q is an optional tuple of functions computing the solution for each substep, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v_i providing the vector field must have the interface\n\nfunction v_i(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nand the functions q_i providing the solutions must have the interface\n\nfunction q_i(q₁, t₁, q₀, t₀, params)\n    q₁[1] = q₀[1] + ...\n    q₁[2] = q₀[2] + ...\n    ...\nend\n\nwhere t₀ is the current time, q₀ is the current solution vector, q₁ is the new solution vector at time t₁, holding the result of computing one substep\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps. with the vector field v_i.\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#Differential-Algebraic-Equations","page":"Problems","title":"Differential Algebraic Equations","text":"","category":"section"},{"location":"modules/problems/","page":"Problems","title":"Problems","text":"GeometricEquations.DAEProblem\nGeometricEquations.PDAEProblem\nGeometricEquations.HDAEProblem\nGeometricEquations.IDAEProblem\nGeometricEquations.LDAEProblem\nGeometricEquations.SPDAEProblem","category":"page"},{"location":"modules/problems/#GeometricEquations.DAEProblem","page":"Problems","title":"GeometricEquations.DAEProblem","text":"DAEProblem: Differential Algebraic Equation Problem\n\nDefines a differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))  \n0 = phi (t q(t)) \nendaligned\n\nwith vector field v, projection u, algebraic constraint phi=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t)) + baru (t q(t) dotq (t) dotp (t) mu(t))  \n0 = phi (t q(t))  \n0 = psi (t q(t) dotq (t)) \nendaligned\n\nThe dynamical variable q with initial conditions q(t_0) = q_0 takes values in mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nDAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, ics::NamedTuple; kwargs...)\nDAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, q₀::StateVariable, λ₀::StateVariable, μ₀::StateVariable = zero(λ₀); kwargs...)\nDAEProblem(v, u, ϕ, tspan, tstep, ics::NamedTuple; kwargs...)\nDAEProblem(v, u, ϕ, tspan, tstep, q₀::StateVariable, λ₀::StateVariable; kwargs...)\n\nThe functions v and u compute the vector field and the projection, respectively, ϕ provides the algebraic constraint. The functions ψ and ū are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, λ and μ. The initial conditions q₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v, u, ϕ, ū, ψ see DAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a DAEProblem accepts a function v̄ for the computation of an initial guess for the vector field with default value v̄ = v.\n\nFunction Definitions\n\nThe functions v, u and ϕ must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction u(u, t, q, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the DAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\nλ₀ = [0.]\nμ₀ = [0.]\n\nprob = DAEProblem(v, u, ϕ, tspan, tstep, q₀, λ₀)\n\nor\n\nprob = DAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, q₀, λ₀, μ₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.PDAEProblem","page":"Problems","title":"GeometricEquations.PDAEProblem","text":"PDAEProblem: Partitioned Differential Algebraic Equation Problem\n\nA partitioned differential algebraic equation has the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t))  \n0 = phi (t q(t) p(t)) \nendaligned\n\nwith vector fields v and f, projection u and g, algebraic constraint phi=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) mu(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) mu(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq (t) dotp (t)) \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nPDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, ics::NamedTuple; kwargs...)\nPDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable, μ₀::StateVariable = zero(λ₀); kwargs...)\nPDAEProblem(v, f, u, g, ϕ, tspan, tstep, ics::NamedTuple; kwargs...)\nPDAEProblem(v, f, u, g, ϕ, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p, λ and μ. The initial conditions q₀, p₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v, f, u, g, ϕ, ū, ḡ, ψ see PDAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a PDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = v and f̄ = f.\n\nFunction Definitions\n\nThe functions v, f, u, g and ϕ must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q, p and λ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections u and g, and ϕ holds the algebraic constraint phi, evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the PDAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\nμ₀ = [0.]\n\nprob = PDAEProblem(v, f, u, g, ϕ, tspan, tstep, q₀, p₀, λ₀)\n\nor\n\nprob = PDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀, p₀, λ₀, μ₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.HDAEProblem","page":"Problems","title":"GeometricEquations.HDAEProblem","text":"HDAEProblem: Hamiltonian Differential Algebraic Equation\n\nA Hamiltonian differential algebraic is an initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) mu(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) mu(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qpdotqdotp)=0.\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nHDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, ics::NamedTuple; kwargs...)\nHDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable, μ₀::StateVariable = zero(λ₀); kwargs...)\nHDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, ics::NamedTuple; kwargs...)\nHDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, ϕ provides the algebraic constraint and h the Hamiltonian. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p, λ and μ. The initial conditions q₀, p₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v, f, u, g, ϕ, ū, ḡ, ψ, and h see HDAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a HDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = v and f̄ = f.\n\nFunction Definitions\n\nThe functions v, f, u, g, ϕ and h must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nfunction h(t, q, p, params)\n    ...\nend\n\nwhere t is the current time, q, p, λ and μ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections on the primary constraint u and g,  ϕ holds the algebraic constraint phi, and h returns the Hamiltonian of the system, all evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the HDAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\nμ₀ = [0.]\n\nprob = HDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, q₀, p₀, λ₀)\n\nor\n\nprob = HDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, q₀, p₀, λ₀, μ₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.IDAEProblem","page":"Problems","title":"GeometricEquations.IDAEProblem","text":"IDAEProblem: Implicit Differential Algebraic Equation Problem\n\nAn implicit differential algebraic initial value problem takes the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t))  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t)) \nendaligned\n\nwith force field f, the momentum defined by ϑ, projections u and g, algebraic constraint phi(tqvp)=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) mu(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) mu(t))  \np(t) = ϑ(t q(t) v(t))   \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq (t) dotp (t)) \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nIDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, ics; kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀), μ₀::StateVariable = zero(λ₀); kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, tspan, tstep, ics; kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀, p₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions ϑ, f, u, g, ϕ, ū, ḡ, ψ see IDAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, an IDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _idae_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v, params)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.LDAEProblem","page":"Problems","title":"GeometricEquations.LDAEProblem","text":"LDAEProblem: Lagrangian Differential Algebraic Equation Problem\n\nA special case of an implicit initial value problem is a Lagrangian differential algebraic equation of the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) mu(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) mu(t))  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v (qv)  \nf = fracpartial Lpartial q (qv) \nendaligned\n\nprojection fields u, baru and g, barg. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and mu.\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nLDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, ics; kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀), μ₀::StateVariable = zero(λ₀); kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, ics; kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀, p₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω and l see LDAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a LDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _ldae_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v, params)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nand the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the LDAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\nμ₀ = [0.]\n\nprob = LDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, q₀, p₀, λ₀)\n\nor\n\nprob = LDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, q₀, p₀, λ₀, μ₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.SPDAEProblem","page":"Problems","title":"GeometricEquations.SPDAEProblem","text":"\n\n\n\n","category":"type"},{"location":"modules/problems/#Stochastic-Differential-Equations","page":"Problems","title":"Stochastic Differential Equations","text":"","category":"section"},{"location":"modules/problems/","page":"Problems","title":"Problems","text":"GeometricEquations.SDEProblem\nGeometricEquations.PSDEProblem\nGeometricEquations.SPSDEProblem","category":"page"},{"location":"modules/problems/#GeometricEquations.SDEProblem","page":"Problems","title":"GeometricEquations.SDEProblem","text":"SDEProblem: Stratonovich Stochastic Differential Equation Problem\n\nDefines a stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendaligned\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nSDEProblem(v, B, tspan, tstep, ics::NamedTuple; kwargs...)\nSDEProblem(v, B, tspan, tstep, q₀::StateVariable; kwargs...)\n\nwhere v is the function computing the vector field and B computes the diffusion matrix tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v and B, providing the drift vector field and diffusion matrix. The function v must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params are additional parameters. The function B should have a method with interface\n\nfunction B(B, t, q, params)\n    B[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.PSDEProblem","page":"Problems","title":"GeometricEquations.PSDEProblem","text":"PSDEProblem: Stratonovich Partitioned Stochastic Differential Equation Problem\n\nA partitioned stochastic differential equations is an initial value problem of the form\n\nbeginaligned\ndq (t) = v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) = f(t q(t) p(t))  dt + G(t q(t) p(t)) circ dW   p(t_0) = p_0\nendaligned\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nPSDEProblem(v, f, B, G, tspan, tstep, ics::NamedTuple; kwargs...)\nPSDEProblem(v, f, B, G, tspan, tstep, q₀::StateVariable; p₀::StateVariable; kwargs...)\n\nwhere v and f are the functions computing the vector field and B and G compute the diffusion matrices, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, each take five arguments, v(v, t, q, p, params), f(f, t, q, p, params), B(B, t, q, p, params) and G(G, t, q, p, params), where t is the current time, (q, p) is the current solution, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p), and params are optional parameters.\n\nThe corresponding methods should have the following signatures:\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.SPSDEProblem","page":"Problems","title":"GeometricEquations.SPSDEProblem","text":"SPSDEProblem: Stratonovich Split Partitioned Stochastic Differential Equation Problem\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) =   v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) =  f_1(t q(t) p(t)) + f_2(t q(t) p(t))   dt +  G_1(t q(t) p(t)) + G_2(t q(t) p(t))  circ dW   p(t_0) = p_0 \nendaligned\n\nwith the drift vector fields v and f_i, diffusion matrices B and G_i, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nSPSDEProblem(v, f1, f2, B, G1, G2, tspan, tstep, ics::NamedTuple; kwargs...)\nSPSDEProblem(v, f1, f2, B, G1, G2, tspan, tstep, q₀::StateVariable; p₀::StateVariable; kwargs...)\n\nwhere v and f are the functions computing the vector field and Bᵢ and Gᵢ compute the diffusion matrices, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v, f1, f2, B, G1 and G2, providing the drift vector fields and diffusion matrices, all take five arguments, (out, t, q, p, params).\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f1(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction f2(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G1(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nfunction G2(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nwhere t is the current time, (q,p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B_i, G_i on (t,q,p).\n\n\n\n\n\n","category":"type"},{"location":"developer/custom_integrators/#Custom-Integrators","page":"Custom Integrators","title":"Custom Integrators","text":"","category":"section"},{"location":"modules/integrators/#Integrators","page":"Integrators","title":"Integrators","text":"","category":"section"},{"location":"modules/integrators/#Geometric-Integrator","page":"Integrators","title":"Geometric Integrator","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\n            \"integrators/integrator_cache.jl\",\n            \"integrators/integrator.jl\",\n        ]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.GeometricIntegrator","page":"Integrators","title":"GeometricIntegrators.Integrators.GeometricIntegrator","text":"GeometricIntegrator\n\nCollects all data structures needed by an integrator:\n\nproblem: EquationProblem to solve\nmethod: integration method\ncache: temprary data structures needed by method\nsolver: linear or nonlinear solver needed by method\niguess: initial guess for implicit methods\nprojection: optional projection method\n\nConstructors:\n\nGeometricIntegrator(problem::EquationProblem, method::GeometricMethod; solver = default_solver(method), iguess = default_iguess(method), projection = default_projection(method))\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricBase.integrate!-Tuple{GeometricSolution, GeometricIntegrators.Integrators.DeterministicIntegrator, Int64, Int64}","page":"Integrators","title":"GeometricBase.integrate!","text":"Solve for time steps n with n₁ ≤ n ≤ n₂.\n\nintegrate!(solution, integrator, n₁, n₂)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricBase.integrate!-Tuple{GeometricSolution, GeometricIntegrators.Integrators.DeterministicIntegrator}","page":"Integrators","title":"GeometricBase.integrate!","text":"Solve for all time steps n:\n\nintegrate!(solution, integrator)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.internal_variables-Tuple{GeometricIntegrator}","page":"Integrators","title":"GeometricIntegrators.Integrators.internal_variables","text":"internal_variables(::Integrator) = NamedTuple()\n\nReturns a NamedTuple containing all internal variables of an integrator that shall be stored in an SolutionStep. If there is no method for a specific integrator implemented an empty NamedTuple() is returned.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Initial-Guesses","page":"Integrators","title":"Initial Guesses","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\n            \"initial_guess/initial_guess.jl\",\n            \"initial_guess/hermite.jl\",\n            \"initial_guess/midpoint.jl\",\n          ]","category":"page"},{"location":"modules/integrators/#Extrapolation-Methods","page":"Integrators","title":"Extrapolation Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"The extrapolation routines are exclusively used for computing initial guesses and are usually not called directly by the user.","category":"page"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Extrapolators]\nOrder   = [:constant, :type, :macro, :function]\nPages   = [\"extrapolation/extrapolation.jl\",\n           \"extrapolation/aitken_neville.jl\",\n           \"extrapolation/euler.jl\",\n           \"extrapolation/hermite.jl\",\n           \"extrapolation/midpoint.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Extrapolators.aitken_neville!-Union{Tuple{TT}, Tuple{AbstractVector, TT, AbstractVector{TT}, AbstractMatrix}} where TT","page":"Integrators","title":"GeometricIntegrators.Extrapolators.aitken_neville!","text":"Compute p(x) where p is the unique polynomial of degree length(xi), such that p(x[i]) = y[i]) for all i. Call with\n\naitken_neville!(x::AbstractVector, t::Real, ti::AbstractVector, xi::AbstractMatrix)\n\nwhere\n\nx:  evaluation value\nt:  evaluation point\nti: interpolation nodes\nxi: interpolation values\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Extrapolators.EulerExtrapolation","page":"Integrators","title":"GeometricIntegrators.Extrapolators.EulerExtrapolation","text":"Euler extrapolation method with arbitrary order p.\n\nSolves the ordinary differential equation\n\nbeginaligned\ndotx = v(t x)  \nx(t_0) = x_0 \nendaligned\n\nfor x_1 = x(t_1), and is called with\n\nextrapolate!(t₀, x₀, t₁, x₁, problem, EulerExtrapolation(s))\n\nwhere\n\nt₀: initial time\nt₁: final   time\nx₀: initial value x_0 = x(t_0)\nx₁: final   value x_1 = x(t_1)\nproblem: ODEProblem whose solution to extrapolate\ns:  number of interpolations (order p=s+1)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Extrapolators.HermiteExtrapolation","page":"Integrators","title":"GeometricIntegrators.Extrapolators.HermiteExtrapolation","text":"Hermite's Interpolating Polynomials\n\nImplements a two point Hermite inter-/extrapolation function which passes through the function and its first derivative for the interval 01. The polynomial is determined by four constraint equations, matching the function and its derivative at the points 0 and 1.\n\nCall with one of the following methods\n\nextrapolate!(t₀, x₀, ẋ₀, t₁, x₁, ẋ₁, t, x, HermiteExtrapolation())\nextrapolate!(t₀, x₀, ẋ₀, t₁, x₁, ẋ₁, t, x, ẋ, HermiteExtrapolation())\nextrapolate!(t₀, x₀, t₁, x₁, t, x, v, HermiteExtrapolation())\nextrapolate!(t₀, x₀, t₁, x₁, t, x, ẋ, v, HermiteExtrapolation())\nextrapolate!(t₀, x₀, t₁, x₁, t, x, problem, HermiteExtrapolation())\nextrapolate!(t₀, x₀, t₁, x₁, t, x, ẋ, problem, HermiteExtrapolation())\n\nwhere\n\nt₀: first  sample time t_0\nx₀: first  solution value x_0 = x(t_0)\nẋ₀: first  vector field value x_0 = v(t_0 x(t_0))\nt₁: second sample time t_1\nx₁: second solution value x_1 = x(t_1)\nẋ₁: second vector field value x_1 = v(t_1 x(t_1))\nt:  time t to extrapolate\nx:  extrapolated solution value x(t)\nẋ:  extrapolated vector field value x(t)\nv:  function to compute vector field with signature v(ẋ,t,x)\nproblem: ODEProblem whose vector field to use\n\nDerivation\n\nThe interpolation works as follows: Start by defining the 3rd degree polynomial and its derivative by\n\nbeginaligned\ng(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3  \ng(x) = a_1 + 2 a_2 x + 3 a_3 x^2 \nendaligned\n\nand apply the constraints\n\nbeginaligned\ng(0) = f_0   Rightarrow  a_0 = f_0  \ng(1) = f_1   Rightarrow  a_0 + a_1 + a_2 + a_3 = f_1  \ng(0) = f_0   Rightarrow  a_1 = f_0  \ng(1) = f_1   Rightarrow  a_1 + 2 a_2 + 3 a_3 = f_1  \nendaligned\n\nSolving for a_0 a_1 a_2 a_3 leads to\n\nbeginaligned\na_0 = f_0  \na_1 = f_0  \na_2 = - 3 f_0 + 3 f_1 - 2 f_0 - f_1  \na_3 = 2 f_0 - 2 f_1 + f_0 + f_1 \nendaligned\n\nso that the polynomial g(x) reads\n\ng(x) = f_0 + f_0 x + (- 3 f_0 + 3 f_1 - 2 f_0 - f_1) x^2 + (2 f_0 - 2 f_1 + f_0 + f_1) x^3 \n\nThe function and derivative values can be factored out, so that g(x) can be rewritten as\n\ng(x) = f_0 (1 - 3 x^2 + 2 x^3) + f_1 (3 x^2 - 2 x^3) + f_0 (x - 2 x^2 + x^3) + f_1 (- x^2 + x^3) \n\nor in generic form as\n\ng(x) = f_0 a_0(x) + f_1 a_1(x) + f_0 b_0(x) + f_1 b_1(x) \n\nwith basis functions\n\nbeginaligned\na_0 (x) = 1 - 3 x^2 + 2 x^3  \nb_0 (x) = x - 2 x^2 + x^3  \na_1 (x) = 3 x^2 - 2 x^3  \nb_1 (x) = - x^2 + x^3 \nendaligned\n\nThe derivative g(x) accordingly reads\n\ng(x) = f_0 a_0(x) + f_1 a_1(x) + f_0 b_0(x) + f_1 b_1(x) \n\nwith\n\nbeginaligned\na_0 (x) = - 6 x + 6 x^2  \nb_0 (x) = 1 - 4 x + 3 x^2  \na_1 (x) = 6 x - 6 x^2  \nb_1 (x) = - 2 x + 3 x^2 \nendaligned\n\nThe basis functions a_0and a_1 are associated with the function values at x_0 and x_1, respectively, while the basis functions b_0 and b_1 are associated with the derivative values at x_0 and x_1. The basis functions satisfy the following relations,\n\nbeginaligned\na_i (x_j) = delta_ij  \nb_i (x_j) = 0  \na_i (x_j) = 0  \nb_i (x_j) = delta_ij  \nij = 0 1 \nendaligned\n\nwhere delta_ij denotes the Kronecker-delta, so that\n\nbeginaligned\ng(0) = f_0  \ng(1) = f_1  \ng(0) = f_0  \ng(1) = f_1 \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Extrapolators.MidpointExtrapolation","page":"Integrators","title":"GeometricIntegrators.Extrapolators.MidpointExtrapolation","text":"Midpoint extrapolation method with arbitrary order p.\n\nFor an ODEProblem, this solves the ordinary differential equation\n\nbeginaligned\ndotx = v(t x)  \nx(t_0) = x_0 \nendaligned\n\nfor x_1 = x(t_1), and is called with\n\nextrapolate!(t₀, x₀, t₁, x₁, ::ODEProblem, MidpointExtrapolation(s))\n\nwhere\n\nt₀: initial time\nx₀: initial value x_0 = x(t_0)\nt₁: final   time\nx₁: final   value x_1 = x(t_1)\ns:  number of interpolations (order p=2s+2)\n\nFor a PODEProblem or HODEProblem, this solves the partitioned ordinary differential equation\n\nbeginaligned\ndotq = v(t q p)  \nq(t_0) = q_0  \ndotp = f(t q p)  \np(t_0) = p_0  \nendaligned\n\nfor q_1 = q(t_1) and p_1 = p(t_1)m and is called with\n\nextrapolate!(t₀, q₀, p₀, t₁, q₁, p₁, ::PODEProblem, MidpointExtrapolation(s))\nextrapolate!(t₀, q₀, p₀, t₁, q₁, p₁, ::HODEProblem, MidpointExtrapolation(s))\n\nwhere\n\nt₀: initial time\nq₀: initial position q_0 = q(t_0)\np₀: initial momentum p_0 = p(t_0)\nt₁: final   time\nq₁: final   position q_1 = q(t_1)\np₁: final   momentum p_1 = p(t_1)\ns:  number of interpolations (order p=2s+2)\n\nSimilarly, for a IODEProblem or LODEProblem, this solves the explicit dynamical equation\n\nbeginaligned\ndotq = v(t q)  \nq(t_0) = q_0  \ndotp = f(t q v)  \np(t_0) = p_0  \nendaligned\n\ncorresponding to the implicit problem, for q_1 = q(t_1) and p_1 = p(t_1), and is called with\n\nextrapolate!(t₀, q₀, p₀, t₁, q₁, p₁, ::IODEProblem, MidpointExtrapolation(s))\nextrapolate!(t₀, q₀, p₀, t₁, q₁, p₁, ::LODEProblem, MidpointExtrapolation(s))\n\nwhere\n\nt₀: initial time\nq₀: initial position q_0 = q(t_0)\np₀: initial momentum p_0 = p(t_0)\nt₁: final   time\nq₁: final   position q_1 = q(t_1)\np₁: final   momentum p_1 = p(t_1)\ns:  number of interpolations (order p=2s+2)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Euler-Integrators","page":"Integrators","title":"Euler Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\n            \"integrators/euler/explicit_euler.jl\",\n            \"integrators/euler/implicit_euler.jl\",\n        ]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ExplicitEuler","page":"Integrators","title":"GeometricIntegrators.Integrators.ExplicitEuler","text":"Explicit Euler Method.\n\nReference:\n\nLeonhard Euler.\nInstitutiones calculi differentialis cum eius vsu in analysi finitorum ac doctrina serierum.\nImp. Acad. Imper. Scient. Petropolitanae, Opera Omnia, Vol.X, [I.6], 1755.\nIn: Opera Omnia, 1st Series, Volume 11, Institutiones Calculi Integralis. Teubner, Leipzig, Pages 424-434, 1913.\nSectio secunda. Caput VII. De integratione aequationum differentialium per approximationem. Problema 85.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ImplicitEuler","page":"Integrators","title":"GeometricIntegrators.Integrators.ImplicitEuler","text":"Implicit Euler Method.\n\nReference:\n\nAugustin-Louis Cauchy.\nÉquations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.\nEd. Christian Gilain, Etudes Vivantes, 1981.\nPage 102, Equation (5), Θ=1.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ImplicitEulerCache","page":"Integrators","title":"GeometricIntegrators.Integrators.ImplicitEulerCache","text":"Implicit Euler integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Runge-Kutta-Integrators","page":"Integrators","title":"Runge-Kutta Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/rk/abstract.jl\",\n           \"integrators/rk/common.jl\",\n           \"integrators/rk/tableaus.jl\",\n           \"integrators/rk/updates.jl\",\n           \"integrators/rk/integrators_erk.jl\",\n           \"integrators/rk/integrators_irk.jl\",\n           \"integrators/rk/integrators_irk_implicit.jl\",\n           \"integrators/rk/integrators_dirk.jl\",\n           \"integrators/rk/integrators_eprk.jl\",\n           \"integrators/rk/integrators_iprk.jl\",\n           \"integrators/rk/integrators_iprk_implicit.jl\",\n           \"integrators/rk/methods.jl\",\n          ]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_matrix-NTuple{4, Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_matrix","text":"Create a vector of S solution matrices of type DT to store the solution of S internal stages for a problem with DxM dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector-Tuple{Any, Any, Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector","text":"Create a vector of S solution vectors of type DT to store the solution of S internal stages for a problem with D dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero-NTuple{4, Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero","text":"Create a vector of (S,M+1) solution vectors of type DT to store the solution of S internal stages and M random processes for a problem with D dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero-Tuple{Any, Any, Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero","text":"Create a vector of S+1 solution vectors of type DT to store the solution of S internal stages and the solution of the previous timestep for a problem with D     dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ERK","page":"Integrators","title":"GeometricIntegrators.Integrators.ERK","text":"Explicit Runge-Kutta Method\n\nERK(tableau)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ERKCache","page":"Integrators","title":"GeometricIntegrators.Integrators.ERKCache","text":"Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ERKMethod","page":"Integrators","title":"GeometricIntegrators.Integrators.ERKMethod","text":"Explicit Runge-Kutta method solving the system\n\nbeginaligned\nV_ni = v (t_i Q_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IRK","text":"Implicit Runge-Kutta Method\n\nIRK(tableau)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IRKCache","page":"Integrators","title":"GeometricIntegrators.Integrators.IRKCache","text":"Implicit Runge-Kutta integrator cache.\n\nFields\n\nx: nonlinear solver solution vector\nq̄: solution at previous timestep\nQ: internal stages of solution\nV: internal stages of vector field\nY: vector field of internal stages\nJ: Jacobi matrices for all internal stages\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IRKMethod","page":"Integrators","title":"GeometricIntegrators.Integrators.IRKMethod","text":"Implicit Runge-Kutta method solving the explicit system of equations for ODEs\n\nbeginaligned\nV_ni = v (t_i Q_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni \nendaligned\n\nor the implicit systems of equations for IODEs and LODEs,\n\nbeginaligned\nP_ni = vartheta (Q_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nF_ni = f (Q_ni V_ni)  \nP_ni = p_n + h sum limits_i=1^s bara_ij  F_nj \nendaligned\n\nIf implicit_update is set to true, the update is computed by solving\n\nvartheta(q_n+1) = vartheta(q_n) + h sum limits_i=1^s b_i   f (Q_nj V_nj) \n\notherwise it is computed explicitly by\n\nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni \n\nUsually we are interested in Lagrangian systems, where\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni) \nendaligned\n\nand tableaus satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IRKimplicitCache","page":"Integrators","title":"GeometricIntegrators.Integrators.IRKimplicitCache","text":"Implicit Runge-Kutta integrator cache.\n\nFields\n\nq̄: solution at previous timestep\np̄: momentum at previous timestep\nQ: internal stages of solution\nV: internal stages of vector field\nΘ: internal stages of one-form vartheta\nF: internal stages of force field\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.DIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.DIRK","text":"Diagonally Implicit Runge-Kutta Method\n\nDIRK(tableau)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.DIRKCache","page":"Integrators","title":"GeometricIntegrators.Integrators.DIRKCache","text":"Diagonally implicit Runge-Kutta integrator cache.\n\nFields\n\nx: nonlinear solver solution vector\nQ: internal stages of solution q\nV: internal stages of vector field v = q̇\nY: summed vector field of internal stages Q\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.DIRKMethod","page":"Integrators","title":"GeometricIntegrators.Integrators.DIRKMethod","text":"Diagonally implicit Runge-Kutta integrator solving the system\n\nbeginaligned\nV_ni = v (t_i Q_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.EPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.EPRK","text":"Explicit Partitioned Runge-Kutta Method\n\nEPRK(tableau)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.EPRKCache","page":"Integrators","title":"GeometricIntegrators.Integrators.EPRKCache","text":"Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.EPRKMethod","page":"Integrators","title":"GeometricIntegrators.Integrators.EPRKMethod","text":"Explicit partitioned Runge-Kutta method solving the system\n\nbeginaligned\nV_ni = v (t_i Q_ni P_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = f (t_i Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nUsually we are interested in Hamiltonian systems, where\n\nbeginaligned\nV_ni = dfracpartial Hpartial p (Q_ni P_ni)  \nF_ni = - dfracpartial Hpartial q (Q_ni P_ni)  \nendaligned\n\nand tableaus satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IPRK","text":"Implicit Partitioned Runge-Kutta Method\n\nIPRK(tableau)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IPRKCache","page":"Integrators","title":"GeometricIntegrators.Integrators.IPRKCache","text":"Implicit partitioned Runge-Kutta integrator cache.\n\nFields\n\nx: nonlinear solver solution vector\nq̄: solution at previous timestep\np̄: momentum at previous timestep\nQ: internal stages of solution q\nP: internal stages of momentum p\nV: internal stages of vector field v = q̇\nF: internal stages of vector field f = ṗ\nY: summed vector field of internal stages Q\nZ: summed vector field of internal stages P\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IPRKMethod","page":"Integrators","title":"GeometricIntegrators.Integrators.IPRKMethod","text":"Implicit partitioned Runge-Kutta method solving the system\n\nbeginaligned\nV_ni = v (t_i Q_ni P_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = f (t_i Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nUsually we are interested in Hamiltonian systems, where\n\nbeginaligned\nV_ni = dfracpartial Hpartial p (Q_ni P_ni)  \nF_ni = - dfracpartial Hpartial q (Q_ni P_ni)  \nendaligned\n\nand tableaus satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\nFor implicit equations like IODEs and LODEs this method is solving the system\n\nbeginaligned\nP_ni = vartheta (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = f (Q_ni V_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nUsually we are interested in Lagrangian systems, where\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni) \nendaligned\n\nand tableaus satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.BackwardEuler","page":"Integrators","title":"GeometricIntegrators.Integrators.BackwardEuler","text":"Fully implicit Runge-Kutta method with TableauBackwardEuler.\n\nReference:\n\nAugustin-Louis Cauchy.\nÉquations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.\nEd. Christian Gilain, Etudes Vivantes, 1981.\nPage 102, Equation (5), Θ=1.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.CrankNicolson","page":"Integrators","title":"GeometricIntegrators.Integrators.CrankNicolson","text":"Diagonally implicit Runge-Kutta method with TableauCrankNicolson.\n\nReference:\n\nJ. Crank and P. Nicolson.\nA practical method for numerical evaluation of solutions of partial differential equations of the heat-conduction type.\nMathematical Proceedings of the Cambridge Philosophical Society, Volume 43, Issue 1, Pages 50-67, 1947.\ndoi: 10.1017/S0305004100023197\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Crouzeix","page":"Integrators","title":"GeometricIntegrators.Integrators.Crouzeix","text":"Diagonally implicit Runge-Kutta method with TableauCrouzeix.\n\nReference:\n\nM.Crouzeix.\nSur L'approximation des équations différentielles opérationelles linéaires par des méthodes de Runge-Kutta.\nThesis. Université de Paris, 1975.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ExplicitEulerRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ExplicitEulerRK","text":"Explicit Runge-Kutta method with TableauExplicitEuler.\n\nReference:\n\nLeonhard Euler.\nInstitutiones calculi differentialis cum eius vsu in analysi finitorum ac doctrina serierum.\nImp. Acad. Imper. Scient. Petropolitanae, Opera Omnia, Vol.X, [I.6], 1755.\nIn: Opera Omnia, 1st Series, Volume 11, Institutiones Calculi Integralis. Teubner, Leipzig, Pages 424-434, 1913.\nSectio secunda. Caput VII. De integratione aequationum differentialium per approximationem. Problema 85.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ExplicitMidpoint","page":"Integrators","title":"GeometricIntegrators.Integrators.ExplicitMidpoint","text":"Explicit Runge-Kutta method with TableauExplicitMidpoint.\n\nReference:\n\nCarl Runge.\nÜber die numerische Auflösung von Differentialgleichungen.\nMathematische Annalen, Volume 46, Pages 167-178, 1895.\ndoi: 10.1007/BF01446807.\nEquation (2)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ForwardEuler","page":"Integrators","title":"GeometricIntegrators.Integrators.ForwardEuler","text":"Explicit Runge-Kutta method with TableauForwardEuler.\n\nReference:\n\nLeonhard Euler.\nInstitutiones calculi differentialis cum eius vsu in analysi finitorum ac doctrina serierum.\nImp. Acad. Imper. Scient. Petropolitanae, Opera Omnia, Vol.X, [I.6], 1755.\nIn: Opera Omnia, 1st Series, Volume 11, Institutiones Calculi Integralis. Teubner, Leipzig, Pages 424-434, 1913.\nSectio secunda. Caput VII. De integratione aequationum differentialium per approximationem. Problema 85.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Gauss","page":"Integrators","title":"GeometricIntegrators.Integrators.Gauss","text":"Fully implicit Runge-Kutta method with TableauGauss.\n\nReferences:\n\nJohn C. Butcher.\nImplicit Runge-Kutta processes.\nMathematics of Computation, Volume 18, Pages 50-64, 1964.\ndoi: 10.1090/S0025-5718-1964-0159424-9.\n\nJohn C. Butcher.\nGauss Methods. \nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_115.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Heun2","page":"Integrators","title":"GeometricIntegrators.Integrators.Heun2","text":"Explicit Runge-Kutta method with TableauHeun2.\n\nReference:\n\nKarl Heun.\nNeue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.\nZeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.\nAlgorithm II.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Heun3","page":"Integrators","title":"GeometricIntegrators.Integrators.Heun3","text":"Explicit Runge-Kutta method with TableauHeun3.\n\nReference:\n\nKarl Heun.\nNeue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.\nZeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.\nAlgorithm VI.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ImplicitEulerRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ImplicitEulerRK","text":"Fully implicit Runge-Kutta method with TableauImplicitEuler.\n\nReference:\n\nAugustin-Louis Cauchy.\nÉquations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.\nEd. Christian Gilain, Etudes Vivantes, 1981.\nPage 102, Equation (5), Θ=1.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ImplicitMidpoint","page":"Integrators","title":"GeometricIntegrators.Integrators.ImplicitMidpoint","text":"Fully implicit Runge-Kutta method with TableauImplicitMidpoint.\n\nReference:\n\nAugustin-Louis Cauchy.\nÉquations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.\nEd. Christian Gilain, Etudes Vivantes, 1981.\nPage 102, Equation (5), Θ=1/2.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.KraaijevangerSpijker","page":"Integrators","title":"GeometricIntegrators.Integrators.KraaijevangerSpijker","text":"Diagonally implicit Runge-Kutta method with TableauKraaijevangerSpijker.\n\nReference:\n\nJ. F. B. M. Kraaijevanger and M. N. Spijker.\nAlgebraic stability and error propagation in Runge-Kutta methods.\nApplied Numerical Mathematics, Volume 5, Issues 1-2, Pages 71-87, 1989.\ndoi: 10.1016/0168-9274(89)90025-1\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Kutta3","page":"Integrators","title":"GeometricIntegrators.Integrators.Kutta3","text":"Explicit Runge-Kutta method with TableauKutta3.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.\nPage 440\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIII","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIII","text":"Runge-Kutta method with TableauLobattoIII.\n\nReferences:\n\nJohn C. Butcher.\nIntegration processes based on Radau quadrature formulas\nMathematics of Computation, Volume 18, Pages 233-244, 1964.\ndoi: 10.1090/S0025-5718-1964-0165693-1.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIA","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIA","text":"Runge-Kutta method with TableauLobattoIIIA.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIAIIIB","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIAIIIB","text":"Partitioned Runge-Kutta method with TableauLobattoIIIA for q and TableauLobattoIIIB for p.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIAIIIĀ","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIAIIIĀ","text":"Partitioned Runge-Kutta method with TableauLobattoIIIA for q and TableauLobattoIIIĀ for p.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIB","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIB","text":"Runge-Kutta method with TableauLobattoIIIB.\n\nReferences:\n\nByron Leonard Ehle.\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIBIIIA","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIBIIIA","text":"Partitioned Runge-Kutta method with TableauLobattoIIIB for q and TableauLobattoIIIA for p.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIBIIIB̄","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIBIIIB̄","text":"Partitioned Runge-Kutta method with TableauLobattoIIIB for q and TableauLobattoIIIB̄ for p.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIC","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIC","text":"Runge-Kutta method with TableauLobattoIIIC.\n\nReferences:\n\nF. H. Chipman.\nA-stable Runge-Kutta processes.\nBIT, Volume 11, Pages 384-388, 1971.\ndoi: 10.1007/BF01939406.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIICIIIC̄","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIICIIIC̄","text":"Partitioned Runge-Kutta method with TableauLobattoIIIC for q and TableauLobattoIIIC̄ for p.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIC̄IIIC","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIC̄IIIC","text":"Partitioned Runge-Kutta method with TableauLobattoIIIC̄ for q and TableauLobattoIIIC for p.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIID","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIID","text":"Runge-Kutta method with TableauLobattoIIID.\n\nReferences:\n\nR.P.K. Chan.\nOn symmetric Runge-Kutta methods of high order.\nComputing, Volume 45, Pages 301-309, 1990.\ndoi: 10.1007/BF02238798\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIDIIID̄","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIDIIID̄","text":"Partitioned Runge-Kutta method with TableauLobattoIIID for q and TableauLobattoIIID̄ for p.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIE","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIE","text":"Runge-Kutta method with TableauLobattoIIIE.\n\nReferences:\n\nR.P.K. Chan.\nOn symmetric Runge-Kutta methods of high order.\nComputing, Volume 45, Pages 301-309, 1990.\ndoi: 10.1007/BF02238798\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIEIIIĒ","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIEIIIĒ","text":"Partitioned Runge-Kutta method with TableauLobattoIIIE for q and TableauLobattoIIIĒ for p.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIF","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIF","text":"Runge-Kutta method with TableauLobattoIIIF.\n\nReferences:\n\nWang Fangzong and Liao Xiaobing.\nA Class of Lobatto Methods of Order 2s.\nJournal of Applied Mathematics, Volume 46, Pages 6-10, 2016.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIFIIIF̄","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIFIIIF̄","text":"Partitioned Runge-Kutta method with TableauLobattoIIIF for q and TableauLobattoIIIF̄ for p.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIF̄","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIF̄","text":"Runge-Kutta method with TableauLobattoIIIF̄.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIF̄IIIF","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIF̄IIIF","text":"Partitioned Runge-Kutta method with TableauLobattoIIIF̄ for q and TableauLobattoIIIF for p.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIG","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIG","text":"Runge-Kutta method with TableauLobattoIIIG.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LobattoIIIGIIIḠ","page":"Integrators","title":"GeometricIntegrators.Integrators.LobattoIIIGIIIḠ","text":"Partitioned Runge-Kutta method with TableauLobattoIIIG for q and TableauLobattoIIIḠ for p.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.PartitionedGauss","page":"Integrators","title":"GeometricIntegrators.Integrators.PartitionedGauss","text":"Partitioned Runge-Kutta method TableauGauss for both q and p.\n\nReferences:\n\nJohn C. Butcher.\nImplicit Runge-Kutta processes.\nMathematics of Computation, Volume 18, Pages 50-64, 1964.\ndoi: 10.1090/S0025-5718-1964-0159424-9.\n\nJohn C. Butcher.\nGauss Methods. \nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_115.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.QinZhang","page":"Integrators","title":"GeometricIntegrators.Integrators.QinZhang","text":"Diagonally implicit Runge-Kutta method with TableauQinZhang.\n\nReference:\n\nM.-Z. Qin and M.-Q. Zhang.\nSymplectic Runge-Kutta algorithms for Hamilton systems.\nJournal of Computational Mathematics, Supplementary Issue, Pages 205-215, 1992.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RK21","page":"Integrators","title":"GeometricIntegrators.Integrators.RK21","text":"Explicit Runge-Kutta method with TableauRK21.\n\nReference:\n\nKarl Heun.\nNeue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.\nZeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.\nAlgorithm II.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RK22","page":"Integrators","title":"GeometricIntegrators.Integrators.RK22","text":"Explicit Runge-Kutta method with TableauRK22.\n\nReference:\n\nCarl Runge\nÜber die numerische Auflösung von Differentialgleichungen.\nMathematische Annalen, Volume 46, Pages 167-178, 1895.\ndoi: 10.1007/BF01446807.\nEquation (3)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RK31","page":"Integrators","title":"GeometricIntegrators.Integrators.RK31","text":"Explicit Runge-Kutta method with TableauRK31.\n\nReference:\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 99\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RK32","page":"Integrators","title":"GeometricIntegrators.Integrators.RK32","text":"Explicit Runge-Kutta method with TableauRK32.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.\nPage 440\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RK4","page":"Integrators","title":"GeometricIntegrators.Integrators.RK4","text":"Explicit Runge-Kutta method with TableauRK4.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.\nPage 443\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RK41","page":"Integrators","title":"GeometricIntegrators.Integrators.RK41","text":"Explicit Runge-Kutta method with TableauRK41.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.\nPage 443\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RK416","page":"Integrators","title":"GeometricIntegrators.Integrators.RK416","text":"Explicit Runge-Kutta method with TableauRK416.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.\nPage 443\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RK42","page":"Integrators","title":"GeometricIntegrators.Integrators.RK42","text":"Explicit Runge-Kutta method with TableauRK42.\n\nReference:\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 102\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RK438","page":"Integrators","title":"GeometricIntegrators.Integrators.RK438","text":"Explicit Runge-Kutta method with TableauRK438.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.\nPage 441\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RK5","page":"Integrators","title":"GeometricIntegrators.Integrators.RK5","text":"Explicit Runge-Kutta method with TableauRK5.\n\nReference:\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 103\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RadauIA","page":"Integrators","title":"GeometricIntegrators.Integrators.RadauIA","text":"Runge-Kutta method with TableauRadauIA.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RadauIB","page":"Integrators","title":"GeometricIntegrators.Integrators.RadauIB","text":"Runge-Kutta method with TableauRadauIB.\n\nReference:\n\nSun Geng\nConstruction of high order symplectic Runge-Kutta methods\nJournal of Computational Mathematics, Volume 11, Pages 250-260, 1993.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RadauIIA","page":"Integrators","title":"GeometricIntegrators.Integrators.RadauIIA","text":"Runge-Kutta method with TableauRadauIIA.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nOwe Axelsson.\nA class of A-stable methods.\nBIT, Volume 9, Pages 185-199, 1969.\ndoi: 10.1007/BF01946812.\n\nErnst Hairer and Gerhard Wanner.\nRadau Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_139.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RadauIIB","page":"Integrators","title":"GeometricIntegrators.Integrators.RadauIIB","text":"Runge-Kutta method with TableauRadauIIB.\n\nReference:\n\nSun Geng\nConstruction of high order symplectic Runge-Kutta methods\nJournal of Computational Mathematics, Volume 11, Pages 250-260, 1993.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Ralston2","page":"Integrators","title":"GeometricIntegrators.Integrators.Ralston2","text":"Explicit Runge-Kutta method with TableauRalston2.\n\nReference:\n\nAnthony Ralston.\nRunge-Kutta Methods with Minimum Error Bounds.\nMathematics of Computation, Volume 16, Pages 431-437, 1962.\ndoi: 10.1090/S0025-5718-1962-0150954-0.\nEquation (3.5)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Ralston3","page":"Integrators","title":"GeometricIntegrators.Integrators.Ralston3","text":"Explicit Runge-Kutta method with TableauRalston3.\n\nReference:\n\nAnthony Ralston.\nRunge-Kutta Methods with Minimum Error Bounds.\nMathematics of Computation, Volume 16, Pages 431-437, 1962.\ndoi: 10.1090/S0025-5718-1962-0150954-0.\nEquation (4.10)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Runge2","page":"Integrators","title":"GeometricIntegrators.Integrators.Runge2","text":"Explicit Runge-Kutta method with TableauRunge2.\n\nReference:\n\nCarl Runge\nÜber die numerische Auflösung von Differentialgleichungen.\nMathematische Annalen, Volume 46, Pages 167-178, 1895.\ndoi: 10.1007/BF01446807.\nEquation (3)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SRK3","page":"Integrators","title":"GeometricIntegrators.Integrators.SRK3","text":"Fully implicit Runge-Kutta method with TableauSRK3.\n\nReference:\n\nShan Zhao and Guo-Wei Wei.\nA unified discontinuous Galerkin framework for time integration.\nMathematical Methods in the Applied Sciences, Volume 37, Issue 7, Pages 1042-1071, 2014.\ndoi: 10.1002/mma.2863.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SSPRK2","page":"Integrators","title":"GeometricIntegrators.Integrators.SSPRK2","text":"Explicit Runge-Kutta method with TableauSSPRK2.\n\nReference:\n\nChi-Wang Shu, Stanley Osher.\nEfficient implementation of essentially non-oscillatory shock-capturing schemes.\nJournal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.\ndoi: 10.1016/0021-9991(88)90177-5.\nEquation (2.16)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SSPRK3","page":"Integrators","title":"GeometricIntegrators.Integrators.SSPRK3","text":"Explicit Runge-Kutta method with TableauSSPRK3.\n\nReference:\n\nChi-Wang Shu, Stanley Osher.\nEfficient implementation of essentially non-oscillatory shock-capturing schemes.\nJournal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.\ndoi: 10.1016/0021-9991(88)90177-5.\nEquation (2.18)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SymplecticEulerA","page":"Integrators","title":"GeometricIntegrators.Integrators.SymplecticEulerA","text":"SymplecticEulerA\n\nSymplectic Euler method using explicit Euler for q and implicit Euler for p.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SymplecticEulerB","page":"Integrators","title":"GeometricIntegrators.Integrators.SymplecticEulerB","text":"SymplecticEulerB\n\nSymplectic Euler method using implicit Euler for q and explicit Euler for p.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.PRK-Tuple{PartitionedTableau}","page":"Integrators","title":"GeometricIntegrators.Integrators.PRK","text":"Partitioned Runge-Kutta Method\n\nPRK(tableau)\n\nReturns an explicit or implicit partitioned Runge-Kutta method depending on the tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.RK-Tuple{Tableau}","page":"Integrators","title":"GeometricIntegrators.Integrators.RK","text":"Runge-Kutta Method\n\nRK(tableau)\n\nReturns an explicit, implicit or diagonally implicit Runge-Kutta method depending on the tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Variational-Integrators","page":"Integrators","title":"Variational Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\n            \"integrators/vi/vi_methods.jl\",\n            \"integrators/vi/position_momentum_midpoint.jl\",\n            \"integrators/vi/position_momentum_trapezoidal.jl\",\n            \"integrators/vi/vprk_integrator.jl\",\n            \"integrators/vi/vprk_methods.jl\",\n        ]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.PMVImidpoint","page":"Integrators","title":"GeometricIntegrators.Integrators.PMVImidpoint","text":"Midpoint Variational Integrator in position-momentum form.\n\nWe consider a discrete Lagrangian of the form\n\nL_d (q_n q_n+1) = h  L bigg( fracq_n + q_n+12 fracq_n+1 - q_nh bigg) \n\nwhere q_n approximates the solution q(t_n). The Euler-Lagrange equations are computed as:\n\nbeginaligned\np_n   =           -  D_1 L_d (q_n q_n+1) = frach2  fracpartial Lpartial q bigg( fracq_n + q_n+12 fracq_n+1 - q_nh bigg) + fracpartial Lpartial v bigg( fracq_n + q_n+12 fracq_n+1 - q_nh bigg)  \np_n+1 = hphantom- D_2 L_d (q_n q_n+1) = frach2  fracpartial Lpartial q bigg( fracq_n + q_n+12 fracq_n+1 - q_nh bigg) + fracpartial Lpartial v bigg( fracq_n + q_n+12 fracq_n+1 - q_nh bigg) \nendaligned\n\nThe first equation can be solved implicitly for q_n+1 given (q_n p_n). The second equation can be used to explicitly compute p_n+1.    \n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.PMVItrapezoidal","page":"Integrators","title":"GeometricIntegrators.Integrators.PMVItrapezoidal","text":"Trapezoidal Variational Integrator in position-momentum form.\n\nWe consider a discrete Lagrangian of the form\n\nL_d (q_n q_n+1) = frach2 bigg L bigg( q_n fracq_n+1 - q_nh bigg) + L bigg( q_n+1 fracq_n+1 - q_nh bigg) bigg \n\nwhere q_n approximates the solution q(t_n). The Euler-Lagrange equations are computed as:\n\nbeginaligned\np_n   =           -  D_1 L_d (q_n q_n+1) = frach2  fracpartial Lpartial q bigg( q_n fracq_n+1 - q_nh bigg) + frac12 fracpartial Lpartial v bigg( q_n fracq_n+1 - q_nh bigg) + frac12 fracpartial Lpartial v bigg( q_n+1 fracq_n+1 - q_nh bigg)  \np_n+1 = hphantom- D_2 L_d (q_n q_n+1) = frach2  fracpartial Lpartial q bigg( q_n fracq_n+1 - q_nh bigg) + frac12 fracpartial Lpartial v bigg( q_n fracq_n+1 - q_nh bigg) + frac12 fracpartial Lpartial v bigg( q_n+1 fracq_n+1 - q_nh bigg) \nendaligned\n\nThe first equation can be solved implicitly for q_n+1 given (q_n p_n). The second equation can be used to explicitly compute p_n+1.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK","text":"Variational Partitioned Runge-Kutta Method\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nP_ni = p_n + h sum limits_i=1^s bara_ij  F_nj - d_i lambda  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni  \n\n0 = sum limits_i=1^s d_i V_i  \nendaligned\n\nsatisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + b_j a_ji = b_i b_j  \nbarb_i = b_i \nendaligned\n\nConstructors\n\nVPRK(tableau::PartitionedTableau, d=nothing)\nVPRK(tableau::Tableau, args...; kwargs...) = VPRK(PartitionedTableau(tableau), args...; kwargs...)\nVPRK(tableau1::Tableau, tableau2::Tableau, args...; kwargs...) = VPRK(PartitionedTableau(tableau1, tableau2), args...; kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKGauss","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKGauss","text":"Variational Partitioned Runge-Kutta Method that uses  Gauss-Legendre coefficients for both a_ij and bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIII","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIII","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIII for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIA","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIA","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIA for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIAIIIB","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIAIIIB","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIA for the coefficients a_ij and TableauLobattoIIIB for the coefficients bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIAIIIĀ","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIAIIIĀ","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIA for the coefficients a_ij and its symplectic conjugate for the coefficients bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIB","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIB","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIB for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIBIIIA","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIBIIIA","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIB for the coefficients a_ij and TableauLobattoIIIA for the coefficients bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIBIIIB̄","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIBIIIB̄","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIB for the coefficients a_ij and its symplectic conjugate for the coefficients bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIC","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIC","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIC for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIICIIIC̄","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIICIIIC̄","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIC for the coefficients a_ij and its symplectic conjugate for the coefficients bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIC̄IIIC","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIC̄IIIC","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIC̄ for the coefficients a_ij and its symplectic conjugate for the coefficients bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIID","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIID","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIID for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIDIIID̄","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIDIIID̄","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIID for the coefficients a_ij and its symplectic conjugate for the coefficients bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIE","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIE","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIE for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIEIIIĒ","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIEIIIĒ","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIE for the coefficients a_ij and its symplectic conjugate for the coefficients bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIF","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIF","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIF for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIFIIIF̄","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIFIIIF̄","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIF for the coefficients a_ij and its symplectic conjugate for the coefficients bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIF̄","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIF̄","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIF̄ for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIF̄IIIF","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIF̄IIIF","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIF̄ for the coefficients a_ij and its symplectic conjugate for the coefficients bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIG","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIG","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIG for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKLobattoIIIGIIIḠ","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKLobattoIIIGIIIḠ","text":"Variational Partitioned Runge-Kutta Method that uses  TableauLobattoIIIG for the coefficients a_ij and its symplectic conjugate for the coefficients bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKRadauIIA","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKRadauIIA","text":"Variational Partitioned Runge-Kutta Method that uses  TableauRadauIIA for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRKRadauIIB","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRKRadauIIB","text":"Variational Partitioned Runge-Kutta Method that uses  TableauRadauIIB for both coefficients a_ij and bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPSRK3","page":"Integrators","title":"GeometricIntegrators.Integrators.VPSRK3","text":"Variational Partitioned Runge-Kutta Method that uses  the symmetric TableauSRK3 coefficients with 3 stages for both a_ij and bara_ij.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Degenerate-Variational-Integrators","page":"Integrators","title":"Degenerate Variational Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\n            \"integrators/dvi/dvi_euler.jl\",\n            \"integrators/dvi/dvi_midpoint.jl\",\n            \"integrators/dvi/dvi_trapezoidal.jl\",\n            \"integrators/dvi/dvrk.jl\",\n        ]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.DVIA","page":"Integrators","title":"GeometricIntegrators.Integrators.DVIA","text":"Symplectic Euler-A Degenerate Variational Integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.DVIB","page":"Integrators","title":"GeometricIntegrators.Integrators.DVIB","text":"Symplectic Euler-B Degenerate Variational Integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.CMDVI","page":"Integrators","title":"GeometricIntegrators.Integrators.CMDVI","text":"Midpoint Degenerate Variational Integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.CTDVI","page":"Integrators","title":"GeometricIntegrators.Integrators.CTDVI","text":"Trapezoidal Degenerate Variational Integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.CTDVICache","page":"Integrators","title":"GeometricIntegrators.Integrators.CTDVICache","text":"Degenerate variational integrator cache.\n\nFields\n\nq: internal stages of solution\nv: internal stages of vector field\nΘ: implicit function evaluated on solution\nf: vector field of implicit function\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.DVRK","page":"Integrators","title":"GeometricIntegrators.Integrators.DVRK","text":"Degenerate Variational Runge-Kutta (DVRK) method for noncanonical symplectic equations solving the system\n\nbeginaligned\nP_ni = vartheta (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = f (Q_ni V_ni)  \nP_ni = p_n + h sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nUsually we are interested in Lagrangian systems, where\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni) \nendaligned\n\nand tableaus satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\nA Degenerate Variational Runge-Kutta method is instantiated by either passing a Runge-Kutta tableau or a Runge-Kutta method:\n\nDVRK(tableau::Tableau)\nDVRK(method::RKMethod)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.DVRKCache","page":"Integrators","title":"GeometricIntegrators.Integrators.DVRKCache","text":"Degenerate Variational Runge-Kutta integrator cache.\n\nFields\n\nq: initial guess of solution\nv: initial guess of vector field\nθ: initial guess of symplectic potential\nf: initial guess of force field\nQ: internal stages of solution\nV: internal stages of vector field\nΘ: implicit function of internal stages\nF: vector field of implicit function\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Galerkin-Variational-Integrators","page":"Integrators","title":"Galerkin Variational Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/cgvi/integrators_cgvi.jl\",\n           \"integrators/dgvi/integrators_dgvi.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.CGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.CGVI","text":"Continuous Galerkin Variational Integrator.\n\nb: weights of the quadrature rule\nc: nodes of the quadrature rule\nx: nodes of the basis\nm: mass matrix\na: derivative matrix\nr₀: reconstruction coefficients at the beginning of the interval\nr₁: reconstruction coefficients at the end of the interval\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Hamilton-Pontryagin-Integrators","page":"Integrators","title":"Hamilton-Pontryagin Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\n            \"integrators/hpi/hpi_methods.jl\",\n            \"integrators/hpi/hpi_midpoint.jl\",\n            \"integrators/hpi/hpi_trapezoidal.jl\",\n        ]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.HPImidpoint","page":"Integrators","title":"GeometricIntegrators.Integrators.HPImidpoint","text":"Hamilton-Pontryagin Integrator using midpoint quadrature.\n\nWe consider a discrete Lagrangian of the form\n\nL_d (q_n q_n+1) = h  L bigg( fracq_n + q_n+12 v_n+12 bigg) \n\nwhere q_n approximates the solution q(t_n) and v_n+12 is the velocity, which is assumed to be constant in the interval t_n t_n+1. The discrete Hamilton-Pontryagin action reads\n\nA_d q_d = sum limits_n=0^N-1 bigg L_d^alphabeta (q_n q_n+1 v_n+12) + left p_n+12  phi_h (q_n q_n+1 a_nn+1) - v_n+12 right bigg \n\nwhere phi_h is a map that computes the velocity v_n+12 as a function of q_n, q_n+1 and a set of parameters a_nn+1. A trivial example of such a map that does not depend on any parameters a_nn+1 is\n\nphi_h (q_n q_n+1 a_nn+1) = fracq_n+1 - q_nh \n\nIn order to solve the discrete Euler-Lagrange equations, the user needs to specify the map phi_h, its gradients with respect to q_n and q_n+1, denoted by D_1 phi_h and D_2 phi_h, respectively, the gradient with respect to the parameters, denoted by D_a phi_h, and an initial set of parameters a_0.\n\nThe equations of motion, that are solved by this integrator, is computed as:\n\nbeginaligned\n0 = frach2  fracpartial Lpartial q bigg( fracq_n-1 + q_n2 v_n-12 bigg)\n   + frach2  fracpartial Lpartial q bigg( fracq_n + q_n+12 v_n+12 bigg) \n  + h  D_1 phi_h (q_n q_n+1 a_nn+1) cdot p_n+12\n   + h  D_2 phi_h (q_n-1 q_n a_n-1n) cdot p_n-12  \n0 = D_a phi_h (q_n q_n+1 a_nn+1) cdot p_n+12  \np_n+12 = fracpartial Lpartial v bigg( fracq_n + q_n+12 v_n+12 bigg)  \nv_n+12 = phi_h (q_n q_n+1 a_nn+1) \nendaligned\n\nUpon defining the momentum\n\np_n\n= h  D_2 phi_h (q_n-1 q_n a_n-1n) cdot p_n-12\n+ frach2  fracpartial Lpartial q bigg( fracq_n-1 + q_n2 v_n-12 bigg) \n\nwe can rewrite the equations of motion as\n\nbeginaligned\n0 = p_n\n   + frach2  fracpartial Lpartial q bigg( fracq_n + q_n+12 v_n+12 bigg)\n   + h  D_1 phi_h (q_n q_n+1 a_nn+1) cdot p_n+12  \n0 = D_a phi_h (q_n q_n+1 a_nn+1) cdot p_n+12  \nv_n+12 = phi_h (q_n q_n+1 a_nn+1)  \np_n+12 = fracpartial Lpartial v bigg( fracq_n + q_n+12 v_n+12 bigg)  \np_n+1\n= h  D_2 phi_h (q_n q_n+1 a_nn+1) cdot p_n+12\n + frach2  fracpartial Lpartial q bigg( fracq_n + q_n+12 v_n+12 bigg) \nendaligned\n\nGiven (q_n p_n), the first four equations are solved for q_n+1, where v_n+12, p_n+12, and a_nn+1 are treated as internal variables similar to the internal stages of a Runge-Kutta method. The last equation provides an explicit update for p_n+1.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.HPItrapezoidal","page":"Integrators","title":"GeometricIntegrators.Integrators.HPItrapezoidal","text":"Hamilton-Pontryagin Integrator using trapezoidal quadrature.\n\nWe consider a discrete Lagrangian of the form\n\nL_d (q_n q_n+1) = frach2 big L (q_n v_n+12) + L (q_n+1 v_n+12) big \n\nwhere q_n approximates the solution q(t_n) and v_n+12 is the velocity, which is assumed to be constant in the interval t_n t_n+1. The discrete Hamilton-Pontryagin action reads\n\nA_d q_d = sum limits_n=0^N-1 bigg L_d (q_n q_n+1) + h left p_n+12  phi_h (q_n q_n+1 a_nn+1) - v_n+12 right bigg \n\nwhere phi_h is a map that computes the velocity v_n+12 as a function of q_n, q_n+1 and a set of parameters a_nn+1. A trivial example of such a map that does not depend on any parameters a_nn+1 is\n\nphi_h (q_n q_n+1 a_nn+1) = fracq_n+1 - q_nh \n\nIn order to solve the discrete Euler-Lagrange equations, the user needs to specify the map phi_h, its gradients with respect to q_n and q_n+1, denoted by D_1 phi_h and D_2 phi_h, respectively, the gradient with respect to the parameters, denoted by D_a phi_h, and an initial set of parameters a_0.\n\nThe equations of motion, that are solved by this integrator, are:\n\nbeginaligned\n0 = p_n\n   + frach2  fracpartial Lpartial q (q_n v_n+12)\n   + h  D_1 phi_h (q_n q_n+1 a_nn+1) cdot p_n+12  \n0 = D_a phi_h (q_n q_n+1 a_nn+1) cdot p_n+12  \nv_n+12\n= phi_h (q_n q_n+1 a_nn+1)  \np_n+12\n= frac12  fracpartial Lpartial v (q_n v_n+12)\n + frac12  fracpartial Lpartial v (q_n+1 v_n+12)  \np_n+1\n= h  D_2 phi_h (q_n q_n+1 a_nn+1) cdot p_n+12\n + frach2  fracpartial Lpartial q (q_n+1 v_n+12) \nendaligned\n\nGiven (q_n p_n), the first four equations are solved for q_n+1, where v_n+12, p_n+12, and a_nn+1 are treated as internal variables similar to the internal stages of a Runge-Kutta method. The last equation provides an explicit update for p_n+1.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Splitting-and-Composition-Methods","page":"Integrators","title":"Splitting and Composition Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\n            \"integrators/splitting/exact_solution.jl\",\n            \"integrators/splitting/splitting_coefficients.jl\",\n            \"integrators/splitting/splitting_methods.jl\",\n            \"integrators/splitting/splitting_integrator.jl\",\n            \"integrators/splitting/composition_integrator.jl\",\n            \"integrators/splitting/composition_methods.jl\",\n        ]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ExactSolution","page":"Integrators","title":"GeometricIntegrators.Integrators.ExactSolution","text":"Implements the GeometricIntegrator interface for the exact solution of a substep in SODE.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SplittingCoefficientsGS","page":"Integrators","title":"GeometricIntegrators.Integrators.SplittingCoefficientsGS","text":"Symmetric splitting method with general stages.     See McLachlan, Quispel, 2003, Equ. (4.11).\n\nBasic method: Lie composition\n\nbeginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1\nendaligned\n\nIntegrator:\n\nvarphi_tau^GS = varphi_a_1 tau^A circ varphi_b_1 tau^B circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SplittingCoefficientsGeneral","page":"Integrators","title":"GeometricIntegrators.Integrators.SplittingCoefficientsGeneral","text":"General splitting method for vector fields with two components A and B.\n\nIntegrator:\n\nvarphi_tau = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SplittingCoefficientsNonSymmetric","page":"Integrators","title":"GeometricIntegrators.Integrators.SplittingCoefficientsNonSymmetric","text":"Non-symmetric splitting method.     See McLachlan, Quispel, 2003, Equ. (4.10).     The methods A and B are the composition of all vector fields in the SODE     and its adjoint, respectively.\n\nBasic method: Lie composition\n\nbeginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1\nendaligned\n\nIntegrator:\n\nvarphi_tau^NS = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SplittingCoefficientsSS","page":"Integrators","title":"GeometricIntegrators.Integrators.SplittingCoefficientsSS","text":"Symmetric splitting method with symmetric stages.     See McLachlan, Quispel, 2003, Equ. (4.6).\n\nBasic method: symmetric Strang composition\n\nvarphi_tau^A = varphi_tau2^v_1 circ varphi_tau2^v_2 circ dotsc circ varphi_tau2^v_r-1 circ varphi_tau2^v_r circ varphi_tau2^v_r circ varphi_tau2^v_r-1 circ dotsc circ varphi_tau2^v_2 circ varphi_tau2^v_1\n\nIntegrator:\n\nvarphi_tau^SS = varphi_a_1 tau^A circ varphi_a_2 tau^A circ dotsc circ varphi_a_s tau^A circ dotsc circ varphi_a_2 tau^A circ varphi_a_1 tau^A\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LieA","page":"Integrators","title":"GeometricIntegrators.Integrators.LieA","text":"Lie-Trotter Splitting A\n\nFor a vector field dotx = f_1 (tx) +  f_2 (tx), the splitting reads\n\nPhi_Delta t = varphi^2_Delta t circ varphi^1_Delta t\n\nReference:\n\nH. F. Trotter.\nOn the product of semi-groups of operators.\nProceedings of the American Mathematical Society, Volume 10, Pages 545-551, 1959.\ndoi: 10.1090/S0002-9939-1959-0108732-6.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.LieB","page":"Integrators","title":"GeometricIntegrators.Integrators.LieB","text":"Lie-Trotter Splitting B\n\nFor a vector field dotx = f_1 (tx) +  f_2 (tx), the splitting reads\n\nPhi_Delta t = varphi^1_Delta t circ varphi^2_Delta t\n\nReference:\n\nH. F. Trotter.\nOn the product of semi-groups of operators.\nProceedings of the American Mathematical Society, Volume 10, Pages 545-551, 1959.\ndoi: 10.1090/S0002-9939-1959-0108732-6.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Marchuk","page":"Integrators","title":"GeometricIntegrators.Integrators.Marchuk","text":"Alias for Strang\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.McLachlan2","page":"Integrators","title":"GeometricIntegrators.Integrators.McLachlan2","text":"McLachlan's 2nd order symmetric, minimum error composition method\n\nThe composition reads\n\nPhi_Delta t = varphi_alpha Delta t circ varphi^*_(12 - alpha) Delta t circ varphi_(12 - alpha) Delta t circ varphi^*_alpha Delta t \n\nwhere the parameter alpha can be optimized, e.g., to minimize the solution error. McLachlan arrives at alpha  = 01932 as a generally useful value.\n\nReference:\n\nRobert I. McLachlan.\nOn the Numerical Integration of Ordinary Differential Equations by Symmetric Composition Methods\nSIAM Journal on Scientific Computing, Volume 16, Pages 151-168, 1995.\ndoi: 10.1137/0916010.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.McLachlan4","page":"Integrators","title":"GeometricIntegrators.Integrators.McLachlan4","text":"McLachlan's 4th order symmetric, minimum error composition method\n\nThe composition reads\n\nPhi_Delta t = varphi_alpha_5 Delta t circ varphi^*_beta_5 Delta t circ dotsc circ varphi_alpha_2 Delta t circ varphi^*_beta_2 Delta t circ varphi_alpha_1 Delta t circ varphi^*_beta_1 Delta t \n\nwith\n\nbeginaligned\nbeta_1 = alpha_5 = frac14 - sqrt19108  \nalpha_1 = beta_5 = frac146 + 5 sqrt19540    \nbeta_2 = alpha_4 = frac- 23 - 20 sqrt19270  \nalpha_2 = beta_4 = frac-2 + 10 sqrt19135   \nbeta_3 = alpha_3 = frac15 \nendaligned\n\nThe coefficients are optimised to provide an integrator with minimal solution error.\n\nReference:\n\nRobert I. McLachlan.\nOn the Numerical Integration of Ordinary Differential Equations by Symmetric Composition Methods\nSIAM Journal on Scientific Computing, Volume 16, Pages 151-168, 1995.\ndoi: 10.1137/0916010.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Strang","page":"Integrators","title":"GeometricIntegrators.Integrators.Strang","text":"Strang Splitting\n\nFor a vector field dotx = f_1 (tx) + f_2 (tx), the splitting reads\n\nPhi_Delta t = varphi^1_Delta t  2 circ varphi^2_Delta t  2 circ varphi^2_Delta t  2 circ varphi^1_Delta t  2\n\nFor vector fields with two components, this is not the most efficient implementation. For such cases StrangA or StrangB should be used instead.\n\nReferences:\n\nGilbert Strang.\nOn the construction and comparison of difference schemes.\nSIAM Journal on Numerical Analysis, Volume 5, Pages 506-517, 1968.\ndoi: 10.1137/0705041.\n\nGurij Ivanovich Marchuk.\nSome applications of splitting-up methods to the solution of mathematical physics problems.\nAplikace Matematiky, Volume 13, Pages 103-132, 1968.\ndoi: 10.21136/AM.1968.103142.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.StrangA","page":"Integrators","title":"GeometricIntegrators.Integrators.StrangA","text":"Strang Splitting A for a vector field dotx = f_1 (tx) + f_2 (tx).\n\nThe splitting reads\n\nPhi_Delta t = varphi^1_Delta t  2 circ varphi^2_Delta t circ varphi^1_Delta t  2\n\nReferences:\n\nGilbert Strang.\nOn the construction and comparison of difference schemes.\nSIAM Journal on Numerical Analysis, Volume 5, Pages 506-517, 1968.\ndoi: 10.1137/0705041.\n\nGurij Ivanovich Marchuk.\nSome applications of splitting-up methods to the solution of mathematical physics problems.\nAplikace Matematiky, Volume 13, Pages 103-132, 1968.\ndoi: 10.21136/AM.1968.103142.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.StrangB","page":"Integrators","title":"GeometricIntegrators.Integrators.StrangB","text":"Strang Splitting B for a vector field dotx = f_1 (tx) + f_2 (tx)\n\nThe splitting reads\n\nPhi_Delta t = varphi^2_Delta t  2 circ varphi^1_Delta t circ varphi^2_Delta t  2\n\nReferences:\n\nGilbert Strang.\nOn the construction and comparison of difference schemes.\nSIAM Journal on Numerical Analysis, Volume 5, Pages 506-517, 1968.\ndoi: 10.1137/0705041.\n\nGurij Ivanovich Marchuk.\nSome applications of splitting-up methods to the solution of mathematical physics problems.\nAplikace Matematiky, Volume 13, Pages 103-132, 1968.\ndoi: 10.21136/AM.1968.103142.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SuzukiFractal","page":"Integrators","title":"GeometricIntegrators.Integrators.SuzukiFractal","text":"Suzuki's 4th order \"fractal\" composition method\n\nThe composition reads\n\nPhi_Delta t = varphi_gamma_5 Delta t circ varphi_gamma_4 Delta t circ varphi_gamma_3 Delta t circ varphi_gamma_2 Delta t circ varphi_gamma_1 Delta t\n\nwith\n\ngamma_1 = gamma_2 = gamma_4 = gamma_5 = frac14 - 4^1(p+1)  qquad\ngamma_3 = - frac4^1(p+1)4 - 4^1(p+1) \n\nReference:\n\nMasuo Suzuki\nFractal decomposition of exponential operators with applications to many-body theories and Monte Carlo simulations.\nPhysics Letters A, Volume 146, Pages 319-323, 1990.\ndoi: 10.1016/0375-9601(90)90962-N\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TripleJump","page":"Integrators","title":"GeometricIntegrators.Integrators.TripleJump","text":"4th order \"Triple Jump\" composition method.\n\nThe composition reads\n\nPhi_Delta t = varphi_gamma_3 Delta t circ varphi_gamma_2 Delta t circ varphi_gamma_1 Delta t\n\nwith\n\ngamma_1 = gamma_3 = frac12 - 2^1(p+1)  qquad\ngamma_2 = - frac2^1(p+1)2 - 2^1(p+1) \n\nReferences:\n\nMichael Creutz and Andreas Gocksch.\nHigher-order hybrid Monte Carlo algorithms.\nPhysical Review Letters, Volume 63, Pages 9-12, 1989.\ndoi: 10.1103/PhysRevLett.63.9.\n\nEtienne Forest.\nCanonical integrators as tracking codes (or how to integrate perturbation theory with tracking).\nAIP Conference Proceedings, Volume 184, Pages 1106-1136, 1989.\ndoi: 10.1063/1.38062.\n\nMasuo Suzuki\nFractal decomposition of exponential operators with applications to many-body theories and Monte Carlo simulations.\nPhysics Letters A, Volume 146, Pages 319-323, 1990.\ndoi: 10.1016/0375-9601(90)90962-N\n\nHaruo Yoshida.\nConstruction of higher order symplectic integrators.\nPhysics Letters A, Volume 150, Pages 262-268, 1990.\ndoi: 10.1016/0375-9601(90)90092-3\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Splitting","page":"Integrators","title":"GeometricIntegrators.Integrators.Splitting","text":"Splitting integrator for the solution of initial value problems\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwhose vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nSplitting has two constructors:\n\nSplitting(f::Vector{Int}, c::Vector)\nSplitting(method::AbstractSplittingMethod, problem::SODEProblem)\n\nThe vectors f and c define the actual splitting method: f is a vector of indices of the flows in the split equation (that is the exact solution which can be obtained by solutions(problem)) to be solved and c is a vector of the same size as f that contains the coefficients for each splitting step, i.e., the resulting integrator has the form\n\nvarphi_tau = phi_cs tau^v_fs circ dotsc circ phi_c2 tau^v_f2 circ phi_c1 tau^v_f1 \n\nIn the second constructor, these vectors are constructed from the splitting method and the problem.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SplittingCache","page":"Integrators","title":"GeometricIntegrators.Integrators.SplittingCache","text":"Splitting integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Composition","page":"Integrators","title":"GeometricIntegrators.Integrators.Composition","text":"Composition integrator for the solution of initial value problems\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwhose vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nComposition has one main constructor:\n\nComposition(methods, splitting)\n\nThe first argument is tuple of methods that are used to solve each substep, and the second argument is a splitting method. A second convenience constructor uses the ExactSolution for all steps:\n\nComposition(splitting) = Composition(ExactSolution(), splitting)\n\nThis constructs a composition method that is equivalent to a plain Splitting. In order to include exact solutions in the composition, the ExactSolution method implements the general integrator interface.\n\n\n\n\n\n","category":"type"},{"location":"integrators/dgvi/#dgvi","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Discontinuous Galerkin Variational Integrators (DGVIs) are a family of integrators for degenerate Lagrangian systems and for Hamiltonian systems subject to Dirac constraints. For integrators for non-degenerate (regular) Lagrangian and unconstrained Hamiltonian systems see Hamilton-Pontryagin-Galerkin (HPG) Integrators.","category":"page"},{"location":"integrators/dgvi/#Degenerate-Lagrangian-Systems","page":"Discontinuous Galerkin Variational Integrators","title":"Degenerate Lagrangian Systems","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Consider a fully degenerate Lagrangian system of the form","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"L(q dotq) = vartheta (q) cdot dotq - H(q) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where vartheta (q) denotes the Cartan one-form and H(q) the Hamiltonian, that is usually given by the total energy of the system.","category":"page"},{"location":"integrators/dgvi/#Discrete-Trajectories-and-Numerical-Quadrature","page":"Discontinuous Galerkin Variational Integrators","title":"Discrete Trajectories and Numerical Quadrature","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The first step in the derivation of variational integrators is the discretization of the action integral","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q = int limits_0^T L(q(t) dotq(t))  dt ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"To this end, the interval 0T is split into N sub-intervals t_n t_n+1 with t_n = nh and h the time step size, so that t_N = T and the action can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q = sum limits_n=0^N-1 int limits_t_n t_n+1 L(q(t) dotq(t))  dt ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Within each interval (t_n t_n+1) a piecewise-polynomial approximation q_h of the trajectory q is constructed using S basis functions varphi_i,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_h(t) vert_(t_n t_n+1) = sum limits_i=1^S x_ni  barvarphi_ni (t) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where barvarphi_ni (t) is a rescaled basis function, defined by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"barvarphi_ni (t) = varphi_i bigg( fract - t_nt_n+1 - t_n bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and it is assumed that varphi_i is compactly supported on 01. These approximations q_h(t) do not need to be continuous across interval boundaries but are indeed allowed to have jumps. Replacing the continuous trajectory q in the action with q_h, we obtain","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q_h = sum limits_n=0^N-1 int limits_(t_n t_n+1) big vartheta (q_h (t)) cdot dotq_h (t) - H(q_h (t)) big  dt\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n  ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The integral of the Hamiltonian H(q_h) over the interval boundaries does not contribute to the integral, differently from the term vartheta (q_h) cdot dotq_h, which will determine the numerical flux  cdot _n at t_n of the Discontinuous Galerkin method. The approximation of this term will be discussed below. In order to obtain a fully discrete action, a numerical quadrature rule with R nodes c_i and weights b_i is introduced for the approximation of the integral,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (q_h(t_n + c_i h)) cdot dotq_h (t_n + c_i h) - H(q_h(t_n + c_i h)) big\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Here, x_d denotes the vector of all the degrees of freedom, i.e.,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"x_d = ( x_01  x_0S  x_11  x_N-2S  x_N-11  x_N-1S )^T ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In order to write the discrete action in a more explicit form, mass and derivative matrices m and a are introduced, whose elements are given by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"m_ij = varphi_j (c_i) \nqquad\na_ij = varphi_j (c_i) \nqquad\ni = 1  R \n\nj = 1  S ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"so that the solution and its time derivative at the quadrature points can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Q_ni equiv q_h(t_n + c_i h) = m_ij x_nj \nqquad\nV_ni equiv dotq_h (t_n + c_i h) = a_ij x_nj ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"x_n = ( x_n1  x_nS )^T","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"is the vector containing the degrees of freedom of q_h vert_t_n t_n+1. Using these definitions, the discrete action can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n ","category":"page"},{"location":"integrators/dgvi/#Numerical-Fluxes","page":"Discontinuous Galerkin Variational Integrators","title":"Numerical Fluxes","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In the following, the solution values \"left\" and \"right\" of the jump will be needed. This will be denoted by q_n^- and q_n^+, respectively. Usually, these just correspond to the polynomials on the left and right, evaluated at t_n, i.e.,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_n^- = lim_t uparrow t_n q_h (t) = q_h vert_t_n-1 t_n (t_n) \nqquad\nq_n^+ = lim_t downarrow t_n q_h (t) = q_h vert_t_n t_n+1 (t_n) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In principle, however, more general reconstructions of the solution could be used. In the following, it will be assumed, that q_n^- is given by some linear combinations of the degrees of freedom of the polynomial on the left interval and correspondingly that q_n^+ is given by some linear combinations of the degrees of freedom of the polynomial on the right interval, specifically","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_n^- = r^- cdot x_n \nqquad\nq_n^+ = r^+ cdot x_n+1 ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where r^pm are appropriate coefficient vectors.","category":"page"},{"location":"integrators/dgvi/#Gauge-Terms","page":"Discontinuous Galerkin Variational Integrators","title":"Gauge Terms","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The Lagrangian L can be augmented with any total time derivative without changing the (continuous) Euler-Lagrange equations. In particular, one can consider the modified Lagrangian","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"L(q dotq) = vartheta (q) cdot dotq - H(q) - nu dfracddt bigg( vartheta (q) cdot q bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"While this gauge term vanishes in the continuous case, it takes a finite value across jumps of the discontinuous discrete solution, so that the modified discrete action reads","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big\n+ sum limits_n=1^N-1 biggbigg vartheta (q_h (t)) cdot dotq_h (t) - nu dfracddt bigg( vartheta (q) cdot q bigg) biggbigg_t=t_n ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In the following, only the modified Lagrangian and action will be considered, in order to obtain a sufficiently general framework for constructing numerical fluxes. For brevity of notation, the prime will be dropped.","category":"page"},{"location":"integrators/dgvi/#Total-Time-Derivatives-Across-Jumps","page":"Discontinuous Galerkin Variational Integrators","title":"Total Time Derivatives Across Jumps","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The computation of the total time derivative in the gauge term is simple, at least in the distributional sense. Even though both, vartheta (q_h) and q_h have a jump, the jump occurs at the same position in time, so that the derivative can be computed as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"dfracddt bigg( vartheta (q_h) cdot q_h bigg) biggvert_t=t_n\n= dfracddt bigg( vartheta (q_n^-) cdot q_n^-  Theta (t_n - t) + vartheta (q_n^+) cdot q_n^+  Theta (t - t_n) bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where Theta denotes the Heaviside function. This can be explicitly computed as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"dfracddt bigg( vartheta (q_h) cdot q_h bigg) biggvert_t=t_n\n= - vartheta (q_n^-) cdot q_n^-  delta (t_n) + vartheta (q_n^+) cdot q_n^+  delta (t_n)\n=  vartheta (q_h) cdot q_h _t=t_n  delta (t_n) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"with delta (t_n) the Dirac delta-function at t_n.","category":"page"},{"location":"integrators/dgvi/#Non-conservative-Products","page":"Discontinuous Galerkin Variational Integrators","title":"Non-conservative Products","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Simple means for integrating the Lagrangian across jumps are provided by discretisations of the integral","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"int limits_0^1 vartheta (Phi(tau q^- q^+)) cdot dfracd Phi(tau q^- q^+)dtau  dtau ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where Phi is a path connecting the solution values q^- and q^+ on the left and the right of the jump. Upon picking a quadrature rule with sigma nodes gamma_i and corresponding weights beta_i, the discrete product takes the form","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"sum limits_i=1^sigma beta_i  vartheta big( Phi (gamma_i q_n^-  q_n^+) big) cdot dfracdPhidtau (gamma_i q_n^-  q_n^+) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"For a compact notation, \"mass\" and \"derivative\" vectors mu^pm and alpha^pm are introduced, so that","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Phi (gamma_i q_n^-  q_n^+) = mu^-_i q_n^- + mu^+_i q_n^+\nqquad\nPhi (gamma_i q_n^-  q_n^+) = alpha^-_i q_n^- + alpha^+_i q_n^+ ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and the discrete product can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"sum limits_i=1^sigma beta_i  vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Providing the path Phi by two functions phi^pm(tau), so that","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"phi(tau q^- q^+) = q^- phi^-(tau) + q^+ phi^+(tau) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"the components of the \"mass\" and \"derivative\" vectors are given by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mu^-_i = phi^- (gamma_i) \nqquad\nmu^+_i = phi^+ (gamma_i) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"alpha^-_i = fracdphi^-dtau (gamma_i) \nqquad\nalpha^+_i = fracdphi^+dtau (gamma_i) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"respectively.","category":"page"},{"location":"integrators/dgvi/#Discrete-Variational-Principle","page":"Discontinuous Galerkin Variational Integrators","title":"Discrete Variational Principle","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Using the construction of the previous sections, the discrete action reads","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma beta_i  vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ )\n- nu big vartheta (q_n^+) cdot q_n^+ - vartheta (q_n^-) cdot q_n^- big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The discrete Euler-Lagrange equations are obtained by applying Hamilton's principle of stationary action to mathcalA_d x_d, that is requiring that delta mathcalA_d x_d = 0. The variations of the discrete action are computed as follows,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta mathcalA_d x_d\n= h sum limits_n=0^N-1 sum limits_i=1^R b_i big delta Q_ni cdot nabla vartheta (Q_ni) cdot V_ni + vartheta (Q_ni) cdot delta V_ni - delta Q_ni cdot nabla H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma beta_i  big ( mu^-_i delta q_n^- + mu^+_i delta q_n^+ ) cdot nabla vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) + vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i delta q_n^- + alpha^+_i delta q_n^+ ) big \n- nu big delta q_n^+ cdot nabla vartheta (q_n^+) cdot q_n^+  + vartheta (q_n^+) cdot delta q_n^+ - delta q_n^- cdot nabla vartheta (q_n^-) cdot q_n^- - vartheta (q_n^-) cdot delta q_n^- big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Using the relations","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta Q_ni = m_ij delta x_nj \nqquad\ndelta V_ni = fraca_ijh delta x_nj \nqquad\ndelta q_n^- = r^-_j delta x_n-1j \nqquad\ndelta q_n^+ = r^+_j delta x_nj ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"the variations of the discrete action become","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta mathcalA_d x_d\n= sum limits_n=0^N-1 sum limits_i=1^R sum limits_j=1^S b_i big h m_ij delta x_nj cdot nabla vartheta (Q_ni) cdot V_ni + vartheta (Q_ni) cdot a_ij delta x_nj - h m_ij delta x_nj cdot nabla H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma sum limits_j=1^S beta_i  big ( mu^-_i r^-_j delta x_n-1j + mu^+_i r^+_j delta x_nj ) cdot nabla vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) + vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i r^-_j delta x_n-1j + alpha^+_i r^+_j delta x_nj ) big \n- nu big r^+_j delta x_nj cdot nabla vartheta (q_n^+) cdot q_n^+  + vartheta (q_n^+) cdot r^+_j delta x_nj - r^-_j delta x_n-1j cdot nabla vartheta (q_n^-) cdot q_n^- - vartheta (q_n^-) cdot r^-_j delta x_n-1j big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Requiring the variation of the discrete action to vanish yields the discrete equations of motion,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"0 = sum limits_i=1^R b_i big h m_ij nabla vartheta (Q_ni) cdot V_ni + a_ij vartheta (Q_ni) - h m_ij nabla H(Q_ni) big \n+ bigg sum limits_i=1^sigma beta_i  big\n   mu^-_i r^-_j nabla vartheta ( mu^-_i q_n+1^- + mu^+_i q_n+1^+ ) cdot ( alpha^-_i q_n+1^- + alpha^+_i q_n+1^+ )\n + mu^+_i r^+_j nabla vartheta ( mu^-_i q_n  ^- + mu^+_i q_n  ^+ ) cdot ( alpha^-_i q_n  ^- + alpha^+_i q_n  ^+ ) \n + vartheta ( mu^-_i q_n+1^- + mu^+_i q_n+1^+ ) alpha^-_i r^-_j\n + vartheta ( mu^-_i q_n  ^- + mu^+_i q_n  ^+ ) alpha^+_i r^+_j\n   big \n - nu big\n     r^+_j nabla vartheta (q_n  ^+) cdot q_n  ^+ + r^+_j vartheta (q_n  ^+)\n   - r^-_j nabla vartheta (q_n+1^-) cdot q_n+1^- - r^-_j vartheta (q_n+1^-)\n   big\n bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"for all n and all j.","category":"page"},{"location":"modules/solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"modules/solutions/","page":"Solutions","title":"Solutions","text":"Modules = [GeometricSolutions]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/solutions/#GeometricSolutions.EnsembleSolution","page":"Solutions","title":"GeometricSolutions.EnsembleSolution","text":"EnsembleSolution: Collection of all solutions of an EnsembleProblem.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricSolutions.GeometricSolution","page":"Solutions","title":"GeometricSolutions.GeometricSolution","text":"GeometricSolution: Solution of a geometric differential equation\n\nContains all fields necessary to store the solution of a GeometricProblem.\n\nFields\n\nt:  time steps\ns:  NamedTuple of DataSeries for each solution component\nstep: store every step'th time step (default: 1)\nnstore: number of time steps to store\noffset: offset of current time step\n\nConstructors\n\nGeometricSolution(problem; step=1)\n\nThe usual way to initialise a Solution is by passing a GeometricProblem, which  can for example be an ODEProblem or PODEProblem. The optional parameter step determines the intervals for storing the solution, i.e., if store > 1 only every store'th solution is actually stored.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#Solution-Steps","page":"Solutions","title":"Solution Steps","text":"","category":"section"},{"location":"modules/solutions/","page":"Solutions","title":"Solutions","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"solutions/solution.jl\",\n           \"solutions/solution_step.jl\",\n           \"solutions/solution_step_dae.jl\",\n           \"solutions/solution_step_ode.jl\",\n           \"solutions/solution_step_pdae.jl\",\n           \"solutions/solution_step_pode.jl\",\n           \"solutions/solution_step_constructors.jl\"]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/solutions/#GeometricIntegrators.Integrators.SolutionStep","page":"Solutions","title":"GeometricIntegrators.Integrators.SolutionStep","text":"Abstract atomic or single-step solution.\n\nConstructors:\n\nSolutionStep(equation)\nSolutionStep(solution)\nSolutionStep(solution, integrator)\n\nAutomatically construct the appropriate atomic solution based on the  given equation or solution type. If an integrator is provided as, the internal field of the atomic solution is constructed according to the internal state of the integrator as obtained from the function internal_variables.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#Base.copy!-Tuple{SolutionStep, EquationProblem}","page":"Solutions","title":"Base.copy!","text":"Copy the initial conditions of a EquationProblem to the current state of an atomic solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Integrators.current","page":"Solutions","title":"GeometricIntegrators.Integrators.current","text":"Returns a NamedTuple with the solution of the current time step.\n\n\n\n\n\n","category":"function"},{"location":"modules/solutions/#GeometricIntegrators.Integrators.previous","page":"Solutions","title":"GeometricIntegrators.Integrators.previous","text":"Returns a NamedTuple with the solution of the previous time step.\n\n\n\n\n\n","category":"function"},{"location":"modules/solutions/#GeometricIntegrators.Integrators.SolutionStepDAE","page":"Solutions","title":"GeometricIntegrators.Integrators.SolutionStepDAE","text":"Solution step for a DAEProblem.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̄: time of previous time steps\nq: current solution of q\nλ: current solution of λ\nq̄: previous solutions of q\nλ̄: previous solutions of λ\nv: vector field of q\nv̄: vector field of q̄\nu: projective vector field of q\nū: projective vector field of q̄\nq̃: compensated summation error of q\ninternal: internal variables of the integrator (e.g., internal stages of a Runge-Kutta methods or solver output)\n\nConstructors\n\nSolutionStepDAE(t::TT, q::AT, λ::AT, internal::IT=NamedTuple())\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Integrators.SolutionStepODE","page":"Solutions","title":"GeometricIntegrators.Integrators.SolutionStepODE","text":"Solution step for an ODEProblem.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̄: time of previous time step\nq: current solution of q\nq̄: previous solution of q\nv: vector field of q\nv̄: vector field of q̄\nq̃: compensated summation error of q\ninternal: internal variables of the integrator (e.g., internal stages of a Runge-Kutta methods or solver output)\n\nConstructors\n\nSolutionStepODE(t::TT, q::AT; nhistory=1, internal::IT=NamedTuple())\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Integrators.SolutionStepPDAE","page":"Solutions","title":"GeometricIntegrators.Integrators.SolutionStepPDAE","text":"Solution step for a PDAEProblem.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̄: time of previous time steps\nq: current solution of q\np: current solution of p\nλ: current solution of λ\nq̄: previous solution of q\np̄: previous solution of p\nλ̄: previous solution of λ\nv: vector field of q\nf: vector field of p\nv̄: vector field of q̄\nf̄: vector field of p̄\nu: projective vector field of q\nū: projective vector field of q̄\ng: projective vector field of p\nḡ: projective vector field of p̄\nq̃: compensated summation error of q\np̃: compensated summation error of p\ninternal: internal variables of the integrator (e.g., internal stages of a Runge-Kutta methods or solver output)\n\nConstructors\n\nSolutionStepPDAE(t::TT, q::AT, p::AT, λ::AT; nhistory=1, internal::IT=NamedTuple())\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Integrators.SolutionStepPODE","page":"Solutions","title":"GeometricIntegrators.Integrators.SolutionStepPODE","text":"Solution step for a PODEProblem.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̄: time of previous time step\nq: current solution of q\np: current solution of p\nq̄: previous solution of q\np̄: previous solution of p\nv: vector field of q\nf: vector field of p\nv̄: vector field of q̄\nf̄: vector field of p̄\nq̃: compensated summation error of q\np̃: compensated summation error of p\ninternal: internal variables of the integrator (e.g., internal stages of a Runge-Kutta methods or solver output)\n\nConstructors\n\nSolutionStepPODE(t::TT, q::AT, p::AT; nhistory=1, internal::IT=NamedTuple())\n\n\n\n\n\n","category":"type"},{"location":"developer/code_integration/#Code-Integration","page":"Code Integration","title":"Code Integration","text":"","category":"section"},{"location":"modules/discontinuities/#Discontinuities","page":"Discontinuities","title":"Discontinuities","text":"","category":"section"},{"location":"modules/discontinuities/","page":"Discontinuities","title":"Discontinuities","text":"Modules = [GeometricIntegrators.Discontinuities]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/discontinuities/#GeometricIntegrators.Discontinuities.PathIntegralLinear","page":"Discontinuities","title":"GeometricIntegrators.Discontinuities.PathIntegralLinear","text":"PathIntegralLinear is a path integral along a linear path\n\nphi (tau q^- q^+) = (1-tau) q^- + tau q^+ \n\n\n\n\n\n","category":"type"},{"location":"modules/discontinuities/#GeometricIntegrators.Discontinuities.PathIntegralTrigonometric","page":"Discontinuities","title":"GeometricIntegrators.Discontinuities.PathIntegralTrigonometric","text":"PathIntegralTrigonometric is a path integral along a cos^2/sin^2 path\n\nphi (tau q^- q^+) = cos^2 (pi tau  2) q^- + sin^2 (pi tau  2) q^+ \n\n\n\n\n\n","category":"type"},{"location":"modules/rungekutta/#RungeKuttaTableaus","page":"Runge-Kutta Tableaus","title":"Runge-Kutta Tableaus","text":"","category":"section"},{"location":"modules/rungekutta/","page":"Runge-Kutta Tableaus","title":"Runge-Kutta Tableaus","text":"The following tableaus are all implemented in RungeKutta.jl.","category":"page"},{"location":"modules/rungekutta/#ordinary-runge-kutta_tableaus","page":"Runge-Kutta Tableaus","title":"Ordinary Runge-Kutta Tableaus","text":"","category":"section"},{"location":"modules/rungekutta/","page":"Runge-Kutta Tableaus","title":"Runge-Kutta Tableaus","text":"RungeKutta.Tableau","category":"page"},{"location":"modules/rungekutta/#RungeKutta.Tableau","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableau","text":"Holds the tableau of a Runge-Kutta method\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  v(t_n + c_j Delta t Q_nj)  \nq_n+1 = q_n + h sum limits_i=1^s b_i   v(t_n + c_j Delta t Q_ni)  \nendaligned\n\nParameters:\n\nT: datatype of coefficient arrays\n\nFields:\n\nname: symbolic name of the tableau\no: order of the method\ns: number of stages\na: coefficients a_ij with $ 1 \\le i,j \\le s$\nb: weights b_i  with $ 1 \\le i \\le s$\nc: nodes c_i  with $ 1 \\le i \\le s$\nR∞: stability function at infinity\n\nConstructors:\n\nTableau{T}(name, o, s, a, b, c)\nTableau{T}(name, o, a, b, c)\nTableau(name::Symbol, o::Int, s::Int, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)\nTableau(name::Symbol, o::Int, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)\nTableau(name::Symbol, o::Int, t::AbstractMatrix)\n\nThe last constructor accepts an (s+1) times (s+1) array that holds the whole tableau in the form of a Butcher tableau, i.e.,\n\nc a\n b\n\n\n\n\n\n","category":"type"},{"location":"modules/rungekutta/","page":"Runge-Kutta Tableaus","title":"Runge-Kutta Tableaus","text":"Modules = [RungeKutta.Tableaus]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauBackwardEuler","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauBackwardEuler","text":"Alias for TableauImplicitEuler\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauCrankNicolson-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauCrankNicolson","text":"Tableau of Crank-Nicolson two-stage, 2nd order method\n\nTableauCrankNicolson(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJ. Crank and P. Nicolson.\nA practical method for numerical evaluation of solutions of partial differential equations of the heat-conduction type.\nMathematical Proceedings of the Cambridge Philosophical Society, Volume 43, Issue 1, Pages 50-67, 1947.\ndoi: 10.1017/S0305004100023197\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauCrouzeix-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauCrouzeix","text":"Tableau of Crouzeix's two-stage, 3rd order method\n\nTableauCrouzeix(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nM.Crouzeix.\nSur L'approximation des équations différentielles opérationelles linéaires par des méthodes de Runge-Kutta.\nThesis. Université de Paris, 1975.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauExplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauExplicitEuler","text":"Tableau of one-stage, 1st order explicit (forward) Euler method\n\nTableauExplicitEuler(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nLeonhard Euler.\nInstitutiones calculi differentialis cum eius vsu in analysi finitorum ac doctrina serierum.\nImp. Acad. Imper. Scient. Petropolitanae, Opera Omnia, Vol.X, [I.6], 1755.\nIn: Opera Omnia, 1st Series, Volume 11, Institutiones Calculi Integralis. Teubner, Leipzig, Pages 424-434, 1913.\nSectio secunda. Caput VII. De integratione aequationum differentialium per approximationem. Problema 85.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauExplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauExplicitMidpoint","text":"Tableau of explicit two-stage, 2nd order midpoint method\n\nTableauExplicitMidpoint(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nCarl Runge.\nÜber die numerische Auflösung von Differentialgleichungen.\nMathematische Annalen, Volume 46, Pages 167-178, 1895.\ndoi: 10.1007/BF01446807.\nEquation (2)\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauForwardEuler","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauForwardEuler","text":"Alias for TableauExplicitEuler\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauGauss-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauGauss","text":"Gauss tableau with s stages\n\nTableauGauss(::Type{T}, s)\nTableauGauss(s) = TableauGauss(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nJohn C. Butcher.\nImplicit Runge-Kutta processes.\nMathematics of Computation, Volume 18, Pages 50-64, 1964.\ndoi: 10.1090/S0025-5718-1964-0159424-9.\n\nJohn C. Butcher.\nGauss Methods. \nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_115.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauHeun2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauHeun2","text":"Tableau of Heun's two-stage, 2nd order method\n\nTableauHeun2(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nKarl Heun.\nNeue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.\nZeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.\nAlgorithm II.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauHeun3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauHeun3","text":"Tableau of Heun's three-stage, 3rd order method\n\nTableauHeun3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nKarl Heun.\nNeue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.\nZeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.\nAlgorithm VI.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauImplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauImplicitEuler","text":"Tableau of one-stage, 1st order implicit (backward) Euler method\n\nTableauImplicitEuler(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAugustin-Louis Cauchy.\nÉquations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.\nEd. Christian Gilain, Etudes Vivantes, 1981.\nPage 102, Equation (5), Θ=1.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauImplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauImplicitMidpoint","text":"Tableau of two-stage, 2nd order implicit midpoint method\n\nTableauImplicitMidpoint(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAugustin-Louis Cauchy.\nÉquations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.\nEd. Christian Gilain, Etudes Vivantes, 1981.\nPage 102, Equation (5), Θ=1/2.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauKraaijevangerSpijker-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauKraaijevangerSpijker","text":"Tableau of Kraaijevanger and Spijker's two-stage, 2nd order method\n\nTableauKraaijevangerSpijker(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJ. F. B. M. Kraaijevanger and M. N. Spijker.\nAlgebraic stability and error propagation in Runge-Kutta methods.\nApplied Numerical Mathematics, Volume 5, Issues 1-2, Pages 71-87, 1989.\ndoi: 10.1016/0168-9274(89)90025-1\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauKutta-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauKutta","text":"Tableau of Kutta's three-stage, 3rd order method\n\nTableauKutta(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.\nPage 440\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauKutta3","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauKutta3","text":"Alias for TableauKutta\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIII-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIII","text":"Lobatto III tableau with s stages\n\nTableauLobattoIII(::Type{T}, s)\nTableauLobattoIII(s) = TableauLobattoIII(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nSometimes this tableau is also referred to as Lobatto IIIC*.\n\nReferences:\n\nJohn C. Butcher.\nIntegration processes based on Radau quadrature formulas\nMathematics of Computation, Volume 18, Pages 233-244, 1964.\ndoi: 10.1090/S0025-5718-1964-0165693-1.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIA","text":"Lobatto IIIA tableau with s stages\n\nTableauLobattoIIIA(::Type{T}, s)\nTableauLobattoIIIA(s) = TableauLobattoIIIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIB","text":"Lobatto IIIB tableau with s stages\n\nTableauLobattoIIIB(::Type{T}, s)\nTableauLobattoIIIB(s) = TableauLobattoIIIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle.\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIB̄","text":"Lobatto IIIB̄ tableau with s stages\n\nTableauLobattoIIIB̄(::Type{T}, s)\nTableauLobattoIIIB̄(s) = TableauLobattoIIIB̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIB̄ tableau is the conjugate symplectic to TableauLobattoIIIB. On paper, its coefficients are identical to TableauLobattoIIIA, however, they are computed by the symplecticity condition and not by the formula for Lobatto IIIA and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIC-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIC","text":"Lobatto IIIC tableau with s stages\n\nTableauLobattoIIIC(::Type{T}, s)\nTableauLobattoIIIC(s) = TableauLobattoIIIC(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nF. H. Chipman.\nA-stable Runge-Kutta processes.\nBIT, Volume 11, Pages 384-388, 1971.\ndoi: 10.1007/BF01939406.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIC̄","text":"Lobatto IIIC̄ tableau with s stages\n\nTableauLobattoIIIC̄(::Type{T}, s)\nTableauLobattoIIIC̄(s) = TableauLobattoIIIC̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIC̄ tableau is the conjugate symplectic to TableauLobattoIIIC. On paper, its coefficients are identical to TableauLobattoIII, however, they are computed by the symplecticity condition and not by the formula for Lobatto III and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIID-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIID","text":"Lobatto IIID tableau with s stages\n\nTableauLobattoIIID(::Type{T}, s)\nTableauLobattoIIID(s) = TableauLobattoIIID(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nR.P.K. Chan.\nOn symmetric Runge-Kutta methods of high order.\nComputing, Volume 45, Pages 301-309, 1990.\ndoi: 10.1007/BF02238798\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIID̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIID̄","text":"Lobatto IIID̄ tableau with s stages\n\nTableauLobattoIIID̄(::Type{T}, s)\nTableauLobattoIIID̄(s) = TableauLobattoIIID̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIID̄ tableau is the conjugate symplectic to TableauLobattoIIID. On paper, the coefficients of the Lobatto IIID tableau are symplectic, however, the Lobatto IIID̄ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIID and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIE-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIE","text":"Lobatto IIIE tableau with s stages\n\nTableauLobattoIIIE(::Type{T}, s)\nTableauLobattoIIIE(s) = TableauLobattoIIIE(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nR.P.K. Chan.\nOn symmetric Runge-Kutta methods of high order.\nComputing, Volume 45, Pages 301-309, 1990.\ndoi: 10.1007/BF02238798\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIF","text":"Lobatto IIIF tableau with s stages\n\nTableauLobattoIIIF(::Type{T}, s)\nTableauLobattoIIIF(s) = TableauLobattoIIIF(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nWang Fangzong and Liao Xiaobing.\nA Class of Lobatto Methods of Order 2s.\nJournal of Applied Mathematics, Volume 46, Pages 6-10, 2016.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIF̄","text":"Lobatto IIIF̄ tableau with s stages\n\nTableauLobattoIIIF̄(::Type{T}, s)\nTableauLobattoIIIF̄(s) = TableauLobattoIIIF̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThe Lobatto IIIF̄ tableau is the conjugate symplectic to TableauLobattoIIIF.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIG-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIG","text":"Lobatto IIIG tableau with s stages\n\nTableauLobattoIIIG(::Type{T}, s)\nTableauLobattoIIIG(s) = TableauLobattoIIIG(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nSymplectizied algorithm for TableauLobattoIIIF\n\nCoefficients are taken as a^G = frac12 ( a^F + bara^F ) where the coefficients bara^F are computed such that the symplecticity conditions b_i bara_ij + barb_j a_ji = b_i barb_j and b_i = barb_i hold for all 1 le ij le s.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIĀ","text":"Lobatto IIIĀ tableau with s stages\n\nTableauLobattoIIIĀ(::Type{T}, s)\nTableauLobattoIIIĀ(s) = TableauLobattoIIIĀ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIĀ tableau is the conjugate symplectic to TableauLobattoIIIA. On paper, its coefficients are identical to TableauLobattoIIIB, however, they are computed by the symplecticity condition and not by the formula for Lobatto IIIB and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIĒ","text":"Lobatto IIIĒ tableau with s stages\n\nTableauLobattoIIIĒ(::Type{T}, s)\nTableauLobattoIIIĒ(s) = TableauLobattoIIIĒ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIĒ tableau is the conjugate symplectic to TableauLobattoIIIE. On paper, the coefficients of the Lobatto IIIE tableau are symplectic, however, the Lobatto IIIĒ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIIE and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIḠ","text":"Lobatto IIIḠ tableau with s stages\n\nTableauLobattoIIIḠ(::Type{T}, s)\nTableauLobattoIIIḠ(s) = TableauLobattoIIIḠ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIḠ tableau is the conjugate symplectic to TableauLobattoIIIG. On paper, the coefficients of the Lobatto IIIG tableau are symplectic, however, the Lobatto IIIḠ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIIG and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauQinZhang-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauQinZhang","text":"Tableau of Qin and Zhang's symplectic two-stage, 2nd order method\n\nTableauQinZhang(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nM.-Z. Qin and M.-Q. Zhang.\nSymplectic Runge-Kutta algorithms for Hamilton systems.\nJournal of Computational Mathematics, Supplementary Issue, Pages 205-215, 1992.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK21","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK21","text":"Alias for TableauHeun2     according to\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 99\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK22","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK22","text":"Alias for TableauRunge     according to\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 99\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK31-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK31","text":"Tableau of a three-stage, 3rd order method\n\nTableauKutta(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 99\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK32","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK32","text":"Alias for TableauKutta according to\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 99\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK4","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK4","text":"Alias for TableauRK416\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK41","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK41","text":"Alias for TableauRK416 according to\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 102\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK416-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK416","text":"Tableau of explicit Runge-Kutta method of order four (1/6 rule)\n\nTableauRK416(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.\nPage 443\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK42-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK42","text":"Tableau of explicit Runge-Kutta method of order four with four stages\n\nTableauRK42(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 102\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK438-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK438","text":"Tableau of explicit Runge-Kutta method of order four (3/8 rule)\n\nTableauRK438(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.\nPage 441\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK5-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK5","text":"Tableau of explicit Runge-Kutta method of order five with six stages\n\nTableauRK5(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 103\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRadauIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRadauIA","text":"Radau IA tableau with s stages\n\nTableauRadauIA(::Type{T}, s)\nTableauRadauIA(s) = TableauRadauIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRadauIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRadauIB","text":"Radau IB tableau with s stages\n\nTableauRadauIB(::Type{T}, s)\nTableauRadauIB(s) = TableauRadauIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nCoefficients are taken as a^B = frac12 ( a^A + bara^A ) where a^A are the coefficients of the Radau IA method and bara^A are computed such that the symplecticity conditions b_i bara_ij + barb_j a_ji = b_i barb_j and b_i = barb_i hold for all 1 le ij le s.\n\nReference:\n\nSun Geng\nConstruction of high order symplectic Runge-Kutta methods\nJournal of Computational Mathematics, Volume 11, Pages 250-260, 1993.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRadauIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRadauIIA","text":"Radau IIA tableau with s stages\n\nTableauRadauIIA(::Type{T}, s)\nTableauRadauIIA(s) = TableauRadauIIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nOwe Axelsson.\nA class of A-stable methods.\nBIT, Volume 9, Pages 185-199, 1969.\ndoi: 10.1007/BF01946812.\n\nErnst Hairer and Gerhard Wanner.\nRadau Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_139.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRadauIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRadauIIB","text":"Radau IIB tableau with s stages\n\nTableauRadauIIB(::Type{T}, s)\nTableauRadauIIB(s) = TableauRadauIIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nCoefficients are taken as a^B = frac12 ( a^A + bara^A ) where a^A are the coefficients of the Radau IIA method and bara^AV are computed such that the symplecticity conditionsb{i} \\bar{a}{i,j} + \\bar{b}{j} a{j,i} = b{i} \\bar{b}{j}andb{i} = \\bar{b}ihold for all1 \\le i,j \\le s``.\n\nReference:\n\nSun Geng\nConstruction of high order symplectic Runge-Kutta methods\nJournal of Computational Mathematics, Volume 11, Pages 250-260, 1993.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRalston2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRalston2","text":"Tableau of Ralston's two-stage, 2nd order method\n\nTableauRalston2(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAnthony Ralston.\nRunge-Kutta Methods with Minimum Error Bounds.\nMathematics of Computation, Volume 16, Pages 431-437, 1962.\ndoi: 10.1090/S0025-5718-1962-0150954-0.\nEquation (3.5)\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRalston3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRalston3","text":"Tableau of Ralston's three-stage, 3rd order method\n\nTableauRalston3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAnthony Ralston.\nRunge-Kutta Methods with Minimum Error Bounds.\nMathematics of Computation, Volume 16, Pages 431-437, 1962.\ndoi: 10.1090/S0025-5718-1962-0150954-0.\nEquation (4.10)\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRunge-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRunge","text":"Tableau of Runge's two-stage, 2nd order method\n\nTableauRunge(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nCarl Runge\nÜber die numerische Auflösung von Differentialgleichungen.\nMathematische Annalen, Volume 46, Pages 167-178, 1895.\ndoi: 10.1007/BF01446807.\nEquation (3)\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRunge2","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRunge2","text":"Alias for TableauRunge\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauSRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauSRK3","text":"Tableau of symmetric and symplectic three-stage, 4th order Runge-Kutta method\n\nTableauSRK3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nShan Zhao and Guo-Wei Wei.\nA unified discontinuous Galerkin framework for time integration.\nMathematical Methods in the Applied Sciences, Volume 37, Issue 7, Pages 1042-1071, 2014.\ndoi: 10.1002/mma.2863.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauSSPRK2-Tuple","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauSSPRK2","text":"Tableau of 2rd order Strong Stability Preserving method with two stages and CFL ≤ 1\n\nTableauSSPRK2(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nThis is the same tableau as TableauHeun2.\n\nReference:\n\nChi-Wang Shu, Stanley Osher.\nEfficient implementation of essentially non-oscillatory shock-capturing schemes.\nJournal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.\ndoi: 10.1016/0021-9991(88)90177-5.\nEquation (2.16)\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauSSPRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauSSPRK3","text":"Tableau of 3rd order Strong Stability Preserving method with three stages and CFL ≤ 1\n\nTableauSSPRK3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nChi-Wang Shu, Stanley Osher.\nEfficient implementation of essentially non-oscillatory shock-capturing schemes.\nJournal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.\ndoi: 10.1016/0021-9991(88)90177-5.\nEquation (2.18)\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_gauss_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_gauss_coefficients","text":"The Gauss coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_gauss_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_gauss_nodes","text":"The Gauss nodes are given by the roots of the shifted Legendre polynomial P_s (2x-1) with s the number of stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_gauss_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_gauss_weights","text":"The Gauss weights are given by the following integrals\n\nb_i = bigg( fracdPdx (c_i) bigg)^-2 int limits_0^1 bigg( fracP(x)x - c_i bigg)^2 dx \n\nwhere P(x) denotes the shifted Legendre polynomial P(x) = P_s (2x-1) with s the number of stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_a_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_a_coefficients","text":"The Lobatto IIIA coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_b_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_b_coefficients","text":"The Lobatto IIIB coefficients are implicitly given by the so-called simplifying assumption D(s):\n\nsum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k)  qquad j = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_c_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_c_coefficients","text":"The Lobatto IIIC coefficients are determined by setting a_i1 = b_1 and solving the so-called simplifying assumption C(s-1), given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s-1 \n\nfor a_ij with i = 1  s and j = 2  s.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_c̄_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_c̄_coefficients","text":"The Lobatto IIIC̄ coefficients are determined by setting a_is = 0 and solving the so-called simplifying assumption C(s-1), given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s-1 \n\nfor a_ij with i = 1  s and j = 1  s-1.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_nodes","text":"The s-stage Lobatto nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-2dx^s-2 big( (x - x^2)^s-1 big) \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_nullvector-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_nullvector","text":"get_lobatto_nullvector(::Type, s; normalize=false)\nget_lobatto_nullvector(s; kwargs...)\n\nComputes the nullvector of the matrix containing the derivatives of the Lagrange basis on the s Lobatto nodes evaluated on these nodes.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_weights","text":"The Lobatto weights can be explicitly computed by the formula\n\nb_j = frac1s (s-1) P_s-1(2 c_j - 1)^2 qquad j = 1      s \n\nwhere P_k is the kth Legendre polynomial, given by\n\nP_k (x) = frac1k 2^k big( fracd^kdx^k (x^2 - 1)^k big) \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_radau_1_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_radau_1_coefficients","text":"The Radau IA coefficients are implicitly given by the so-called simplifying assumption D(s):\n\nsum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k)  qquad j = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_radau_1_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_radau_1_nodes","text":"The s-stage Radau IA nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-1dx^s-1 big( x^s (x - 1)^s-1 big) \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_radau_1_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_radau_1_weights","text":"The Radau IA weights are implicitly given by the so-called simplifying assumption B(s):\n\nsum limits_j=1^s b_j c_j^k-1 = frac1k  qquad k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_radau_2_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_radau_2_coefficients","text":"The Radau IIA coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_radau_2_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_radau_2_nodes","text":"The s-stage Radau IIA nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-1dx^s-1 big( x^s-1 (x - 1)^s big) \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_radau_2_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_radau_2_weights","text":"The Radau IIA weights are implicitly given by the so-called simplifying assumption B(s):\n\nsum limits_j=1^s b_j c_j^k-1 = frac1k  qquad k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#partitioned-runge-kutta-rableaus","page":"Runge-Kutta Tableaus","title":"Partitioned Runge-Kutta Tableaus","text":"","category":"section"},{"location":"modules/rungekutta/","page":"Runge-Kutta Tableaus","title":"Runge-Kutta Tableaus","text":"RungeKutta.PartitionedTableau","category":"page"},{"location":"modules/rungekutta/#RungeKutta.PartitionedTableau","page":"Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableau","text":"Tableau of a Partitioned Runge-Kutta method\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  v(t_n + c_j Delta t Q_nj P_nj)  \nq_n+1 = q_n + h sum limits_i=1^s b_i   v(t_n + c_j Delta t Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  f(t_n + c_j Delta t Q_nj P_nj)  \np_n+1 = p_n + h sum limits_i=1^s barb_i    f(t_n + c_j Delta t Q_ni P_ni) \nendaligned\n\nParameters:\n\nT: datatype of coefficient arrays\n\nFields:\n\nname: symbolic name of the tableau\no: order of the method\ns: number of stages\nq: Tableau for q\np: Tableau for p\nR∞: stability function at infinity\n\nThe actual tableaus are stored in q and p:\n\na: coefficients a_ij with $ 1 \\le i,j \\le s$\nb: weights b_i  with $ 1 \\le i \\le s$\nc: nodes c_i  with $ 1 \\le i \\le s$\n\nConstructors:\n\nPartitionedTableau{T}(name, o, q, p)\nPartitionedTableau{T}(name, q, p)\nPartitionedTableau(name::Symbol, q::Tableau, p::Tableau)\nPartitionedTableau(name::Symbol, q::Tableau)\n\n\n\n\n\n","category":"type"},{"location":"modules/rungekutta/","page":"Runge-Kutta Tableaus","title":"Runge-Kutta Tableaus","text":"Modules = [RungeKutta.PartitionedTableaus]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/rungekutta/#RungeKutta.PartitionedTableaus.PartitionedTableauGauss-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.PartitionedTableauGauss","text":"Partitioned Gauss-Legendre Runge-Kutta tableau with s stages\n\nPartitionedTableauGauss(::Type{T}, s)\nPartitionedTableauGauss(s) = PartitionedTableauGauss(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauGauss for both coefficients a and ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIB-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIB","text":"Partitioned Gauss-Lobatto IIIA-IIIB tableau with s stages\n\nTableauLobattoIIIAIIIB(::Type{T}, s)\nTableauLobattoIIIAIIIB(s) = TableauLobattoIIIAIIIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIA for a and TableauLobattoIIIB for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIĀ","text":"Tableau for Gauss-Lobatto IIIA-IIIĀ method with s stages\n\nTableauLobattoIIIAIIIĀ(::Type{T}, s)\nTableauLobattoIIIAIIIĀ(s) = TableauLobattoIIIAIIIĀ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIA for a and TableauLobattoIIIĀ for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIA-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages\n\nTableauLobattoIIIBIIIA(::Type{T}, s)\nTableauLobattoIIIBIIIA(s) = TableauLobattoIIIBIIIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIB for a and TableauLobattoIIIA for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIB̄","text":"Tableau for Gauss-Lobatto IIIB-IIIB̄ method with s stages\n\nTableauLobattoIIIBIIIB̄(::Type{T}, s)\nTableauLobattoIIIBIIIB̄(s) = TableauLobattoIIIBIIIB̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIB for a and TableauLobattoIIIB̄ for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.PartitionedTableaus.TableauLobattoIIICIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIICIIIC̄","text":"Tableau for Gauss-Lobatto IIIC-IIIC̄ method with s stages\n\nTableauLobattoIIICIIIC̄(::Type{T}, s)\nTableauLobattoIIICIIIC̄(s) = TableauLobattoIIICIIIC̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIC for a and TableauLobattoIIIC̄ for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.PartitionedTableaus.TableauLobattoIIIC̄IIIC-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIC̄IIIC","text":"Tableau for Gauss-Lobatto IIIC̄-IIIC method with s stages\n\nTableauLobattoIIIC̄IIIC(::Type{T}, s)\nTableauLobattoIIIC̄IIIC(s) = TableauLobattoIIIC̄IIIC(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIC̄ for a and TableauLobattoIIIC for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.PartitionedTableaus.TableauLobattoIIIDIIID̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIDIIID̄","text":"Tableau for Gauss-Lobatto IIID-IIID̄ method with s stages\n\nTableauLobattoIIIDIIID̄(::Type{T}, s)\nTableauLobattoIIIDIIID̄(s) = TableauLobattoIIIDIIID̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIID for a and TableauLobattoIIID̄ for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.PartitionedTableaus.TableauLobattoIIIEIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIEIIIĒ","text":"Tableau for Gauss-Lobatto IIIE-IIIĒ method with s stages\n\nTableauLobattoIIIEIIIĒ(::Type{T}, s)\nTableauLobattoIIIEIIIĒ(s) = TableauLobattoIIIEIIIĒ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIE for a and TableauLobattoIIIĒ for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.PartitionedTableaus.TableauLobattoIIIFIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIFIIIF̄","text":"Tableau for Gauss-Lobatto IIIF-IIIF̄ method with s stages\n\nTableauLobattoIIIFIIIF̄(::Type{T}, s)\nTableauLobattoIIIFIIIF̄(s) = TableauLobattoIIIFIIIF̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIF for a and TableauLobattoIIIF̄ for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.PartitionedTableaus.TableauLobattoIIIF̄IIIF-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIF̄IIIF","text":"Tableau for Gauss-Lobatto IIIF̄-IIIF method with s stages\n\nTableauLobattoIIIF̄IIIF(::Type{T}, s)\nTableauLobattoIIIF̄IIIF(s) = TableauLobattoIIIF̄IIIF(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIF̄ for a and TableauLobattoIIIF for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.PartitionedTableaus.TableauLobattoIIIGIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIGIIIḠ","text":"Tableau for Gauss-Lobatto IIIG-IIIḠ method with s stages\n\nTableauLobattoIIIGIIIḠ(::Type{T}, s)\nTableauLobattoIIIGIIIḠ(s) = TableauLobattoIIIGIIIḠ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIG for a and TableauLobattoIIIḠ for ā.\n\n\n\n\n\n","category":"method"},{"location":"methods/#List-of-all-Methods","page":"Methods","title":"List of all Methods","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Method Order Explicit Symmetric Symplectic ODE PODE HODE IODE LODE SODE DAE PDAE HDAE IDAE LDAE\nERK missing ✓ missing missing ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nIRK missing ✗ missing missing ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nDIRK missing ✗ missing missing ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nEPRK missing ✓ missing missing ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nIPRK missing ✗ missing missing ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRK missing missing missing missing ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nDVRK missing ✗ missing ✓ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nCGVI missing ✗ missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nProjectedMethod missing missing missing missing ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗\nHPImidpoint missing missing missing missing ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nHPItrapezoidal missing missing missing missing ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nExplicitEuler missing ✓ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗\nImplicitEuler missing ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗\nForwardEuler missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nExplicitEulerRK missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nExplicitMidpoint missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nHeun2 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nHeun3 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nKutta3 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRalston2 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRalston3 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRK21 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRK22 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRK31 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRK32 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRK4 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRK41 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRK42 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRK416 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRK438 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRK5 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRunge2 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nSSPRK2 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nSSPRK3 missing ✓ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nCrankNicolson missing ✗ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nCrouzeix missing ✗ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nKraaijevangerSpijker missing ✗ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nQinZhang missing ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nBackwardEuler missing ✗ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nImplicitEulerRK missing ✗ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nImplicitMidpoint missing ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nSRK3 missing ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nGauss 2s ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIII 2s-2 ✗ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIA 2s-2 ✗ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIB 2s-2 ✗ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIC 2s-2 ✗ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIID 2s-2 ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIE 2s-2 ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIF 2s ✗ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIF̄ 2s ✗ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIG 2s ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRadauIA 2s-1 ✗ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRadauIB 2s-1 ✗ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRadauIIA 2s-1 ✗ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nRadauIIB 2s-1 ✗ ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nSymplecticEulerA 1 ✓ ✗ ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nSymplecticEulerB 1 ✓ ✗ ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nPartitionedGauss 2s ✗ missing ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIAIIIB 2s-2 missing missing ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIBIIIA 2s-2 missing missing ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIAIIIĀ 2s-2 missing missing ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIBIIIB̄ 2s-2 missing missing ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIICIIIC̄ 2s-2 missing missing ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIC̄IIIC 2s-2 missing missing ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIDIIID̄ 2s-2 missing missing ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIEIIIĒ 2s-2 missing missing ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIFIIIF̄ 2s missing missing ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIF̄IIIF 2s missing missing ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLobattoIIIGIIIḠ 2s missing missing ✓ ✗ ✓ ✓ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPSRK3 missing ✗ ✓ ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKGauss 2s missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKRadauIIA 2s-1 missing missing ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKRadauIIB 2s-1 missing missing ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIII 2s-2 missing missing ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIA 2s-2 missing missing ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIB 2s-2 missing missing ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIC 2s-2 missing missing ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIID 2s-2 missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIE 2s-2 missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIF 2s missing missing ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIF̄ 2s missing missing ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIG 2s missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIAIIIB 2s-2 missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIBIIIA 2s-2 missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIAIIIĀ 2s-2 missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIBIIIB̄ 2s-2 missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIICIIIC̄ 2s-2 missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIC̄IIIC 2s-2 missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIDIIID̄ 2s-2 missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIEIIIĒ 2s-2 missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIFIIIF̄ 2s missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIF̄IIIF 2s missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nVPRKLobattoIIIGIIIḠ 2s missing missing ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nHPImidpoint missing missing missing missing ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nHPItrapezoidal missing missing missing missing ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nPMVImidpoint missing ✗ ✓ ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nPMVItrapezoidal missing ✗ ✓ ✓ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nDVIA 1 ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nDVIB 1 ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nCMDVI 2 ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nCTDVI 2 ✗ ✓ ✓ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗\nLieA 1 ✓ missing missing ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗\nLieB 1 ✓ missing missing ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗\nStrang 2 ✓ missing missing ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗\nMarchuk 2 ✓ missing missing ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗\nStrangA 2 ✓ missing missing ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗\nStrangB 2 ✓ missing missing ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗\nMcLachlan2 2 ✓ missing missing ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗\nMcLachlan4 4 ✓ missing missing ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗\nTripleJump 4 ✓ missing missing ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗\nSuzukiFractal 4 ✓ missing missing ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗","category":"page"},{"location":"methods/#ODE-Methods","page":"Methods","title":"ODE Methods","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Method Order Explicit Symmetric Symplectic\nERK missing ✓ missing missing\nIRK missing ✗ missing missing\nDIRK missing ✗ missing missing\nExplicitEuler missing ✓ ✗ ✗\nImplicitEuler missing ✗ ✗ ✗\nForwardEuler missing ✓ ✗ ✗\nExplicitEulerRK missing ✓ ✗ ✗\nExplicitMidpoint missing ✓ ✗ ✗\nHeun2 missing ✓ ✗ ✗\nHeun3 missing ✓ ✗ ✗\nKutta3 missing ✓ ✗ ✗\nRalston2 missing ✓ ✗ ✗\nRalston3 missing ✓ ✗ ✗\nRK21 missing ✓ ✗ ✗\nRK22 missing ✓ ✗ ✗\nRK31 missing ✓ ✗ ✗\nRK32 missing ✓ ✗ ✗\nRK4 missing ✓ ✗ ✗\nRK41 missing ✓ ✗ ✗\nRK42 missing ✓ ✗ ✗\nRK416 missing ✓ ✗ ✗\nRK438 missing ✓ ✗ ✗\nRK5 missing ✓ ✗ ✗\nRunge2 missing ✓ ✗ ✗\nSSPRK2 missing ✓ ✗ ✗\nSSPRK3 missing ✓ ✗ ✗\nCrankNicolson missing ✗ ✓ ✗\nCrouzeix missing ✗ ✗ ✗\nKraaijevangerSpijker missing ✗ ✗ ✗\nQinZhang missing ✗ ✓ ✓\nBackwardEuler missing ✗ ✗ ✗\nImplicitEulerRK missing ✗ ✗ ✗\nImplicitMidpoint missing ✗ ✓ ✓\nSRK3 missing ✗ ✓ ✓\nGauss 2s ✗ ✓ ✓\nLobattoIII 2s-2 ✗ ✗ ✗\nLobattoIIIA 2s-2 ✗ ✓ ✗\nLobattoIIIB 2s-2 ✗ ✓ ✗\nLobattoIIIC 2s-2 ✗ ✗ ✗\nLobattoIIID 2s-2 ✗ ✓ ✓\nLobattoIIIE 2s-2 ✗ ✓ ✓\nLobattoIIIF 2s ✗ ✓ ✗\nLobattoIIIF̄ 2s ✗ ✓ ✗\nLobattoIIIG 2s ✗ ✓ ✓\nRadauIA 2s-1 ✗ ✗ ✗\nRadauIB 2s-1 ✗ ✗ ✗\nRadauIIA 2s-1 ✗ ✗ ✗\nRadauIIB 2s-1 ✗ ✗ ✗","category":"page"},{"location":"methods/#PODE-Methods","page":"Methods","title":"PODE Methods","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Method Order Explicit Symmetric Symplectic\nERK missing ✓ missing missing\nIRK missing ✗ missing missing\nDIRK missing ✗ missing missing\nEPRK missing ✓ missing missing\nIPRK missing ✗ missing missing\nForwardEuler missing ✓ ✗ ✗\nExplicitEulerRK missing ✓ ✗ ✗\nExplicitMidpoint missing ✓ ✗ ✗\nHeun2 missing ✓ ✗ ✗\nHeun3 missing ✓ ✗ ✗\nKutta3 missing ✓ ✗ ✗\nRalston2 missing ✓ ✗ ✗\nRalston3 missing ✓ ✗ ✗\nRK21 missing ✓ ✗ ✗\nRK22 missing ✓ ✗ ✗\nRK31 missing ✓ ✗ ✗\nRK32 missing ✓ ✗ ✗\nRK4 missing ✓ ✗ ✗\nRK41 missing ✓ ✗ ✗\nRK42 missing ✓ ✗ ✗\nRK416 missing ✓ ✗ ✗\nRK438 missing ✓ ✗ ✗\nRK5 missing ✓ ✗ ✗\nRunge2 missing ✓ ✗ ✗\nSSPRK2 missing ✓ ✗ ✗\nSSPRK3 missing ✓ ✗ ✗\nCrankNicolson missing ✗ ✓ ✗\nCrouzeix missing ✗ ✗ ✗\nKraaijevangerSpijker missing ✗ ✗ ✗\nQinZhang missing ✗ ✓ ✓\nBackwardEuler missing ✗ ✗ ✗\nImplicitEulerRK missing ✗ ✗ ✗\nImplicitMidpoint missing ✗ ✓ ✓\nSRK3 missing ✗ ✓ ✓\nGauss 2s ✗ ✓ ✓\nLobattoIII 2s-2 ✗ ✗ ✗\nLobattoIIIA 2s-2 ✗ ✓ ✗\nLobattoIIIB 2s-2 ✗ ✓ ✗\nLobattoIIIC 2s-2 ✗ ✗ ✗\nLobattoIIID 2s-2 ✗ ✓ ✓\nLobattoIIIE 2s-2 ✗ ✓ ✓\nLobattoIIIF 2s ✗ ✓ ✗\nLobattoIIIF̄ 2s ✗ ✓ ✗\nLobattoIIIG 2s ✗ ✓ ✓\nRadauIA 2s-1 ✗ ✗ ✗\nRadauIB 2s-1 ✗ ✗ ✗\nRadauIIA 2s-1 ✗ ✗ ✗\nRadauIIB 2s-1 ✗ ✗ ✗\nSymplecticEulerA 1 ✓ ✗ ✓\nSymplecticEulerB 1 ✓ ✗ ✓\nPartitionedGauss 2s ✗ missing ✓\nLobattoIIIAIIIB 2s-2 missing missing ✓\nLobattoIIIBIIIA 2s-2 missing missing ✓\nLobattoIIIAIIIĀ 2s-2 missing missing ✓\nLobattoIIIBIIIB̄ 2s-2 missing missing ✓\nLobattoIIICIIIC̄ 2s-2 missing missing ✓\nLobattoIIIC̄IIIC 2s-2 missing missing ✓\nLobattoIIIDIIID̄ 2s-2 missing missing ✓\nLobattoIIIEIIIĒ 2s-2 missing missing ✓\nLobattoIIIFIIIF̄ 2s missing missing ✓\nLobattoIIIF̄IIIF 2s missing missing ✓\nLobattoIIIGIIIḠ 2s missing missing ✓","category":"page"},{"location":"methods/#HODE-Methods","page":"Methods","title":"HODE Methods","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Method Order Explicit Symmetric Symplectic\nERK missing ✓ missing missing\nIRK missing ✗ missing missing\nDIRK missing ✗ missing missing\nEPRK missing ✓ missing missing\nIPRK missing ✗ missing missing\nForwardEuler missing ✓ ✗ ✗\nExplicitEulerRK missing ✓ ✗ ✗\nExplicitMidpoint missing ✓ ✗ ✗\nHeun2 missing ✓ ✗ ✗\nHeun3 missing ✓ ✗ ✗\nKutta3 missing ✓ ✗ ✗\nRalston2 missing ✓ ✗ ✗\nRalston3 missing ✓ ✗ ✗\nRK21 missing ✓ ✗ ✗\nRK22 missing ✓ ✗ ✗\nRK31 missing ✓ ✗ ✗\nRK32 missing ✓ ✗ ✗\nRK4 missing ✓ ✗ ✗\nRK41 missing ✓ ✗ ✗\nRK42 missing ✓ ✗ ✗\nRK416 missing ✓ ✗ ✗\nRK438 missing ✓ ✗ ✗\nRK5 missing ✓ ✗ ✗\nRunge2 missing ✓ ✗ ✗\nSSPRK2 missing ✓ ✗ ✗\nSSPRK3 missing ✓ ✗ ✗\nCrankNicolson missing ✗ ✓ ✗\nCrouzeix missing ✗ ✗ ✗\nKraaijevangerSpijker missing ✗ ✗ ✗\nQinZhang missing ✗ ✓ ✓\nBackwardEuler missing ✗ ✗ ✗\nImplicitEulerRK missing ✗ ✗ ✗\nImplicitMidpoint missing ✗ ✓ ✓\nSRK3 missing ✗ ✓ ✓\nGauss 2s ✗ ✓ ✓\nLobattoIII 2s-2 ✗ ✗ ✗\nLobattoIIIA 2s-2 ✗ ✓ ✗\nLobattoIIIB 2s-2 ✗ ✓ ✗\nLobattoIIIC 2s-2 ✗ ✗ ✗\nLobattoIIID 2s-2 ✗ ✓ ✓\nLobattoIIIE 2s-2 ✗ ✓ ✓\nLobattoIIIF 2s ✗ ✓ ✗\nLobattoIIIF̄ 2s ✗ ✓ ✗\nLobattoIIIG 2s ✗ ✓ ✓\nRadauIA 2s-1 ✗ ✗ ✗\nRadauIB 2s-1 ✗ ✗ ✗\nRadauIIA 2s-1 ✗ ✗ ✗\nRadauIIB 2s-1 ✗ ✗ ✗\nSymplecticEulerA 1 ✓ ✗ ✓\nSymplecticEulerB 1 ✓ ✗ ✓\nPartitionedGauss 2s ✗ missing ✓\nLobattoIIIAIIIB 2s-2 missing missing ✓\nLobattoIIIBIIIA 2s-2 missing missing ✓\nLobattoIIIAIIIĀ 2s-2 missing missing ✓\nLobattoIIIBIIIB̄ 2s-2 missing missing ✓\nLobattoIIICIIIC̄ 2s-2 missing missing ✓\nLobattoIIIC̄IIIC 2s-2 missing missing ✓\nLobattoIIIDIIID̄ 2s-2 missing missing ✓\nLobattoIIIEIIIĒ 2s-2 missing missing ✓\nLobattoIIIFIIIF̄ 2s missing missing ✓\nLobattoIIIF̄IIIF 2s missing missing ✓\nLobattoIIIGIIIḠ 2s missing missing ✓","category":"page"},{"location":"methods/#IODE-Methods","page":"Methods","title":"IODE Methods","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Method Order Explicit Symmetric Symplectic\nERK missing ✓ missing missing\nIRK missing ✗ missing missing\nDIRK missing ✗ missing missing\nEPRK missing ✓ missing missing\nIPRK missing ✗ missing missing\nVPRK missing missing missing missing\nCGVI missing ✗ missing ✓\nHPImidpoint missing missing missing missing\nHPItrapezoidal missing missing missing missing\nForwardEuler missing ✓ ✗ ✗\nExplicitEulerRK missing ✓ ✗ ✗\nExplicitMidpoint missing ✓ ✗ ✗\nHeun2 missing ✓ ✗ ✗\nHeun3 missing ✓ ✗ ✗\nKutta3 missing ✓ ✗ ✗\nRalston2 missing ✓ ✗ ✗\nRalston3 missing ✓ ✗ ✗\nRK21 missing ✓ ✗ ✗\nRK22 missing ✓ ✗ ✗\nRK31 missing ✓ ✗ ✗\nRK32 missing ✓ ✗ ✗\nRK4 missing ✓ ✗ ✗\nRK41 missing ✓ ✗ ✗\nRK42 missing ✓ ✗ ✗\nRK416 missing ✓ ✗ ✗\nRK438 missing ✓ ✗ ✗\nRK5 missing ✓ ✗ ✗\nRunge2 missing ✓ ✗ ✗\nSSPRK2 missing ✓ ✗ ✗\nSSPRK3 missing ✓ ✗ ✗\nCrankNicolson missing ✗ ✓ ✗\nCrouzeix missing ✗ ✗ ✗\nKraaijevangerSpijker missing ✗ ✗ ✗\nQinZhang missing ✗ ✓ ✓\nBackwardEuler missing ✗ ✗ ✗\nImplicitEulerRK missing ✗ ✗ ✗\nImplicitMidpoint missing ✗ ✓ ✓\nSRK3 missing ✗ ✓ ✓\nGauss 2s ✗ ✓ ✓\nLobattoIII 2s-2 ✗ ✗ ✗\nLobattoIIIA 2s-2 ✗ ✓ ✗\nLobattoIIIB 2s-2 ✗ ✓ ✗\nLobattoIIIC 2s-2 ✗ ✗ ✗\nLobattoIIID 2s-2 ✗ ✓ ✓\nLobattoIIIE 2s-2 ✗ ✓ ✓\nLobattoIIIF 2s ✗ ✓ ✗\nLobattoIIIF̄ 2s ✗ ✓ ✗\nLobattoIIIG 2s ✗ ✓ ✓\nRadauIA 2s-1 ✗ ✗ ✗\nRadauIB 2s-1 ✗ ✗ ✗\nRadauIIA 2s-1 ✗ ✗ ✗\nRadauIIB 2s-1 ✗ ✗ ✗\nSymplecticEulerA 1 ✓ ✗ ✓\nSymplecticEulerB 1 ✓ ✗ ✓\nPartitionedGauss 2s ✗ missing ✓\nLobattoIIIAIIIB 2s-2 missing missing ✓\nLobattoIIIBIIIA 2s-2 missing missing ✓\nLobattoIIIAIIIĀ 2s-2 missing missing ✓\nLobattoIIIBIIIB̄ 2s-2 missing missing ✓\nLobattoIIICIIIC̄ 2s-2 missing missing ✓\nLobattoIIIC̄IIIC 2s-2 missing missing ✓\nLobattoIIIDIIID̄ 2s-2 missing missing ✓\nLobattoIIIEIIIĒ 2s-2 missing missing ✓\nLobattoIIIFIIIF̄ 2s missing missing ✓\nLobattoIIIF̄IIIF 2s missing missing ✓\nLobattoIIIGIIIḠ 2s missing missing ✓\nVPSRK3 missing ✗ ✓ ✓\nVPRKGauss 2s missing missing ✓\nVPRKRadauIIA 2s-1 missing missing ✗\nVPRKRadauIIB 2s-1 missing missing ✗\nVPRKLobattoIII 2s-2 missing missing ✗\nVPRKLobattoIIIA 2s-2 missing missing ✗\nVPRKLobattoIIIB 2s-2 missing missing ✗\nVPRKLobattoIIIC 2s-2 missing missing ✗\nVPRKLobattoIIID 2s-2 missing missing ✓\nVPRKLobattoIIIE 2s-2 missing missing ✓\nVPRKLobattoIIIF 2s missing missing ✗\nVPRKLobattoIIIF̄ 2s missing missing ✗\nVPRKLobattoIIIG 2s missing missing ✓\nVPRKLobattoIIIAIIIB 2s-2 missing missing ✓\nVPRKLobattoIIIBIIIA 2s-2 missing missing ✓\nVPRKLobattoIIIAIIIĀ 2s-2 missing missing ✓\nVPRKLobattoIIIBIIIB̄ 2s-2 missing missing ✓\nVPRKLobattoIIICIIIC̄ 2s-2 missing missing ✓\nVPRKLobattoIIIC̄IIIC 2s-2 missing missing ✓\nVPRKLobattoIIIDIIID̄ 2s-2 missing missing ✓\nVPRKLobattoIIIEIIIĒ 2s-2 missing missing ✓\nVPRKLobattoIIIFIIIF̄ 2s missing missing ✓\nVPRKLobattoIIIF̄IIIF 2s missing missing ✓\nVPRKLobattoIIIGIIIḠ 2s missing missing ✓\nHPImidpoint missing missing missing missing\nHPItrapezoidal missing missing missing missing\nPMVImidpoint missing ✗ ✓ ✓\nPMVItrapezoidal missing ✗ ✓ ✓","category":"page"},{"location":"methods/#LODE-Methods","page":"Methods","title":"LODE Methods","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Method Order Explicit Symmetric Symplectic\nERK missing ✓ missing missing\nIRK missing ✗ missing missing\nDIRK missing ✗ missing missing\nEPRK missing ✓ missing missing\nIPRK missing ✗ missing missing\nVPRK missing missing missing missing\nDVRK missing ✗ missing ✓\nCGVI missing ✗ missing ✓\nHPImidpoint missing missing missing missing\nHPItrapezoidal missing missing missing missing\nForwardEuler missing ✓ ✗ ✗\nExplicitEulerRK missing ✓ ✗ ✗\nExplicitMidpoint missing ✓ ✗ ✗\nHeun2 missing ✓ ✗ ✗\nHeun3 missing ✓ ✗ ✗\nKutta3 missing ✓ ✗ ✗\nRalston2 missing ✓ ✗ ✗\nRalston3 missing ✓ ✗ ✗\nRK21 missing ✓ ✗ ✗\nRK22 missing ✓ ✗ ✗\nRK31 missing ✓ ✗ ✗\nRK32 missing ✓ ✗ ✗\nRK4 missing ✓ ✗ ✗\nRK41 missing ✓ ✗ ✗\nRK42 missing ✓ ✗ ✗\nRK416 missing ✓ ✗ ✗\nRK438 missing ✓ ✗ ✗\nRK5 missing ✓ ✗ ✗\nRunge2 missing ✓ ✗ ✗\nSSPRK2 missing ✓ ✗ ✗\nSSPRK3 missing ✓ ✗ ✗\nCrankNicolson missing ✗ ✓ ✗\nCrouzeix missing ✗ ✗ ✗\nKraaijevangerSpijker missing ✗ ✗ ✗\nQinZhang missing ✗ ✓ ✓\nBackwardEuler missing ✗ ✗ ✗\nImplicitEulerRK missing ✗ ✗ ✗\nImplicitMidpoint missing ✗ ✓ ✓\nSRK3 missing ✗ ✓ ✓\nGauss 2s ✗ ✓ ✓\nLobattoIII 2s-2 ✗ ✗ ✗\nLobattoIIIA 2s-2 ✗ ✓ ✗\nLobattoIIIB 2s-2 ✗ ✓ ✗\nLobattoIIIC 2s-2 ✗ ✗ ✗\nLobattoIIID 2s-2 ✗ ✓ ✓\nLobattoIIIE 2s-2 ✗ ✓ ✓\nLobattoIIIF 2s ✗ ✓ ✗\nLobattoIIIF̄ 2s ✗ ✓ ✗\nLobattoIIIG 2s ✗ ✓ ✓\nRadauIA 2s-1 ✗ ✗ ✗\nRadauIB 2s-1 ✗ ✗ ✗\nRadauIIA 2s-1 ✗ ✗ ✗\nRadauIIB 2s-1 ✗ ✗ ✗\nSymplecticEulerA 1 ✓ ✗ ✓\nSymplecticEulerB 1 ✓ ✗ ✓\nPartitionedGauss 2s ✗ missing ✓\nLobattoIIIAIIIB 2s-2 missing missing ✓\nLobattoIIIBIIIA 2s-2 missing missing ✓\nLobattoIIIAIIIĀ 2s-2 missing missing ✓\nLobattoIIIBIIIB̄ 2s-2 missing missing ✓\nLobattoIIICIIIC̄ 2s-2 missing missing ✓\nLobattoIIIC̄IIIC 2s-2 missing missing ✓\nLobattoIIIDIIID̄ 2s-2 missing missing ✓\nLobattoIIIEIIIĒ 2s-2 missing missing ✓\nLobattoIIIFIIIF̄ 2s missing missing ✓\nLobattoIIIF̄IIIF 2s missing missing ✓\nLobattoIIIGIIIḠ 2s missing missing ✓\nVPSRK3 missing ✗ ✓ ✓\nVPRKGauss 2s missing missing ✓\nVPRKRadauIIA 2s-1 missing missing ✗\nVPRKRadauIIB 2s-1 missing missing ✗\nVPRKLobattoIII 2s-2 missing missing ✗\nVPRKLobattoIIIA 2s-2 missing missing ✗\nVPRKLobattoIIIB 2s-2 missing missing ✗\nVPRKLobattoIIIC 2s-2 missing missing ✗\nVPRKLobattoIIID 2s-2 missing missing ✓\nVPRKLobattoIIIE 2s-2 missing missing ✓\nVPRKLobattoIIIF 2s missing missing ✗\nVPRKLobattoIIIF̄ 2s missing missing ✗\nVPRKLobattoIIIG 2s missing missing ✓\nVPRKLobattoIIIAIIIB 2s-2 missing missing ✓\nVPRKLobattoIIIBIIIA 2s-2 missing missing ✓\nVPRKLobattoIIIAIIIĀ 2s-2 missing missing ✓\nVPRKLobattoIIIBIIIB̄ 2s-2 missing missing ✓\nVPRKLobattoIIICIIIC̄ 2s-2 missing missing ✓\nVPRKLobattoIIIC̄IIIC 2s-2 missing missing ✓\nVPRKLobattoIIIDIIID̄ 2s-2 missing missing ✓\nVPRKLobattoIIIEIIIĒ 2s-2 missing missing ✓\nVPRKLobattoIIIFIIIF̄ 2s missing missing ✓\nVPRKLobattoIIIF̄IIIF 2s missing missing ✓\nVPRKLobattoIIIGIIIḠ 2s missing missing ✓\nHPImidpoint missing missing missing missing\nHPItrapezoidal missing missing missing missing\nPMVImidpoint missing ✗ ✓ ✓\nPMVItrapezoidal missing ✗ ✓ ✓\nDVIA 1 ✗ ✗ ✓\nDVIB 1 ✗ ✗ ✓\nCMDVI 2 ✗ ✓ ✓\nCTDVI 2 ✗ ✓ ✓","category":"page"},{"location":"methods/#SODE-Methods","page":"Methods","title":"SODE Methods","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Method Order Explicit Symmetric Symplectic\nLieA 1 ✓ missing missing\nLieB 1 ✓ missing missing\nStrang 2 ✓ missing missing\nMarchuk 2 ✓ missing missing\nStrangA 2 ✓ missing missing\nStrangB 2 ✓ missing missing\nMcLachlan2 2 ✓ missing missing\nMcLachlan4 4 ✓ missing missing\nTripleJump 4 ✓ missing missing\nSuzukiFractal 4 ✓ missing missing","category":"page"},{"location":"modules/#Modules","page":"Modules","title":"Modules","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Pages = [#\"modules/discontinuities.md\",\n         \"modules/equations.md\",\n         \"modules/solutions.md\",\n         \"modules/integrators.md\",\n         \"modules/interpolation.md\",\n         #\"modules/simulations.md\",\n         \"modules/tableaus.md\",\n         \"modules/rungekutta.md\"]\nDepth = 3","category":"page"},{"location":"releasenotes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"releasenotes/#0.11.0","page":"Release Notes","title":"0.11.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Rename AtomicSolution to SolutionStep\nDisable Simulation functionality until EnsembleSolution is added to GeometricEquations.jl","category":"page"},{"location":"releasenotes/#New-Features","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/#Documentation","page":"Release Notes","title":"Documentation","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Include documentation of GeometricEquations.jl and GeometricSolutions.jl","category":"page"},{"location":"releasenotes/#0.10.0","page":"Release Notes","title":"0.10.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes-2","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Refactor TimeSeries, DataSeries and Solution and move to GeometricSolutions.jl\nAdapt Solution HDF5 interface to default Julia argument order and naming conventions\nExtract HDF5 functionality from Solutions into separate data structure\nRemove parallel Solution types","category":"page"},{"location":"releasenotes/#0.9.0","page":"Release Notes","title":"0.9.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes-3","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Move HermiteInterpolation to Integrators and remove Interpolation sub-package\nMove Equations submodule to GeometricEquations.jl\nMove Common, Config and Utils submodules to GeometricBase.jl\nMove TimeSeries, DataSeries and Solution from Solutions types to GeometricBase.jl\nRemove parallel DataSeries and Solution types","category":"page"},{"location":"releasenotes/#New-Features-2","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Implement first and second order Degenerate Variational Integrators (DVIs)\nAdd tests for extrapolation methods","category":"page"},{"location":"releasenotes/#Fixes","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bugfixes in implicit equations\nBugfixes in extrapolation methods\nBugfixes in initial guesses\nBugfixes in VPRK and VSPARK initialisation\nBugfixes in TimeSeries getindex methods","category":"page"},{"location":"releasenotes/#Documentation-2","page":"Release Notes","title":"Documentation","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Add missing docstrings in various places and remove superficial docstrings","category":"page"},{"location":"releasenotes/#0.8.0","page":"Release Notes","title":"0.8.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes-4","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Use RungeKutta.jl for most tableaus and coefficients\nMove stochastic integrators to separate package\nRewrite of most equation types\nRename VODE and VDAE to LODE and LDAE for consistency with HODE and HDAE\nAdd optional fields for the secondary constraint to all *DAE equations","category":"page"},{"location":"releasenotes/#New-Features-3","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Allow for arbitrary data structures as states (still experimental and not fully supported)\nAdd convert methods for PODE and HODE to ODE and SODE","category":"page"},{"location":"releasenotes/#Fixes-2","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Countless minor bugfixes","category":"page"},{"location":"releasenotes/#Documentation-3","page":"Release Notes","title":"Documentation","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Add theoretical background for variational integrators, Runge-Kutta and splitting methods\nAdd references for most methods","category":"page"},{"location":"releasenotes/#0.7.0","page":"Release Notes","title":"0.7.0","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Use CompactBasisFunctions.jl instead of BasisFunctions submodule\nUse QuadratureRules.jl instead of Quadratures submodule\nUse SimpleSolvers.jl instead of Solvers submodule\nUse GeometricProblems.jl instead of TestProblems submodule","category":"page"},{"location":"releasenotes/#0.6.2","page":"Release Notes","title":"0.6.2","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bugfix release","category":"page"},{"location":"releasenotes/#0.6.1","page":"Release Notes","title":"0.6.1","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bugfix release","category":"page"},{"location":"releasenotes/#0.6.0","page":"Release Notes","title":"0.6.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes-5","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Revise tableaus: align constructor names with RungeKutta.jl","category":"page"},{"location":"releasenotes/#New-Features-4","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Add new Runge-Kutta tableaus\nGeneralise Lobatto and Radau tableaus to arbitrary number of stages\nExtend documentation on integrators and tableaus","category":"page"},{"location":"releasenotes/#0.5.1","page":"Release Notes","title":"0.5.1","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Update documentation\nFix HDF5 v0.14 deprecations","category":"page"},{"location":"releasenotes/#0.5.0","page":"Release Notes","title":"0.5.0","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Moved repository to JuliaGNI\nMoved CI from Travis to GitHub","category":"page"},{"location":"releasenotes/#Breaking-Changes-6","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Functions for initial guesses are now called v̄ and f̄ and can be prescribed separately from v and f in PDAE, HDAE, etc.\nRename SPARK tableau constructors and unify distinct constructors for Lobatto tableaus with different number of stages","category":"page"},{"location":"releasenotes/#New-Features-5","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Implement SPARK integrator for index-two DAEs\nImplement infrastructure for storing internal variables and solver output to atomic solutions\nStore internal variables of SPARK and VPRK integrators in atomic solution\nAdd various five-stage Lobatto tableaus\nAdd and clean up SPARK tableaus and add docstrings\nAdd functions for checking symplecticity conditions of SPARK tableaus\nAdd Aqua.jl tests","category":"page"},{"location":"releasenotes/#Fixes-3","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Fix initial guess warnings in tests by prescribing proper functions for v̄ and f̄ in example problems\nFix update_multiplier() method for SPARK integrators","category":"page"},{"location":"releasenotes/#0.4.1","page":"Release Notes","title":"0.4.1","text":"","category":"section"},{"location":"releasenotes/#New-Features-6","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Atomic solutions can now store a NamedTuple of internal variables of the integrator, including nonlinear solver output\nOutput of internal variables has been added to VPRK integrators\nAdd Gauss-Legendre tableaus for implicit partitioned Runge-Kutta methods","category":"page"},{"location":"releasenotes/#Fixes-4","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Revision of integrator type hierarchy","category":"page"},{"location":"releasenotes/#0.4.0","page":"Release Notes","title":"0.4.0","text":"","category":"section"},{"location":"releasenotes/#New-Integrators","page":"Release Notes","title":"New Integrators","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Runge-Kutta integrators for implicit ODEs (FIRKimplicit and SRKimplicit)\nVariational Partitioned Runge-Kutta integrator with projection based on internal stages","category":"page"},{"location":"releasenotes/#Fixes-5","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Computation of initial guess in all implicit integrators","category":"page"},{"location":"integrators/hpg/#hpg","page":"Hamilton-Pontryagin-Galerkin Integrators","title":"Hamilton-Pontryagin-Galerkin Integrators","text":"","category":"section"},{"location":"modules/projections/#Projections","page":"Projections","title":"Projections","text":"","category":"section"},{"location":"modules/projections/#Projection-Methods","page":"Projections","title":"Projection Methods","text":"","category":"section"},{"location":"modules/projections/","page":"Projections","title":"Projections","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\n    \"projections/methods.jl\",\n    \"projections/projection.jl\",\n    \"projections/standard_projection.jl\",\n    \"projections/symmetric_projection.jl\",\n    \"projections/midpoint_projection.jl\",\n]","category":"page"},{"location":"modules/projections/#GeometricIntegrators.Integrators.ProjectedMethod","page":"Projections","title":"GeometricIntegrators.Integrators.ProjectedMethod","text":"A ProjectedMethod consists of a ProjectionMethod and a GeometricMethod.\n\n\n\n\n\n","category":"type"},{"location":"modules/projections/#GeometricIntegrators.Integrators.ProjectionIntegrator","page":"Projections","title":"GeometricIntegrators.Integrators.ProjectionIntegrator","text":"The ProjectionIntegrator is the counterpart to the GeometricIntegrator for ProjectionMethods.\n\n\n\n\n\n","category":"type"},{"location":"modules/projections/#GeometricIntegrators.Integrators.ProjectionMethod","page":"Projections","title":"GeometricIntegrators.Integrators.ProjectionMethod","text":"A ProjectionMethod is an algorithm that is applied together with a geometric integrator to enforce constraints which are not automatically satisfied by the integrator. Examples include conservation of invariants like energy or the Dirac constraint in IODEs.\n\n\n\n\n\n","category":"type"},{"location":"modules/projections/#Projected-VPRK-Methods","page":"Projections","title":"Projected VPRK Methods","text":"","category":"section"},{"location":"modules/projections/","page":"Projections","title":"Projections","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\n    \"integrators/vi/vprk_projected.jl\",\n]","category":"page"},{"location":"modules/projections/#GeometricIntegrators.Integrators.VPRKpInternal-Tuple{VPRKMethod}","page":"Projections","title":"GeometricIntegrators.Integrators.VPRKpInternal","text":"VPRK integrator with projection on internal stages\n\n\n\n\n\n","category":"method"},{"location":"modules/projections/#GeometricIntegrators.Integrators.VPRKpLegendre-Tuple{VPRKMethod}","page":"Projections","title":"GeometricIntegrators.Integrators.VPRKpLegendre","text":"VPRK integrator with Legendre projection\n\n\n\n\n\n","category":"method"},{"location":"modules/projections/#GeometricIntegrators.Integrators.VPRKpMidpoint-Tuple{VPRKMethod}","page":"Projections","title":"GeometricIntegrators.Integrators.VPRKpMidpoint","text":"VPRK integrator with Midpoint projection\n\n\n\n\n\n","category":"method"},{"location":"modules/projections/#GeometricIntegrators.Integrators.VPRKpSecondary-Tuple{VPRKMethod}","page":"Projections","title":"GeometricIntegrators.Integrators.VPRKpSecondary","text":"VPRK integrator with projection on secondary constraint\n\n\n\n\n\n","category":"method"},{"location":"modules/projections/#GeometricIntegrators.Integrators.VPRKpStandard-Tuple{VPRKMethod}","page":"Projections","title":"GeometricIntegrators.Integrators.VPRKpStandard","text":"VPRK integrator with standard projection\n\n\n\n\n\n","category":"method"},{"location":"modules/projections/#GeometricIntegrators.Integrators.VPRKpSymmetric-Tuple{VPRKMethod}","page":"Projections","title":"GeometricIntegrators.Integrators.VPRKpSymmetric","text":"VPRK integrator with symmetric projection\n\n\n\n\n\n","category":"method"},{"location":"modules/projections/#GeometricIntegrators.Integrators.VPRKpSymplectic-Tuple{VPRKMethod}","page":"Projections","title":"GeometricIntegrators.Integrators.VPRKpSymplectic","text":"VPRK integrator with symplectic projection\n\n\n\n\n\n","category":"method"},{"location":"modules/projections/#GeometricIntegrators.Integrators.VPRKpVariational-Tuple{VPRKMethod}","page":"Projections","title":"GeometricIntegrators.Integrators.VPRKpVariational","text":"VPRK integrator with variational projection\n\n\n\n\n\n","category":"method"},{"location":"modules/projections/#GeometricIntegrators.Integrators.VPRKpVariationalP-Tuple{VPRKMethod}","page":"Projections","title":"GeometricIntegrators.Integrators.VPRKpVariationalP","text":"VPRK integrator with variational projection on P\n\n\n\n\n\n","category":"method"},{"location":"modules/projections/#GeometricIntegrators.Integrators.VPRKpVariationalQ-Tuple{VPRKMethod}","page":"Projections","title":"GeometricIntegrators.Integrators.VPRKpVariationalQ","text":"VPRK integrator with variational projection on Q\n\n\n\n\n\n","category":"method"},{"location":"modules/equations/#Equations","page":"Equations","title":"Equations","text":"","category":"section"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"The following data structures are all implemented in GeometricEquations.jl.","category":"page"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"GeometricEquations.GeometricEquation","category":"page"},{"location":"modules/equations/#GeometricEquations.GeometricEquation","page":"Equations","title":"GeometricEquations.GeometricEquation","text":"GeometricEquation{invType,parType,perType} is the abstract type all equation types are derived from.\n\nAll equations should have fields for defining invariants, parameters and periodicity of the main state variable. The types of these fields are stored in the following type parameters:\n\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nThe Optional* types are all unions of the respective Null* types and NamedTuple or AbstractArray, i.e.,\n\nconst OptionalInvariants = Union{NamedTuple, NullInvariants}\nconst OptionalParameters = Union{NamedTuple, NullParameters}\nconst OptionalPeriodicity = Union{AbstractArray, NullPeriodicity}\n\nThe Null* types are empty structs, merely used for dispatch and the traits hasinvariants, hasparameters and hasperiodicity.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#Ordinary-Differential-Equations","page":"Equations","title":"Ordinary Differential Equations","text":"","category":"section"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"GeometricEquations.ODE\nGeometricEquations.PODE\nGeometricEquations.HODE\nGeometricEquations.IODE\nGeometricEquations.LODE\nGeometricEquations.SODE","category":"page"},{"location":"modules/equations/#GeometricEquations.ODE","page":"Equations","title":"GeometricEquations.ODE","text":"ODE: Ordinary Differential Equation\n\nOrdinary differential equations define an initial value problem of the form\n\ndotq (t) = v(t q(t)) \n\nwith vector field v.\n\nParameters\n\nvType <: Callable: type of v\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nODE(v, invariants, parameters, periodicity)\nODE(v; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe function v providing the vector field must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params is a NamedTuple of additional parameters on which the vector field may depend.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.PODE","page":"Equations","title":"GeometricEquations.PODE","text":"PODE: Partitioned Ordinary Differential Equation\n\nA partitioned ordinary differential equation is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \ndotp (t) = f(t q(t) p(t)) \nendaligned\n\nwith vector fields v and f.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPODE(v, f, invariants, parameters, periodicity)\nPODE(v, f; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe functions v and f must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.HODE","page":"Equations","title":"GeometricEquations.HODE","text":"HODE: Hamiltonian Ordinary Differential Equation\n\nA canonical Hamiltonian system of equations is special case of a partitioned ordinary differential equation,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \ndotp (t) = f(t q(t) p(t)) \nendaligned\n\nwith vector fields v and f, given by\n\nbeginaligned\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendaligned\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nhamType <: Callable: Hamiltonian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\nhamiltonian: function computing the Hamiltonian H (usually the total energy of the system)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nHODE(v, f, hamiltonian, invariants, parameters, periodicity)\nHODE(v, f, hamiltonian; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe functions v, f and hamiltonian must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction hamiltonian(t, q, p, params)\n    return ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.IODE","page":"Equations","title":"GeometricEquations.IODE","text":"IODE: Implicit Ordinary Differential Equation\n\nAn implicit ordinary differential equations is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \ndotp (t) = f(t q(t) v(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwith force field f, the momentum defined by p. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMost integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + λ(t)  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) λ(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\ngType <: Callable: type of g\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (tqv) cdot lambda\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nIODE(ϑ, f, g, v̄, f̄, invariants, parameters, periodicity)\nIODE(ϑ, f, g; v̄ = _iode_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_iode_default_v̄(v, t, q, params) = nothing\n\nThe functions ϑ, f and g compute the momentum and the vector fields, respectively.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. In addition, the functions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, v, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.LODE","page":"Equations","title":"GeometricEquations.LODE","text":"LODE: Lagrangian Ordinary Differential Equation\n\nA Lagrangian system of equations is a special case of an implicit ordinary differential equations, that is an implicit initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \ndotp (t) = f(t q(t) v(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v  \nf = fracpartial Lpartial q \nendaligned\n\nThis is a special case of an implicit ordinary differential equation, that is defined by a Lagrangian, as well as a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMany integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + lambda(t)  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) lambda(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nParameters\n\nϑType <: Function: type of ϑ\nfType <: Function: type of f\ngType <: Function: type of g\nωType <: Function: type of ω\nv̄Type <: Function: type of v̄\nf̄Type <: Function: type of f̄\nlagType <: Function: Lagrangian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (q) cdot lambda\nω: function computing the symplectic matrix\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nlagrangian: function computing the Lagrangian L\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nLODE(ϑ, f, g, ω, l, v̄, f̄, invariants, parameters, periodicity)\nLODE(ϑ, f, g, ω, l; v̄ = _lode_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_lode_default_v̄(v, t, q, params) = nothing\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nand\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers. Finally, the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.SODE","page":"Equations","title":"GeometricEquations.SODE","text":"SODE: Split Ordinary Differential Equation\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nParameters\n\nvType <: Union{Tuple,Nothing}: type of v\nqType <: Union{Tuple,Nothing}: type of q\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: tuple of functions computing the vector fields for each substep\nq: tuple of functions computing the solutions for each substep\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSODE(v, invariants, parameters, periodicity)\nSODE(v; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())\nSODE(v, q, invariants, parameters, periodicity)\nSODE(v, q; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())\n\nFunction Definitions\n\nThe functions v_i providing the vector field must have the interface\n\nfunction v_i(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nand the functions q_i providing the solutions must have the interface\n\nfunction q_i(q₁, t₁, q₀, t₀, params)\n    q₁[1] = q₀[1] + ...\n    q₁[2] = q₀[2] + ...\n    ...\nend\n\nwhere t₀ is the current time, q₀ is the current solution vector, q₁ is the new solution vector at time t₁, holding the result of computing one substep\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps. with the vector field v_i.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#Differential-Algebraic-Equations","page":"Equations","title":"Differential Algebraic Equations","text":"","category":"section"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"GeometricEquations.DAE\nGeometricEquations.PDAE\nGeometricEquations.HDAE\nGeometricEquations.IDAE\nGeometricEquations.LDAE\nGeometricEquations.SPDAE","category":"page"},{"location":"modules/equations/#GeometricEquations.DAE","page":"Equations","title":"GeometricEquations.DAE","text":"DAE: Differential Algebraic Equation\n\nDefines a differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))  \n0 = phi (t q(t)) \nendaligned\n\nwith vector field v, projection u, algebraic constraint phi=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t)) + baru (t q(t) dotq (t) dotp (t) mu(t))  \n0 = phi (t q(t))  \n0 = psi (t q(t) dotq (t)) \nendaligned\n\nParameters\n\nvType <: Callable: type of v\nuType <: Callable: type of u\nϕType <: Callable: type of ϕ\nūType <: OptionalCallable: type of ū\nψType <: OptionalCallable: type of ψ\nv̄Type <: Callable: type of v̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v(v, t, q, params)\nu: function computing the projection u(u, t, q, λ, params)\nϕ: algebraic constraint ϕ(ϕ, t, q, params)\nū: function computing the secondary projection field ū(ū, t, q, λ, params) (optional)\nψ: secondary constraint ψ(ψ, t, q, v, params) (optional)\nv̄: function computing an initial guess for the velocity field v (defaults to v)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nDAE(v, u, ϕ, ū, ψ, v̄, invariants, parameters, periodicity)\nDAE(v, u, ϕ, ū, ψ; kwargs...)\nDAE(v, u, ϕ; kwargs...)\n\nThe functions v and u compute the vector field and the projection, respectively, ϕ provides the algebraic constraint. The functions ψ and ū are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, u and ϕ must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction u(u, t, q, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, params)\n    ψ[1] = ...\nend\n\nThe DAE is created by\n\nequ = DAE(v, u, ϕ)\n\nor\n\nequ = DAE(v, u, ϕ, ū, ψ)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.PDAE","page":"Equations","title":"GeometricEquations.PDAE","text":"PDAE: Partitioned Differential Algebraic Equation\n\nA partitioned differential algebraic equation has the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t))  \n0 = phi (t q(t) p(t)) \nendaligned\n\nwith vector fields v and f, projection u and g, algebraic constraint phi=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) mu(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) mu(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq (t) dotp (t)) \nendaligned\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional, defaults to v)\nf̄: function computing an initial guess for the force field f (optional, defaults to f)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, invariants, parameters, periodicity)\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ; kwargs...)\nPDAE(v, f, u, g, ϕ; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, f, u, g and ϕ must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q, p and λ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections u and g, and ϕ holds the algebraic constraint phi, evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nThe PDAE is created by\n\nequ = PDAE(v, f, u, g, ϕ)\n\nor\n\nequ = PDAE(v, f, u, g, ϕ, ū, ḡ, ψ)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.HDAE","page":"Equations","title":"GeometricEquations.HDAE","text":"HDAE: Hamiltonian Differential Algebraic Equation\n\nA Hamiltonian differential algebraic is an initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) mu(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) mu(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qpdotqdotp)=0.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\nhamType <: Callable: Hamiltonian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the Hamiltonian vector field v\nf: function computing the Hamiltonian vector field f\nu: function computing the projection for q\ng: function computing the primary projection field g\nϕ: primary constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional, defaults to v)\nf̄: function computing an initial guess for the force field f (optional, defaults to f)\nhamiltonian: function computing the Hamiltonian H (usually the total energy of the system)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, v̄, f̄, invariants, parameters, periodicity)\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h; kwargs...)\nHDAE(v, f, u, g, ϕ, h; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, ϕ provides the algebraic constraint and h the Hamiltonian. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, f, u, g, ϕ and h must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nfunction h(t, q, p, params)\n    ...\nend\n\nwhere t is the current time, q, p, λ and μ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections on the primary constraint u and g,  ϕ holds the algebraic constraint phi, and h returns the Hamiltonian of the system, all evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nThe HDAE is created by\n\nequ = HDAE(v, f, u, g, ϕ, h)\n\nor\n\nequ = HDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.IDAE","page":"Equations","title":"GeometricEquations.IDAE","text":"IDAE: Implicit Differential Algebraic Equation\n\nAn implicit differential algebraic initial value problem takes the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t))  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t)) \nendaligned\n\nwith force field f, the momentum defined by ϑ, projections u and g, algebraic constraint phi(tqvp)=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) mu(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) mu(t))  \np(t) = ϑ(t q(t) v(t))   \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq (t) dotp (t)) \nendaligned\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, invariants, parameters, periodicity)\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ; v̄ = _idae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\nIDAE(ϑ, f, u, g, ϕ; v̄ = _idae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_idae_default_v̄(v, t, q, params) = nothing\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v, params)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.LDAE","page":"Equations","title":"GeometricEquations.LDAE","text":"LDAE: Lagrangian Differential Algebraic Equation\n\nA special case of an implicit initial value problem is a Lagrangian differential algebraic equation of the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) mu(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) mu(t))  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v (qv)  \nf = fracpartial Lpartial q (qv) \nendaligned\n\nprojection fields u, baru and g, barg. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and mu.\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nωType <: Callable: type of ω\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\nlagType <: Callable: Lagrangian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nf: function computing the vector field\nu: function computing the projection for q, for a degenerate system given by lambda\ng: function computing the projection for p, for a degenerate system given by nabla vartheta (q) cdot lambda\nϕ: primary constraints, for a degenerate system given by p - vartheta (tq)\nū: function computing the secondary projection field baru, for a degenerate system given by lambda (optional)\nḡ: function computing the secondary projection field barg, for a degenerate system given by lambda cdot nabla vartheta (tq) (optional)\nψ: secondary constraints, for a degenerate system given by dotp - dotq cdot nabla vartheta (tq) (optional)\nω: function computing the symplectic matrix\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nlagrangian: function computing the Lagrangian L\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, v̄, f̄, lagrangian, invariants, parameters, periodicity)\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, lagrangian; v̄ = _ldae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\nLDAE(ϑ, f, u, g, ϕ, ω, lagrangian; v̄ = _ldae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_ldae_default_v̄(v, t, q, params) = nothing\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v, params)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nand the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.SPDAE","page":"Equations","title":"GeometricEquations.SPDAE","text":"SPDAE: Split Partitioned Differential Algebraic Equation EXPERIMENTAL\n\nDefines a split differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v_1(t q(t) p(t)) + v_2(t q(t) p(t) lambda(t)) + v_3(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f_1(t q(t) p(t)) + f_2(t q(t) p(t) lambda(t)) + f_3(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v_i and f_i for i = 1  3, primary constraint phi(qp)=0 and secondary constraint psi(qplambda)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^n times mathbbR^d.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nϕType <: Callable: type of ϕ\nψType <: Callable: type of ψ\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: tuple of functions computing the vector fields v_i, i = 1  3\nf: tuple of functions computing the vector fields f_i, i = 1  3\nϕ: primary constraints\nψ: secondary constraints\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSPDAE(v, f, ϕ, ψ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nSPDAE(v, f, ϕ, ψ, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nSPDAE(v, f, ϕ, ψ, t₀, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\nSPDAE(v, f, ϕ, ψ, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\n\nKeyword arguments:\n\ninvariants = nothing\nparameters = nothing\nperiodicity = nothing\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#Stochastic-Differential-Equations","page":"Equations","title":"Stochastic Differential Equations","text":"","category":"section"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"GeometricEquations.SDE\nGeometricEquations.PSDE\nGeometricEquations.SPSDE","category":"page"},{"location":"modules/equations/#GeometricEquations.SDE","page":"Equations","title":"GeometricEquations.SDE","text":"SDE: Stratonovich Stochastic Differential Equation\n\nDefines a stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendaligned\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Callable: type of v\nBType <: Callable: type of B\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv:  function computing the deterministic vector field\nB:  function computing the d x m diffusion matrix\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSDE(v, B, invariants, parameters, periodicity)\nSDE(v, B; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v and B, providing the drift vector field and diffusion matrix. The function v must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params are additional parameters. The function B should have a method with interface\n\nfunction B(B, t, q, params)\n    B[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.PSDE","page":"Equations","title":"GeometricEquations.PSDE","text":"PSDE: Stratonovich Partitioned Stochastic Differential Equation\n\nA partitioned stochastic differential equations is an initial value problem of the form\n\nbeginaligned\ndq (t) = v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) = f(t q(t) p(t))  dt + G(t q(t) p(t)) circ dW   p(t_0) = p_0\nendaligned\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nBType <: Callable: type of B\nGType <: Callable: type of G\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv:  function computing the drift vector field for the position variable q\nf:  function computing the drift vector field for the momentum variable p\nB:  function computing the d x m diffusion matrix for the position variable q\nG:  function computing the d x m diffusion matrix for the momentum variable p\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPSDE(v, f, B, G, invariants, parameters, periodicity)\nPSDE(v, f, B, G; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, each take five arguments, v(v, t, q, p, params), f(f, t, q, p, params), B(B, t, q, p, params) and G(G, t, q, p, params), where t is the current time, (q, p) is the current solution, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p), and params are optional parameters.\n\nThe corresponding methods should have the following signatures:\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.SPSDE","page":"Equations","title":"GeometricEquations.SPSDE","text":"SPSDE: Stratonovich Split Partitioned Stochastic Differential Equation\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) =   v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) =  f_1(t q(t) p(t)) + f_2(t q(t) p(t))   dt +  G_1(t q(t) p(t)) + G_2(t q(t) p(t))  circ dW   p(t_0) = p_0 \nendaligned\n\nwith the drift vector fields v and f_i, diffusion matrices B and G_i, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Function: type of v\nf1Type <: Function: type of f1\nf2Type <: Function: type of f2\nBType <: Function: type of B\nG1Type <: Function: type of G1\nG2Type <: Function: type of G2\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv :  function computing the drift vector field for the position variable q\nf1:  function computing the drift vector field for the momentum variable p\nf2:  function computing the drift vector field for the momentum variable p\nB :  function computing the d x m diffusion matrix for the position variable q\nG1:  function computing the d x m diffusion matrix for the momentum variable p\nG2:  function computing the d x m diffusion matrix for the momentum variable p\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSPSDE(v, f1, f2, B, G1, G2, invariants, parameters, periodicity)\nSPSDE(v, f1, f2, B, G1, G2; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v, f1, f2, B, G1 and G2, providing the drift vector fields and diffusion matrices, all take five arguments, (out, t, q, p, params).\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f1(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction f2(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G1(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nfunction G2(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nwhere t is the current time, (q,p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B_i, G_i on (t,q,p).\n\n\n\n\n\n","category":"type"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"CurrentModule = GeometricIntegrators.Integrators","category":"page"},{"location":"integrators/vprk/#vprk","page":"VPRK","title":"Variational Partitioned Runge-Kutta Integrators","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Variational partitioned Runge-Kutta methods solve Lagrangian systems in implicit form, i.e.,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\np       = dfracpartial Lpartial dotq (q dotq)  \ndotp = dfracpartial Lpartial q       (q dotq)  \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"by the following scheme,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ki = dfracpartial Lpartial q (Q_ni V_ni)  \nP_nj = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s b_i  F_ni \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Here, s denotes the number of internal stages, a_ij and bara_ij are the coefficients of the Runge-Kutta method and b_i and barb_i the corresponding weights. If the coefficients satisfy the symplecticity conditions,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j \n textand \nbarb_i = b_i \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"these methods correspond to the position-momentum form of the discrete Lagrangian [[9]]","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk-discrete-lagrangian\nL_d (q_n q_n+1) = h sum limits_i=1^s b_i  L big( Q_ni V_ni big) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"While these integrators show favourable properties for systems with regular Lagrangian, they are usually not applicable for degenerate Lagrangian systems, in particular those with Lagrangians of the form L (q dotq) = vartheta(q) cdot dotq - H(q). While variational integrators are still applicable in the case of vartheta being a linear function of q, they are often found to be unstable when vartheta is a nonlinear function of q as is the case with Lotka-Volterra systems, various nonlinear oscillators, guiding centre dynamics and other reduced charged particle models. To mitigate this problem, projection methods have been developed, which can be used in conjunction with variational integrators. These projected variational integrators provide long-time stable methods for general degenerate Lagrangian systems that maintain conservation of energy and momenta over long integration periods [[14]].","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"GeometricIntegrators.jl provides the following VPRK methods:","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Integrator Description\nVPRK Variational Partitioned Runge-Kutta (VPRK) integrator without projection\nVPRKpStandard VPRK integrator with standard projection\nVPRKpSymmetric VPRK integrator with symmetric projection\nVPRKpMidpoint VPRK integrator with midpoint projection\nVPRKpVariational VPRK integrator with variational projection (unstable)\nVPRKpSecondary VPRK integrator with projection on secondary constraint\nVPRKpInternal Gauss-Legendre VPRK integrator with projection on internal stages of Runge-Kutta method","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For testing purposes VPRKpStandard provides some additional constructors (note that these methods are generally unstable):","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Integrator Description\nVPRKpVariationalQ VPRK integrator with variational projection on (q_n p_n+1)\nVPRKpVariationalP VPRK integrator with variational projection on (p_n q_n+1)\nVPRKpSymplectic VPRK integrator with symplectic projection","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"All of the above integrators are applied to either an IODEProblem or LODEProblem and instantiated as follows:","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"int = GeometricIntegrator(iode, VPRK(Gauss(1)))","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where the constructor of each method needs to be supplied with a Runge-Kutta or partitioned Runge-Kutta method. The only exception is VPRKpSecondary which can only be applied to an LODEProblem as it needs some additional functions which are only defined for variational problems.","category":"page"},{"location":"integrators/vprk/#Discrete-Action-Princtiple","page":"VPRK","title":"Discrete Action Princtiple","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Symplectic partitioned Runge-Kutta integrators have been shown to be variational integrators [[9], [5]]. Here, the discrete Lagrangian \\eqref{eq:vprk-discrete-lagrangian} has s internal points (or stages) located at t_n + h c_i with weights b_i which are all non-zero and sum up to one. The internal stages Q_ni approx q(t_n + h c_i) are given by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Q_ni = q_n + h sum limits_j=1^s a_ij  V_nj ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In contrast to the composition methods, we do not require c_1 = 0 and c_s = 1. Instead the discrete action is extremised under the constraints","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"q_n+1 = q_n + h sum limits_i=1^s b_i  V_ni ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"which we add to the action with the Lagrange multiplier lambda_n+1, so that we can write","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk-action-gauss\nmathcalA_d = sum limits_n=1^N-1 bigg h sum limits_i=1^s b_i  L big( Q_ni V_n1 big) + lambda_n+1 cdot bigg( q_n+1 - q_n - h sum limits_i=1^s b_i  V_ni bigg) bigg \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Computing variations of the action leads to","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\ndelta mathcalA_d\n= sum limits_n=1^N-1left h sum limits_i=1^s h b_i a_ij  dfracpartial Lpartial q (Q_ni V_ni) \n + h b_j  dfracpartial Lpartial v (Q_nj V_nj)\n - h b_j  lambda_n+1 right cdot delta V_nj \n+ sum limits_n=1^N-1left h sum limits_i=1^s b_i  dfracpartial Lpartial q (Q_ni V_ni) \n - lambda_n+1 + lambda_n right cdot delta q_n \n+ sum limits_n=1^N-1 bigg q_n+1 - q_n - h sum limits_i=1^s b_i  V_ni bigg cdot delta lambda_n+1\n = 0 \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"We define discrete forces and momenta as","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"F_ni = dfracpartial Lpartial q (Q_ni V_ni)\nhspace3em\ntextand\nhspace3em\nP_ni = dfracpartial Lpartial v (Q_ni V_ni) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that the terms of the variation which are multiplying delta V_nj become","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"P_nj = lambda_n+1 - h sum limits_i=1^s dfracb_i a_ijb_j  F_ni ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The terms of the variations which are multiplying delta q_n become","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"lambda_n+1 = lambda_n + h sum limits_i=1^s b_i  F_ni ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Similar to classical variational integrators, we can use the discrete fibre derivative","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdiscrete-fibre-derivative\nbeginaligned\nmathbbF^- L_d  (q_n q_n+1) mapsto (q_n   p_n)   = big( q_n   - D_1 L_d (q_n q_n+1) big)  \nmathbbF^+ L_d  (q_n q_n+1) mapsto (q_n+1 p_n+1) = big( q_n+1   D_2 L_d (q_n q_n+1) big) \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"to define the position-momentum form of the integrator,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvi-position-momentum-form\nbeginaligned\np_n  \n=           -  D_1 L_d (q_n q_n+1)\n = lambda_n+1 - h sum limits_i=1^s b_i  F_ni  \np_n+1\n= hphantom- D_2 L_d (q_n q_n+1)\n = lambda_n+1 \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Replacing lambda_n+1 in the second equation with its expression obtained from the first equation, we get","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"p_n+1 = p_n + h sum limits_i=1^s v_i  F_ni ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"which states that the second symplecticity condition (b_i = barb_i) is automatically satisfied. In the same fashion, we obtain","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"P_nj = p_n + h sum limits_i=1^s bara_ij  F_nj ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"with","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"bara_ij = b_j - b_j a_ji  b_i ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"such that the first symplecticity condition is also satisfied. In summary, we obtain the variational-partitioned Runge-Kutta integrator \\eqref{eq:vprk}. If the fibre derivative is invertible, an equivalent set of equations can be obtained by applying","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nV_ni =   dfracpartial Hpartial p (Q_ni P_ni)  \nF_ni = - dfracpartial Hpartial q (Q_ni P_ni) \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"to the Hamiltonian H(qp) obtained via the Legendre transform. The interested reader can find more details on this in [[5]] and references therein.","category":"page"},{"location":"integrators/vprk/#Lobatto-Methods","page":"VPRK","title":"Lobatto Methods","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Some words of caution are in order. The above derivation works well, if all discrete velocities V_ni are linearly independent. This is the case e.g. for Gauss-Legendre Runge-Kutta discretizations but not for Lobatto discretizations (see [15] for details). For discretizations of Lobatto-IIIA type, where the first internal stage coincides with the solution at the previous time step, the velocities V_ni are not linearly independent and the discrete action \\eqref{eq:vprk-action-gauss} needs to be augmented by an additional constraint to take this dependence into account,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk-action-lobatto\nbeginaligned\nmathcalA_d =\nsum limits_n=0^N-1 Bigglgroup\nh sum limits_i=1^s b_i  bigg L big( Q_ni V_ni big)\n+ F_ni cdot bigg( Q_ni - q_n - h sum limits_j=1^s a_ij  V_nj bigg) bigg \n- p_n+1 cdot bigg( q_n+1 - q_n - h sum limits_i=1^s b_i  V_ni bigg)\n+ mu_n cdot bigg( sum limits_i=1^s d_i V_ni bigg)\nBiggrgroup \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Requiring stationarity of \\eqref{eq:vprk-action-lobatto}, we obtain a modified system of equations,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk-lobatto\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nP_ni = p_n + h sum limits_j=1^s bara_ij  F_nj - mu_n dfracd_ib_i  \nq_n+1 = q_n + h sum limits_i=1^s b_i   V_ni  \np_n+1 = p_n + h sum limits_i=1^s barb_i   F_ni  \n0 = sum limits_i=1^s d_i V_ni \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"accounting for the linear dependence of the dotQ_ni and consequently also of the P_ni. The particular values of d_i depend on the number of stages s and the definition of the q_ni [[15]]. For two stages, we have d_1 = - d_2, so that we can choose, for example, d = (+1 -1), and \\eqref{eq:vprk-lobatto} becomes equivalent to the variational integrator of the trapezoidal Lagrangian. For three stages, we can choose d = (tfrac12 -1 tfrac12), and for four stages we can use d = (+1 -sqrt5 +sqrt5 -1). In GeometricIntegrators, these vectors can be obtained via the function get_lobatto_nullvector from RungeKutta.jl.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Another approach that always works is to use directly compute the position-momentum form \\eqref{eq:vi-position-momentum-form} of the variational integrator for the discrete Lagrangian \\eqref{eq:vprk-discrete-lagrangian} instead of applying the discrete action principle. Such subtleties, which are easily overlooked, can be avoided by starting the discretisation of the action from a more fundamental point of view, namely by approximating the function spaces of the trajectories, which leads us to Galerkin Variational Integrators.","category":"page"},{"location":"integrators/vprk/#sec:degenerate-lagrangian-systems","page":"VPRK","title":"Degenerate Lagrangians","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Degenerate Lagrangian systems are relevant for the study of population models, point vortex dynamics or reduced charged particle models like the guiding centre system. Here, we consider degenerate Lagrangian systems characterized by a Lagrangian that is linear or singular in the velocities. In particular, we consider the class of systems whose Lagrangian is of the form","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdegenerate-lagrangian\nL (q v) = vartheta(q) cdot v - H(q) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The Lagrangian L is a function on the tangent bundle tbmfM,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqlagrangian-tangent-bundle\nL  tbmfM rightarrow mathbbR \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where mfM denotes the configuration manifold of the system which is assumed to be of dimension d. The cotangent bundle of the configuration manifold mfM is denoted by cbmfM. Further, we denote the coordinates of a point m in mfM by q(m) = (q^1 (m) dotsc q^d (m)) and similarly coordinates of points in tbmfM by (q^i v^i) and coordinates of points in cbmfM by (q^i p^i). In the following, we will always assume the existence of a global coordinate chart, so that mfM can be identified with the Euclidean space mathbbR^d. For simplicity, we often use short-hand notation where we write q to refer to both a point in mfM as well as its coordinates. Similarly, we often denote points in the tangent bundle tbmfM by (q v). In local coordinates, the Lagrangian \\eqref{eq:lagrangian-tangent-bundle} is thus written as a map (q v) mapsto L(q v).","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In Equation \\eqref{eq:degenerate-lagrangian}, vartheta = vartheta_i (q)  ext q^i is a differential one-form vartheta  mfM rightarrow cbmfM, whose components vartheta_i  mfM rightarrow mathbbR are general, possibly nonlinear functions of q, some of which (but not all) could be identically zero. For details on differential forms, tangent and cotangent bundles the interested reader may consult any modern book in mathematical physics or differential geometry. We recommend [16], [17], [18], [19] for more physics oriented accounts and [20], [21], [22], [23] for more mathematics oriented accounts. In the following we assume a basic understanding of these concepts. To see their usefulness for classical mechanics we refer to [24], [25], [26].","category":"page"},{"location":"integrators/vprk/#sec:dirac-constraints","page":"VPRK","title":"Dirac Constraints","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Degenerate systems of the form \\eqref{eq:degenerate-lagrangian} can also be formulated in terms of the phasespace trajectory (q p) in the cotangent bundle cbmfM, subject to a primary constraint in the sense of Dirac, determined by the function phi  cbmfM rightarrow mathbbR^d, given by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdirac_constraint\nphi (q p) = p - vartheta(q) = 0 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and originating from the fibre derivative mathbbF L  tbmfM rightarrow cbmfM,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqfibre-derivative-general\nmathbbF L (v_q) cdot w_q = dfracddepsilon biggvert_epsilon=0 L(v_q + epsilon w_q) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where v_q = (q v) and w_q = (q w) denote two points in tbmfM which share the same base point q and are thus elements of the same fibre of tbmfM. By acting point-wise for each t, the fibre derivative maps the curve (q dotq) in the tangent bundle tbmfM into the curve (q p) in the cotangent bundle cbmfM,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqfibre_derivative\n(q (t) p (t)) = left( q (t) dfracpartial Lpartial v (q (t) dotq (t)) right) = (q (t) vartheta (q (t))) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where the last equality follows for Lagrangians of the form \\eqref{eq:degenerate-lagrangian}. The Dirac constraint arising from the degenerate Lagrangian restricts the dynamics to the submanifold","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqconstraint-submanifold\nDelta = big (q p) in cbmfM  bigvert  phi (q p) = 0  big subset cbmfM \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the preceding and the following, we assume that the Lagrangian is degenerate in all velocity components, that is, the Lagrangian is either linear or singular in each component of v, so that","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"dfracpartial^2 Lpartial v^i  partial v^j = 0\nhspace3em\ntextfor all 1 leq ij leq d","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For instructive reasons, however, assume for a moment that the Lagrangian is degenerate in only m  d components of v and, e.g., quadratic in the other d-m components. That is to say we can write","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"p (t)\n= big( beta_1 (q (t) dotq (t)) dotsc beta_d-m (q (t) dotq (t))  vartheta_d-m+1 (q (t)) dotsc vartheta_d (q (t)) big)^T ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"dfracpartial Lpartial v^i (q (t) dotq (t)) = begincases\nbeta_i (q (t) dotq (t))  1 leq i leq d - m  \nvartheta_i (q (t))  d-m+1 leq i leq d  \nendcases","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"We can then denote coordinates in Delta by (q^i pi^j) with 1 leq i leq d and 1 leq j leq d-m, where the pi^i denote those momenta which are ``free'', i.e., not determined by the Dirac constraint. The inclusion map i  Delta rightarrow cbmfM can then be written as","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdirac-inclusion_genereal\ni  (q pi) mapsto (q pi vartheta (q)) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the fully degenerate case, however, we have m=d, so that the configuration manifold mfM and the constraint submanifold Delta are isomorphic and we can label points in Delta by the same q we use to label points in mfM. The inclusion map i  Delta rightarrow cbmfM simplifies accordingly and reads","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdirac-inclusion\ni  q mapsto (q vartheta (q)) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where it is important to keep in mind that q denotes a point in Delta. The inverse operation is given by the projection pi_Delta  cbmfM rightarrow Delta, defined such that pi_Delta circ i = id.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"As we are lacking a general framework for constructing structure-preserving numerical algorithms for noncanonical Hamiltonian systems on mfM, we will construct such algorithms on i(Delta). This can be achieved by using canonically symplectic integrators on cbmfM and assuring that their solution stays on i(Delta). To this end we will employ various projection methods.","category":"page"},{"location":"integrators/vprk/#Projection-Methods","page":"VPRK","title":"Projection Methods","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Projection methods are a standard technique for the integration of ordinary differential equations on manifolds [[27], [5]]. The problem of constructing numerical integrators on manifolds with complicated structure is often difficult and thus avoided by embedding the manifold into a larger space with simple, usually Euclidean structure, where standard integrators can be applied. Projection methods are then used to ensure that the solution stays on the correct subspace of the extended solution space, as that is usually not guaranteed by the numerical integrator itself.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the standard projection method, a projection is applied after each step of the numerical algorithm. Assuming that the initial condition lies in the manifold, the solution of the projected integrator will stay in the manifold. The problem with this approach is that even though assuming that the numerical integrator is symmetric, the whole algorithm comprised of the integrator and the projection will not be symmetric. This often leads to growing errors in the solution and consequently a drift in the total energy of the system. This can be remedied by symmetrizing the projection [[28], [27], [29], [5]], where the initial data is first perturbed out of the constraint submanifold, before the numerical integrator is applied, and then projected back to the manifold. This leads to very good long-time stability and improved energy behaviour.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"While such projection methods, both standard and symmetric ones, are standard procedures for conserving energy, as well as holonomic and non-holonomic constraints, not much is known about their application to Dirac constraints.  Some authors consider general differential algebraic systems of index two [[30], [31], [32], [29], [33], [34]], the class to which the systems considered here belong, but a discussion of symplecticity seems to be mostly lacking from the literature, aside from some remarks on the conservation of quadratic invariants by the post-projection method of [[32]].","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the following, we apply several projection methods (standard, symmetric, symplectic, midpoint) to variational integrators in position-momentum form. As it turns out, both the standard projection and the symmetric projection are not symplectic. The symmetric projection nevertheless shows very good long-time stability, as it can be shown to be pseudo-symplectic. The symplectic projection method, as the name suggests, is indeed symplectic, although in a generalized sense. The midpoint projection method is symplectic in the usual sense but only for particular integrators.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The general procedure is as follows. We start with initial conditions q_n on Delta (recall that for the particular Lagrangian \\eqref{eq:degenerate-lagrangian} considered here, the configuration manifold mfM and the constraint submanifold Delta are isomorphic, so that we can use the same coordinates on Delta as we use on mfM). We compute the corresponding momentum p_n by the continuous fibre derivative \\eqref{eq:fibre-derivative-general}, which yields initial conditions (q_n p_n = vartheta(q_n)) on cbmfM satisfying the constraint phi(q_n p_n) = 0. This corresponds to the inclusion map \\eqref{eq:dirac-inclusion}. Then, we may or may not perturb these initial conditions off the constraint submanifold by applying a map (q_n p_n) mapsto (barq_n barp_n) which is either the inverse mathbbP^-1 of a projection mathbbP  cbmfM rightarrow i(Delta) or, in the case of the standard projection, just the identity. The perturbation is followed by the application of some canonically symplectic algorithm Psi_h on cbmfM, namely a variational integrator in position-momentum form \\eqref{eq:vi-position-momentum-form} or a variational Runge-Kutta method \\eqref{eq:vprk} or \\eqref{eq:vprk-lobatto}, in which cases we have that Psi_h = big( mathbbF^+ L_d big) circ big( mathbbF^- L_d big)^-1. In general, the result of this algorithm, (barq_n+1 barp_n+1) = Psi_h (barq_n barp_n), will not lie on the constraint submanifold \\eqref{eq:constraint-submanifold}. Therefore we apply a projection (barq_n+1 barp_n+1) mapsto (q_n+1 p_n+1) which enforces phi (q_n+1 p_n+1) = p_n+1 - vartheta(q_n+1) = 0. As this final result is a point in i(Delta) it is completely characterized by the value q_n+1.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: )","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Gradient of the constraint function phi orthogonal and Omega-orthogonal to constant surfaces of phi(q p) = p - sqrtp_0^2 - q^2 for p_0 in  1 2 3 .","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Let us emphasize that in contrast to standard projection methods, where the solution is projected orthogonal to the constrained submanifold, along the gradient of phi, here the projection has to be Omega-orthogonal, where Omega is the canonical symplectic matrix","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqcanonical-symplectic-matrix\nOmega = beginpmatrix\nmathbb0            -  mathbb1 \nmathbb1  hphantom- mathbb0 \nendpmatrix \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"That is, denoting by lambda the Lagrange multiplier, the projection step is given by Omega^-1 nabla phi^T lambda instead of an orthogonal projection nabla phi^T lambda.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Let us also note that, practically speaking, the momenta p_n and p_n+1 are merely treated as intermediate variables much like the internal stages of a Runge-Kutta method. The Lagrange multiplier lambda, on the other hand, is determined in different ways for the different methods and can be the same or different in the perturbation and the projection. It thus takes the role of an internal variable only for the standard, symmetric projection and midpoint projection, but not for the symplectic projection.","category":"page"},{"location":"integrators/vprk/#Geometric-Aside:-Projected-Fibre-Derivatives","page":"VPRK","title":"Geometric Aside: Projected Fibre Derivatives","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the following, we will try to underpin the construction of the various projection methods with some geometric ideas. We already mentioned several times that the position-momentum form of the variational integrator \\eqref{eq:vi-position-momentum-form} suffers from the problem that it does not preserve the constraint submanifold Delta defined in \\eqref{eq:constraint-submanifold}. That is, even though it is applied to a point in i(Delta), it usually returns a point in cbmfM, but outside of i(Delta). In order to understand the reason for this, let us define Delta_mfM^- and Delta_mfM^+ as the subsets of mfM times mfM which are mapped into the constraint submanifold i(Delta) by the discrete fibre derivatives mathbbF^- L_d and mathbbF^+ L_d, respectively, i.e.,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqconstraint-submanifold_QxQ\nbeginaligned\nDelta_mfM^- =  (q_n q_n+1) in mfM times mfM  bigvert  mathbbF^- L_d (q_n q_n+1) = (q_n p_n) in i(Delta) big  \nDelta_mfM^+ =  (q_n q_n+1) in mfM times mfM  bigvert  mathbbF^+ L_d (q_n q_n+1) = (q_n+1 p_n+1) in i(Delta) big \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"or more explicitly,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqconstraint-submanifold_QxQ_coordinates\nbeginaligned\nDelta_mfM^- =  (q_n q_n+1) in mfM times mfM  bigvert  - D_1 L_d (q_n q_n+1) = vartheta(q_n) big  \nDelta_mfM^+ =  (q_n q_n+1) in mfM times mfM  bigvert  D_2 L_d (q_n q_n+1) = vartheta(q_n+1) big \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"A sufficient condition for the position-momentum form of the variational integrator \\eqref{eq:vi-position-momentum-form} to preserve the constraint submanifold \\eqref{eq:constraint-submanifold} would be that Delta_mfM^- and Delta_mfM^+ are identical.  In principle, slightly weaker necessary conditions can be formulated, however in practice it is unclear how to prove any of these conditions and in general they are not satisfied.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In order to construct a modified algorithm which does preserve the constraint submanifold, we compose the discrete fibre derivatives mathbbF^pm with appropriate projections mathbbP^pm,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqposition_momentum_projection\nbeginaligned\n(q_n p_n  )\n= big( mathbbP^- circ mathbbF^- L_d big) (q_n q_n+1)\n = mathbbP_lambda_n^-^- big( q_n -  D_1 L_d (q_n q_n+1) big)  \n(q_n+1 p_n+1)\n= big( mathbbP^+ circ mathbbF^+ L_d big) (q_n q_n+1)\n = mathbbP_lambda_n+1^+^+ big( q_n+1 D_2 L_d (q_n q_n+1) big)  \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that they take any point in mfM times mfM to the constraint submanifold Delta. The Lagrange multiplier lambda is indicated as subscript and implicitly determined by requiring that the constraint phi is satisfied by the projected values of q and p. These projected fibre derivatives will not be a fibre-preserving map anymore, but they will change both q and p. Noting that the nullspace of mathbbP_lambda is the span of Omega^-1 nabla phi, a natural candidate for the projection mathbbP_lambda is given by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqprojector\nbeginaligned\nmathbbP_lambda^pm (q p)  (q p) = (q p) pm h  Omega^-1 nabla phi^T (q p) lambda  \n0 = phi(q p) \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that ( mathbbP^- circ mathbbF^- L_d ) (q_n q_n+1) explicitly reads","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nq_n = q_n - h  phi_p^T (q_n p_n) lambda_n^-  \np_n = - D_1 L_d (q_n q_n+1) + h  phi_q^T (q_n p_n) lambda_n^-  \n0 = phi(q_n p_n) \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and ( mathbbP^+ circ mathbbF^+ L_d ) (q_n q_n+1) explicitly reads","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nq_n+1 = q_n+1 + h  phi_p^T (q_n+1 p_n+1) lambda_n+1^+  \np_n+1 = D_2 L_d (q_n q_n+1) - h  phi_q^T (q_n+1 p_n+1) lambda_n+1^+  \n0 = phi(q_n+1 p_n+1) \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The signs in front of the projections have been chosen in correspondence with the signs of the discrete forces in [9], Chapter 3. With these projections we obtain all of the algorithms introduced in the following sections, except for the midpoint projection, in a similar fashion to the definition of the position-momentum form of the variational integrator \\eqref{eq:vi-position-momentum-form}, as a map Delta rightarrow Delta which can formally be written as","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqprojection-composition-map\nPhi_h = big( pi_Delta circ mathbbP^+ circ mathbbF^+ L_d big) circ big( pi_Delta circ mathbbP^- circ mathbbF^- L_d big)^-1 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In total, we obtain algorithms which map q_n into q_n+1 via the steps","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Delta\nxrightarrowpi_Delta^-1\ni(Delta)\nxrightarrow(mathbbP^-)^-1\ncbmfM\nxrightarrow(mathbbF^- L_d)^-1\nmfM times mfM\nxrightarrowmathbbF^+ L_d\ncbmfM\nxrightarrowmathbbP^+\ni(Delta)\nxrightarrowpi_Delta\nDelta ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where pi_Delta^-1 is identical to the inclusion \\eqref{eq:dirac-inclusion}. The difference of the various algorithms lies in the choice of lambda_n^- and lambda_n+1^+ as follows","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Projection lambda_n^- lambda_n+1^+\nStandard 0 lambda_n+1\nSymplectic lambda_n R (infty)  lambda_n+1hphantom2\nSymmetric lambda_n+12 R (infty)  lambda_n+12\nMidpoint lambda_n+12 R (infty)  lambda_n+12","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For the symmetric, symplectic and midpoint projections, it is important to adapt the sign in the projection according to the stability function R(infty) of the basic integrator (for details see e.g. [29]). For the methods we are interested in, namely Runge-Kutta methods, the stability function is given by R(z) = 1 + z b^T (identity - zA)^-1 e with e = (1 1  1)^T in mathbbR^s, and we have absR(infty)=1 or, more specifically, for Gauss-Legendre methods R(infty) = (-1)^s and for partitioned Gauss-Lobatto IIIA-IIIB and IIIB-IIIA methods we have R(infty) = (-1)^s-1.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Let us remark that for the standard projection, the basic integrator and the projection step can be applied independently. Similarly, for the symplectic projection, the three steps, namely perturbation, numerical integrator, and projection, decouple and can be solved consecutively, as we use different Lagrange multipliers lambda_n in the perturbation and lambda_n+1 in the projection. For the symmetric projection and the midpoint projection, however, this is not the case.  There, we used the same Lagrange multiplier lambda_n+12 in both the perturbation and the projection, so that the whole system has to be solved at once, which is more costly. This also implies that for the projection methods where lambda_n^- and lambda_n+1^+ are the same (possibly up to a sign due to R(infty)), strictly speaking we cannot write the projected algorithm in terms of a composition of two steps as we did in \\eqref{eq:projection-composition-map}. Instead the whole algorithm has to be treated as one nonlinear map. The idea of the construction of the methods is still the same, though. Only the midpoint projection needs special treatment. There, the operator mathbbP_lambda is defined in a slightly more complicated way than in \\eqref{eq:projector}, using different arguments in the projection step, which does not quite fit the general framework outlined here.","category":"page"},{"location":"integrators/vprk/#sec:standard-projection","page":"VPRK","title":"Standard Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: Illustration of the standard projection method)","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Illustration of the standard projection method: The solution is projected to the constraint submanifold Delta after each step of the numerical integrator Psi_h.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The standard projection method [[5], Section IV.4] is the simplest projection method. Starting from q_n, we use the continuous fibre derivative \\eqref{eq:fibre-derivative-general} to compute p_n = vartheta (q_n). Then we apply some symplectic one-step method Psi_h to z_n = (q_n p_n) to obtain an intermediate solution z_n+1,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"barz_n+1 = Psi_h (z_n) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"which is projected onto the constraint submanifold \\eqref{eq:constraint-submanifold} by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqorthogonal_projection\nz_n+1 = barz_n+1 + h  Omega^-1 nabla phi^T (z_n+1) lambda_n+1 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"enforcing the constraint","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"0 = phi (z_n+1) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"This projection method, combined with the variational integrator in position-momentum form \\eqref{eq:vi-position-momentum-form}, is not symmetric, and therefore not reversible. Moreover, it exhibits a drift of the energy, as has been observed before, e.g., for holonomic constraints [[28], [27], [5]].","category":"page"},{"location":"integrators/vprk/#sec:symmetric-projection","page":"VPRK","title":"Symmetric Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: Symmetric Projection +) (Image: Symmetric Projection -)","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Illustration of the symmetric projection method: The solution is first perturbed off the constraint submanifold Delta, then one step of the numerical integrator Psi_h is performed, and the result is projected back onto Delta.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"To overcome the shortcomings of the standard projection, we consider a symmetric projection of the variational Runge-Kutta integrators following [28], [27] and [29], see also [5], Section V.4.1. Here, one starts again by computing the momentum p_n as a function of the coordinates q_n according to the continuous fibre derivative, which can be expressed with the constraint function as","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymmetric-symplectic-projection\n0 = phi (z_n) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Then the initial value z_n is first perturbed,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymmetric-projection-pre\nbarz_n = z_n + h  Omega^-1 nabla phi^T (z_n)  lambda_n+12  \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"followed by the application of some one-step method Psi_h,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"barz_n+1 = Psi_h (barz_n) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and a projection of the result onto the constraint submanifold,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymmetric_projection_post\nz_n+1 = barz_n+1 + h  R(infty)  Omega^-1 nabla phi^T (z_n+1) lambda_n+12 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"which enforces the constraint","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"0 = phi (z_n+1) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Here, it is important to note that Lagrange multiplier lambda_n+12 is the same in both the perturbation and the projection step, and to account for the stability function R(infty) of the basic integrator, as mentioned before. The algorithm composed of the symmetric projection and some symmetric variational integrator in position-momentum form, constitutes a symmetric map","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Phi_h  q_n mapsto q_n+1 ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where, from a practical point of view, p_n, p_n+1 and lambda_n+12 are treated as intermediate variables. Unfortunately, the method is not symplectic but instead satisfies the relation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginmultlinelabeleqsymmetric-projection-symplecticity-condition\n   dfrac12 barOmega_ij (q_n)  big( ext q_n^i wedge ext q_n^j\n - h^2  ext lambda_n+12^i wedge ext lambda_n+12^j big)\n - h^2 lambda_n+12^k vartheta_kij (q_n)  ext q_n^i wedge ext lambda_n+12^j = \n = dfrac12 barOmega_ij (q_n+1)  big( ext q_n+1^i wedge ext q_n+1^j\n - h^2  ext lambda_n+12^i wedge ext lambda_n+12^j big)\n - h^2 lambda_n+12^k vartheta_kij (q_n+1)  ext q_n+1^i wedge ext lambda_n+12^j \nendmultline","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For certain systems, this method can even be shown to be symplectic. In general, though, it is not symplectic. Nevertheless, it tends to perform very well in long-time simulations.","category":"page"},{"location":"integrators/vprk/#sec:symplectic-projection","page":"VPRK","title":"Symplectic Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: )","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Illustration of the post projection method. Starting on the constraint submanifold Delta, the numerical integrator Psi_h moves the solution away from Delta in the first step. After each step, the solution is projected back onto Delta, but the perturbation at the beginning of each consecutive step is exactly the inverse of the previous projection, so that, practically speaking, the solution is projected back onto Delta only for output purposes.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the symplectic projection, we modify the perturbation \\eqref{eq:symmetric-projection-pre} to use the Lagrange multiplier at the previous time step, lambda_n, instead of lambda_n+1. As before, we assum the initial condition z_n satisfies the constraint,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic-projection-pre-constraint\n0 = phi (z_n) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The initial condition is perturbed, using the Lagrange multiplier lambda_n,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic-projection-pre\nbarz_n = z_n + h  Omega^-1 nabla phi^T (z_n)  lambda_n \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Then the usual one-step method Psi_h is applied,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"barz_n+1 = Psi_h (barz_n) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and the result is projected onto the constraint submanifold using the Lagrange multiplier lambda_n+1,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic-projection-post\nz_n+1 = barz_n+1 + h  R(infty)  Omega^-1 nabla phi^T (z_n+1) lambda_n+1 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"in order to enforce the constraint","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic-projection-post-constraint\n0 = phi (z_n+1) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The symplecticity condition \\eqref{eq:symmetric-projection-symplecticity-condition} is modified as follows,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginmultlinelabeleqsymplectic_projection_symplecticity_condition\n   dfrac12 barOmega_ij (q_n)  big( ext q_n^i wedge ext q_n^j\n - h^2  ext lambda_n^i wedge ext lambda_n^j big)\n - h^2 lambda_n^k vartheta_kij (q_n)  ext q_n^i wedge ext lambda_n^j = \n = dfrac12 barOmega_ij (q_n+1)  big( ext q_n+1^i wedge ext q_n+1^j\n - h^2  ext lambda_n+1^i wedge ext lambda_n+1^j big) \n - h^2 lambda_n+12^k vartheta_kij (q_n+1)  ext q_n+1^i wedge ext lambda_n+1^j \nendmultline","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"implying the conservation of a modified symplectic form omega_lambda defined on an extended phasespace mfM times mathbbR^d with coordinates (q lambda) by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic_projection_two_form\nomega_lambda\n = dfrac12 barOmega_ij (q)  ext q^i wedge ext q^j\n - dfrach^22 barOmega_ij (q)  ext lambda^i wedge ext lambda^j\n - h^2 lambda^k vartheta_kij (q)  ext q^i wedge ext lambda^j \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"with matrix representation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Omega_lambda =\nbeginpmatrix\nbarOmega  - h^2 lambda cdot vartheta_qq \nh^2 lambda cdot vartheta_qq  - h^2 barOmega \nendpmatrix ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"This corresponds to a modified one-form vartheta_lambda, such that omega_lambda = ext vartheta_lambda, given by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic_projection_one_form\nvartheta_lambda = ( vartheta_i (q) - h  lambda^k vartheta_ki (q) )  ( ext q^i - h  ext lambda^i )\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"As noted by [29], the modified perturbation \\eqref{eq:symplectic-projection-pre-constraint}-\\eqref{eq:symplectic-projection-pre} can be viewed as a change of variables from (q lambda) on mfM times mathbbR^d to (q p) on cbmfM, and the projection \\eqref{eq:symplectic-projection-post}-\\eqref{eq:symplectic-projection-post-constraint} as a change of variables back from (q p) to (q lambda). The symplectic form omega_lambda on mfM times mathbbR^d thus corresponds to the pullback of the canonical symplectic form omega on cbmfM by this variable transformation.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Let us note that the sign in in front of the projection in \\eqref{eq:symplectic-projection-post}, given by the stability function of the basic integrator, has very important implications on the nature of the algorithm. If it is the same as in \\eqref{eq:symplectic-projection-pre}, the character of the method is very similar to the symmetric projection method described before. If the sign is the opposite of the one in \\eqref{eq:symplectic-projection-pre}, like for Gauss-Legendre Runge-Kutta methods with an odd number of stages, the perturbation reverses the projection of the previous step, so that we effectively apply the post-projection method of [32]. That is, the projected integrator Phi_h is conjugate to the unprojected integrator Psi_h by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Phi_h = mathbbP^-1 circ Psi_h circ mathbbP ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that the following diagram commutes","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: Commuting Diagram)","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and the projection is effectively only applied for the output of the solution, but the actual advancement of the solution in time happens outside of the constraint submanifold. In other words, applying n times the algorithm Phi_h to a point (q_0 0) is equivalent to applying the perturbation mathbbP^-1, then applying n times the algorithm Psi_h and projecting the result with mathbbP.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Potentially, this might degrade the performance of the algorithm. If the accumulated global error drives the solution too far away from the constraint submanifold, the projection step might not have a solution anymore. Interestingly, however, post-projected Gauss-Legendre Runge-Kutta methods retain their optimal order of 2s [[32]]. Moreover, for methods with an odd number of stages, the global error of the unprojected solution is mathcalO(h^s+1), compared to mathcalO(h^s) for methods with an even number of stages. In practice this seems to be at least part of the reason of the good long-time stability of these methods.","category":"page"},{"location":"integrators/vprk/#sec:midpoint-projection","page":"VPRK","title":"Midpoint Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For certain variational Runge-Kutta methods, we can also modify the symmetric projection in a different way in order to obtain a symplectic projection, namely by evaluating the projection at the midpoint","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nbarz_n+12 = (barq_n+12 barp_n+12)  \nbarq_n+12 = tfrac12 big( barq_n + barq_n+1 big)  \nbarp_n+12 = tfrac12 big( barp_n + barp_n+1 big) \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that the projection algorithm is modified as follows. As always, the initial condition is expected to satisfy the constraint,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqmidpoint_projection_pre_constraint\n0 = phi (z_n) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For the perturbation of the initial condition,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqmidpoint_projection_pre\nbarz_n = z_n + h  Omega^-1 nabla phi^T (barz_n+12)  lambda_n+12 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"the gradient of the constraint is evaluated at the midpoint barz_n+12. A one step method is applied,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"barz_n+1 = Psi_h (z_barz) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and the result is projected, again evaluating the gradient of phi at the midpoint barz_n+12,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqmidpoint_projection_post\nz_n+1 = barz_n+1 + h  R(infty)  Omega^-1 nabla phi^T (z_n+12) lambda_n+12 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"in order to force the solution to satisfy the constraint,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic_projection_midpoint_post_constraint\n0 = phi (z_n+1) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For certain systems, this method can be shown to be symplectic with respect to the original noncanonical symplectic form on mfM if the integrator Psi_h is a symmetric, symplectic Runge-Kutta method with an odd number of stages s, for which the central stage with index (s+1)2 corresponds to z_n+12. This is obviously the case for the implicit midpoint rule, that is the Gauss-Legendre Runge-Kutta method with s=1, but unfortunately not for higher-order Gauss-Legendre or for Gauss-Lobatto methods. However, following [35] and [36], higher-order methods similar to Gauss-Legendre methods but satisfying the requested property can be obtained. See for example the method with three stages, implemented as SRK3.","category":"page"},{"location":"integrators/vprk/#sec:internal-stage-projection","page":"VPRK","title":"Internal Stage Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"TODO","category":"page"},{"location":"authors/#Authors","page":"Authors","title":"Authors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"GeometricIntegrators' development is coordinated by a group of principal developers, who are also its main contributors and who can be contacted in case of questions about GeometricIntegrators. In addition, there are contributors who have provided substantial additions or modifications. Together, these two groups form \"The GeometricIntegrators Authors\" as mentioned in the LICENSE file.","category":"page"},{"location":"authors/#Principal-Developers","page":"Authors","title":"Principal Developers","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"Michael Kraus, Max Planck Institute for Plasma Physics, Garching, Germany","category":"page"},{"location":"authors/#Contributors","page":"Authors","title":"Contributors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"The following people contributed to GeometricIntegrators and are listed in alphabetical order:","category":"page"},{"location":"authors/","page":"Authors","title":"Authors","text":"Christopher Albert\nMichael Kraus\nChristopher Rackauckas\nTomasz M. Tyranoski","category":"page"},{"location":"integrators/hpi/#hpi","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin Integrators","text":"","category":"section"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"Hamilton-Pontryagin integrators are obtained from discrete versions of the Hamilton-Pontryagin action principle,","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"delta mathcalA qvp = delta int_０^T left L (q v) - left p  dotq - v right right  dt = 0 ","category":"page"},{"location":"integrators/hpi/#Trapezoidal-Discrete-Lagrangian","page":"Hamilton-Pontryagin","title":"Trapezoidal Discrete Lagrangian","text":"","category":"section"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"We consider a discrete Lagrangian of the form","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"L_d (q_n q_n+1) = frach2 big L (q_n v_n+12) + L (q_n+1 v_n+12) big ","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"where q_n approximates the solution q(t_n) and v_n+12 is the velocity, which is assumed to be constant in the interval t_n t_n+1. The discrete Hamilton-Pontryagin action reads","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"A_d q_d = sum limits_n=0^N-1 bigg L_d (q_n q_n+1) + h left p_n+12  phi_h (q_n q_n+1 a_nn+1) - v_n+12 right bigg ","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"where phi_h is a map that computes the velocity v_n+12 as a function of q_n, q_n+1 and a set of parameters a_nn+1. A trivial example of such a map that does not depend on any parameters a_nn+1 is","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"phi_h (q_n q_n+1 a_nn+1) = fracq_n+1 - q_nh ","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"In order to solve the discrete Euler-Lagrange equations, the user needs to specify the map phi_h, its gradients with respect to q_n and q_n+1, denoted by D_1 phi_h and D_2 phi_h, respectively, the gradient with respect to the parameters, denoted by D_a phi_h, and an initial set of parameters a_0.","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"The equations of motion, that are solved by this integrator, are computed as:","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"beginaligned\n0 = frach2  fracpartial Lpartial q (q_n v_n+12)\n   + frach2  fracpartial Lpartial q (q_n v_n-12) \n  + h  D_1 phi_h (q_n q_n+1 a_nn+1) cdot p_n+12\n   + h  D_2 phi_h (q_n-1 q_n a_n-1n) cdot p_n-12  \n0 = D_a phi_h (q_n q_n+1 a_nn+1) cdot p_n+12  \nv_n+12\n= phi_h (q_n q_n+1 a_nn+1)  \np_n+12\n= frac12  fracpartial Lpartial v (q_n v_n+12)\n + frac12  fracpartial Lpartial v (q_n+1 v_n+12) \nendaligned","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"Upon defining the momentum","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"p_n\n= h  D_2 phi_h (q_n-1 q_n a_n-1n) cdot p_n-12\n+ frach2  fracpartial Lpartial q (q_n v_n-12) ","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"we can rewrite the equations of motion as","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"beginaligned\n0 = p_n\n   + frach2  fracpartial Lpartial q (q_n v_n+12)\n   + h  D_1 phi_h (q_n q_n+1 a_nn+1) cdot p_n+12  \n0 = D_a phi_h (q_n q_n+1 a_nn+1) cdot p_n+12  \nv_n+12\n= phi_h (q_n q_n+1 a_nn+1)  \np_n+12\n= frac12  fracpartial Lpartial v (q_n v_n+12)\n + frac12  fracpartial Lpartial v (q_n+1 v_n+12)  \np_n+1\n= h  D_2 phi_h (q_n q_n+1 a_nn+1) cdot p_n+12\n + frach2  fracpartial Lpartial q (q_n+1 v_n+12) \nendaligned","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"Given (q_n p_n), the first four equations can be solved for q_n+1, where v_n+12, p_n+12, and a_nn+1 are treated as internal variables similar to the internal stages of a Runge-Kutta method, and the last equation provides an explicit update for p_n+1.","category":"page"},{"location":"integrators/hpi/#Midpoint-Discrete-Lagrangian","page":"Hamilton-Pontryagin","title":"Midpoint Discrete Lagrangian","text":"","category":"section"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"Similarly to the previous section, we can consider a discrete Lagrangian of the form","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"L_d (q_n q_n+1) = h  L bigg( fracq_n + q_n+12 v_n+12 bigg) ","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"where q_n approximates the solution q(t_n) and v_n+12 is the velocity, which is assumed to be constant in the interval t_n t_n+1. The discrete Hamilton-Pontryagin action reads","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"A_d q_d = sum limits_n=0^N-1 bigg L_d^alphabeta (q_n q_n+1 v_n+12) + left p_n+12  phi_h (q_n q_n+1 a_nn+1) - v_n+12 right bigg ","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"where phi_h is a map that computes the velocity v_n+12 as a function of q_n, q_n+1 and a set of parameters a_nn+1.","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"The equations of motion, that are solved by this integrator, is computed as:","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"beginaligned\n0 = frach2  fracpartial Lpartial q bigg( fracq_n-1 + q_n2 v_n-12 bigg)\n   + frach2  fracpartial Lpartial q bigg( fracq_n + q_n+12 v_n+12 bigg) \n  + h  D_1 phi_h (q_n q_n+1 a_nn+1) cdot p_n+12\n   + h  D_2 phi_h (q_n-1 q_n a_n-1n) cdot p_n-12  \n0 = D_a phi_h (q_n q_n+1 a_nn+1) cdot p_n+12  \nv_n+12 = phi_h (q_n q_n+1 a_nn+1)  \np_n+12 = fracpartial Lpartial v bigg( fracq_n + q_n+12 v_n+12 bigg) \nendaligned","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"Upon defining the momentum","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"p_n\n= h  D_2 phi_h (q_n-1 q_n a_n-1n) cdot p_n-12\n+ frach2  fracpartial Lpartial q bigg( fracq_n-1 + q_n2 v_n-12 bigg) ","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"we can rewrite the equations of motion as","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"beginaligned\n0 = p_n\n   + frach2  fracpartial Lpartial q bigg( fracq_n + q_n+12 v_n+12 bigg)\n   + h  D_1 phi_h (q_n q_n+1 a_nn+1) cdot p_n+12  \n0 = D_a phi_h (q_n q_n+1 a_nn+1) cdot p_n+12  \nv_n+12 = phi_h (q_n q_n+1 a_nn+1)  \np_n+12 = fracpartial Lpartial v bigg( fracq_n + q_n+12 v_n+12 bigg)  \np_n+1\n= h  D_2 phi_h (q_n q_n+1 a_nn+1) cdot p_n+12\n + frach2  fracpartial Lpartial q bigg( fracq_n + q_n+12 v_n+12 bigg) \nendaligned","category":"page"},{"location":"integrators/hpi/","page":"Hamilton-Pontryagin","title":"Hamilton-Pontryagin","text":"Given (q_n p_n), the first four equations can be solved for q_n+1, where v_n+12, p_n+12, and a_nn+1 are treated as internal variables similar to the internal stages of a Runge-Kutta method, and the last equation provides an explicit update for p_n+1.","category":"page"},{"location":"integrators/variational/#variational-integrators","page":"Variational","title":"Variational Integrators","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The basic idea of variational integrators is to construct a discrete counterpart to a particular mechanical system instead of directly discretising its equations of motion. This means that the fundamental building blocks of classical mechanics, namely the action functional, the Lagrangian, the variational principle, and the Noether theorem, all have discrete equivalents. The application of the discrete variational principle to the discrete action then leads to discrete Euler-Lagrange equations. The evolution map that corresponds to the discrete Euler-Lagrange equations is what is called a variational integrator. The discrete Noether theorem can be used to relate symmetries of the discretised system to discrete momenta that are in principle exactly preserved by this integrator.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"With standard numerical methods, one approximately solves the exact equations of some system. In a sense, the idea of variational integrators is to exactly solve the equations of an approximate system.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The seminal work in the development of a discrete equivalent of classical mechanics was presented by [[10], [10]]. His method, based on a discrete variational principle, leads to symplectic integration schemes that automatically preserve constants of motion [[11], [12]]. A comprehensive review of discrete mechanics can be found in [[9]], including a thorough account on the historical development. The discrete version of Hamilton's phasespace action principle is presented in [[13]].","category":"page"},{"location":"integrators/variational/#Discretisation-of-the-Action","page":"Variational","title":"Discretisation of the Action","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The derivation of the discrete theory follows along the lines of the derivation of the continuous theory. The starting point is the discretisation of the space of paths mathcalQ ( mfM ) that connect two points in mfM,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ ( mfM ) = big q  mathcalI rightarrow mfM  bigvert  mathcalI subset mathbbR  textsmooth and bounded big ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Therefore we divide each time interval mathcalI into an equidistant, monotonic sequence  t_n _n=0^N and defined the discrete path space as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ_d ( mfM ) = big q_d   t_n _n=0^N rightarrow mfM big ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The space mathcalQ_d ( mfM ) contains all possible discrete trajectories q_d in mfM and is isomorphic to mfM times  times mfM (N+1 copies),","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ_d ( mfM ) cong bigtimes_N+1 mfM ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Therefore mathcalQ_d ( mfM ) constitutes a finite-dimensional approximation of the infinite-dimensional space mathcalQ ( mfM ). Note that mathcalQ_d is not a subspace of mathcalQ. Fixing an interval 0 T, so that","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":" t_n _n=0^N =  t_n = nh  vert  n = 0  N   Nh = T  subset mathbbR ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"is an increasing sequence of time points and h is the discrete time step, the discrete equivalent of the space of curves from q_0 to q_N,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ ( q_0 q_N 0 T ) = big q  0 T rightarrow mfM  bigvert  q(0) = q_0  q(T) = q_N big subset mathcalQ ( mfM ) ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"is the space that contains all discrete trajectories with fixed endpoints q_0 and q_N, defined as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ_d ( q_0 q_N  t_n _n=0^N ) = big q_d   t_n _n=0^N rightarrow mfM  bigvert  q(t_0) = q_0 q(t_N) = q_N big subset mathcalQ_d ( mfM ) ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete trajectory can be written as q_d =  q_n _n=0^N, where q_n denotes the generalised coordinates at time t_n. The space mathcalQ_d ( q_0 q_N  t_n _n=0^N ) is a finite-dimensional approximation of mathcalQ ( q_0 q_N 0 T ). In the following, we will use piecewise linear Lagrange polynomials to approximate the trajectory q(t), that is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-linear-interpolation\nq_h (t) bigvert_t_n t_n+1 = q_n dfract_n+1 - tt_n+1 - t_n + q_n+1 dfract - t_nt_n+1 - t_n \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The next step is to choose a quadrature rule which determines the discrete action. While the continuous action is a map","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalA  mathcalQ ( q_0 q_N 0 T ) rightarrow mathbbR ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"assigning real values to each path q(t), the discrete action is a map","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalA_d  mathcalQ_d ( q_0 q_N  t_n _n=0^N ) rightarrow mathbbR ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"assigning real values to each discrete path q_d. Once we obtained the discrete action, everything else follows in a straight forward and systematic way from Hamilton's principle of stationary action, so that these choices are determining the form of the discrete equations of motion.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"After we fix the sequence  t_n _n=0^N, the continuous action can be written as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalA q = sum_n=0^N-1 int_t_n^t_n+1 L (q dotq)  dt ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The terms of the sum are called the \\emph{exact discrete Lagrangian},","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"L_d^mathrme (q_n q_n+1) = int_t_n^t_n+1 L big( q_nn+1 (t)  dotq_nn+1 (t) big)  dt ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which is defined as a function of two consecutive points on the discrete trajectory q_d =  q_n _n=0^N. Here, q_nn+1 (t) denotes the solution of the continuous Euler-Lagrange equations in the interval t_n t_n+1  satisfying the boundary conditions q_nn+1 (t_n) = q_n and q_nn+1 (t_n+1) = q_n+1, with q_n denoting the generalised coordinates at time t_n and dotq_n the generalised velocities at time point t_n. In practice, the exact discrete Lagrangian cannot be computed exactly, which means we have to approximate it,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"L_d (q_n q_n+1) approx int_t_n^t_n+1 L big( q_nn+1 (t)  dotq_nn+1 (t) big)  dt ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"That is, we have to approximate the trajectory q(t), the velocity dotq(t) and the integral. This approximation leads to the discrete Lagrangian, given as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-quadrature\nL_d (q_n q_n+1) = h sum limits_i=1^s b_i  L big( q_h (t_n + c_i h)  dotq_h (t_n + c_i h) big) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"where q_n = q_h (t_n) and q_n+1 = q_h (t_n+1). The discrete action thus becomes merely a sum over the time index of discrete Lagrangians","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-action\nmathcalA_d q_d = sum limits_n=0^N-1 L_d (q_n q_n+1) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which defines a map mathcalA_d  mathcalQ_d ( q_0 q_N  t_n _n=0^N ) rightarrow mathbbR. In order to obtain the discrete Lagrangian, the generalised velocities are often discretised by simple finite-difference expressions\\footnote{ In the first term of the trapezoidal rule \\eqref{eq:vi-trapezoidal}, this corresponds to a forward finite-difference, in the second term to a backward finite-difference, and in the midpoint rule \\eqref{eq:vi-midpoint} to a centred finite-difference. }, i.e.,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"dotq (t) approx dfracq_n+1 - q_nh\nhspace3em textfor hspace3em\nt in  t_n  t_n+1   ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"This corresponds to approximating the trajectory q(t) between t_n and t_n+1 by linear interpolation between q_n and q_n+1 like in \\eqref{eq:vi-linear-interpolation} and taking the derivative of q_h (t) with respect to t. The quadrature is most often realised by either the trapezoidal rule (c_1 = 0, c_2 = 1),","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-trapezoidal\nL_d^texttr (q_n q_n+1) = dfrach2  L bigg( q_n dfracq_n+1 - q_nh bigg) + dfrach2  L bigg( q_n+1 dfracq_n+1 - q_nh bigg) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"or the midpoint rule (c_1 = 12),","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-midpoint\nL_d^textmp (q_n q_n+1) = h  L bigg( dfracq_n + q_n+12 dfracq_n+1 - q_nh bigg) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The configuration manifold of the discrete theory is still mfM, but the discrete state space is mfM times mfM instead of tbmfM, such that the discrete Lagrangian L_d is a function","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-discrete_lagrangian\nL_d  mfM times mfM rightarrow mathbbR \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mapping two points on the discrete trajectory into the real numbers.","category":"page"},{"location":"integrators/variational/#Discrete-Euler-Lagrange-Equations","page":"Variational","title":"Discrete Euler-Lagrange Equations","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"(Image: Variations of the discrete trajectory)","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete trajectories q_d =  q_n _n=0^N are required to satisfy a discrete version of Hamilton's principle of stationary action","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"delta mathcalA_d q_d = delta sum limits_n=0^N-1 L_d (q_n q_n+1) = 0 ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"As each point q_n of the discrete trajectory takes continuous values, we consider variations as as one-parameter families of transformations, that is families of paths q_d^epsilon =  q_n^epsilon _n=0^N in mathcalQ_d ( q_0 q_N  t_n _n=0^N ) which contain the solution path q_d for epsilon=0. The variations of q_d are contained in the tangent space tbq_dmathcalQ_d ( q_0 q_N  t_n _n=0^N ) to mathcalQ_d ( q_0 q_N  t_n _n=0^N ) at q_d. It is defined as the set of maps","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\nv_q_d   t_n _n=0^N rightarrow tbmfM \n textsuch that \npi_mfM circ v_q_d = q_d \n textand \nv (t_0) = v (t_N) = 0 \nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"where pi_mfM is the canonical projection pi_mfM  tbmfM rightarrow mfM and local coordinates are given by","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"v_q_d =  (q_n v_n) _n=0^N ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"In particular, a discrete variation v_q_d of the discrete path q_d is defined as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"v_q_d = dfracddepsilon q_d^epsilon biggvert_epsilon=0 ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"By identifying delta equiv d  depsilon bigvert_epsilon=0, we can also denote the variation by v_q_d = delta q_d. In analogy to the continuous setting, the variation of the discrete action can be written as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"delta mathcalA_d q_d = \ndfracddepsilon mathcalA_d q_d^epsilon biggvert_epsilon=0\n= ext mathcalA_d q_d cdot v_q_d ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which explicitly computed becomes","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-variation_01\next mathcalA_d q_d cdot v_q_d = sum limits_n=0^N-1 big D_1  L_d (q_n q_n+1) cdot v_n + D_2  L_d (q_n q_n+1) cdot v_n+1 big \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"where D_i denotes the derivative with respect to to the ith argument (slot derivative). What follows corresponds to a discrete integration by parts, i.e., a reordering of the summation. The n=0 term is separated from the first part of the sum and the n=N-1 term is separated from the second part","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-variation_02\nbeginaligned\next mathcalA_d q_d cdot v_q_d\nnonumber\n = D_1  L_d (q_0 q_1) cdot v_0\n+ sum limits_n=1^N-1 D_1  L_d (q_n q_n+1) cdot v_n \n+ sum limits_n=0^N-2 D_2  L_d (q_n q_n+1) cdot v_n+1\n + D_2  L_d (q_N-1 q_N) cdot v_N\n\nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"As the variations at the endpoints are kept fixed, v_0 = v (t_0) = 0 as well as v_N = v (t_N) = 0, the corresponding terms vanish. At last, the summation range of the second sum is shifted upwards by one with the arguments of the discrete Lagrangian adapted correspondingly","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-variation_03\next mathcalA_d q_d cdot v_q_d\n=  sum limits_n=1^N-1 big D_1  L_d (q_n q_n+1) + D_2  L_d (q_n-1 q_n) big cdot v_n\n\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Hamilton's principle of least action requires the variation of the discrete action delta mathcalA_d to vanish for any choice of v_n. Consequently, the expression in the square brackets has to vanish. This defines the discrete Euler-Lagrange equations","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-deleqs\nD_1  L_d (q_n q_n+1) + D_2  L_d (q_n-1 q_n) = 0\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete Euler-Lagrange equations define an evolution map","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-evolution_map\nvarphi_h\n   mfM times mfM rightarrow mfM times mfM\n   ( q_n-1 q_n ) mapsto ( q_n q_n+1 ) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Starting from two configurations, q_0 approx q (t_0) and q_1 approx q (t_1 = t_0 + h), the successive solution of the discrete Euler-Lagrange equations for q_2, q_3, etc., up to q_N, determines the discrete trajectory  q_n _n=0^N.","category":"page"},{"location":"integrators/variational/#Discrete-Fibre-Derivative","page":"Variational","title":"Discrete Fibre Derivative","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Quite often it is more practical to prescribe an initial position and momentum instead of the configuration of the first two time steps. We therefore want to define the discrete momentum p_n at time step n. In the continuous setting this was done with the help of the fibre derivative. However, in the discrete setting, we have two ways to define discrete fibre derivatives,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathbbF^- L_d   mathbbF^+ L_d  mfM times mfM rightarrow cbmfM ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which map the discrete state space mfM times mfM to the tangent bundle cbmfM. They are given by","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\nmathbbF^- L_d  (q_n q_n+1) mapsto (q_n   p_n)   = big( q_n   - D_1 L_d (q_n q_n+1) big)  \nmathbbF^+ L_d  (q_n q_n+1) mapsto (q_n+1 p_n+1) = big( q_n+1   D_2 L_d (q_n q_n+1) big) \nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete Euler-Lagrange equations can now be rewritten as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathbbF^+ L_d (q_n-1 q_n) = mathbbF^- L_d (q_n q_n+1) ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"that is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-momentum\np_n = D_2 L_d (q_n-1 q_n) = - D_1 L_d (q_n q_n+1) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"TODO: Add composition maps of fibre derivatives and Lagrangian evolution map corresponding to the Hamiltonian evolution map.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Thus the discrete fibre derivatives permit a new interpretation of the discrete Euler–Lagrange equations. The variational integrator can be rewritten in position-momentum form,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-position-momentum\nbeginaligned\np_n   =           -  D_1 L_d (q_n q_n+1)  \np_n+1 = hphantom- D_2 L_d (q_n q_n+1) \nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Given (q_n p_n), the first equation can be solved for q_n+1. This is generally a nonlinearly implicit equation that has to be solved by some iterative technique like Newton's method. The second equation is an explicit function, so to obtain p_n+1 we merely have to plug in q_n and q_n+1. The corresponding Hamiltonian evolution map is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-evolution_map_position_momentum\ntildevarphi_h\n   cbmfM rightarrow cbmfM\n   ( q_n p_n ) mapsto ( q_n+1 p_n+1 ) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Thus, starting with an initial position q_0 and an initial momentum p_0, the repeated solution of tildevarphi_h gives the same discrete trajectory  q_n _n=0^N as the repeated solution of varphi_h. The position-momentum form, as a one-step method, is usually easier to implement than the discrete Euler-Lagrange equations. And for most problems, initial conditions are more naturally prescribed via the position and momentum of the particle at a given point in time, (q_0 p_0). If, however, only the position of the particle at two points in time, (q_0 q_1), is known, the Euler-Lagrange equations are the more natural way of describing the dynamics.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"This of course is just reflecting the difference in the Lagrangian and Hamiltonian point of view. For d degrees of freedom, the variational principle leads to d differential equations of second order. Hamilton's equations, on the other hand, are 2d differential equations of first order. Which form is more convenient to use largely depends on the problem at hand.","category":"page"},{"location":"integrators/variational/#Example:-Point-Particle","page":"Variational","title":"Example: Point Particle","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Consider a particle with mass m, moving in some potential V. Its continuous Lagrangian is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1_lagrangian\nL (q dotq) = dfrac12  m dotq^2 - V(q)\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Approximated by the trapezoidal rule, the discrete Lagrangian reads","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1-lagrangian-trapezoidal\nL_d^texttr (q_n q_n+1) = h  bigg dfracm2 bigg( dfracq_n+1 - q_nh bigg)^2 - dfracV (q_n) + V (q_n+1)2 bigg \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Applying the discrete Euler-Lagrange equations \\eqref{eq:vi-deleqs} to this expression results in discrete equations of motion","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1_deleqs_trapezoidal\nm  dfracq_n+1 - 2  q_n + q_n-1h^2 = - nabla V (q_n)\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which clearly are a discrete version of Newton's second law","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1-newton\nm ddotq = - nabla V = F \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"For comparison, consider also the midpoint approximation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1-lagrangian-midpoint\nL_d^textmp (q_n q_n+1) = h  bigg dfracm2  bigg( dfracq_n+1 - q_nh bigg)^2 - V bigg( dfracq_n + q_n+12 bigg) bigg\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which leads to","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1_deleqs_midpoint\nm  dfracq_n+1 - 2  q_n + q_n-1h^2 = - dfrac12  bigg nabla V bigg( dfracq_n-1 + q_n2 bigg) + nabla V bigg( dfracq_n + q_n+12 bigg) bigg\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"and thus a different discretisation of \\eqref{eq:vi-example1-newton}. The position-momentum form \\eqref{eq:vi-position-momentum} of the trapezoidal Lagrangian \\eqref{eq:vi-example1-lagrangian-trapezoidal} can be written as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\ndfracq_n+1 - q_nh =  dfrac1m  bigg p_n - dfrach2  nabla V (q_n) bigg \ndfracp_n+1 - p_nh = -  dfrac12  bigg nabla V (q_n) + nabla V (q_n+1) bigg\nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"and the one of the midpoint Lagrangian \\eqref{eq:vi-example1-lagrangian-midpoint} reads","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\ndfracq_n+1 - q_nh = dfrac1m  bigg p_n - dfrach2  nabla V bigg( dfracq_n + q_n+12 bigg) bigg \ndfracp_n+1 - p_nh = - nabla V bigg( dfracq_n + q_n+12 bigg) \nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"This bears a close resemblance of Hamilton's equations of motion, where the additional term in the first equations can be interpreted as extrapolating the momentum p_n to t_n+12. As already noted, it is not always so easy to solve the first equation in \\eqref{eq:vi-position-momentum} for q_n+1. In general this is an implicit equation.","category":"page"},{"location":"integrators/variational/#Discrete-Symplectic-Form","page":"Variational","title":"Discrete Symplectic Form","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"As in the continuous case, the discrete one-form is obtained by computing the variation of the action for varying endpoints","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\next mathcalA_d q_d cdot v_d\nnonumber\n= sum limits_n=0^N-1 big D_1  L_d (q_n q_n+1) cdot v_n + D_2  L_d (q_n q_n+1) cdot v_n+1 big \nnonumber\n= sum limits_n=1^N-1 big D_1  L_d (q_n q_n+1) + D_2  L_d (q_n-1 q_n) big cdot v_n \nhspace3em\n+ D_1  L_d (q_0 q_1) cdot v_0 + D_2  L_d (q_N-1 q_N) cdot v_N \nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The two latter terms originate from the variation at the boundaries. They form the discrete counterpart of the Lagrangian one-form. However, there are two boundary terms that define two distinct one-forms on mfM times mfM,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\nbeginarrayll\nTheta_L_d^- ( q_0   q_1 ) cdot ( v_0    v_1 ) equiv           -  D_1 L_d (q_0   q_1) cdot v_0  \nTheta_L_d^+ ( q_N-1 q_N ) cdot ( v_N-1  v_N ) equiv hphantom- D_2 L_d (q_N-1 q_N) cdot v_N \nendarray\nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"In general, these one-forms are defined as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-discrete-one-form\nbeginaligned\nTheta_L_d^- ( q_n  q_n+1 ) equiv           -  D_1 L_d (q_n q_n+1)  ext q_n  \nTheta_L_d^+ ( q_n  q_n+1 ) equiv hphantom- D_2 L_d (q_n q_n+1)  ext q_n+1 \nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"As ext L_d = Theta_L_d^+ - Theta_L_d^- and ext^2 L_d = 0 one observes that","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"ext Theta_L_d^+ = ext Theta_L_d^-","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"such that the exterior derivative of both discrete one-forms defines the same \\emph{discrete Lagrangian two-form} or \\emph{discrete symplectic form}","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-discrete_two_form\nbeginaligned\nomega_L_d\n= ext Theta_L_d^+\n = ext Theta_L_d^-\n = dfracpartial^2 L_d (q_n q_n+1)partial q_n   partial q_n+1  ext q_n wedge ext q_n+1 \n text(no summation over n) \nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Consider the exterior derivative of the discrete action \\eqref{eq:vi-action}. Upon insertion of the discrete Euler-Lagrange equations \\eqref{eq:vi-deleqs} it becomes","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-symplectic-ext-action\next mathcalA_d\n= D_1 L_d (q_0 q_1) cdot ext q_0 + D_2 L_d (q_N-1 q_N) cdot ext q_N\n= Theta_L_d^+ (q_N-1 q_N) - Theta_L_d^- (q_0 q_1) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"On the right hand side we find the just defined Lagrangian one-forms \\eqref{eq:vi-discrete-one-form}. Taking the exterior derivative of \\eqref{eq:vi-symplectic-ext-action} gives","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-symplectic-preservation\nomega_L_d (q_0 q_1) = omega_L_d (q_N-1 q_N) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"where q_N-1 and q_N are connected with q_0 and q_1 through the discrete Euler-Lagrange equations \\eqref{eq:vi-deleqs}. Therefore, \\eqref{eq:vi-symplectic-preservation} implies that the discrete symplectic structure omega_L_d is preserved while the system advances from t=0 to t=Nh according to the discrete equations of motion \\eqref{eq:vi-deleqs}. As the number of time steps N is arbitrary, the discrete symplectic form omega_L_d is preserved at all times of the simulation. Note that this does not automatically imply that the continuous symplectic structure omega_L is preserved under the discrete map varphi_h.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"TODO: show preservation of the canonical symplectic form by the position-momentum-form","category":"page"},{"location":"integrators/variational/#Discrete-Noether-Theorem","page":"Variational","title":"Discrete Noether Theorem","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete Noether theorem, just as the continuous Noether theorem, draws the connection between symmetries of a discrete Lagrangian and quantities that are conserved by the discrete Euler-Lagrange equations or, equivalently, the discrete Lagrangian flow. The continuous theory translates straight forwardly to the discrete case. Therefore, we repeat just the important steps, translated to the discrete setting.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Consider a one parameter group of discrete curves q_d^epsilon =  q_n^epsilon _n=0^N with q_n^epsilon = sigma^epsilon (t_n q_n epsilon) such that q_n^0 (q_n) = q_n, i.e., sigma^0 = id (note that sigma^epsilon is the same function as in the continuous case). The discrete Lagrangian L_d has a symmetry if it is invariant under this transformation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_1\nbeginaligned\nL_d big( q_n^epsilon q_n+1^epsilon big) = L_d big( q_n q_n+1 big) \n textfor all epsilon and n \nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The generating vector field of such a symmetry transformation is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_2\nX_n = dfracpartial sigma^epsilonpartial epsilon biggvert_epsilon = 0\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"such that","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-noether-finite-3\ndfracdd epsilon L_d big( q_n^epsilon q_n+1^epsilon big) biggvert_epsilon = 0\n = D_1 L_d big( q_n q_n+1 big) cdot X_n  \n + D_2 L_d big( q_n q_n+1 big) cdot X_n+1 \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"If  q_n _n=0^N solves the discrete Euler-Lagrange equations \\eqref{eq:vi-deleqs},","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_4\nD_1  L_d (q_n q_n+1) + D_2  L_d (q_n-1 q_n) = 0 \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"we can replace the first term on the right hand side of \\eqref{eq:vi-noether-finite-3} to get","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_5\n0 = - D_2 L_d big( q_n-1 q_n big) cdot X_n\n    + D_2 L_d big( q_n q_n+1 big) cdot X_n+1 \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"This amounts to a discrete conservation law of the form","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_6\nD_2 L_d big( q_n-1 q_n big) cdot X_n = D_2 L_d big( q_n q_n+1 big) cdot X_n+1 \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"It states that solutions  q_n _n=0^N of the discrete Euler-Lagrange equations preserve the components of the momentum p_n = D_2 L_d big( q_n-1 q_n big) in direction X_n.","category":"page"},{"location":"integrators/variational/#Available-Variational-Integrators","page":"Variational","title":"Available Variational Integrators","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Currently, the position-momentum form of the midpoint and trapezoidal discrete Lagrangians (cf. above) are implemented:","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Function and Aliases Order\nPMVImidpoint 2\nPMVItrapezoidal 2","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"In addition, the family of variational partitioned Runge-Kutta integrators provide a large number of methods.","category":"page"},{"location":"modules/spark/#SPARK","page":"SPARK Methods","title":"SPARK","text":"","category":"section"},{"location":"modules/spark/","page":"SPARK Methods","title":"SPARK Methods","text":"Modules = [GeometricIntegrators.SPARK]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/spark/#GeometricIntegrators.SPARK.AbstractTableauSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.AbstractTableauSPARK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.CoefficientsARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.CoefficientsARK","text":"Holds the coefficients of an additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.CoefficientsIRK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.CoefficientsIRK","text":"Holds the coefficients of an additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.CoefficientsMRK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.CoefficientsMRK","text":"Holds the multiplier Runge-Kutta coefficients.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.CoefficientsPRK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.CoefficientsPRK","text":"Holds the coefficients of a projective Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.CoefficientsSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.CoefficientsSPARK","text":"Holds the coefficients of a SPARK method.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorCacheSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorCacheSPARK","text":"Cache of a Specialised Partitioned Additive Runge-Kutta integrator.\n\nFields\n\nn: time step number\nt: time of current time step\nt̄: time of previous time step\nq: current solution of q\nq̄: previous solution of q\np: current solution of p\np̄: previous solution of p\nv: vector field of q\nv̄: vector field of q̄\nf: vector field of p\nf̄: vector field of p̄\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: vector field of internal stages of q\nZ: vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorHPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorHPARK","text":"Partitioned Additive Runge-Kutta integrator for Hamiltonian systems subject to Dirac constraints EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \ntildePhi_ni = 0   i = 1  r \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorHSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorHSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorHSPARKprimary","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorHSPARKprimary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorHSPARKsecondary","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorHSPARKsecondary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems subject to Dirac constraints with projection on secondary constraint EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorSLRK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorSLRK","text":"Specialised Partitioned Additive Runge-Kutta integrator for degenerate variational systems with projection on secondary constraint.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a^1_ij V_nj + h sum limits_j=1^sigma a^2_ij tildeLambda_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s bara^1_ij F^1_nj + h sum limits_j=1^s bara^2_ij F^2_nj + h sum limits_j=1^sigma bara^3_ij tildeF^3_nj   i = 1  s  \n0 = Phi_ni   i = 1  s \nendaligned\n\nthe projective stages\n\nbeginaligned\ntildeQ_ni = q_n + h sum limits_j=1^s alpha^1_ij tildeV_nj + h sum limits_j=1^sigma alpha^2_ij tildeLambda_nj   i = 1  sigma  \ntildeP_ni = p_n + h sum limits_j=1^s baralpha^1_ij F^1_nj + h sum limits_j=1^s baralpha^2_ij tildeF^2_nj + h sum limits_j=1^sigma baralpha^3_ij tildeF^3_nj   i = 1  sigma  \n0 = tildePhi_ni   i = 1  sigma  \n0 = sum limits_j=1^sigma omega_ij tildePsi_ni   i = 1  sigma-1 \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b^1_i V_ni + h sum limits_i=1^sigma b^2_i tildeLambda_ni  \np_n+1 = p_n + h sum limits_i=1^s b^1_i F^1_ni + h sum limits_i=1^s b^2_i F^2_ni + h sum limits_i=1^sigma b^3_i tildeF^3_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nwith definitions\n\nbeginaligned\nF^1_ni = nabla H (Q_ni)   i = 1  s  \nF^2_ni = nabla vartheta (Q_ni) cdot V_ni   i = 1  s  \ntildeF^3_ni = nabla phi (tildeQ_ni tildeP_ni) cdot tildeLambda_ni   i = 1  sigma  \nPhi_ni = phi (Q_ni P_ni) = P_ni - vartheta (Q_ni)   i = 1  s  \ntildePhi_ni = phi (tildeQ_ni tildeP_ni) = tildeP_ni - vartheta (tildeQ_ni)   i = 1  sigma  \ntildePsi_ni = psi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla vartheta (tildeQ_ni)   i = 1  sigma \nendaligned\n\nso that\n\nbeginaligned\nF^1_ni + F^2_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nphi (Q_ni P_ni) = P_ni - fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \npsi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla fracpartial Lpartial v (tildeQ_ni tildeV_ni)   i = 1  sigma \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for index-two DAE systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorVPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorVPARK","text":"Variational partitioned additive Runge-Kutta integrator.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \ntildePhi_ni = 0   i = 1  r \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorVSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorVSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for Variational systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorVSPARKprimary","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorVSPARKprimary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Variational systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1  \n0 = sum limits_i=1^r tilded_i  Lambda_ni \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorVSPARKsecondary","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorVSPARKsecondary","text":"Specialised Partitioned Additive Runge-Kutta integrator for degenerate variational systems with projection on secondary constraint.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a^1_ij V_nj + h sum limits_j=1^sigma a^2_ij tildeLambda_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s bara^1_ij F^1_nj + h sum limits_j=1^s bara^2_ij F^2_nj + h sum limits_j=1^sigma bara^3_ij tildeF^3_nj   i = 1  s  \n0 = Phi_ni   i = 1  s \nendaligned\n\nthe projective stages\n\nbeginaligned\ntildeQ_ni = q_n + h sum limits_j=1^s alpha^1_ij tildeV_nj + h sum limits_j=1^sigma alpha^2_ij tildeLambda_nj   i = 1  sigma  \ntildeP_ni = p_n + h sum limits_j=1^s baralpha^1_ij F^1_nj + h sum limits_j=1^s baralpha^2_ij tildeF^2_nj + h sum limits_j=1^sigma baralpha^3_ij tildeF^3_nj   i = 1  sigma  \n0 = tildePhi_ni   i = 1  sigma  \n0 = sum limits_j=1^sigma omega_ij tildePsi_ni   i = 1  sigma-1 \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b^1_i V_ni + h sum limits_i=1^sigma b^2_i tildeLambda_ni  \np_n+1 = p_n + h sum limits_i=1^s b^1_i F^1_ni + h sum limits_i=1^s b^2_i F^2_ni + h sum limits_i=1^sigma b^3_i tildeF^3_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nwith definitions\n\nbeginaligned\nF^1_ni = nabla H (Q_ni)   i = 1  s  \nF^2_ni = nabla vartheta (Q_ni) cdot V_ni   i = 1  s  \ntildeF^3_ni = nabla phi (tildeQ_ni tildeP_ni) cdot tildeLambda_ni   i = 1  sigma  \nPhi_ni = phi (Q_ni P_ni) = P_ni - vartheta (Q_ni)   i = 1  s  \ntildePhi_ni = phi (tildeQ_ni tildeP_ni) = tildeP_ni - vartheta (tildeQ_ni)   i = 1  sigma  \ntildePsi_ni = psi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla vartheta (tildeQ_ni)   i = 1  sigma \nendaligned\n\nso that\n\nbeginaligned\nF^1_ni + F^2_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nphi (Q_ni P_ni) = P_ni - fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \npsi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla fracpartial Lpartial v (tildeQ_ni tildeV_ni)   i = 1  sigma \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SLRK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SLRK","text":"Holds all parameters of an Specialised Partitioned Additive Runge-Kutta method for variational systems subject to constraints.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHPARK","text":"Holds the tableau of a Hamiltonian Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauSPARK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVPARK","text":"Holds the tableau of an Variational Partitioned Additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.VSPARKsecondary","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.VSPARKsecondary","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#Base.show-Tuple{IO, GeometricIntegrators.SPARK.CoefficientsARK}","page":"SPARK Methods","title":"Base.show","text":"Print additive Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#Base.show-Tuple{IO, GeometricIntegrators.SPARK.CoefficientsIRK}","page":"SPARK Methods","title":"Base.show","text":"Print additive Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#Base.show-Tuple{IO, GeometricIntegrators.SPARK.CoefficientsMRK}","page":"SPARK Methods","title":"Base.show","text":"Print multiplier Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#Base.show-Tuple{IO, GeometricIntegrators.SPARK.CoefficientsPRK}","page":"SPARK Methods","title":"Base.show","text":"Print projective Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#Base.show-Tuple{IO, GeometricIntegrators.SPARK.CoefficientsSPARK}","page":"SPARK Methods","title":"Base.show","text":"Print SPARK coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.Integrators.residual!-Union{Tuple{ST}, Tuple{Vector{ST}, Vector{ST}, SolutionStepPDAE, AbstractProblemIDAE{dType, tType} where {dType<:Number, tType<:Real}, GeometricIntegrators.SPARK.SPARKMethod, GeometricIntegrators.Integrators.CacheDict}} where ST","page":"SPARK Methods","title":"GeometricIntegrators.Integrators.residual!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKGLRK-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKGLRK","text":"SPARK tableau for Gauss-Legendre Runge-Kutta method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKGLRKLobattoIIIAIIIB","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKGLRKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Legendre/Gauss-Lobatto-IIIA-IIIB methods.\n\n\n\n\n\n","category":"function"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKGLRKLobattoIIIBIIIA","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKGLRKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Legendre/Gauss-Lobatto-IIIB-IIIA methods.\n\n\n\n\n\n","category":"function"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKGLVPRK-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKGLVPRK","text":"Tableau for Variational Gauss-Legendre method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKLobABC-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKLobABC","text":"Tableau for Gauss-Lobatto IIIA-IIIB-IIIC method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKLobABD-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKLobABD","text":"Tableau for Gauss-Lobatto IIIA-IIIB-IIID method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKLobatto-Tuple{Any, Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKLobatto","text":"SPARK tableau for Gauss-Lobatto methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Lobatto IIIA-IIIB method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Lobatto IIIB-IIIA method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKVPRK-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKVPRK","text":"SPARK Tableau for Variational Partitioned Runge-Kutta Methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauGausspSymplectic-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauGausspSymplectic","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHPARKGLRK-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHPARKGLRK","text":"Tableau for Gauss-Legendre HPARK method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHPARKLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHPARKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Lobatto IIIA-IIIB HPARK method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHPARKLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHPARKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Lobatto IIIB-IIIA  method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHSPARKGLRKpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHSPARKGLRKpSymmetric","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHSPARKLobattoIIIAIIIBpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHSPARKLobattoIIIAIIIBpSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHSPARKLobattoIIIBIIIApSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHSPARKLobattoIIIBIIIApSymmetric","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauLobattoIIIAIIIBpSymplectic-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauLobattoIIIAIIIBpSymplectic","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauLobattoIIIBIIIApSymplectic-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauLobattoIIIBIIIApSymplectic","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpInternal-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpInternal","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpLobattoIIIAIIIB","text":"Tableau for Gauss-Legendre method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpLobattoIIIBIIIA","text":"Tableau for Gauss-Legendre method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpMidpoint","text":"Tableau for Gauss-Legendre method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedInternal-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedInternal","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedMidpoint","text":"Tableau for Gauss-Legendre method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpSymmetric","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKInternalProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKInternalProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. Use the same tableaus for tildea^1 and tildea^3, so that tildes = s, as well as\n\nbeginaligned\nbeginarrayccc\n tfrac12 b^1 \n vdots \n tfrac12 b^1 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \n vdots \n tfrac12 b^3 \nhline\na^4  \nendarray\n\nbeginarrayccc\n tfrac12 b^1 \nc^1  vdots \n tfrac12 b^1 \nhline\ntildea^2  tfrac12 (1 + R(infty))  b^1 \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \nc^3  vdots \n tfrac12 b^3 \nhline\ntildea^4  tfrac12 (1 + R(infty))  b^3 \nendarray\nendaligned\n\nSet omega = 0  0 1 and\n\ndelta_ij = begincases\n+1  j = i  \n-1  j = tildes  \n 0  textelse \nendcases\n\nso that Lambda_1 = Lambda_2 =  = Lambda_tildes.\n\nThis methods is constructed to satisfy the constraint on the projective stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes. Note, however, that it violates the symplecticity conditions b^1_i b^4_j = b^1_i a^4_ij + b^4_j tildea^1_ji and b^2_i b^3_j = b^2_i tildea^3_ij + b^3_j a^2_ji.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^4 b^4) and (tildea^2 b^2), respectively, and choose tildea^1 and tildea^3 such that the projective stages correspond to the initial condition and the solution, i.e.,\n\nbeginaligned\nbeginarrayccc\n0  0 \n1  b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\n0  tfrac12  0 \n1  tfrac12  0 \nhline\ntildea^2  \nendarray\n\nbeginarrayccc\n0  0 \n1  b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\n0  0  0 \n1  tfrac12  tfrac12 \nhline\ntildea^4  \nendarray\nendaligned\n\nand compute a^2 and a^4 by the symplecticity conditions, that is a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i and a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i. Finally choose omega = 0 0 1 and delta = -1 R_infty, implying that rho = 1. By construction, this method satisfies all symplecticity conditions, but the constraint on the projection stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, is not satisfied exactly, but only approximately, although with bounded error.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpMidpoint","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpModifiedMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpModifiedMidpoint","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIAProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIAProjection","text":"This methods is the same as TableauVSPARKLobattoIIIAIIIBProjection, except for using Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^2 b^2), and (tildea^4 b^4) respectively, instead of the other way around.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApMidpoint","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApModifiedMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApModifiedMidpoint","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApSymmetric","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKMidpointProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKMidpointProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 1 and rho = 0, such that tildeQ_n1 = tfrac12 ( q_n + q_n+1), tildeP_n1 = tfrac12 ( p_n + p_n+1), i.e.,\n\nbeginaligned\nbeginarrayccc\n tfrac12 \n vdots \n tfrac12 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 \n vdots \n tfrac12 \nhline\na^4  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^2  tfrac12 (1 + R(infty))\nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^4  tfrac12 (1 + R(infty))\nendarray\nendaligned\n\nThe coefficients tildea^1 and tildea^3 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i, and omega = 0 1.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKModifiedInternalProjection","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKModifiedInternalProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s, and set\n\nbeginaligned\nbeginarrayccc\n tfrac12 b^1 \n vdots \n tfrac12 b^1 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 b^4 \n vdots \n tfrac12 b^4 \nhline\na^4  \nendarray\n\nbeginarrayccc\n tfrac12 b^1 \nc^1  vdots \n tfrac12 b^1 \nhline\ntildea^2  tfrac12 (1 + R(infty))  b^1 \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \nc^3  vdots \n tfrac12 b^3 \nhline\ntildea^4  tfrac12 (1 + R(infty))  b^3 \nendarray\nendaligned\n\nNote that by this definition tildes = s. The coefficients tildea^1 and tildea^3 are determined by the (modified) symplecticity conditions, specifically a^4_ij = b^3_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^1_j ( b^3_i - tildea^3_ji )  b^3_i, where b^2 has been replaced with b^1 and b^4 with b^3, respectively. Set omega = 0  0 1 and\n\ndelta_ij = begincases\n+1  j = i  \n-1  j = tildes  \n 0  textelse \nendcases\n\nso that Lambda_1 = Lambda_2 =  = Lambda_tildes.\n\nNote that this method satisfies the symplecticity conditions b^1_i b^4_j = b^1_i a^4_ij + b^4_j tildea^1_ji and b^2_i b^3_j = b^2_i tildea^3_ij + b^3_j a^2_ji only if R(infty) = 1 due to the definitions of b^2 and b^4. Moreover, it does usually not satisfy the constraint on the projective stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, exactly, but only approximately with bounded error, thus implying a residual in the symplecticity equation even if R(infty) = 1.\n\n\n\n\n\n","category":"function"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKModifiedLobattoIIIAIIIBProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKModifiedLobattoIIIAIIIBProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^4 b^4) and (tildea^2 b^2), respectively.\n\nThe coefficients tildea^1 and tildea^3 are determined by the relations\n\nbeginaligned\nsum limits_j=1^s tildea^1_ij (c_j^1)^k-1 = frac(c_i^2)^kk  qquad \nsum limits_j=1^s tildea^3_ij (c_j^3)^k-1 = frac(c_i^4)^kk  qquad \ni = 1      tildes  qquad \nk = 1      s \nendaligned\n\nThe coefficients a^2 and a^4 by the symplecticity conditions, that is a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i and a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i. Finally choose omega = 0 0 1 and delta = -1 R_infty, implying that rho = 1. By construction, this method satisfies all symplecticity conditions, but the constraint on the projection stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, is not satisfied exactly, but only approximately, although with bounded error.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKModifiedLobattoIIIBIIIAProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKModifiedLobattoIIIBIIIAProjection","text":"This methods is the same as TableauVSPARKModifiedLobattoIIIAIIIBProjection, except for using Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^2 b^2), and (tildea^4 b^4) respectively, instead of the other way around.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKModifiedMidpointProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKModifiedMidpointProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 1 and rho = 0, such that tildeQ_n1 = tfrac12 ( q_n + q_n+1), tildeP_n1 = tfrac12 ( p_n + p_n+1), i.e.,\n\nbeginaligned\nbeginarrayccc\ntfrac12  tfrac12 b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^2  tfrac12 ( 1 + R (infty) ) \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^4  tfrac12 ( 1 + R (infty) ) \nendarray\nendaligned\n\nThe coefficients a^2 and a^4 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i, and omega = 0 1.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKSymmetricProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKSymmetricProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 2 and rho = 1, such that tildeQ_n1 = q_n, tildeQ_n2 = q_n+1, tildeP_n1 = p_n, tildeP_n2 = p_n+1, i.e.,\n\nbeginaligned\nbeginarrayccc\n0  0 \n1  b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\n 0  0 \n tfrac12  tfrac12 \nhline\ntildea^2  tfrac12  tfrac12 \nendarray\n\nbeginarrayccc\n0  0 \n1  b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\n 0  0 \n tfrac12  tfrac12 \nhline\ntildea^4  tfrac12  tfrac12 \nendarray\nendaligned\n\nThe coefficients a^2 and a^4 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i. Further choose omega = 1 1 0 and delta = -1 R_infty, so that tildeLambda_n1 = R_infty tildeLambda_n2 and\n\ntildeP_n1 - vartheta (tildeQ_n1) + R_infty ( tildeP_n2 - vartheta (tildeQ_n2) ) = 0 \n\nDue to the particular choice of projective stages, this is equivalent to\n\np_n - vartheta (q_n) + R_infty ( p_n+1 - vartheta (q_n+1) ) = 0 \n\nso that the constraint phi(q_n+1 p_n+1) = 0 is satisfied if phi(q_n p_n) = 0. Note that the choice of tildea^2 and tildea^4 violates the symplecticity condition b^2_i b^4_j = b^2_i tildea^4_ij + b^4_j tildea^2_ji.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.lobatto_gauss_coefficients","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.lobatto_gauss_coefficients","text":"The projective Lobatto-GLRK coefficients are implicitly given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracbarc_i^kk  qquad i = 1      sigma   k = 1      s \n\nwhere c are Gauß-Legendre nodes with s stages and barc are Gauß-Lobatto nodes with sigma stages.\n\n\n\n\n\n","category":"function"},{"location":"problems/#Equation-and-Problem-Types","page":"Problems","title":"Equation and Problem Types","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"In GeometricIntegrators.jl we support three basic types of equations:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"ordinary differential equations (ODEs),\ndifferential algebraic equations (DAEs),\nstochastic differential equations (SDEs).","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"For each type, there are several subtypes:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"standard equations (ODEProblem, DAEProblem, SDEProblem),\nimplicit equations (IODEProblem, IDAEProblem),\npartitioned equations (PODEProblem, PDAEProblem, PSDEProblem),\nHamiltonian equations (HODEProblem, HDAEProblem),\nLagrangian equations (LODEProblem, LDAEProblem),\nsplit equations (SODEProblem, SPDAEProblem, SPSDEProblem).","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"Each equation holds a number of functions determining the vector field, constraints, and possibly additional information like parameters, periodicity, invariants and the Hamiltonian or Lagrangian.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"To each equation type there exists a corresponding problem type, which holds the equation, initial conditions, parameters, a time span to integrate over, as well as a time step (which is typically fixed in GeometricIntegrators). In addition, these problem types provide some convenience constructors to generate the equation and the problem at once.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"All of the equation and problem types are defined in the GeometricEquations.jl package. The GeometricProblems.jl package implements a number of example problems for testing and benchmarking.","category":"page"},{"location":"problems/#Keyword-Arguments","page":"Problems","title":"Keyword Arguments","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"All equation and problem types take the following keyword arguments:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"invariants = NullInvariants()\nparameters = NullParameters()\nperiodicity = NullPeriodicity()","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"If not set to their corresponding Null types, the user needs to pass a NamedTuple whose values are","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"functions for invariants,\narbitrary data structures for parameters, \nthe same data structure as the solution for periodicity.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The latter should be zero everywhere, except for those components, that are periodic, i.e., whose value are supposed to stay within a range (0, max). Support for ranges starting with other values than zero is currently missing but can be added if demand arises.","category":"page"},{"location":"problems/#Ordinary-Differential-Equations-(ODEs)","page":"Problems","title":"Ordinary Differential Equations (ODEs)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.ode_equations)","category":"page"},{"location":"problems/#Example:-Harmonic-Oscillator","page":"Problems","title":"Example: Harmonic Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example, let us consider the harmonic oscillator. The dynamical equations are given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"dotq (t) = beginpmatrix\n0  1 \n-k  0 \nendpmatrix q(t) \nqquad\nq in mathbbR^2 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an ODEProblem for the harmonic oscillator, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction v(v, t, x, params)\n    v[1] = x[2]\n    v[2] = - params.k * x[1]\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [0.5, 0.0]\n\nprob = ODEProblem(v, tspan, tstep, q₀; parameters = (k = 0.5,))","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The energy of the harmonic oscillator is preserved, so we can add it as an invariant, ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"energy(t, q, params) = q[2]^2 / 2 + params.k * q[1]^2 / 2\n\nprob = ODEProblem(v, tspan, tstep, q₀; parameters = (k = 0.5,), invariants = (h=energy,))","category":"page"},{"location":"problems/#Partitioned-Ordinary-Differential-Equations-(PODEs)","page":"Problems","title":"Partitioned Ordinary Differential Equations (PODEs)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.pode_equations)","category":"page"},{"location":"problems/#Example:-Harmonic-Oscillator-2","page":"Problems","title":"Example: Harmonic Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example, let us consider the harmonic oscillator. The dynamical equations are given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = p (t) \ndotp (t) = - k  q(t) \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create a PODEProblem for the harmonic oscillator, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction v(v, t, q, p, params)\n    v[1] = p[1]\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = - params.k * q[1]\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [0.5]\np₀ = [0.0]\n\nprob = PODEProblem(v, f, tspan, tstep, q₀, p₀; parameters = (k = 0.5,))","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The energy of the harmonic oscillator is preserved, so we can add it as an invariant, ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"energy(t, q, p, params) = p[1]^2 / 2 + params.k * q[1]^2 / 2\n\nprob = PODEProblem(v, f, tspan, tstep, q₀, p₀; parameters = (k = 0.5,), invariants = (h=energy,))","category":"page"},{"location":"problems/#Hamiltonian-Ordinary-Differential-Equations-(HODEs)","page":"Problems","title":"Hamiltonian Ordinary Differential Equations (HODEs)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.hode_equations)","category":"page"},{"location":"problems/#Example:-Harmonic-Oscillator-3","page":"Problems","title":"Example: Harmonic Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example, let us consider the harmonic oscillator. The dynamical equations are given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = p (t) \ndotp (t) = - k  q(t) \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"which can also be written as ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginpmatrix\ndotq (t) \ndotp (t) \nendpmatrix = beginpmatrix\n0  1 \n-1  0 \nendpmatrix\nnabla H( q(t)  p(t) ) \nqquad\nH(qp) = fracp^22 + k  fracq^22 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"where H is the Hamiltonian, i.e., the total energy of the system.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create a HODEProblem for the harmonic oscillator, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction v(v, t, q, p, params)\n    v[1] = p[1]\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = - params.k * q[1]\nend\n\nh(t, q, p, params) = p[1]^2 / 2 + params.k * q[1]^2 / 2\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [0.5]\np₀ = [0.0]\n\nprob = HODEProblem(v, f, h, tspan, tstep, q₀, p₀; parameters = (k = 0.5,))","category":"page"},{"location":"problems/#Implicit-Ordinary-Differential-Equations-(IODEs)","page":"Problems","title":"Implicit Ordinary Differential Equations (IODEs)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.iode_equations)","category":"page"},{"location":"problems/#Example:-Harmonic-Oscillator-4","page":"Problems","title":"Example: Harmonic Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example, let us consider the harmonic oscillator. In implicit form, its equations are given as follows,","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = v(t)  \np(t) = v(t)  \ndotp (t) = - k q(t) \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"Here, v acts as a Lagrange multiplier that enforces the \"constraint\" p(t) = v(t).","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an IODEProblem for the harmonic oscillator, we thus need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction p(p, t, q, v, params)\n    p[1] = v[1]\nend\n\nfunction f(f, t, q, v, params)\n    p[1] = - params.k * q[1]\nend\n\nfunction g(f, t, q, v, params)\n    p[1] = - params.k * q[1]\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [0.5]\np₀ = [0.0]\n\nprob = IODEProblem(p, f, tspan, tstep, q₀, p₀; parameters = (k = 0.5,))","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The energy of the harmonic oscillator is preserved, so we can add it as an invariant, ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"energy(t, q, v, params) = v[1]^2 / 2 + params.k * q[1]^2 / 2\n\nprob = IODEProblem(p, f, tspan, tstep, q₀, p₀; parameters = (k = 0.5,), invariants = (h=energy,))","category":"page"},{"location":"problems/#Lagrangian-Ordinary-Differential-Equations-(LODEs)","page":"Problems","title":"Lagrangian Ordinary Differential Equations (LODEs)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.lode_equations)","category":"page"},{"location":"problems/#Example:-Harmonic-Oscillator-5","page":"Problems","title":"Example: Harmonic Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example, let us consider the harmonic oscillator. Its Lagrangian is given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"L(q dotq) = fracdotq^22 - k  fracq^22 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"so that the Euler-Lagrange equations","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"fracddt fracpartial Lpartial dotq = fracpartial Lpartial q ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"become","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"ddotq (t) = - k q(t) ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"Most integrators for Lagrangian systems do not solve this second order system (semi-spray form), but instead use a reformulation as an implicit ordinary differential equation. This formulation can most easily be obtained from a Hamilton-Pontryagin principle","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"delta int limits_t_0^t_1 big L(q v) + left p  dotq - v right big = 0 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"as follows,","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = v(t)  \np(t) = fracpartial Lpartial v (q(t)v(t)) = v(t)  \ndotp (t) = fracpartial Lpartial q (q(t)v(t)) = - k q(t) \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"Here, v acts as a Lagrange multiplier that enforces the \"constraint\" p(t) = partial L  partial v.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an LODEProblem for the harmonic oscillator, we thus need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction p(p, t, q, v, params)\n    p[1] = v[1]\nend\n\nfunction f(f, t, q, v, params)\n    p[1] = - params.k * q[1]\nend\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] =  0\n    ω[1,2] = -1\n    ω[2,1] = +1\n    ω[2,2] =  0\nend\n\nfunction l(t, q, v, params)\n    v[1]^2 / 2 - params.k * q[1]^2 / 2\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [0.5]\np₀ = [0.0]\n\nprob = LODEProblem(p, f, ω, l, tspan, tstep, q₀, p₀; parameters = (k = 0.5,))","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The energy of the harmonic oscillator is preserved, so we can add it as an invariant, ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"energy(t, q, v, params) = v[1]^2 / 2 + params.k * q[1]^2 / 2\n\nprob = LODEProblem(p, f, ω, l, tspan, tstep, q₀, p₀; parameters = (k = 0.5,), invariants = (h=energy,))","category":"page"},{"location":"problems/#Differential-Algebraic-Equation-(DAE)","page":"Problems","title":"Differential Algebraic Equation (DAE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.dae_equations)","category":"page"},{"location":"problems/#Example:-Harmonic-Oscillator-6","page":"Problems","title":"Example: Harmonic Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example we consider the harmonic oscillator, with an additional constraint that enforces energy conservation. While the system itself is energy conserving, most integrators do not respect this property. A possible way of remedying this flaw is to explicitly add energy conservation as an algebraic constraint. ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The dynamical equations are given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"dotq (t) = beginpmatrix\n0  1 \n-k  0 \nendpmatrix q(t) \n+ nabla phi (q(t)) lambda \nqquad\nphi (q) = fracq_2^22 + k  fracq_1^22\nqquad\nq in mathbbR^2 \nqquad\nlambda in mathbbR^1 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an DAEProblem for the harmonic oscillator including the projection on the constant energy manifold, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nhamiltonian(t, q, params) = q[2]^2 / 2 + params.k * q[1]^2 / 2\n\nfunction v(v, t, q, params)\n    v[1] = q[2]\n    v[2] = - params.k * q[1]\nend\n\nfunction u(u, t, q, λ, params)\n    u[1] = λ[1] * params.k * q[1]\n    u[2] = λ[1] * q[2]\nend\n\nfunction ϕ(ϕ, t, q, params)\n    ϕ[1] = hamiltonian(t, q, params)\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\nλ₀ = [0.]\nparams = (k=0.5,)\n\nprob = DAEProblem(v, u, ϕ, tspan, tstep, q₀, λ₀; parameters = params)","category":"page"},{"location":"problems/#Partitioned-Differential-Algebraic-Equation-(PDAE)","page":"Problems","title":"Partitioned Differential Algebraic Equation (PDAE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.pdae_equations)","category":"page"},{"location":"problems/#Example:-Pendulum","page":"Problems","title":"Example: Pendulum","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example we consider the pendulum in cartesian coordinates, with a constraint that enforces the solution to respect the length of the pendulum.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The dynamical equations are given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = p (t)  \nq in mathbbR^2\n\ndotp (t) = \nbeginpmatrix\n  - lambda q_1 (t) \n1 - lambda q_2 (t) \nendpmatrix  \np in mathbbR^2 \n\nphi (q) = q^2 - l^2  \nlambda in mathbbR^1 \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an PDAEProblem for the pendulum including the projection on the constant length constraint, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\n\nfunction v(v, t, q, p, params)\n    v .= p\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = 0\n    f[2] = 1\nend\n\nfunction u(u, t, q, p, λ, params)\n    u .= 0\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = - λ[1] * q[1]\n    g[2] = - λ[1] * q[2]\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = q[1]^2 + q[2]^2 - params.l^2\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nparams = (l=0.5,)\n\nq₀ = [params.l, 0.0]\np₀ = [0.0, 0.1]\nλ₀ = [0.0]\n\nprob = PDAEProblem(v, f, u, g, ϕ, tspan, tstep, q₀, p₀, λ₀; parameters = params)","category":"page"},{"location":"problems/#Hamiltonian-Differential-Algebraic-Equation-(HDAE)","page":"Problems","title":"Hamiltonian Differential Algebraic Equation (HDAE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.hdae_equations)","category":"page"},{"location":"problems/#Example:-Pendulum-2","page":"Problems","title":"Example: Pendulum","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example we consider the pendulum in cartesian coordinates, with a constraint that enforces the solution to respect the length of the pendulum.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The Hamiltonian is given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"H(qp) = frac12 p^2 + l - q_2 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"and dynamical equations read","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = p (t)  \nq in mathbbR^2\n\ndotp (t) = \nbeginpmatrix\n  - lambda q_1 (t) \n1 - lambda q_2 (t) \nendpmatrix  \np in mathbbR^2 \n\nphi (q) = q^2 - l^2  \nlambda in mathbbR^1 \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an HDAEProblem for the pendulum including the projection on the constant length constraint, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\n\nfunction v(v, t, q, p, params)\n    v .= p\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = 0\n    f[2] = 1\nend\n\nfunction u(u, t, q, p, λ, params)\n    u .= 0\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = - λ[1] * q[1]\n    g[2] = - λ[1] * q[2]\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = q[1]^2 + q[2]^2 - params.l^2\nend\n\nfunction h(t, q, p, params)\n    return (p[1]^2 + p[2]^2)/2 + params.l - q[2]\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nparams = (l=0.5,)\n\nq₀ = [params.l, 0.0]\np₀ = [0.0, 0.1]\nλ₀ = [0.0]\n\nprob = HDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, q₀, p₀, λ₀; parameters = params)","category":"page"},{"location":"problems/#Implicit-Differential-Algebraic-Equation-(IDAE)","page":"Problems","title":"Implicit Differential Algebraic Equation (IDAE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.idae_equations)","category":"page"},{"location":"problems/#Example:-Pendulum-3","page":"Problems","title":"Example: Pendulum","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example we consider the pendulum in cartesian coordinates, with a constraint that enforces the solution to respect the length of the pendulum.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The implicit equations are given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = v(t)  \nq in mathbbR^2\n\ndotp (t) = \nbeginpmatrix\n0 \n1 \nendpmatrix\n- lambda(t) q(t)  \nv in mathbbR^2 \n\np(t) = v(t)  \np in mathbbR^2 \n\nphi (q) = q^2 - l^2  \nlambda in mathbbR^1 \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an IDAEProblem for the pendulum including the projection on the constant length constraint, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\n\nfunction p(p, t, q, v, params)\n    p .= v\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = 0\n    f[2] = 1\nend\n\nfunction u(u, t, q, v, p, λ, params)\n    u .= 0\nend\n\nfunction g(g, t, q, v, p, λ, params)\n    g[1] = - λ[1] * q[1]\n    g[2] = - λ[1] * q[2]\nend\n\nfunction ϕ(ϕ, t, q, v, p, params)\n    ϕ[1] = q[1]^2 + q[2]^2 - params.l^2\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nparams = (l=0.5,)\n\nq₀ = [params.l, 0.0]\np₀ = [0.0, 0.1]\nλ₀ = [0.0]\n\nprob = IDAEProblem(p, f, u, g, ϕ, tspan, tstep, q₀, p₀, λ₀; parameters = params)","category":"page"},{"location":"problems/#Lagrangian-Differential-Algebraic-Equation-(LDAE)","page":"Problems","title":"Lagrangian Differential Algebraic Equation (LDAE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.ldae_equations)","category":"page"},{"location":"problems/#Example:-Pendulum-4","page":"Problems","title":"Example: Pendulum","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example we consider the pendulum in cartesian coordinates, with a constraint that enforces the solution to respect the length of the pendulum.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The Hamilton-Pontryagin principle for this system is given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"delta int limits_t_0^t_1 big L(q v) + left p  dotq - v right + lambda  phi (q) big = 0 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"with Lagrangian","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"L(qv) = frac12 v^2 - (l - q_2) ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"and constraint","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"phi(q) = q^2 - l^2 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The resulting implicit equations read","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = v(t)  \nq in mathbbR^2\n\ndotp (t) = \nbeginpmatrix\n0 \n1 \nendpmatrix\n- lambda(t) q(t)  \nv in mathbbR^2 \n\np(t) = v(t)  \np in mathbbR^2 \n\nphi (q) = q^2 - l^2  \nlambda in mathbbR^1 \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an LDAEProblem for the pendulum including the projection on the constant length constraint, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\n\nfunction p(p, t, q, v, params)\n    p .= v\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = 0\n    f[2] = 1\nend\n\nfunction u(u, t, q, v, p, λ, params)\n    u .= 0\nend\n\nfunction g(g, t, q, v, p, λ, params)\n    g[1] = - λ[1] * q[1]\n    g[2] = - λ[1] * q[2]\nend\n\nfunction ϕ(ϕ, t, q, v, p, params)\n    ϕ[1] = q[1]^2 + q[2]^2 - params.l^2\nend\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] =  0\n    ω[1,2] = -1\n    ω[2,1] = +1\n    ω[2,2] =  0\nend\n\nfunction l(t, q, v, params)\n    return (v[1]^2 + v[2]^2)/2 - (params.l - q[2])\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nparams = (l=0.5,)\n\nq₀ = [params.l, 0.0]\np₀ = [0.0, 0.1]\nλ₀ = [0.0]\n\nprob = LDAEProblem(p, f, u, g, ϕ, ω, l, tspan, tstep, q₀, p₀, λ₀; parameters = params)","category":"page"},{"location":"problems/#Stochastic-Differential-Equations-(SDEs)","page":"Problems","title":"Stochastic Differential Equations (SDEs)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.sde_equations)","category":"page"},{"location":"problems/#Example:-Kubo-Oscillator","page":"Problems","title":"Example: Kubo Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction v(t, q, v, params)\n    v[1] = + params.λ * q[2]\n    v[2] = - params.λ * q[1]\nend\n\nfunction B(t, q, B, params)\n    for j in axes(B, 2)\n        B[1,j] = + params.ν * q[2]\n        B[2,j] = - params.ν * q[1]\n    end\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.01\nq₀ = [0.5, 0.0]\n\nprob = SDEProblem(v, B, tspan, tstep, q₀; parameters = (λ=2.0, μ=1.0))","category":"page"},{"location":"problems/#Partitioned-Stochastic-Differential-Equation-(PSDE)","page":"Problems","title":"Partitioned Stochastic Differential Equation (PSDE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.psde_equations)","category":"page"},{"location":"problems/#Example:-Kubo-Oscillator-2","page":"Problems","title":"Example: Kubo Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction v(v, t, q, p, params)\n    v[1] = + params.λ * p[1]\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = - params.λ * q[1]\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = params.ν * p[1]\nend\n\nfunction G(G, t, q, p, params)\n    G[1,1] = - params.ν * q[1]\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.01\nq₀ = [0.5]\np₀ = [0.0]\n\nprob = PSDEProblem(v, f, B, G, tspan, tstep, q₀, p₀; parameters = (λ=2.0, μ=1.0))","category":"page"},{"location":"problems/#Split-Partitioned-Stochastic-Differential-Equation-(SPSDE)","page":"Problems","title":"Split Partitioned Stochastic Differential Equation (SPSDE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.spsde_equations)","category":"page"},{"location":"problems/#Example:-Kubo-Oscillator-3","page":"Problems","title":"Example: Kubo Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction v(v, t, q, p, params)\n    v[1] = + params.λ * p[1]\nend\n\nfunction f1(f, t, q, p, params)\n    f[1] = - params.λ * q[1]\nend\n\nfunction f2(f, t, q, p, params)\n    f[1] = 0\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = params.ν * p[1]\nend\n\nfunction G1(G, t, q, p, params)\n    G[1,1] = - params.ν * q[1]\nend\n\nfunction G2(G, t, q, p, params)\n    G[1,1] = 0\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.01\nq₀ = [0.5]\np₀ = [0.0]\n\nprob = SPSDEProblem(v, f1, f2, B, G1, G2, tspan, tstep, q₀, p₀; parameters = (λ=2.0, μ=1.0))","category":"page"},{"location":"LICENSE/#MIT-License","page":"License","title":"MIT License","text":"","category":"section"},{"location":"LICENSE/","page":"License","title":"License","text":"Copyright (c) The GeometricIntegrators AuthorsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"integrators/splitting/#Splitting-and-Composition-Methods","page":"Splitting","title":"Splitting and Composition Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"GeometricIntegrators supports splitting and composition methods, where the solution to an ODE of the form","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"dotx = v_1 (tx) +  + v_r (tx)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"is obtained by consecutively integrating each vector field v_i independently and combining the resulting solutions in an appropriate way. Consider a simple ODE dotx = V where the vector field v can be written as V = sum_i v_i. The flow (exact solution) of this ODE is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"x(t) = phi_t (x(0)) = exp(t V) (x(0)) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and the composition method ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = exp(tau v_1) exp(tau v_2) dotsc exp(tau v_r) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where tau denotes the time step, provides a first-order accurate approximation to the exact flow as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"phi_tau = exp bigg( tau sum_i v_i bigg) + mathcalO (tau^2) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the following, we use \"splitting methods\" to denote integrators that utilize the exact solution of each vector field v_i and \"composition methods\" to denote integrators that utilize some consistent but possibly approximate solution for each of the vector fields v_i, i.e., that solution can be exact or obtained by some other integrator. For reference see the excellent review paper by [4] or the canonical book on Geometric Numerical Integration by [5].","category":"page"},{"location":"integrators/splitting/#Splitting-Integrators","page":"Splitting","title":"Splitting Integrators","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In GeometricIntegrators, basic splitting methods are implemented in Splitting, which has two constructors:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Splitting(f::Vector{Int}, c::Vector)\nSplitting(method::AbstractSplittingMethod, problem::SODEProblem)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The vectors f and c define the actual splitting method: f is a vector of indices of the flows in the split equation (that is the exact solution which can be obtained by solutions(problem)) to be solved and c is a vector of the same size as f that contains the coefficients for each splitting step, i.e., the resulting integrator has the form","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_cs tau^v_fs circ dotsc circ phi_c2 tau^v_f2 circ phi_c1 tau^v_f1 ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the second constructor, these vectors are constructed from the splitting method and the problem.","category":"page"},{"location":"integrators/splitting/#Composition-Integrators","page":"Splitting","title":"Composition Integrators","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Fully flexible composition methods are implemented in Composition, which can use any ODE integrator implemented in GeometricIntegrators to solve the steps of the splitting. For each step, a different integrator can be chosen as well as the exact solution using ExactSolution, which is a simple wrapper around the exact flow of a splitting step, implementing the general integrator interface.","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Composition has one main constructor:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Composition(methods, splitting)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The first argument is tuple of methods that are used to solve each substep, and the second argument is a splitting method. A second convenience constructor uses the ExactSolution for all steps:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Composition(splitting) = Composition(ExactSolution(), splitting)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"This constructs a composition method that is equivalent to a plain Splitting.","category":"page"},{"location":"integrators/splitting/#Splitting-of-Hamiltonian-Systems","page":"Splitting","title":"Splitting of Hamiltonian Systems","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"For Hamiltonian systems, splitting is a simple and versatile technique for the construction of symplectic integrators. Suppose that the Hamiltonian H can be split into the sum of r geq 2 Hamiltonians H_i with 1 leq i leq r, i.e.,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"H (z) = sum limits_i=1^r H_i (z) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"with each Hamiltonian vector field","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"dotz = Omega^-T  nabla H_i (z) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"explicitly solvable. The exact solution phi_t^H_i of each subsystem provides a symplectic map. As the composition of symplectic maps yields a symplectic map, a symplectic integrator can be obtained by an appropriate composition of the flow maps of each subsystem. A first-order symplectic integrator is obtained from the Lie-Trotter splitting,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_tau^H_1 circ phi_tau^H_2 circ dotsc circ phi_tau^H_k ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Second-order symplectic integrators are obtained from symmetric splittings,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_h2^H_1 circ phi_h2^H_2 circ dotsc circ phi_h2^H_k-1 circ phi_tau^H_k circ phi_h2^H_k-1 circ dotsc circ phi_h2^H_2 circ phi_h2^H_1 ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"or","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_h2^H_k circ phi_h2^H_k-1 circ dotsc circ phi_h2^H_2 circ phi_tau^H_1 circ phi_h2^H_2 circ dotsc circ phi_h2^H_k-1 circ phi_h2^H_k ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Higher order integrators can be constructed by using the Baker-Campbell-Hausdorff formula.","category":"page"},{"location":"integrators/splitting/#Separable-Hamiltonian-Systems","page":"Splitting","title":"Separable Hamiltonian Systems","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"If we have a Hamiltonian of the form H(pq) = T(p) + U(q), we can consider only the subsystem with Hamiltonian U(q),","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ndotq = 0  \ndotp = - nabla U(q) \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"This system can be solved exactly. The exact flow is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"phi^U_t (qp) = beginpmatrix\nq \np - t nabla U(q)\nendpmatrix ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Next, consider the subsystem with Hamiltonian T(p) = tfrac12 p^T M^-1 p, ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ndotq = M^-1 p  \ndotp = 0  \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"This system can be solved exactly as well. The exact flow is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"phi^T_t (qp) = beginpmatrix\nq + t M^-1 p \np\nendpmatrix ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"As phi^U_t and phi^T_t are exact flows of the respective Hamiltonian, they are both symplectic. We see that the compositions of phi^U_t and phi^T_t correspond to the symplectic Euler methods for separable Hamiltonians,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi^A_tau = phi^U_tau circ phi^T_tau  \nvarphi^B_tau = phi^T_tau circ phi^U_tau \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where varphi^A_tau and varphi^B_tau denote the numerical flows of symplectic Euler-A and symplectic Euler-B, respectively. As the Störmer-Verlet methods are compositions of the symplectic Euler methods, they are also splitting methods, corresponding to the compositions","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau^SV1 = varphi^A_h2 circ varphi^B_h2 = phi^U_h2 circ phi^T_tau circ phi^U_h2  \nvarphi_tau^SV2 = varphi^B_h2 circ varphi^A_h2 = phi^T_h2 circ phi^U_tau circ phi^T_h2 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"respectively. This particular splitting is often referred to as Strang splitting [[6], see also [7]].","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Let us note that not all symplectic integrators can be obtained as splitting methods. For the symplectic Euler methods and the Störmer-Verlet methods, this is only possible for separable Hamiltonian systems. For general Hamiltonians, these methods cannot be obtained from any splitting but are nevertheless symplectic.","category":"page"},{"location":"integrators/splitting/#Fourth-Order-Methods","page":"Splitting","title":"Fourth Order Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The general form of a fourth order symplectic integrator for separable Hamiltonian systems is given by","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nq_1 = q_0 + b_1 tau  T_p (p_0)  \np_1 = p_0 - hatb_1 tau  U_q (q_1)  \nq_2 = q_1 + b_2 tau  T_p (p_1)  \np_2 = p_1 - hatb_2 tau  U_q (q_2)  \nq_3 = q_2 + b_3 tau  T_p (p_2)  \np_3 = p_2 - hatb_3 tau  U_q (q_3)  \nq_4 = q_3 + b_4 tau  T_p (p_3)  \np_4 = p_3 - hatb_4 tau  U_q (q_4) \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The quantities (q_0 p_0) are initial values and (q_4 p_4) are the numerical solution after one time step tau. The whole algorithm can be written as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau = \nvarphi_hatb_4 tau^U\ncirc\nvarphi_b_4 tau^T\ncirc\nvarphi_hatb_3 tau^U\ncirc\nvarphi_b_3 tau^T\ncirc\nvarphi_hatb_2 tau^U\ncirc\nvarphi_b_2 tau^T\ncirc\nvarphi_hatb_1 tau^U\ncirc\nvarphi_b_1 tau^T\nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and is therefore immediately seen to be symplectic. Two methods of fourth order are given by","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nb_1 = b_4 = dfrac12 (2 - gamma)  \nb_2 = b_3 = dfrac1-gamma2 (2 - gamma)  \nhatb_1 = hatb_3 = dfrac12 - gamma  \nhatb_2 = - dfracgamma2 - gamma  \nhatb_4 = 0 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nb_1 = 0  \nb_2 = b_4 = dfrac12 - gamma  \nb_3 = dfrac11 - gamma^2  \nhatb_1 = hatb_4 = tfrac16 (2 + gamma + gamma^-1)  \nhatb_2 = hatb_3 = tfrac16 (2 - gamma - gamma^-1) \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where gamma = 2^13. Both methods are explicit and symmetric as either varphi_hatb_4 tau^U or varphi_b_1 tau^T corresponds to the identity.","category":"page"},{"location":"integrators/splitting/#Higher-Order-Methods-by-Composition","page":"Splitting","title":"Higher Order Methods by Composition","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The composition of a one-step symplectic integrator varphi_tau with different step sizes provides a simple way of obtaining higher order schemes. We assume that the initial scheme varphi_tau is symmetric, that is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau circ varphi_-tau = mathrmid ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"as this simplifies the construction. A symmetric method can always be built by combining a non-symmetric method with its adjoint. If a numerical method varphi_tau is symmetric, it can be used to compose higher order methods by splitting up each timestep into s substeps [[5], [8], [9]],","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = varphi_gamma_s tau circ  circ varphi_gamma_i tau circ  circ varphi_gamma_1 tau ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where the careful selection of the gamma_i is crucial for the performance of the resulting scheme. In the following, we present some fourth and sixth order composition methods that can be applied in most situations.","category":"page"},{"location":"integrators/splitting/#Fourth-Order-Composition-Methods","page":"Splitting","title":"Fourth Order Composition Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"If varphi_tau is a method of order r, a method hatvarphi_tau of order r+2 is obtained by the composition [[5], Section V.3.2]","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nhatvarphi_tau = varphi_gamma tau circ varphi_(1-2gamma) tau circ varphi_gamma tau \n textwith \ngamma = (2 - 2^1(r+1))^-1  \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Hence, if varphi_tau is of second order, the resulting method hatvarphi_tau will be of fourth order. Note that symmetric methods are always of even order. A method of the same order but with generally smaller errors is obtained by considering five steps","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nhatvarphi_tau = varphi_gamma tau circ varphi_gamma tau circ varphi_(1-4gamma) tau circ varphi_gamma tau circ varphi_gamma tau \n textwith \ngamma = (4 - 4^1(r+1))^-1  \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Multiple application of these compositions yields methods of orders higher than four.","category":"page"},{"location":"integrators/splitting/#Sixth-Order-Composition-Methods","page":"Splitting","title":"Sixth Order Composition Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Higher order compositions can also be constructed directly [[5], Section V.3.2]. A sixth order method with seven substeps is given by","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ngamma_1 = gamma_7 = + 078451361047755726381949763  \ngamma_2 = gamma_6 = + 023557321335935813368479318  \ngamma_3 = gamma_5 = - 117767998417887100694641568  \ngamma_4 = + 131518632068391121888424973 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"but again smaller errors can be achieved by using nine steps","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ngamma_1 = gamma_9 = + 039216144400731413927925056  \ngamma_2 = gamma_8 = + 033259913678935943859974864  \ngamma_3 = gamma_7 = - 070624617255763935980996482  \ngamma_4 = gamma_6 = + 008221359629355080023149045  \ngamma_5 = + 079854399093482996339895035 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The computational effort of these high order methods is quite large. Each step requires the solution of a nonlinear system of equations. Given the outstanding performance already second order symplectic integrators are able to deliver, the necessity for such high order methods is rarely found. Nevertheless, if extremely high accuracy is indispensable, think for example of long-time simulations of the solar system, these methods can be applied. Moreover, there exist special methods optimized for such problems.","category":"page"},{"location":"integrators/splitting/#Splitting-Coefficients","page":"Splitting","title":"Splitting Coefficients","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Actually splitting methods are usually prescribed in one of the following forms.","category":"page"},{"location":"integrators/splitting/#[SplittingCoefficientsGeneral](@ref)","page":"Splitting","title":"SplittingCoefficientsGeneral","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for general splitting methods for vector fields with two terms v = v_A + v_B, leading to the following integrator:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A ","category":"page"},{"location":"integrators/splitting/#[SplittingCoefficientsNonSymmetric](@ref)","page":"Splitting","title":"SplittingCoefficientsNonSymmetric","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for non-symmetric splitting methods [[4], Equation (4.10)]. Here, two flows varphi_tau^A and varphi_tau^B are constructed as the Lie composition of all vector fields in the SODE and its adjoint, respectively, i.e..","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r  \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and the integrator is composed as follows:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^NS = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A ","category":"page"},{"location":"integrators/splitting/#[SplittingCoefficientsGS](@ref)","page":"Splitting","title":"SplittingCoefficientsGS","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for symmetric splitting methods with general stages [[4], Equation (4.11)], where again two flows varphi_tau^A and varphi_tau^B are constructed via Lie composition","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r  \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"but with an integrator composed as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^GS = varphi_a_1 tau^A circ varphi_b_1 tau^B circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A ","category":"page"},{"location":"integrators/splitting/#[SplittingCoefficientsSS](@ref)","page":"Splitting","title":"SplittingCoefficientsSS","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for symmetric splitting methods with symmetric stages [[4], Equation (4.6)]. Here, only one flow varphi_tau^S is constructed via symmetric Strang composition,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^S = varphi_tau2^v_1 circ varphi_tau2^v_2 circ dotsc circ varphi_tau2^v_r-1 circ varphi_tau2^v_r circ varphi_tau2^v_r circ varphi_tau2^v_r-1 circ dotsc circ varphi_tau2^v_2 circ varphi_tau2^v_1 ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and composed as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^SS = varphi_a_1 tau^S circ varphi_a_2 tau^S circ dotsc circ varphi_a_s tau^S circ dotsc circ varphi_a_2 tau^S circ varphi_a_1 tau^S ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"to obtain an integrator.","category":"page"},{"location":"integrators/splitting/#Implemented-Splitting-Methods","page":"Splitting","title":"Implemented Splitting Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Function Order Method\nLieA 1 Lie-Trotter Splitting A\nLieB 1 Lie-Trotter Splitting B\nStrang 2 Strang / Marchuk Splitting\nMarchuk 2 Strang / Marchuk Splitting\nStrangA 2 Strang / Marchuk Splitting A\nStrangB 2 Strang / Marchuk Splitting B\nMcLachlan2 2 McLachlan's 2nd order symmetric, minimum error composition method\nMcLachlan4 2 McLachlan's 4th order symmetric, minimum error composition method\nTripleJump 4 4th order \"Triple Jump\" composition method\nSuzukiFractal 4 Suzuki's 4th order \"fractal\" composition method","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = GeometricIntegrators","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we try to give an overview of the basic usage of GeometricIntegrators and its main components.","category":"page"},{"location":"tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"GeometricIntegrators.jl can be installed using Julia's built-in package manager in the command line interface by","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ]\n(v1.9) pkg> add GeometricIntegrators","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In a Jupyter notebook, GeometricIntegrators.jl can be installed by explicitly using the Pkg module as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg\nPkg.add(\"GeometricIntegrators\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This will install the library itself as well as all dependencies.","category":"page"},{"location":"tutorial/#Basic-usage","page":"Tutorial","title":"Basic usage","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the simplest cases, the use of GeometricIntegrators.jl requires the construction of two objects, an equation and an integrator. For many standard methods, the integrator is implicitly selected by specifying an equation and a tableau.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Before any use, we need to load GeometricIntegrators,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeometricIntegrators","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then we can create an ODE problem for the equation dotx (t) = x(t) with integration time span (0 1). a time step of Delta t = 01, and initial condition x(0) = 1, ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"prob = ODEProblem((ẋ, t, x, params) -> ẋ[1] = x[1], (0.0, 1.0), 0.1, [1.0])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"create an integrator for this ODE, using the explicit Euler method","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = GeometricIntegrator(prob, ExplicitEuler())","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and compute the solution,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = integrate(int)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Plot and compare with the exact solution","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplot(xlims=[0,1], xlab=\"t\", ylab=\"x(t)\", legend=:bottomright)\nplot!(sol.t, sol.q[:,1], label=\"numeric\")\nplot!(sol.t, exp.(sol.t), label=\"exact\")\nsavefig(\"images/tutorial-ode-1.png\") # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/#Equations","page":"Tutorial","title":"Equations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In GeometricIntegrators.jl we distinguish between three basic types of equations:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ordinary differential equations (ODEs),\ndifferential algebraic equations (DAEs),\nstochastic differential equations (SDEs).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For each type, there are several subtypes","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"standard equations (ODEProblem, DAEProblem, SDEProblem),\nimplicit equations (IODEProblem, IDAEProblem),\npartitioned equations (PODEProblem, PDAEProblem, PSDEProblem),\nHamiltonian equations (HODEProblem, HDAEProblem),\nLagrangian equations (LODEProblem, LDAEProblem),\nsplit equations (SODEProblem, SPDAEProblem, SPSDEProblem).","category":"page"},{"location":"tutorial/#Ordinary-differential-equations","page":"Tutorial","title":"Ordinary differential equations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Consider an ODE of the form","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dotx (t) = v(t x(t)) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where dotx denotes the derivative of x and f the vector field of the equation, which is assumed to depend on both t and x. In the following, we will solve the mathematical pendulum, whose equations are given by","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginpmatrix\ndotx_1 \ndotx_2 \nendpmatrix\n=\nbeginpmatrix\nx_2 \nsin (x_1) \nendpmatrix ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Together with the integration time span (t₀,t₁) and the time step, an ODE defines an ODEProblem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The user needs to specify a function ẋ that computes the vector field and must have the interface","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function ẋ(v, t, x, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params is a NamedTuple of constant parameters on which the vector field may depend.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the mathematical pendulum, this could look as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function ẋ(v, t, x, params)\n    v[1] = x[2]\n    v[2] = sin(x[1])\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"An ODEProblem is instantiated by","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ODEProblem(<vector field>, <time span>, <time step>, <initial conditions>; kwargs...)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"so to create and ODEProblem, one only needs to pass the above function ẋ, a tuple tspan containing the start and end times of the integration, the time step tstep as well as an initial condition:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tspan = (0.0, 10.0)\ntstep = 0.1\nx₀ = [acos(0.4), 0.0]\n\node = ODEProblem(ẋ, tspan, tstep, x₀)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The full constructor would look like","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ode = ODEProblem(ẋ, tspan, tstep, x₀; invariants = NullInvariants(),\n                 parameters = NullParameters(), periodicity = NullPeriodicity())","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where all keyword arguments, namely invariants, parameters and periodicity, are by default initialized to be absent.","category":"page"},{"location":"tutorial/#Partitioned-ordinary-differential-equations","page":"Tutorial","title":"Partitioned ordinary differential equations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The pendulum problem is a Hamiltonian system that can also be expressed as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dotq = fracpartial Hpartial p = p \nhspace3em\ndotp = - fracpartial Hpartial q = sin (q) \nhspace3em\nH (qp) = frac12 p^2 + cos (q) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This structure, namely the partitioning into two sets of variables (qp) instead of x, can be exploited for more efficient integration. Such equations can be defined in terms of a partitioned ODE, where the vector fields are specified separately,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function q̇(v, t, q, p, params)\n    v[1] = p[1]\nend\n\nfunction ṗ(f, t, q, p, params)\n    f[1] = sin(q[1])\nend\n\npode = PODEProblem(q̇, ṗ, (0.0, 25.0), 0.1, [acos(0.4)], [0.0])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first two arguments to the PODE constructor are the functions that determine the vector fields of the equations dotq (t) = v(t q(t) p(t)) and dotp (t) = f(t q(t) p(t)). The third and fourth argument determines the initial conditions of q and p, respectively. The functions defining the vector field have to take four arguments, the current time t, the current solution vectors q and p and the output vector v or f.","category":"page"},{"location":"tutorial/#Integrators","page":"Tutorial","title":"Integrators","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We support a number of standard integrators (geometric and non-geometric) like explicit, implicit and partitioned Runge-Kutta methods, splitting methods and general linear methods (planned).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to instantiate many of the standard integrators, one needs to specify an ODEProblem, a method and a timestep, e.g.,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = GeometricIntegrator(ode, ExplicitEuler())","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to run the integrator, the integrate() functions is called, passing an integrator object and the number of time steps to integrate:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = integrate(int)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The integrate function automatically creates an appropriate solution object, that contains the result of the integration.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sol.q[:,1], sol.q[:,2], xlab=\"x(t)\", ylab=\"y(t)\", legend=:none)\nsavefig(\"images/tutorial-ode-2.png\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Observe that the explicit Euler method is not well suited for integrating this system. The solutions drifts away although it should follow closed orbits.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For a Hamiltonian system, defined as a PODE, a different methods might be more appropriate, for example a symplectic Euler method,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = integrate(pode, LobattoIIIAIIIB(2))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This creates a different integrator, which exploits the partitioned structure of the system. The solution return by the integrate step will also be a different solution, adapted to the partitioned system.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sol.q[:,1], sol.p[:,1], xlab=\"q(t)\", ylab=\"p(t)\", legend=:none)\nsavefig(\"images/tutorial-pode-1.png\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Moreover, this method respects the Hamiltonian structure of the system, resulting in closed orbits following the contours of the system's energy.","category":"page"},{"location":"tutorial/#Overview-of-Available-Methods","page":"Tutorial","title":"Overview of Available Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"GeometricIntegrators.jl provides a plethora of geometric integrators as well as non-geometric integrators (mainly for testing and benchmarking purposes). Most integrators can be selected by a simple method type, which also stores parameters. Some integrator families can also be selected by specifying a tableau, that is a Butcher tableau for Runge-Kutta methods, a pair of tableaus for partitioned Runge-Kutta and VPRK methods, or generalizations thereof for SPARK methods. Other integrators, such as Galerkin variational integrators require the specification of a basis and a quadrature rule.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The correct integrator is automatically selected based on the method and problem types by calling","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"GeometricIntegrator(problem, method)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As an example, consider an ODE like the harmonic oscillator, which is included in GeometricEquations.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"prob = HarmonicOscillator.odeproblem()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create an explicit Euler method:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = ExplicitEuler()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And now create an Integrator with the general Integrator constructor:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = GeometricIntegrator(prob, method)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We see that we obtained an IntegratorERK, i.e., an explicit Runge-Kutta integrator. If instead we choose the implicit Euler method:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = ImplicitEuler()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"the general Integrator constructor creates a different integrator:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = GeometricIntegrator(prob, method)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"namely an IntegratorFIRK, i.e., a fully implicit Runge-Kutta integrator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"GeometricIntegrators automatically detects if a Runge-Kutta tableau is explicit, diagonally implicit or fully implicity and creates the corresponding Integrator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Certain Runge-Kutta method such as Gauß, Radau and Lobatto methods are available for an arbitrary number of stages. Here the number of stages has to be speficied","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = GeometricIntegrator(prob, Gauss(1))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Special integrators, such as Vartiational Partitioned Runge-Kutta (VPRK) methods, can be initialised by providing one or two tableaus, that is","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = VPRK(Gauss(1))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"or","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = VPRK(LobattoIIIA(2), LobattoIIIB(2))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For standard tableaus there also exist shortcuts, such as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = VPRKGauss(1)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"or","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = VPRKLobattoIIIAIIIB(2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the purpose of a complete example, consider again the harmonic oscillator:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"prob = HarmonicOscillator.iodeproblem()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create a VPRK tableau that uses Gauss-Legendre Runge-Kutta coefficients with two stages:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = VPRKGauss(2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If we call the Integrator constructor,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(prob, method)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"we obtain a IntegratorVPRK.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once an integrator is obtained, we can just call the function","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"integrate(integrator)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"to perform the actual integration steps, where ntime defines the number of steps to integrate:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator\nprob = HarmonicOscillator.odeproblem()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = GeometricIntegrator(prob, ExplicitEuler())\nsol = integrate(int)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The integrate function returns a solution object that stores the solution for each time step. If the solution object is created manually, there exists a function","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"integrate!(integrator, solution)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"that operates on an existing solution.","category":"page"},{"location":"tutorial/#Integrators-for-ODEs","page":"Tutorial","title":"Integrators for ODEs","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The main method types for ODEs currently implemented are Runge-Kutta methods and splitting methods.","category":"page"},{"location":"tutorial/#Runge-Kutta-Methods","page":"Tutorial","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Any Runge-Kutta method can be selected by the RK method","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rk = RK(tableau)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where tableau is any tableau from RungeKutta.Tableaus. For most tableaus there also exist explicit shortcuts to select the method. These are listed in the following.","category":"page"},{"location":"tutorial/#Explicit-Runge-Kutta-Methods","page":"Tutorial","title":"Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nExplicitEuler 1 Explicit / Forward Euler\nExplicitMidpoint 2 Explicit Midpoint\nHeun2 2 Heun's Method of order two\nHeun3 3 Heun's Method of order three\nRalston2 2 Ralston's Method of order two\nRalston3 3 Ralston's Method of order three\nRunge2 2 Runge's Method\nKutta3 3 Kutta's Method\nRK416 4 Explicit 4th order Runge-Kutta (1/6 rule)\nRK438 4 Explicit 4th order Runge-Kutta (3/8 rule)","category":"page"},{"location":"tutorial/#Diagonally-Implicit-Runge-Kutta-Methods","page":"Tutorial","title":"Diagonally Implicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nCrankNicolson 3 Crank-Nicholson Method\nKraaijevangerSpijker 3 Kraaijevanger & Spijker's Method\nQinZhang 3 Qin & Zhang's Method\nCrouzeix 3 Crouzeix's Method","category":"page"},{"location":"tutorial/#Fully-Implicit-Runge-Kutta-Methods","page":"Tutorial","title":"Fully Implicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nImplicitEuler 1 Implicit / Backward Euler\nImplicitMidpoint 2 Implicit Midpoint\nSRK3 4 Symmetric Runge-Kutta s=3","category":"page"},{"location":"tutorial/#Gauß,-Radau-and-Lobatto-Methods","page":"Tutorial","title":"Gauß, Radau and Lobatto Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nGauss 2s Gauss-Legendre\nRadauIA 2s-1 Radau-IA\nRadauIB 2s-1 Radau-IB\nRadauIIA 2s-1 Radau-IIA\nRadauIIB 2s-1 Radau-IIB\nLobattoIII 2s-2 Lobatto-III\nLobattoIIIA 2s-2 Lobatto-IIIA\nLobattoIIIB 2s-2 Lobatto-IIIB\nLobattoIIIC 2s-2 Lobatto-IIIC\nLobattoIIID 2s-2 Lobatto-IIID\nLobattoIIIE 2s-2 Lobatto-IIIE\nLobattoIIIF 2s Lobatto-IIIF\nLobattoIIIF 2s Lobatto-IIIF\nLobattoIIIG 2s Lobatto-IIIG","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"All of these tableaus are generated on the fly and take the number of stages s as parameter.","category":"page"},{"location":"tutorial/#Splitting-Methods","page":"Tutorial","title":"Splitting Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nLieA 1 Lie-Trotter Splitting A\nLieB 1 Lie-Trotter Splitting B\nStrang 2 Strang / Marchuk Splitting\nMarchuk 2 Strang / Marchuk Splitting\nStrangA 2 Strang / Marchuk Splitting A\nStrangB 2 Strang / Marchuk Splitting B\nMcLachlan2 2 McLachlan's 2nd order symmetric, minimum error composition method\nMcLachlan4 2 McLachlan's 4th order symmetric, minimum error composition method\nTripleJump 4 4th order \"Triple Jump\" composition method\nSuzukiFractal 4 Suzuki's 4th order \"fractal\" composition method","category":"page"},{"location":"tutorial/#Integrators-for-partitioned-ODEs","page":"Tutorial","title":"Integrators for partitioned ODEs","text":"","category":"section"},{"location":"tutorial/#Partitioned-Runge-Kutta-Methods","page":"Tutorial","title":"Partitioned Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Any partitioned Runge-Kutta method can be selected by the PRK method","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"prk = PRK(tableau)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where tableau is any tableau from RungeKutta.PartitionedTableaus. For most tableaus there also exist explicit shortcuts to select the method. These are listed in the following.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nLobattoIIIAIIIB 2s-2 Lobatto-IIIA-IIIB\nLobattoIIIBIIIA 2s-2 Lobatto-IIIB-IIIA\nLobattoIIIAIIIĀ 2s-2 Lobatto-IIIA-IIIĀ\nLobattoIIIBIIIB̄ 2s-2 Lobatto-IIIB-IIIB̄\nLobattoIIICIIIC̄ 2s-2 Lobatto-IIIC-IIIC̄\nLobattoIIIC̄IIIC 2s-2 Lobatto-IIIC̄-IIIC\nLobattoIIIDIIID̄ 2s-2 Lobatto-IIID-IIID̄\nLobattoIIIEIIIĒ 2s-2 Lobatto-IIIE-IIIĒ\nLobattoIIIFIIIF̄ 2s Lobatto-IIIF-IIIF̄\nLobattoIIIF̄IIIF 2s Lobatto-IIIF̄-IIIF\nLobattoIIIGIIIḠ 2s Lobatto-IIIG-IIIḠ","category":"page"},{"location":"tutorial/#Integrators-for-implicit-ODEs","page":"Tutorial","title":"Integrators for implicit ODEs","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"All implicit Runge-Kutta and partitioned Runge-Kutta methods can also be applied to implicit ODEs.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nImplicitEuler 1 Implicit / Backward Euler\nImplicitMidpoint 2 Implicit Midpoint\nSRK3 4 Symmetric Runge-Kutta s=3\n  \nGauss 2s Gauss-Legendre\nRadauIA 2s-1 Radau-IA\nRadauIB 2s-1 Radau-IB\nRadauIIA 2s-1 Radau-IIA\nRadauIIB 2s-1 Radau-IIB\nLobattoIII 2s-2 Lobatto-III\nLobattoIIIA 2s-2 Lobatto-IIIA\nLobattoIIIB 2s-2 Lobatto-IIIB\nLobattoIIIC 2s-2 Lobatto-IIIC\nLobattoIIID 2s-2 Lobatto-IIID\nLobattoIIIE 2s-2 Lobatto-IIIE\nLobattoIIIF 2s Lobatto-IIIF\nLobattoIIIG 2s Lobatto-IIIG\n  \nLobattoIIIAIIIB 2s-2 Lobatto-IIIA-IIIB\nLobattoIIIBIIIA 2s-2 Lobatto-IIIB-IIIA\nLobattoIIIAIIIĀ 2s-2 Lobatto-IIIA-IIIĀ\nLobattoIIIBIIIB̄ 2s-2 Lobatto-IIIB-IIIB̄\nLobattoIIICIIIC̄ 2s-2 Lobatto-IIIC-IIIC̄\nLobattoIIIC̄IIIC 2s-2 Lobatto-IIIC̄-IIIC\nLobattoIIIDIIID̄ 2s-2 Lobatto-IIID-IIID̄\nLobattoIIIEIIIĒ 2s-2 Lobatto-IIIE-IIIĒ\nLobattoIIIFIIIF̄ 2s Lobatto-IIIF-IIIF̄\nLobattoIIIF̄IIIF 2s Lobatto-IIIF̄-IIIF\nLobattoIIIGIIIḠ 2s Lobatto-IIIG-IIIḠ","category":"page"},{"location":"tutorial/#Integrators-for-Lagrangian-ODEs","page":"Tutorial","title":"Integrators for Lagrangian ODEs","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Regular (non-degenerate) Lagragian ODEs can be integrated with Variational Partitioned Runge-Kutta (VPRK) methods or Continuous Galerkin Variational Integrators (CGVI).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Method\nVPRK Variational Partitioned Runge-Kutta integrator\n \nVPRKGauss VPRK integrator with Gauss\nVPRKRadauIIA VPRK integrator with RadauIIA\nVPRKRadauIIB VPRK integrator with RadauIIB\nVPRKLobattoIII VPRK integrator with LobattoIII\nVPRKLobattoIIIA VPRK integrator with LobattoIIIA\nVPRKLobattoIIIB VPRK integrator with LobattoIIIB\nVPRKLobattoIIIC VPRK integrator with LobattoIIIC\nVPRKLobattoIIID VPRK integrator with LobattoIIID\nVPRKLobattoIIIE VPRK integrator with LobattoIIIE\nVPRKLobattoIIIF VPRK integrator with LobattoIIIF\nVPRKLobattoIIIG VPRK integrator with LobattoIIIG\nVPRKLobattoIIIAIIIB VPRK integrator with LobattoIIIAIIIB\nVPRKLobattoIIIBIIIA VPRK integrator with LobattoIIIBIIIA\nVPRKLobattoIIIAIIIĀ VPRK integrator with LobattoIIIAIIIĀ\nVPRKLobattoIIIBIIIB̄ VPRK integrator with LobattoIIIBIIIB̄\nVPRKLobattoIIICIIIC̄ VPRK integrator with LobattoIIICIIIC̄\nVPRKLobattoIIIC̄IIIC VPRK integrator with LobattoIIIC̄IIIC\nVPRKLobattoIIIDIIID̄ VPRK integrator with LobattoIIIDIIID̄\nVPRKLobattoIIIEIIIĒ VPRK integrator with LobattoIIIEIIIĒ\nVPRKLobattoIIIFIIIF̄ VPRK integrator with LobattoIIIFIIIF̄\nVPRKLobattoIIIF̄IIIF VPRK integrator with LobattoIIIF̄IIIF\nVPRKLobattoIIIGIIIḠ VPRK integrator with LobattoIIIGIIIḠ","category":"page"},{"location":"tutorial/#Integrators-for-Degenerate-Lagrangian-ODEs","page":"Tutorial","title":"Integrators for Degenerate Lagrangian ODEs","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Degenerate Lagragian ODEs can be integrated with Degenerate Variational Integrators (see also DVRK) or projected Variational Partitioned Runge-Kutta methods.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Method\nDVIA Symplectic Euler-A Degenerate Variational Integrator\nDVIB Symplectic Euler-B Degenerate Variational Integrator\nCMDVI Midpoint Degenerate Variational Integrator\nCTDVI Trapezoidal Degenerate Variational Integrator\nDVRK Degenerate Variational Runge-Kutta integrator\n \nVPRKpInternal VPRK integrator with projection on internal stages\nVPRKpLegendre VPRK integrator with Legendre projection\nVPRKpMidpoint VPRK integrator with Midpoint projection\nVPRKpSecondary VPRK integrator with projection on secondary constraint\nVPRKpStandard VPRK integrator with standard projection\nVPRKpSymmetric VPRK integrator with symmetric projection\nVPRKpSymplectic VPRK integrator with symplectic projection\nVPRKpVariational VPRK integrator with variational projection\nVPRKpVariationalP VPRK integrator with variational projection on P\nVPRKpVariationalQ VPRK integrator with variational projection on Q","category":"page"},{"location":"tutorial/#Integrators-for-DAEs","page":"Tutorial","title":"Integrators for DAEs","text":"","category":"section"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"C. Rackauckas and Q. Nie. DifferentialEquations.jl - A Performant and Feature-Rich Ecosystem for Solving Differential Equations in Julia. Journal of Open Research Software 5, 15 (2017).\n\n\n\nJ. Bezanson, A. Edelman, S. Karpinski and V. B. Shah. Julia: A Fresh Approach to Numerical Computing. Siam Review 59, 65–98 (2017).\n\n\n\nW. Fangzong and L. Xiaobing. A Class of Lobatto Methods of Order 2s. International Journal of Applied Mathematics 46, 6–10 (2016).\n\n\n\nR. I. McLachlan and G. R. Quispel. Splitting methods. Acta Numerica 11, 341–434 (2002).\n\n\n\nE. Hairer, C. Lubich and G. Wanner. Geometric Numerical Integration (Springer, 2006).\n\n\n\nG. Strang. On the construction and comparison of difference schemes. SIAM Journal on Numerical Analysis 5, 506–517 (1968).\n\n\n\nG. I. Marchuk. Some applications of splitting-up methods to the solution of mathematical physics problems. Aplikace Matematiky 13, 103–132 (1968).\n\n\n\nR. I. McLachlan. On the Numerical Integration of Ordinary Differential Equations by Symmetric Composition Methods. SIAM Journal on Scientific Computing 16, 151–168 (1995).\n\n\n\nJ. E. Marsden and M. West. Discrete Mechanics and Variational Integrators. Acta Numerica 10, 357–514 (2001).\n\n\n\nA. P. Veselov. Integrable discrete-time systems and difference operators. Functional Analysis and Its Applications 22, 83–93 (1988).\n\n\n\nJ. M. Wendlandt and J. E. Marsden. Mechanical integrators derived from a discrete variational principle. Physica D: Nonlinear Phenomena 106, 223–246 (1997).\n\n\n\nJ. E. Marsden and J. M. Wendlandt. Mechanical Systems with Symmetry, Variational Principles, and Integration Algorithms. In: Current and Future Directions in Applied Mathematics, edited by M. Alber, B. Hu and J. Rosenthal (Birkhäuser Boston, 1997); pp. 219–261.\n\n\n\nM. Leok and J. Zhang. Discrete Hamiltonian Variational Integrators. IMA Journal of Numerical Analysis 31, 1497–1532 (2011).\n\n\n\nM. Kraus. Projected Variational Integrators for Degenerate Lagrangian Systems, arXiv:1708.07356.\n\n\n\nS. Ober-Blöbaum. Galerkin variational integrators and modified symplectic Runge-Kutta methods. IMA Journal of Numerical Analysis 37, 375–406 (2016).\n\n\n\nT. Dray. Differential Forms and the Geometry of General Relativity (CRC Press, 2014).\n\n\n\nJ. Baez and J. P. Muniain. Gauge Fields, Knots and Gravity (World Scientific, 1994).\n\n\n\nR. W. Darling. Differential Forms and Connections (Cambridge University Press, 1994).\n\n\n\nT. Frankel. The Geometry of Physics (Cambridge University Press, 2011).\n\n\n\nJ. M. Lee. Introduction to Smooth Manifolds (Springer, 2012).\n\n\n\nJ. M. Lee. Manifolds and Differential Geometry (American Mathematical Society, 2009).\n\n\n\nL. W. Tu. An Introduction to Manifolds (Springer, 2011).\n\n\n\nS. Morita. Geometry of Differential Forms (American Mathematical Society, 2001).\n\n\n\nR. Abraham and J. E. Marsden. Foundations of Mechanics (American Mathematical Society, 1978).\n\n\n\nJ. E. Marsden and T. S. Ratiu. Introduction to Mechanics and Symmetry (Springer, 2002).\n\n\n\nD. D. Holm, T. Schmah and C. Stoica. Mechanics and Symmetry (Oxford University Press, 2009).\n\n\n\nE. Hairer. Geometric Integration of Ordinary Differential Equations on Manifolds. BIT Numerical Mathematics 41, 996–1007 (2001).\n\n\n\nE. Hairer. Symmetric Projection Methods for Differential Equations on Manifolds. BIT Numerical Mathematics 40, 726–734 (2000).\n\n\n\nR. P. Chan, P. Chartier and A. Murua. Reversible methods of Runge-Kutta type for Index-2 DAEs. Numerische Mathematik 97, 427–440 (2004).\n\n\n\nE. Hairer, C. Lubich and M. Roche. The Numerical Solution of Differential-Algebraic Systems by Runge-Kutta Methods. Vol. 1409 of Lecture Notes in Mathematics (Springer, 1989).\n\n\n\nU. M. Ascher and L. R. Petzold. Projected implicit Runge-Kutta methods for differential-algebraic equations. SIAM Journal on Numerical Analysis 28, 1097–1120 (1991).\n\n\n\nR. P. Chan, P. Chartier and A. Murua. Post-projected Runge-Kutta methods for index-2 differential-algebraic equations. Applied Numerical Mathematics 42, 77–94 (2002).\n\n\n\nL. O. Jay. Solution of Index 2 Implicit Differential-Algebraic Equations by Lobatto Runge-Kutta Methods. BIT Numerical Mathematics 43, 93–106 (2003).\n\n\n\nL. O. Jay. Specialized Runge-Kutta methods for index 2 differential-algebraic equations. Mathematics of Computation 75, 641–654 (2006).\n\n\n\nW. Oevel and M. Sofroniou. Symplectic Runge-Kutta schemes II: classification of symmetric methods. Preprint.\n\n\n\nS. Zhao and G.-W. Wei. A unified discontinuous Galerkin framework for time integration. Mathematical Methods in the Applied Sciences 37, 1042–1071 (2014).\n\n\n\nL. O. Jay. Structure Preservation for Constrained Dynamics with Super Partitioned Additive Runge-Kutta Methods. SIAM Journal on Scientific Computing 20, 416–446 (1998).\n\n\n\nL. O. Jay. Specialized Partitioned Additive Runge-Kutta Methods for Systems of Overdetermined DAEs with Holonomic Constraints. SIAM Journal on Numerical Analysis 45, 1814–1842 (2007).\n\n\n\nL. O. Jay. Beyond conventional Runge-Kutta methods in numerical integration of ODEs and DAEs by use of structures and local models. Journal of Computational and Applied Mathematics 204, 56–76 (2007).\n\n\n\nM. Kraus. SPARK Methods for Degenerate Lagrangian Systems. In preparation.\n\n\n\nM. Leok. Generalized Galerkin Variational Integrators: Lie group, multiscale, and pseudospectral methods, arXiv:math.NA/0508360.\n\n\n\nC. M. Campos. High Order Variational Integrators: A Polynomial Approach. In: Advances in Differential Equations and Applications (Springer International Publishing, 2014); pp. 249–258.\n\n\n\nC. M. Campos, S. Ober-Blöbaum and E. Trélat. High order variational integrators in the optimal control of mechanical systems. Discrete and Continuous Dynamical Systems 35, 4193–4223 (2015).\n\n\n\nS. Ober-Blöbaum and N. Saake. Construction and analysis of higher order Galerkin variational integrators. Advances in Computational Mathematics 41, 955–986 (2014).\n\n\n\n","category":"page"},{"location":"#GeometricIntegrators.jl","page":"Home","title":"GeometricIntegrators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia library of geometric integrators for differential equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: PkgEval Status) (Image: CI) (Image: Coverage) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl is a library of geometric integrators for ordinary differential equations, stochastic differential equations and differential algebraic equations in Julia. Its main purpose is the democratization and proliferation of geometric integrators by providing a comprehensive collection of structure-preserving as well as standard algorithms under a unified interface.  GeometricIntegrators.jl can be used either interactively, as computational core in other codes, or from within DifferentialEquations.jl via GeometricIntegratorsDiffEq.jl. It provides both, a high-level interface that requires only very few lines of code to solve an actual problem, and a lean low-level interface that allows for straightforward integration into application codes via the exchange of minimalistic data structures. In both, the library leaves maximum control to the user. While trying to pick sensible defaults, all settings are accessible to and modifiable by the user. Suitable abstraction layers allow to choose between different linear and nonlinear solvers, auto-differentiation packages or custom routines for the computation of Jacobians and the like.","category":"page"},{"location":"#Package-Description","page":"Home","title":"Package Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Differential equations are ubiquitous in science and engineering. Many equations possess geometric features or abstract mathematical structures that need to be preserved in the discretisation in order to obtain reliable simulation results, especially for nonlinear problems and long-time simulations. The preservation of such properties improves stability, bounds global error growth and reduces numerical artefacts. Robust, performant and structure-preserving solvers for different types of differential equations are thus needed across many disciplines. GeometricIntegrators.jl provides such solvers and makes them available for both direct use as well as integration into other codes. Furthermore, the implemented algorithms can also be used within the DifferentialEquations.jl ecosystem [[1]], which is the defacto standard differential equation solver for the Julia programming language [[2]].","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl provides a comprehensive library of geometric integration algorithms as well as some non-geometric algorithms. It collects native Julia implementations of many known methods under a unified interface. Once a problem is implemented in the GeometricIntegators framework, all of its algorithms can immediately be applied and their performance evaluated. This facilitates numerical experiments with a wide variety of algorithms, simplifies benchmarking, and makes it easy to identify the best algorithm for a given problem. The implemented algorithms include explicit, implicit and partitioned Runge-Kutta methods, SPARK methods, splitting methods, symplectic methods and variational integrators. Most methods are implemented in an abstract way that allows for the flexible choice of tableaus, approximation spaces, basis functions, quadrature rules, and thus order of convergence. It also means that adding e.g. a new Runge-Kutta or splitting method merely amounts to adding its tableau. Less standard algorithms can be added by extending the package with custom integrators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As most geometric integrators are not easily combined with time step adaption in a structure-preserving way, GeometricIntegrators.jl does not provide any general infrastructure for adaptive time stepping. Nonetheless, individual integrators can implement their own adaptivity strategies as long as they provide a solution at a predefined, equidistant series of time steps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"One of the original aims of GeometricIntegrators.jl is to serve as a testbed for the development and analysis of novel algorithms. Due to the modular structure and the use of the multiple dispatch paradigm, the library can easily be extended, e.g., towards new algorithms or new types of equations. The library aims at providing efficient implementations of diverse algorithms in order to be able to perform simulations and benchmarks with millions or even billions of time steps that facilitate the study of the long-time behaviour of both numerical algorithms and dynamical systems. The current scope of applications is mainly small- to mid-size systems of differential equations, e.g., systems of ordinary differential equations or semidiscretisations of partial differential equations with a moderate number of degrees of freedom. It is envisaged that in the future GeometricIntegrators.jl will also be able to address larger problems, especially semidiscretisations of partial differential equations in higher dimensions. In particular, this requires interfaces to appropriate iterative and parallel linear solvers, which are still lacking.","category":"page"},{"location":"#Similar-Software","page":"Home","title":"Similar Software","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package closely related to GeometricIntegrators.jl is DifferentialEquations.jl [[1]]. Although serving similar purposes, the scope of the two libraries is rather different. While DifferentialEquations.jl provides a feature-rich ecosystem for the solution of differential equations, the focus of GeometricIntegrators.jl is on algorithms. While DifferentialEquations.jl is based around adaptive time stepping algorithms, GeometricIntegrators.jl focuses on fixed time step methods, given that structure-preservation is not easily combined with time step adaptivity. Therefore both packages are rather complementary, and GeometricIntegrators.jl can in fact be used as backend for DifferentialEquations.jl via GeometricIntegratorsDiffEq.jl.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"tutorial/tutorial.md\",\n    \"problems.md\",\n    \"methods.md\",\n]","category":"page"},{"location":"#Integrators","page":"Home","title":"Integrators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"integrators/rk.md\",\n    \"integrators/splitting.md\",\n    \"integrators/variational.md\",\n    \"integrators/vprk.md\",\n    \"integrators/spark.md\",\n    \"integrators/dvi.md\",\n    \"integrators/cgvi.md\",\n    \"integrators/dgvi.md\",\n    \"integrators/hpi.md\",\n    \"integrators/hpg.md\",\n]","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    # \"modules/discontinuities.md\",\n    \"modules/equations.md\",\n    \"modules/integrators.md\",\n    \"modules/methods.md\",\n    \"modules/projections.md\",\n    \"modules/problems.md\",\n    \"modules/rungekutta.md\",\n    # \"modules/simulations.md\",\n    \"modules/solutions.md\",\n    \"modules/spark.md\",\n]","category":"page"},{"location":"#Developer-Documentation","page":"Home","title":"Developer Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"developer/integrators.md\",\n    \"developer/projections.md\",\n    \"developer/code_integration.md\",\n    \"developer/custom_integrators.md\",\n    \"developer/adaptive_time_stepping.md\",\n]","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use GeometricIntegrators.jl in your work, please consider citing it by","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{Kraus:2020:GeometricIntegrators,\n  title={GeometricIntegrators.jl: Geometric Numerical Integration in Julia},\n  author={Kraus, Michael},\n  year={2020},\n  howpublished={\\url{https://github.com/JuliaGNI/GeometricIntegrators.jl}},\n  doi={10.5281/zenodo.3648325}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl contains reference implementation for the methods described in the following articles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Michael Kraus. Projected Variational Integrators for Degenerate Lagrangian Systems. arXiv:1708.07356.\nMichael Kraus and Tomasz M. Tyranowski. Variational Integrators for Stochastic Dissipative Hamiltonian Systems. arXiv:1909.07202, Journal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"References for most of the available Runge-Kutta methods can be found in the documentation of RungeKutta.jl.","category":"page"},{"location":"#Background-Material","page":"Home","title":"Background Material","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ernst Hairer and Christian Lubich. Numerical Solution of Ordinary Differential Equations. The Princeton Companion to Applied Mathematics, 293-305, 2015. Princeton University Press. (Author's Web Site)\nErnst Hairer, Christian Lubich and Gerhard Wanner. Geometric Numerical Integration Illustrated by the Störmer–Verlet Method. Acta Numerica 12, 399-450, 2003. (Journal)\nJohn C. Butcher. Gauss Methods. Encyclopedia of Applied and Computational Mathematics, Pages 583-589, 2015. (Article)\nLaurent O. Jay. Lobatto Methods. Encyclopedia of Applied and Computational Mathematics, Pages 817–826, 2015. (Article)\nErnst Hairer and Gerhard Wanner. Radau Methods. Encyclopedia of Applied and Computational Mathematics, Pages 1213-1216, 2015. (Article)","category":"page"},{"location":"#Books-on-Geometric-Numerical-Integration","page":"Home","title":"Books on Geometric Numerical Integration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sergio Blanes, Fernando Casas. A Concise Introduction to Geometric Numerical Integration. CRC Press, 2016. (eBook)\nErnst Hairer, Christian Lubich and Gerhard Wanner. Geometric Numerical Integration. Springer, 2006. (eBook)\nBenedict Leimkuhler and Sebastian Reich. Simulating Hamiltonian Dynamics. Cambridge University Press, 2005. (eBook)\nJesús Maria Sanz-Serna, Manuel P. Calvo. Numerical Hamiltonian Problems. Chapman Hall, 1994.","category":"page"},{"location":"#Books-on-the-Numerical-Integration-of-Differential-Equations","page":"Home","title":"Books on the Numerical Integration of Differential Equations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ernst Hairer, Syvert P. Nørsett and Gerhard Wanner. Solving Ordinary Differential Equations I: Nonstiff Problems. Springer, 1993. (eBook)\nErnst Hairer and Gerhard Wanner. Solving Ordinary Differential Equations II: Stiff and Differential-Algebraic Problems. Springer, 1996. (eBook)\nErnst Hairer, Christian Lubich, Michel Roche. The Numerical Solution of Differential-Algebraic Systems by Runge-Kutta Methods. Springer, 1989. (eBook)\nPeter Deuflhard, Folkmar Bornemann. Scientific Computing with Ordinary Differential Equations. Springer, 2002. (eBook)\nJohn C. Butcher. Numerical Methods for Ordinary Differential Equations. Wiley, 2016. (eBook)","category":"page"}]
}
