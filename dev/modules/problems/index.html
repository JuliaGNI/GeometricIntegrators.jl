<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Problems · GeometricIntegrators.jl</title><meta name="title" content="Problems · GeometricIntegrators.jl"/><meta property="og:title" content="Problems · GeometricIntegrators.jl"/><meta property="twitter:title" content="Problems · GeometricIntegrators.jl"/><meta name="description" content="Documentation for GeometricIntegrators.jl."/><meta property="og:description" content="Documentation for GeometricIntegrators.jl."/><meta property="twitter:description" content="Documentation for GeometricIntegrators.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GeometricIntegrators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../problems/">Problems</a></li><li><a class="tocitem" href="../../methods/">Methods</a></li><li><span class="tocitem">Integrators</span><ul><li><a class="tocitem" href="../../integrators/rk/">Runge-Kutta</a></li><li><a class="tocitem" href="../../integrators/splitting/">Splitting</a></li><li><a class="tocitem" href="../../integrators/variational/">Variational</a></li><li><a class="tocitem" href="../../integrators/vprk/">VPRK</a></li><li><a class="tocitem" href="../../integrators/spark/">SPARK</a></li><li><a class="tocitem" href="../../integrators/dvi/">DVI</a></li><li><a class="tocitem" href="../../integrators/hpi/">Hamilton-Pontryagin</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../equations/">Equations</a></li><li><a class="tocitem" href="../integrators/">Integrators</a></li><li><a class="tocitem" href="../methods/">Methods</a></li><li class="is-active"><a class="tocitem" href>Problems</a><ul class="internal"><li><a class="tocitem" href="#Geometric-Equation-Problems"><span>Geometric Equation Problems</span></a></li><li><a class="tocitem" href="#Ordinary-Differential-Equations"><span>Ordinary Differential Equations</span></a></li><li><a class="tocitem" href="#Differential-Algebraic-Equations"><span>Differential Algebraic Equations</span></a></li><li><a class="tocitem" href="#Stochastic-Differential-Equations"><span>Stochastic Differential Equations</span></a></li></ul></li><li><a class="tocitem" href="../projections/">Projections</a></li><li><a class="tocitem" href="../rungekutta/">Runge-Kutta Tableaus</a></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li><a class="tocitem" href="../spark/">SPARK Methods</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../developer/integrators/">Integrators</a></li><li><a class="tocitem" href="../../developer/projections/">Projections</a></li><li><a class="tocitem" href="../../developer/code_integration/">Code Integration</a></li><li><a class="tocitem" href="../../developer/custom_integrators/">Custom Integrators</a></li><li><a class="tocitem" href="../../developer/adaptive_time_stepping/">Adaptive Time Stepping</a></li></ul></li><li><a class="tocitem" href="../../releasenotes/">Release Notes</a></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../authors/">Authors</a></li><li><a class="tocitem" href="../../LICENSE/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Problems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Problems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/GeometricIntegrators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGNI/GeometricIntegrators.jl/blob/main/docs/src/modules/problems.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Problem-Types"><a class="docs-heading-anchor" href="#Problem-Types">Problem Types</a><a id="Problem-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Types" title="Permalink"></a></h1><p>The following data structures are all implemented in <a href="https://github.com/JuliaGNI/GeometricEquations.jl">GeometricEquations.jl</a>. Each problem type is derived from <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a>.</p><h2 id="Geometric-Equation-Problems"><a class="docs-heading-anchor" href="#Geometric-Equation-Problems">Geometric Equation Problems</a><a id="Geometric-Equation-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-Equation-Problems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.GeometricProblem" href="#GeometricEquations.GeometricProblem"><code>GeometricEquations.GeometricProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type that describes a generic interface for different problem types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/geometric_problem.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.EquationProblem" href="#GeometricEquations.EquationProblem"><code>GeometricEquations.EquationProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>EquationProblem: stores a GeometricEquation together with initial conditions, parameters, time span and time step size.</p><p><strong>Parameters</strong></p><ul><li><code>ST &lt;: GeometricEquation</code>: super type, used for dispatch</li><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type of state variable</li><li><code>equType &lt;: GeometricEquation</code>: equation type</li><li><code>functionsType &lt;: NamedTuple</code>: types of all function methods</li><li><code>solutionsType &lt;: NamedTuple</code>: types of all solution methods</li><li><code>icsType &lt;: NamedTuple</code>: types of all initial conditions </li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li></ul><p><strong>Fields</strong></p><ul><li><code>equation</code>: reference to the parent equation object holding the vector fields, etc.</li><li><code>functions</code>: methods for all vector fields, etc., that define the problem</li><li><code>solutions</code>: methods for all solutions, etc., if defined</li><li><code>tspan</code>: time span for problem <code>(t₀,t₁)</code></li><li><code>tstep</code>: time step to be used in simulation</li><li><code>ics</code>: <code>NamedTuple</code> containing the initial conditions, must contain one field for each state variable</li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code> indicating that the equation does not have any parameters</li></ul><p><strong>Subtypes</strong></p><p>The <code>EquationProblem</code> type has various subtypes for the different equations types, that are defined e.g. via</p><pre><code class="language-julia hljs">const ODEProblem = EquationProblem{ODE}</code></pre><p>and provide convenience constructors to construct an equation and the corresponding problem in one step, e.g.,</p><pre><code class="language-julia hljs">ODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)
ODEProblem(v, tspan, tstep, q₀::StateVariable; kwargs...)</code></pre><p>All problem subtypes take the following keyword arguments:</p><ul><li><code>invariants = NullInvariants()</code></li><li><code>parameters = NullParameters()</code></li><li><code>periodicity = NullPeriodicity()</code></li></ul><p>If not set to their corresponding Null types, the user needs to pass a <code>NamedTuple</code> whose values are</p><ul><li>functions for invariants,</li><li>arbitrary data structures for parameters, </li><li>the same data structure as the solution for periodicity.</li></ul><p>The latter should be zero everywhere, except for those components, that are periodic, i.e., whose value are supposed to stay within a range <code>(0, max)</code>. Support for ranges starting with other values than zero is currently missing but can be added if demand arises.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/problems/equation_problem.jl#L1-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.EnsembleProblem" href="#GeometricEquations.EnsembleProblem"><code>GeometricEquations.EnsembleProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>EnsembleProblem: stores a GeometricEquation together with multiple sets of initial conditions, parameters, time span and time step size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/problems/ensemble_problem.jl#L1-L4">source</a></section></article><h2 id="Ordinary-Differential-Equations"><a class="docs-heading-anchor" href="#Ordinary-Differential-Equations">Ordinary Differential Equations</a><a id="Ordinary-Differential-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Ordinary-Differential-Equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.ODEProblem" href="#GeometricEquations.ODEProblem"><code>GeometricEquations.ODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ODEProblem</code>: Ordinary Differential Equation Problem</p><p>Ordinary differential equations define an initial value problem of the form</p><p class="math-container">\[\dot{q} (t) = v(t, q(t)) ,\]</p><p>with vector field <span>$v$</span>.</p><p>The dynamical variables with initial condition <span>$q_{0}$</span> take values in <span>$\mathbb{R}^{d}$</span>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)
ODEProblem(v, tspan, tstep, q₀::StateVariable; kwargs...)</code></pre><p>where <code>v</code> is the function computing the vector field,  <code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entry <code>q</code>. The initial condition <code>q₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>. For the interface of the function <code>v</code> see <a href="../equations/#GeometricEquations.ODE"><code>ODE</code></a>.</p><p>For possible keyword arguments see the documentation on <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes.</p><p><strong>Function Definitions</strong></p><p>The function <code>v</code> providing the vector field must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, params)
    v[1] = ...
    v[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the vector which holds the result of evaluating the vector field <span>$v$</span> on <code>t</code> and <code>q</code>, and <code>params</code> is a <code>NamedTuple</code> of additional parameters on which the vector field may depend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/odes/ode.jl#L128-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.PODEProblem" href="#GeometricEquations.PODEProblem"><code>GeometricEquations.PODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PODEProblem</code>: Partitioned Ordinary Differential Equation Problem</p><p>A partitioned ordinary differential equation is an initial value problem of the form</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span> and <span>$f$</span>.</p><p>The dynamical variables <span>$(q,p)$</span> with initial conditions <span>$(q(t_{0}) = q_{0}, p(t_{0}) = p_{0})$</span> take values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">PODEProblem(v, f, tspan, tstep, ics; kwargs...)
PODEProblem(v, f, tspan, tstep, q₀::StateVariable, p₀::StateVariable; kwargs...)</code></pre><p>where <code>v</code> and <code>f</code> are the function computing the vector fields,  <code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entries <code>q</code> and <code>p</code>. The initial conditions <code>q₀</code> and <code>p₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>. For the interfaces of the functions <code>v</code> and <code>f</code> see <a href="../equations/#GeometricEquations.PODE"><code>PODE</code></a>.</p><p>For possible keyword arguments see the documentation on <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes.</p><p><strong>Function Definitions</strong></p><p>The functions <code>v</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f(f, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> and <code>p</code> are the current solution vectors, <code>v</code> and <code>f</code> are the vectors which hold the result of evaluating the vector fields <span>$v$</span> and <span>$f$</span> on <code>t</code>, <code>q</code> and <code>p</code>, and params is a <code>NamedTuple</code> of additional parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/odes/pode.jl#L140-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.HODEProblem" href="#GeometricEquations.HODEProblem"><code>GeometricEquations.HODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>HODEProblem</code>: Hamiltonian Ordinary Differential Equation Problem</p><p>A canonical Hamiltonian system of equations is special case of a partitioned ordinary differential equation,</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span> and <span>$f$</span>, given by</p><p class="math-container">\[\begin{aligned}
v &amp;=   \frac{\partial H}{\partial p} , &amp;
f &amp;= - \frac{\partial H}{\partial q} .
\end{aligned}\]</p><p>The dynamical variables <span>$(q,p)$</span> with initial conditions <span>$(q(t_{0}) = q_{0}, p(t_{0}) = p_{0})$</span> take values in <span>$T^{*} Q \simeq \mathbb{R}^{d} \times \mathbb{R}^{d}$</span>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HODEProblem(v, f, hamiltonian, tspan, tstep, ics; kwargs...)
HODEProblem(v, f, hamiltonian, tspan, tstep, q₀::StateVariable, p₀::StateVariable; kwargs...)</code></pre><p>where <code>v</code> and <code>f</code> are the function computing the vector fields,  <code>hamiltonian</code> returns the value of the Hamiltonian (i.e. the total energy), <code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entries <code>q</code> and <code>p</code>. The initial conditions <code>q₀</code> and <code>p₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>. For the interfaces of the functions <code>v</code>, <code>f</code>, <code>poisson</code> and <code>hamiltonian</code> see <a href="../equations/#GeometricEquations.HODE"><code>HODE</code></a>.</p><p>For possible keyword arguments see the documentation on <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes.</p><p><strong>Function Definitions</strong></p><p>The functions <code>v</code>, <code>f</code> and <code>hamiltonian</code> must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f(f, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end

function hamiltonian(t, q, p, params)
    return ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> and <code>p</code> are the current solution vectors, <code>v</code> and <code>f</code> are the vectors which hold the result of evaluating the vector fields on <code>t</code>, <code>q</code> and <code>p</code>, and params is a <code>NamedTuple</code> of additional parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/odes/hode.jl#L169-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.IODEProblem" href="#GeometricEquations.IODEProblem"><code>GeometricEquations.IODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>IODEProblem</code>: Implicit Ordinary Differential Equation Problem</p><p>An implicit ordinary differential equations is an initial value problem of the form</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) , \\
p(t) &amp;= ϑ(t, q(t), v(t)) ,
\end{aligned}\]</p><p>with force field <span>$f$</span>, the momentum defined by <span>$p$</span>. This is a special case of a differential algebraic equation with dynamical variables <span>$(q,p)$</span> and algebraic variable <span>$v$</span>, that is determined such that the constraint <span>$p(t) = ϑ(t, q(t), v(t))$</span> is satisfied.</p><p>Most integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + λ(t) , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), v(t), λ(t)) , \\
p(t) &amp;= ϑ(t, q(t), v(t)) ,
\end{aligned}\]</p><p>where the vector field defining the projection step is usually given as</p><p class="math-container">\[\begin{aligned}
g(t, q(t), v(t), λ(t)) &amp;= λ(t) \cdot \nabla ϑ(t, q(t), v(t)) .
\end{aligned}\]</p><p>The dynamical variables <span>$(q,p)$</span> with initial conditions <span>$(q(t_{0}) = q_{0}, p(t_{0}) = p_{0})$</span> take values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>. The algebraic variable <span>$λ$</span> with initial condition <span>$λ(t_{0}) = λ_{0}$</span> takes values in <span>$\mathbb{R}^{m}$</span>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">IODEProblem(ϑ, f, tspan, tstep, ics; kwargs...)
IODEProblem(ϑ, f, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)
IODEProblem(ϑ, f, g, tspan, tstep, ics; kwargs...)
IODEProblem(ϑ, f, g, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)</code></pre><p>The functions <code>ϑ</code>, <code>f</code> and <code>g</code> compute the momentum and the vector fields, respectively.</p><p><code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entries <code>q</code>, <code>p</code> and <code>λ</code>. The initial conditions <code>q₀</code> and <code>p₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>. For the interfaces of the functions <code>ϑ</code>, <code>f</code> and <code>g</code> see <a href="../equations/#GeometricEquations.IODE"><code>IODE</code></a>.</p><p>In addition to the standard keyword arguments for <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes, an <code>IODEProblem</code> accepts functions <code>v̄</code> and <code>f̄</code> for the computation of initial guesses for the vector fields with default values <code>v̄ = _iode_default_v̄</code> and <code>f̄ = f</code>.</p><p><strong>Function Definitions</strong></p><p>The functions <code>ϑ</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">function ϑ(p, t, q, v)
    p[1] = ...
    p[2] = ...
    ...
end</code></pre><p>and</p><pre><code class="language-julia hljs">function f(f, t, q, v)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the current velocity and <code>f</code> and <code>p</code> are the vectors which hold the result of evaluating the functions <span>$f$</span> and <span>$ϑ$</span> on <code>t</code>, <code>q</code> and <code>v</code>. In addition, the functions <code>g</code>, <code>v̄</code> and <code>f̄</code> are specified by</p><pre><code class="language-julia hljs">function g(g, t, q, v, λ)
    g[1] = ...
    g[2] = ...
    ...
end

function v̄(v, t, q, p)
    v[1] = ...
    v[2] = ...
    ...
end

function f̄(f, t, q, v)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>The function <code>g</code> is used in projection methods that enforce <span>$p = ϑ(q)$</span>. The functions <code>v̄</code> and <code>f̄</code> are used for initial guesses in nonlinear implicit solvers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/odes/iode.jl#L228-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.LODEProblem" href="#GeometricEquations.LODEProblem"><code>GeometricEquations.LODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LODEProblem</code>: Lagrangian Ordinary Differential Equation Problem</p><p>A Lagrangian system of equations is a special case of an implicit ordinary differential equations, that is an implicit initial value problem of the form</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) , \\
p(t) &amp;= ϑ(t, q(t), v(t)) ,
\end{aligned}\]</p><p>with momentum <span>$p$</span> and force field <span>$f$</span>, given by</p><p class="math-container">\[\begin{aligned}
p &amp;= \frac{\partial L}{\partial v} , &amp;
f &amp;= \frac{\partial L}{\partial q} .
\end{aligned}\]</p><p>This is a special case of an implicit ordinary differential equation, that is defined by a Lagrangian, as well as a special case of a differential algebraic equation with dynamical variables <span>$(q,p)$</span> and algebraic variable <span>$v$</span>, that is determined such that the constraint <span>$p(t) = ϑ(t, q(t), v(t))$</span> is satisfied.</p><p>Many integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + \lambda(t) , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), v(t), \lambda(t)) , \\
p(t) &amp;= ϑ(t, q(t), v(t)) ,
\end{aligned}\]</p><p>where the vector field defining the projection step is usually given as</p><p class="math-container">\[\begin{aligned}
g(t, q(t), v(t), λ(t)) &amp;= λ(t) \cdot \nabla ϑ(t, q(t), v(t)) .
\end{aligned}\]</p><p>The dynamical variables <span>$(q,p)$</span> with initial conditions <span>$(q(t_{0}) = q_{0}, p(t_{0}) = p_{0})$</span> take values in <span>$T^{*} Q \simeq \mathbb{R}^{d} \times \mathbb{R}^{d}$</span>. The algebraic variable <span>$λ$</span> with initial condition <span>$λ(t_{0}) = λ_{0}$</span> takes values in <span>$\mathbb{R}^{m}$</span>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">LODEProblem(ϑ, f, ω, l, tspan, tstep, ics; kwargs...)
LODEProblem(ϑ, f, ω, l, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)
LODEProblem(ϑ, f, g, ω, l, tspan, tstep, ics; kwargs...)
LODEProblem(ϑ, f, g, ω, l, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)</code></pre><p>where <code>ϑ</code>, <code>f</code> and <code>g</code> are the functions computing the momentum and the vector fields, respectively, <code>ω</code> determines the symplectic matrix, and <code>l</code> returns the Lagrangian, <code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entries <code>q</code>, <code>p</code> and <code>λ</code>. The initial conditions <code>q₀</code>, <code>p₀</code> and <code>λ₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>, where <code>λ₀</code> can also be omitted. For the interfaces of the functions <code>ϑ</code>, <code>f</code>, <code>g</code>, <code>ω</code> and <code>l</code> see <a href="../equations/#GeometricEquations.LODE"><code>LODE</code></a>.</p><p>In addition to the standard keyword arguments for <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes, a <code>LODEProblem</code> accepts functions <code>v̄</code> and <code>f̄</code> for the computation of initial guesses for the vector fields with default values <code>v̄ = _lode_default_v̄</code> and <code>f̄ = f</code>.</p><p><strong>Function Definitions</strong></p><p>The functions <code>ϑ</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">function ϑ(p, t, q, v)
    p[1] = ...
    p[2] = ...
    ...
end</code></pre><p>and</p><pre><code class="language-julia hljs">function f(f, t, q, v)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the current velocity and <code>f</code> and <code>p</code> are the vectors which hold the result of evaluating the functions <span>$f$</span> and <span>$ϑ$</span> on <code>t</code>, <code>q</code> and <code>v</code>. The funtions <code>g</code>, <code>v̄</code> and <code>f̄</code> are specified by</p><pre><code class="language-julia hljs">function g(g, t, q, λ)
    g[1] = ...
    g[2] = ...
    ...
end</code></pre><p>and</p><pre><code class="language-julia hljs">function v̄(v, t, q, p)
    v[1] = ...
    v[2] = ...
    ...
end

function f̄(f, t, q, v)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>The function <code>g</code> is used in projection methods that enforce <span>$p = ϑ(q)$</span>. The functions <code>v̄</code> and <code>f̄</code> are used for initial guesses in nonlinear implicit solvers. Finally, the functions <code>ω</code> and <code>l</code>, computing the symplectic matrix and the Lagrangian, have the following signature</p><pre><code class="language-julia hljs">function ω(f, t, q, v, params)
    ω[1,1] = ...
    ω[1,2] = ...
    ...
end

function l(t, q, v, params)
    return ...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/odes/lode.jl#L264-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.SODEProblem" href="#GeometricEquations.SODEProblem"><code>GeometricEquations.SODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SODEProblem</code>: Split Ordinary Differential Equation Problem</p><p>Defines an initial value problem</p><p class="math-container">\[\dot{q} (t) = v(t, q(t)) , \qquad q(t_{0}) = q_{0} ,\]</p><p>with vector field <span>$v$</span>, initial condition <span>$q_{0}$</span> and the solution <span>$q$</span> taking values in <span>$\mathbb{R}^{d}$</span>. Here, the vector field <span>$v$</span> is given as a sum of vector fields</p><p class="math-container">\[v (t) = v_1 (t) + ... + v_r (t) .\]</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SODEProblem(v, q, tspan, tstep, ics::NamedTuple; kwargs...)
SODEProblem(v, q, tspan, tstep, q₀::StateVariable; kwargs...)
SODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)
SODEProblem(v, tspan, tstep, q₀::StateVariable; kwargs...)</code></pre><p>where <code>v</code> is a tuple of functions computing the vector fields for each substep,  <code>q</code> is an optional tuple of functions computing the solution for each substep, <code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entry <code>q</code>. The initial condition <code>q₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>.</p><p>For possible keyword arguments see the documentation on <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes.</p><p><strong>Function Definitions</strong></p><p>The functions <code>v_i</code> providing the vector field must have the interface</p><pre><code class="language-julia hljs">function v_i(v, t, q, params)
    v[1] = ...
    v[2] = ...
    ...
end</code></pre><p>and the functions <code>q_i</code> providing the solutions must have the interface</p><pre><code class="language-julia hljs">function q_i(q₁, t₁, q₀, t₀, params)
    q₁[1] = q₀[1] + ...
    q₁[2] = q₀[2] + ...
    ...
end</code></pre><p>where <code>t₀</code> is the current time, <code>q₀</code> is the current solution vector, <code>q₁</code> is the new solution vector at time <code>t₁</code>, holding the result of computing one substep</p><p>The fact that the function <code>v</code> returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps. with the vector field <span>$v_i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/odes/sode.jl#L180-L208">source</a></section></article><h2 id="Differential-Algebraic-Equations"><a class="docs-heading-anchor" href="#Differential-Algebraic-Equations">Differential Algebraic Equations</a><a id="Differential-Algebraic-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Differential-Algebraic-Equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.DAEProblem" href="#GeometricEquations.DAEProblem"><code>GeometricEquations.DAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>DAEProblem</code>: Differential Algebraic Equation Problem</p><p>Defines a differential algebraic initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t)) + u(t, q(t), \lambda(t)) , \\
0 &amp;= \phi (t, q(t)) ,
\end{aligned}\]</p><p>with vector field <span>$v$</span>, projection <span>$u$</span>, algebraic constraint <span>$\phi=0$</span>.</p><p>Some integrators also enforce the secondary constraint <span>$\psi$</span>, that is the time derivative of the algebraic constraint <span>$\phi$</span>. In this case, the system of equations is modified as follows</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t)) + u(t, q(t), \lambda(t)) + \bar{u} (t, q(t), \dot{q} (t), \dot{p} (t), \mu(t)) , \\
0 &amp;= \phi (t, q(t)) , \\
0 &amp;= \psi (t, q(t), \dot{q} (t)) .
\end{aligned}\]</p><p>The dynamical variable <span>$q$</span> with initial conditions <span>$q(t_{0}) = q_{0}$</span> takes values in <span>$\mathbb{R}^{d}$</span>. The algebraic variables <span>$(λ,μ)$</span> with initial condition <span>$(λ(t_{0}) = λ_{0}, μ(t_{0}) = μ_{0})$</span> take values in <span>$\mathbb{R}^{m} \times \mathbb{R}^{m}$</span>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">DAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, ics::NamedTuple; kwargs...)
DAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, q₀::StateVariable, λ₀::StateVariable, μ₀::StateVariable = zero(λ₀); kwargs...)
DAEProblem(v, u, ϕ, tspan, tstep, ics::NamedTuple; kwargs...)
DAEProblem(v, u, ϕ, tspan, tstep, q₀::StateVariable, λ₀::StateVariable; kwargs...)</code></pre><p>The functions <code>v</code> and <code>u</code> compute the vector field and the projection, respectively, <code>ϕ</code> provides the algebraic constraint. The functions <code>ψ</code> and <code>ū</code> are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.</p><p><code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entries <code>q</code>, <code>λ</code> and <code>μ</code>. The initial conditions <code>q₀</code>, <code>λ₀</code> and <code>μ₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>. For the interfaces of the functions <code>v</code>, <code>u</code>, <code>ϕ</code>, <code>ū</code>, <code>ψ</code> see <a href="../equations/#GeometricEquations.DAE"><code>DAE</code></a>.</p><p>In addition to the standard keyword arguments for <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes, a <code>DAEProblem</code> accepts a function <code>v̄</code> for the computation of an initial guess for the vector field with default value <code>v̄ = v</code>.</p><p><strong>Function Definitions</strong></p><p>The functions <code>v</code>, <code>u</code> and <code>ϕ</code> must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, params)
    v[1] = ...
    v[2] = ...
    ...
end

function u(u, t, q, λ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function ϕ(ϕ, t, q, params)
    ϕ[1] = ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> and <code>λ</code> are the current solution vectors, and <code>v</code>, <code>u</code> and <code>ϕ</code> are the vectors which hold the result of evaluating the vector field <span>$v$</span>, the projection <span>$u$</span> and the algebraic constraint <span>$\phi$</span> on <code>t</code>, <code>q</code> and <code>λ</code>.</p><p>Some integrators also enforce the secondary constraint <span>$\psi$</span> and require the following additional functions</p><pre><code class="nohighlight hljs">function ū(u, t, q, μ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function ψ(ψ, t, q, v, params)
    ψ[1] = ...
end</code></pre><p>With the above function definitions the <code>DAEProblem</code> can be created by</p><pre><code class="language-julia hljs">tspan = (0.0, 1.0)
tstep = 0.1
q₀ = [1., 1.]
λ₀ = [0.]
μ₀ = [0.]

prob = DAEProblem(v, u, ϕ, tspan, tstep, q₀, λ₀)</code></pre><p>or</p><pre><code class="language-julia hljs">prob = DAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, q₀, λ₀, μ₀)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/daes/dae.jl#L255-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.PDAEProblem" href="#GeometricEquations.PDAEProblem"><code>GeometricEquations.PDAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PDAEProblem</code>: Partitioned Differential Algebraic Equation Problem</p><p>A partitioned differential algebraic equation has the form</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) + u(t, q(t), p(t), \lambda(t)) , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) + g(t, q(t), p(t), \lambda(t)) , \\
0 &amp;= \phi (t, q(t), p(t)) ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span> and <span>$f$</span>, projection <span>$u$</span> and <span>$g$</span>, algebraic constraint <span>$\phi=0$</span>.</p><p>Some integrators also enforce the secondary constraint <span>$\psi$</span>, that is the time derivative of the algebraic constraint <span>$\phi$</span>. In this case, the system of equations is modified as follows</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) + u(t, q(t), p(t), \lambda(t)) + \bar{u} (t, q(t), p(t), \mu(t)) , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) + g(t, q(t), p(t), \lambda(t)) + \bar{g} (t, q(t), p(t), \mu(t)) , \\
0 &amp;= \phi (t, q(t), p(t)) , \\
0 &amp;= \psi (t, q(t), p(t), \dot{q} (t), \dot{p} (t)) .
\end{aligned}\]</p><p>The dynamical variables <span>$(q,p)$</span> with initial conditions <span>$(q(t_{0}) = q_{0}, p(t_{0}) = p_{0})$</span> take values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>. The algebraic variables <span>$(λ,μ)$</span> with initial condition <span>$(λ(t_{0}) = λ_{0}, μ(t_{0}) = μ_{0})$</span> take values in <span>$\mathbb{R}^{m} \times \mathbb{R}^{m}$</span>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">PDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, ics::NamedTuple; kwargs...)
PDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable, μ₀::StateVariable = zero(λ₀); kwargs...)
PDAEProblem(v, f, u, g, ϕ, tspan, tstep, ics::NamedTuple; kwargs...)
PDAEProblem(v, f, u, g, ϕ, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable; kwargs...)</code></pre><p>The functions <code>v</code> and <code>f</code> compute the vector field, <code>u</code> and <code>g</code> compute the projections, and <code>ϕ</code> provides the algebraic constraint. The functions <code>ψ</code>, <code>ū</code> and <code>ḡ</code> are optional and provide the secondary constraint and the corresponding projection.</p><p><code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entries <code>q</code>, <code>p</code>, <code>λ</code> and <code>μ</code>. The initial conditions <code>q₀</code>, <code>p₀</code>, <code>λ₀</code> and <code>μ₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>. For the interfaces of the functions <code>v</code>, <code>f</code>, <code>u</code>, <code>g</code>, <code>ϕ</code>, <code>ū</code>, <code>ḡ</code>, <code>ψ</code> see <a href="../equations/#GeometricEquations.PDAE"><code>PDAE</code></a>.</p><p>In addition to the standard keyword arguments for <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes, a <code>PDAEProblem</code> accepts functions <code>v̄</code> and <code>f̄</code> for the computation of initial guesses for the vector fields with default values <code>v̄ = v</code> and <code>f̄ = f</code>.</p><p><strong>Function Definitions</strong></p><p>The functions <code>v</code>, <code>f</code>, <code>u</code>, <code>g</code> and <code>ϕ</code> must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f(g, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end

function u(u, t, q, p, λ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function g(g, t, q, p, λ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function ϕ(ϕ, t, q, p, params)
    ϕ[1] = ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code>, <code>p</code> and <code>λ</code> are the current solution vectors, <code>v</code>, <code>f</code>, <code>u</code> and <code>g</code> are the vectors which hold the result of evaluating the vector fields <span>$v$</span> and <span>$f$</span>, the projections <span>$u$</span> and <span>$g$</span>, and <code>ϕ</code> holds the algebraic constraint <span>$\phi$</span>, evaluated on <code>t</code>, <code>q</code>, <code>p</code> and <code>λ</code>.</p><p>Some integrators also enforce the secondary constraint <span>$\psi$</span> and require the following additional functions</p><pre><code class="nohighlight hljs">function ū(u, t, q, p, μ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function ḡ(g, t, q, p, μ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function ψ(ψ, t, q, p, v, f, params)
    ψ[1] = ...
end</code></pre><p>With the above function definitions the <code>PDAEProblem</code> can be created by</p><pre><code class="language-julia hljs">tspan = (0.0, 1.0)
tstep = 0.1
q₀ = [1., 1.]
p₀ = [1., 0.]
λ₀ = [0.]
μ₀ = [0.]

prob = PDAEProblem(v, f, u, g, ϕ, tspan, tstep, q₀, p₀, λ₀)</code></pre><p>or</p><pre><code class="language-julia hljs">prob = PDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀, p₀, λ₀, μ₀)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/daes/pdae.jl#L309-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.HDAEProblem" href="#GeometricEquations.HDAEProblem"><code>GeometricEquations.HDAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>HDAEProblem</code>: Hamiltonian Differential Algebraic Equation</p><p>A Hamiltonian differential algebraic is an initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) + u(t, q(t), p(t), \lambda(t)) + \bar{u} (t, q(t), p(t), \mu(t)) , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) + g(t, q(t), p(t), \lambda(t)) + \bar{g} (t, q(t), p(t), \mu(t)) , \\
0 &amp;= \phi (t, q(t), p(t)) , \\
0 &amp;= \psi (t, q(t), p(t), \dot{q}(t), \dot{p}(t)) ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span>, <span>$u$</span>, <span>$\bar{u}$</span> and <span>$f$</span>, <span>$g$</span>, <span>$\bar{g}$</span>, primary constraint <span>$\phi(q,p)=0$</span> and secondary constraint <span>$\psi(q,p,\dot{q},\dot{p})=0$</span>.</p><p>The dynamical variables <span>$(q,p)$</span> with initial conditions <span>$(q(t_{0}) = q_{0}, p(t_{0}) = p_{0})$</span> take values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>. The algebraic variables <span>$(λ,μ)$</span> with initial condition <span>$(λ(t_{0}) = λ_{0}, μ(t_{0}) = μ_{0})$</span> take values in <span>$\mathbb{R}^{m} \times \mathbb{R}^{m}$</span>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, ics::NamedTuple; kwargs...)
HDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable, μ₀::StateVariable = zero(λ₀); kwargs...)
HDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, ics::NamedTuple; kwargs...)
HDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable; kwargs...)</code></pre><p>The functions <code>v</code> and <code>f</code> compute the vector field, <code>u</code> and <code>g</code> compute the projections, <code>ϕ</code> provides the algebraic constraint and <code>h</code> the Hamiltonian. The functions <code>ψ</code>, <code>ū</code> and <code>ḡ</code> are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.</p><p><code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entries <code>q</code>, <code>p</code>, <code>λ</code> and <code>μ</code>. The initial conditions <code>q₀</code>, <code>p₀</code>, <code>λ₀</code> and <code>μ₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>. For the interfaces of the functions <code>v</code>, <code>f</code>, <code>u</code>, <code>g</code>, <code>ϕ</code>, <code>ū</code>, <code>ḡ</code>, <code>ψ</code>, and <code>h</code> see <a href="../equations/#GeometricEquations.HDAE"><code>HDAE</code></a>.</p><p>In addition to the standard keyword arguments for <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes, a <code>HDAEProblem</code> accepts functions <code>v̄</code> and <code>f̄</code> for the computation of initial guesses for the vector fields with default values <code>v̄ = v</code> and <code>f̄ = f</code>.</p><p><strong>Function Definitions</strong></p><p>The functions <code>v</code>, <code>f</code>, <code>u</code>, <code>g</code>, <code>ϕ</code> and <code>h</code> must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f(g, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end

function u(u, t, q, p, λ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function g(g, t, q, p, λ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function ϕ(ϕ, t, q, p, params)
    ϕ[1] = ...
end

function h(t, q, p, params)
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code>, <code>p</code>, <code>λ</code> and <code>μ</code> are the current solution vectors, <code>v</code>, <code>f</code>, <code>u</code> and <code>g</code> are the vectors which hold the result of evaluating the vector fields <span>$v$</span> and <span>$f$</span>, the projections on the primary constraint <span>$u$</span> and <span>$g$</span>,  <code>ϕ</code> holds the algebraic constraint <span>$\phi$</span>, and <code>h</code> returns the Hamiltonian of the system, all evaluated on <code>t</code>, <code>q</code>, <code>p</code> and <code>λ</code>.</p><p>Some integrators also enforce the secondary constraint <span>$\psi$</span> and require the following additional functions</p><pre><code class="nohighlight hljs">function ū(u, t, q, p, μ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function ḡ(g, t, q, p, μ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function ψ(ψ, t, q, p, v, f, params)
    ψ[1] = ...
end</code></pre><p>With the above function definitions the <code>HDAEProblem</code> can be created by</p><pre><code class="language-julia hljs">tspan = (0.0, 1.0)
tstep = 0.1
q₀ = [1., 1.]
p₀ = [1., 0.]
λ₀ = [0.]
μ₀ = [0.]

prob = HDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, q₀, p₀, λ₀)</code></pre><p>or</p><pre><code class="language-julia hljs">prob = HDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, q₀, p₀, λ₀, μ₀)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/daes/hdae.jl#L324-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.IDAEProblem" href="#GeometricEquations.IDAEProblem"><code>GeometricEquations.IDAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>IDAEProblem</code>: Implicit Differential Algebraic Equation Problem</p><p>An implicit differential algebraic initial value problem takes the form</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + u(t, q(t), v(t), p(t), \lambda(t)) , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), v(t), p(t), \lambda(t)) , \\
p(t) &amp;= ϑ(t, q(t), v(t)) , \\
0 &amp;= \phi (t, q(t), v(t), p(t)) ,
\end{aligned}\]</p><p>with force field <span>$f$</span>, the momentum defined by <span>$ϑ$</span>, projections <span>$u$</span> and <span>$g$</span>, algebraic constraint <span>$\phi(t,q,v,p)=0$</span>.</p><p>Some integrators also enforce the secondary constraint <span>$\psi$</span>, that is the time derivative of the algebraic constraint <span>$\phi$</span>. In this case, the system of equations is modified as follows</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + u(t, q(t), v(t), p(t), \lambda(t)) + \bar{u} (t, q(t), v(t), p(t), \mu(t)) , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), v(t), p(t), \lambda(t)) + \bar{g} (t, q(t), v(t), p(t), \mu(t)) , \\
p(t) &amp;= ϑ(t, q(t), v(t)) , &amp;&amp; \\
0 &amp;= \phi (t, q(t), v(t), p(t)) , \\
0 &amp;= \psi (t, q(t), v(t), p(t), \dot{q} (t), \dot{p} (t)) .
\end{aligned}\]</p><p>The dynamical variables <span>$(q,p)$</span> with initial conditions <span>$(q(t_{0}) = q_{0}, p(t_{0}) = p_{0})$</span> take values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>. The algebraic variables <span>$(λ,μ)$</span> with initial condition <span>$(λ(t_{0}) = λ_{0}, μ(t_{0}) = μ_{0})$</span> take values in <span>$\mathbb{R}^{m} \times \mathbb{R}^{m}$</span>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">IDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, ics; kwargs...)
IDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀), μ₀::StateVariable = zero(λ₀); kwargs...)
IDAEProblem(ϑ, f, u, g, ϕ, tspan, tstep, ics; kwargs...)
IDAEProblem(ϑ, f, u, g, ϕ, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)</code></pre><p>The function <code>ϑ</code> computes the momentum, <code>f</code> computes the force field, <code>u</code> and <code>g</code> compute the projections, and <code>ϕ</code> provides the algebraic constraint. The functions <code>ψ</code>, <code>ū</code> and <code>ḡ</code> are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.</p><p><code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entries <code>q</code> and <code>p</code>. The initial conditions <code>q₀</code>, <code>p₀</code>, <code>λ₀</code> and <code>μ₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>. For the interfaces of the functions <code>ϑ</code>, <code>f</code>, <code>u</code>, <code>g</code>, <code>ϕ</code>, <code>ū</code>, <code>ḡ</code>, <code>ψ</code> see <a href="../equations/#GeometricEquations.IDAE"><code>IDAE</code></a>.</p><p>In addition to the standard keyword arguments for <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes, an <code>IDAEProblem</code> accepts functions <code>v̄</code> and <code>f̄</code> for the computation of initial guesses for the vector fields with default values <code>v̄ = _idae_default_v̄</code> and <code>f̄ = f</code>.</p><p><strong>Function Definitions</strong></p><p>The functions <code>ϑ</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">function ϑ(p, t, q, v, params)
    p[1] = ...
    p[2] = ...
    ...
end

function f(f, t, q, v, params)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the current velocity and <code>f</code> and <code>p</code> are the vectors which hold the result of evaluating the functions <span>$f$</span> and <span>$ϑ$</span> on <code>t</code>, <code>q</code> and <code>v</code>. The funtions <code>g</code>, <code>v̄</code> and <code>f̄</code> are specified by</p><pre><code class="language-julia hljs">function u(u, t, q, v, p, λ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function g(g, t, q, v, p, λ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function v̄(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f̄(f, t, q, v, params)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>Some integrators also enforce the secondary constraint <span>$\psi$</span> and require the following additional functions</p><pre><code class="nohighlight hljs">function ū(u, t, q, v, p, μ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function ḡ(g, t, q, v, p, μ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function ψ(ψ, t, q, v, p, q̇, ṗ, params)
    ψ[1] = ...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/daes/idae.jl#L324-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.LDAEProblem" href="#GeometricEquations.LDAEProblem"><code>GeometricEquations.LDAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LDAEProblem</code>: Lagrangian Differential Algebraic Equation Problem</p><p>A special case of an implicit initial value problem is a Lagrangian differential algebraic equation of the form</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + u(t, q(t), v(t), p(t), \lambda(t)) + \bar{u} (t, q(t), v(t), p(t), \mu(t)) , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), v(t), p(t), \lambda(t)) + \bar{g} (t, q(t), v(t), p(t), \mu(t)) , \\
p(t) &amp;= ϑ(t, q(t), v(t)) , \\
0 &amp;= \phi (t, q(t), v(t), p(t)) , \\
0 &amp;= \psi (t, q(t), v(t), p(t), \dot{q}(t), \dot{p}(t)) ,
\end{aligned}\]</p><p>with momentum <span>$p$</span> and force field <span>$f$</span>, given by</p><p class="math-container">\[\begin{aligned}
p &amp;= \frac{\partial L}{\partial v} (q,v) , &amp;
f &amp;= \frac{\partial L}{\partial q} (q,v) ,
\end{aligned}\]</p><p>projection fields <span>$u$</span>, <span>$\bar{u}$</span> and <span>$g$</span>, <span>$\bar{g}$</span>. This is a special case of a differential algebraic equation with dynamical variables <span>$(q,p)$</span> and algebraic variables <span>$v$</span>, <span>$\lambda$</span> and <span>$\mu$</span>.</p><p>The dynamical variables <span>$(q,p)$</span> with initial conditions <span>$(q(t_{0}) = q_{0}, p(t_{0}) = p_{0})$</span> take values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>. The algebraic variables <span>$(λ,μ)$</span> with initial condition <span>$(λ(t_{0}) = λ_{0}, μ(t_{0}) = μ_{0})$</span> take values in <span>$\mathbb{R}^{m} \times \mathbb{R}^{m}$</span>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">LDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, ics; kwargs...)
LDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀), μ₀::StateVariable = zero(λ₀); kwargs...)
LDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, ics; kwargs...)
LDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)</code></pre><p>The function <code>ϑ</code> computes the momentum, <code>f</code> computes the force field, <code>u</code> and <code>g</code> compute the projections, and <code>ϕ</code> provides the algebraic constraint. The functions <code>ψ</code>, <code>ū</code> and <code>ḡ</code> are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.</p><p><code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entries <code>q</code> and <code>p</code>. The initial conditions <code>q₀</code>, <code>p₀</code>, <code>λ₀</code> and <code>μ₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>. For the interfaces of the functions <code>ϑ</code>, <code>f</code>, <code>u</code>, <code>g</code>, <code>ϕ</code>, <code>ū</code>, <code>ḡ</code>, <code>ψ</code>, <code>ω</code> and <code>l</code> see <a href="../equations/#GeometricEquations.LDAE"><code>LDAE</code></a>.</p><p>In addition to the standard keyword arguments for <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes, a <code>LDAEProblem</code> accepts functions <code>v̄</code> and <code>f̄</code> for the computation of initial guesses for the vector fields with default values <code>v̄ = _ldae_default_v̄</code> and <code>f̄ = f</code>.</p><p><strong>Function Definitions</strong></p><p>The functions <code>ϑ</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">function ϑ(p, t, q, v, params)
    p[1] = ...
    p[2] = ...
    ...
end

function f(f, t, q, v, params)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the current velocity and <code>f</code> and <code>p</code> are the vectors which hold the result of evaluating the functions <span>$f$</span> and <span>$ϑ$</span> on <code>t</code>, <code>q</code> and <code>v</code>. The funtions <code>g</code>, <code>v̄</code> and <code>f̄</code> are specified by</p><pre><code class="language-julia hljs">function u(u, t, q, v, p, μ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function g(g, t, q, v, p, μ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function v̄(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f̄(f, t, q, v, params)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>and the functions <code>ω</code> and <code>l</code>, computing the symplectic matrix and the Lagrangian, have the following signature</p><pre><code class="language-julia hljs">function ω(f, t, q, v, params)
    ω[1,1] = ...
    ω[1,2] = ...
    ...
end

function l(t, q, v, params)
    return ...
end</code></pre><p>Some integrators also enforce the secondary constraint <span>$\psi$</span> and require the following additional functions</p><pre><code class="nohighlight hljs">function ū(u, t, q, v, p, μ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function ḡ(g, t, q, v, p, μ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function ψ(ψ, t, q, v, p, q̇, ṗ, params)
    ψ[1] = ...
end</code></pre><p>With the above function definitions the <code>LDAEProblem</code> can be created by</p><pre><code class="language-julia hljs">tspan = (0.0, 1.0)
tstep = 0.1
q₀ = [1., 1.]
p₀ = [1., 0.]
λ₀ = [0.]
μ₀ = [0.]

prob = LDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, q₀, p₀, λ₀)</code></pre><p>or</p><pre><code class="language-julia hljs">prob = LDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, q₀, p₀, λ₀, μ₀)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/daes/ldae.jl#L354-L405">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.SPDAEProblem" href="#GeometricEquations.SPDAEProblem"><code>GeometricEquations.SPDAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/daes/spdae.jl#L174">source</a></section></article><h2 id="Stochastic-Differential-Equations"><a class="docs-heading-anchor" href="#Stochastic-Differential-Equations">Stochastic Differential Equations</a><a id="Stochastic-Differential-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-Differential-Equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.SDEProblem" href="#GeometricEquations.SDEProblem"><code>GeometricEquations.SDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SDEProblem</code>: Stratonovich Stochastic Differential Equation Problem</p><p>Defines a stochastic differential initial value problem</p><p class="math-container">\[\begin{aligned}
dq (t) &amp;= v(t, q(t)) \, dt + B(t, q(t)) \circ dW , &amp; q(t_{0}) &amp;= q_{0} ,
\end{aligned}\]</p><p>with drift vector field <span>$v$</span>, diffusion matrix <span>$B$</span>, initial conditions <span>$q_{0}$</span>, the dynamical variable <span>$q$</span> taking values in <span>$\mathbb{R}^{d}$</span>, and the m-dimensional Wiener process W</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SDEProblem(v, B, tspan, tstep, ics::NamedTuple; kwargs...)
SDEProblem(v, B, tspan, tstep, q₀::StateVariable; kwargs...)</code></pre><p>where <code>v</code> is the function computing the vector field and <code>B</code> computes the diffusion matrix <code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entry <code>q</code>. The initial condition <code>q₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>.</p><p>For possible keyword arguments see the documentation on <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes.</p><p><strong>Function Definitions</strong></p><p>The functions <code>v</code> and <code>B</code>, providing the drift vector field and diffusion matrix. The function <code>v</code> must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, params)
    v[1] = ...
    v[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the vector which holds the result of evaluating the vector field <span>$v$</span> on <code>t</code> and <code>q</code>, and params are additional parameters. The function <code>B</code> should have a method with interface</p><pre><code class="language-julia hljs">function B(B, t, q, params)
    B[1,1] = ...
    ...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/sdes/sde.jl#L140-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.PSDEProblem" href="#GeometricEquations.PSDEProblem"><code>GeometricEquations.PSDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PSDEProblem</code>: Stratonovich Partitioned Stochastic Differential Equation Problem</p><p>A partitioned stochastic differential equations is an initial value problem of the form</p><p class="math-container">\[\begin{aligned}
dq (t) &amp;= v(t, q(t), p(t)) \, dt + B(t, q(t), p(t)) \circ dW , &amp; q(t_{0}) &amp;= q_{0} , \\
dp (t) &amp;= f(t, q(t), p(t)) \, dt + G(t, q(t), p(t)) \circ dW , &amp; p(t_{0}) &amp;= p_{0}
\end{aligned}\]</p><p>with the drift vector fields <span>$v$</span> and <span>$f$</span>, diffusion matrices <span>$B$</span> and <span>$G$</span>, initial conditions <span>$q_{0}$</span> and <span>$p_{0}$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>, and the m-dimensional Wiener process W</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">PSDEProblem(v, f, B, G, tspan, tstep, ics::NamedTuple; kwargs...)
PSDEProblem(v, f, B, G, tspan, tstep, q₀::StateVariable; p₀::StateVariable; kwargs...)</code></pre><p>where <code>v</code> and <code>f</code> are the functions computing the vector field and <code>B</code> and <code>G</code> compute the diffusion matrices, <code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entry <code>q</code>. The initial condition <code>q₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>.</p><p>For possible keyword arguments see the documentation on <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes.</p><p><strong>Function Definitions</strong></p><p>The functions <code>v</code>, <code>f</code>, <code>B</code> and <code>G</code>, providing the drift vector fields and diffusion matrices, each take five arguments, <code>v(v, t, q, p, params)</code>, <code>f(f, t, q, p, params)</code>, <code>B(B, t, q, p, params)</code> and <code>G(G, t, q, p, params)</code>, where <code>t</code> is the current time, <code>(q, p)</code> is the current solution, and <code>v</code>, <code>f</code>, <code>B</code> and <code>G</code> are the variables which hold the result of evaluating the vector fields <span>$v$</span>, <span>$f$</span> and the matrices <span>$B$</span>, <span>$G$</span> on <code>t</code> and <code>(q,p)</code>, and <code>params</code> are optional parameters.</p><p>The corresponding methods should have the following signatures:</p><pre><code class="language-julia hljs">function v(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f(f, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end

function B(B, t, q, p, params)
    B[1,1] = ...
    ...
end

function G(G, t, q, p, params)
    G[1,1] = ...
    ...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/sdes/psde.jl#L169-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricEquations.SPSDEProblem" href="#GeometricEquations.SPSDEProblem"><code>GeometricEquations.SPSDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SPSDEProblem</code>: Stratonovich Split Partitioned Stochastic Differential Equation Problem</p><p>Defines a partitioned stochastic differential initial value problem</p><p class="math-container">\[\begin{aligned}
dq (t) &amp;=   v(t, q(t), p(t)) \, dt + B(t, q(t), p(t)) \circ dW , &amp; q(t_{0}) &amp;= q_{0} , \\
dp (t) &amp;= [ f_1(t, q(t), p(t)) + f_2(t, q(t), p(t)) ] \, dt + [ G_1(t, q(t), p(t)) + G_2(t, q(t), p(t)) ] \circ dW , &amp; p(t_{0}) &amp;= p_{0} ,
\end{aligned}\]</p><p>with the drift vector fields <span>$v$</span> and <span>$f_i$</span>, diffusion matrices <span>$B$</span> and <span>$G_i$</span>, initial conditions <span>$q_{0}$</span> and <span>$p_{0}$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>, and the m-dimensional Wiener process W</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SPSDEProblem(v, f1, f2, B, G1, G2, tspan, tstep, ics::NamedTuple; kwargs...)
SPSDEProblem(v, f1, f2, B, G1, G2, tspan, tstep, q₀::StateVariable; p₀::StateVariable; kwargs...)</code></pre><p>where <code>v</code> and <code>f</code> are the functions computing the vector field and <code>Bᵢ</code> and <code>Gᵢ</code> compute the diffusion matrices, <code>tspan</code> is the time interval <code>(t₀,t₁)</code> for the problem to be solved in, <code>tstep</code> is the time step to be used in the simulation, and <code>ics</code> is a <code>NamedTuple</code> with entry <code>q</code>. The initial condition <code>q₀</code> can also be prescribed directly, with <code>StateVariable</code> an <code>AbstractArray{&lt;:Number}</code>.</p><p>For possible keyword arguments see the documentation on <a href="#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> subtypes.</p><p><strong>Function Definitions</strong></p><p>The functions <code>v</code>, <code>f1</code>, <code>f2</code>, <code>B</code>, <code>G1</code> and <code>G2</code>, providing the drift vector fields and diffusion matrices, all take five arguments, <code>(out, t, q, p, params)</code>.</p><pre><code class="language-julia hljs">function v(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f1(f, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end

function f2(f, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end

function B(B, t, q, p, params)
    B[1,1] = ...
    ...
end

function G1(G, t, q, p, params)
    G[1,1] = ...
    ...
end

function G2(G, t, q, p, params)
    G[1,1] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>(q,p)</code> is the current solution vector, and <code>v</code>, <code>f</code>, <code>B</code> and <code>G</code> are the variables which hold the result of evaluating the vector fields <span>$v$</span>, <span>$f$</span> and the matrices <span>$B_i$</span>, <span>$G_i$</span> on <code>(t,q,p)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/v0.14.3/src/sdes/spsde.jl#L201-L226">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../methods/">« Methods</a><a class="docs-footer-nextpage" href="../projections/">Projections »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 15 January 2024 15:34">Monday 15 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
