<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · GeometricIntegrators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GeometricIntegrators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Basic-usage"><span>Basic usage</span></a></li><li><a class="tocitem" href="#Equations"><span>Equations</span></a></li><li><a class="tocitem" href="#Integrators"><span>Integrators</span></a></li><li><a class="tocitem" href="#Overview-of-Available-Methods"><span>Overview of Available Methods</span></a></li></ul></li><li><a class="tocitem" href="../problems/">Problems</a></li><li><a class="tocitem" href="../methods/">Methods</a></li><li><span class="tocitem">Integrators</span><ul><li><a class="tocitem" href="../integrators/rk/">Runge-Kutta</a></li><li><a class="tocitem" href="../integrators/splitting/">Splitting</a></li><li><a class="tocitem" href="../integrators/variational/">Variational</a></li><li><a class="tocitem" href="../integrators/vprk/">VPRK</a></li><li><a class="tocitem" href="../integrators/spark/">SPARK</a></li><li><a class="tocitem" href="../integrators/dvi/">DVI</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../modules/methods/">Methods</a></li><li><a class="tocitem" href="../modules/integrators/">Integrators</a></li><li><a class="tocitem" href="../modules/equations/">Problems</a></li><li><a class="tocitem" href="../modules/solutions/">Solutions</a></li><li><a class="tocitem" href="../modules/rungekutta/">Runge-Kutta Tableaus</a></li><li><a class="tocitem" href="../modules/rungekutta_partitioned/">Partitioned Runge-Kutta Tableaus</a></li><li><a class="tocitem" href="../modules/spark/">SPARK Methods</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../developer/code_integration/">Code Integration</a></li><li><a class="tocitem" href="../developer/custom_integrators/">Custom Integrators</a></li><li><a class="tocitem" href="../developer/adaptive_time_stepping/">Adaptive Time Stepping</a></li></ul></li><li><a class="tocitem" href="../releasenotes/">Release Notes</a></li><li><a class="tocitem" href="../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../authors/">Authors</a></li><li><a class="tocitem" href="../LICENSE/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGNI/GeometricIntegrators.jl/blob/main/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>In this tutorial, we try to give an overview of the basic usage of GeometricIntegrators and its main components.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p><em>GeometricIntegrators.jl</em> can be installed using Julia&#39;s built-in package manager in the command line interface by</p><pre><code class="language-julia hljs">julia&gt; ]
(v1.9) pkg&gt; add GeometricIntegrators</code></pre><p>In a Jupyter notebook, <em>GeometricIntegrators.jl</em> can be installed by explicitly using the <code>Pkg</code> module as</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;GeometricIntegrators&quot;)</code></pre><p>This will install the library itself as well as all dependencies.</p><h2 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h2><p>In the simplest cases, the use of <code>GeometricIntegrators.jl</code> requires the construction of two objects, an equation and an integrator. For many standard methods, the integrator is implicitly selected by specifying an equation and a tableau.</p><p>Before any use, we need to load GeometricIntegrators,</p><pre><code class="language-julia hljs">using GeometricIntegrators</code></pre><p>Then we can create an ODE object for the equation <span>$\dot{x} (t) = x(t)$</span> with initial condition <span>$x(0) = 1$</span>, integration time span <span>$(0, 1)$</span> and a time step of <span>$\Delta t = 0.1$</span>,</p><pre><code class="language-julia hljs">prob = ODEProblem((ẋ, t, x, params) -&gt; ẋ[1] = x[1], (0.0, 1.0), 0.1, [1.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), (v = GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), NamedTuple(), (0.0, 1.0), 0.1, (q = [1.0],), NullParameters())</code></pre><p>create an integrator for this ODE, using the explicit Euler method</p><pre><code class="language-julia hljs">int = Integrator(prob, ExplicitEuler())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Integrator{ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, ExplicitEuler, GeometricIntegrators.Integrators.CacheDict{ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, ExplicitEuler}, NoSolver, NoInitialGuess, Nothing, SolutionStepODE{Float64, Float64, Vector{Float64}, Vector{Float64}, NamedTuple{(:t, :q, :v), Tuple{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}}}, NamedTuple{(), Tuple{}}, 2}}(ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), (v = GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), NamedTuple(), (0.0, 1.0), 0.1, (q = [1.0],), NullParameters()), ExplicitEuler(), GeometricIntegrators.Integrators.CacheDict{ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, ExplicitEuler}(ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), (v = GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), NamedTuple(), (0.0, 1.0), 0.1, (q = [1.0],), NullParameters()), ExplicitEuler(), Dict{UInt64, IntegratorCache}()), NoSolver(), NoInitialGuess(), nothing, SolutionStepODE{Float64, Float64, Vector{Float64}, Vector{Float64}, NamedTuple{(:t, :q, :v), Tuple{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}}}, NamedTuple{(), Tuple{}}, 2}([1.0], [1.0], [0.9048374180359585], [0.9048374180359585], [0.0], (t = [0.0, -0.1, -0.2], q = [[1.0], [0.9048374180359585], [0.8187307530779814]], v = [[1.0], [0.9048374180359585], [0.8187307530779814]]), NamedTuple()))</code></pre><p>and compute the solution,</p><pre><code class="language- hljs">sol = integrate(prob, int)</code></pre><p>Plot and compare with the exact solution</p><pre><code class="language- hljs">using Plots
plot(xlims=[0,1], xlab=&quot;t&quot;, ylab=&quot;x(t)&quot;, legend=:bottomright)
plot!(sol.t, sol.q[:,1], label=&quot;numeric&quot;)
plot!(sol.t, exp.(sol.t), label=&quot;exact&quot;)
savefig(&quot;images/tutorial-ode-1.png&quot;) # hide</code></pre><p><img src="images/tutorial-ode-1.png" alt/></p><h2 id="Equations"><a class="docs-heading-anchor" href="#Equations">Equations</a><a id="Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Equations" title="Permalink"></a></h2><p>In <em>GeometricIntegrators.jl</em> we distinguish between three basic types of equations:</p><ul><li>ordinary differential equations (ODEs),</li><li>differential algebraic equations (DAEs),</li><li>stochastic differential equations (SDEs).</li></ul><p>For each type, there are several subtypes</p><ul><li>standard equations (<a href="../modules/equations/#GeometricEquations.ODEProblem"><code>ODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.DAEProblem"><code>DAEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.SDEProblem"><code>SDEProblem</code></a>),</li><li>implicit equations (<a href="../modules/equations/#GeometricEquations.IODEProblem"><code>IODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.IDAEProblem"><code>IDAEProblem</code></a>),</li><li>partitioned equations (<a href="../modules/equations/#GeometricEquations.PODEProblem"><code>PODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.PDAEProblem"><code>PDAEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.PSDEProblem"><code>PSDEProblem</code></a>),</li><li>Hamiltonian equations (<a href="../modules/equations/#GeometricEquations.HODEProblem"><code>HODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.HDAEProblem"><code>HDAEProblem</code></a>),</li><li>Lagrangian equations (<a href="../modules/equations/#GeometricEquations.LODEProblem"><code>LODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.LDAEProblem"><code>LDAEProblem</code></a>),</li><li>split equations (<a href="../modules/equations/#GeometricEquations.SODEProblem"><code>SODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.SPDAEProblem"><code>SPDAEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.SPSDEProblem"><code>SPSDEProblem</code></a>).</li></ul><h4 id="Ordinary-differential-equations"><a class="docs-heading-anchor" href="#Ordinary-differential-equations">Ordinary differential equations</a><a id="Ordinary-differential-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Ordinary-differential-equations" title="Permalink"></a></h4><p>Consider an ODE of the form</p><p class="math-container">\[\dot{x} (t) = v(t, x(t)) ,\]</p><p>where <span>$\dot{x}$</span> denotes the derivative of <span>$x$</span> and <span>$f$</span> the vector field of the equation, which is assumed to depend on both <span>$t$</span> and <span>$x$</span>. In the following, we will solve the mathematical pendulum, whose equations are given by</p><p class="math-container">\[\begin{pmatrix}
\dot{x}_1 \\
\dot{x}_2 \\
\end{pmatrix}
=
\begin{pmatrix}
x_2 \\
\sin (x_1) \\
\end{pmatrix} .\]</p><p>Together with the integration time span <code>(t₀,t₁)</code> and the time step, an ODE defines an <code>ODEProblem</code>.</p><p>The user needs to specify a function <code>ẋ</code> that computes the vector field and must have the interface</p><pre><code class="language-julia hljs">function ẋ(v, t, x, params)
    v[1] = ...
    v[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the vector which holds the result of evaluating the vector field <span>$v$</span> on <code>t</code> and <code>q</code>, and <code>params</code> is a <code>NamedTuple</code> of constant parameters on which the vector field may depend.</p><p>For the mathematical pendulum, this could look as follows:</p><pre><code class="language-julia hljs">function ẋ(v, t, x, params)
    v[1] = x[2]
    v[2] = sin(x[1])
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ẋ (generic function with 1 method)</code></pre><p>An <code>ODEProblem</code> is instantiated by</p><pre><code class="nohighlight hljs">ODEProblem(&lt;vector field&gt;, &lt;time span&gt;, &lt;time step&gt;, &lt;initial conditions&gt;; kwargs...)</code></pre><p>so to create and <code>ODEProblem</code>, one only needs to pass the above function <code>ẋ</code>, a tuple <code>tspan</code> containing the start and end times of the integration, the time step <code>tstep</code> as well as an initial condition:</p><pre><code class="language-julia hljs">tspan = (0.0, 10.0)
tstep = 0.1
x₀ = [acos(0.4), 0.0]

ode = ODEProblem(ẋ, tspan, tstep, x₀)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), (v = GeometricEquations.var&quot;#13#14&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), NamedTuple(), (0.0, 10.0), 0.1, (q = [1.1592794807274085, 0.0],), NullParameters())</code></pre><p>The full constructor would look like</p><pre><code class="language-julia hljs">ode = ODEProblem(ẋ, tspan, tstep, x₀; invariants = NullInvariants(),
                 parameters = NullParameters(), periodicity = NullPeriodicity())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), (v = GeometricEquations.var&quot;#13#14&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), NamedTuple(), (0.0, 10.0), 0.1, (q = [1.1592794807274085, 0.0],), NullParameters())</code></pre><p>where all keyword arguments, namely invariants, parameters and periodicity, are by default initialized to be absent.</p><h4 id="Partitioned-ordinary-differential-equations"><a class="docs-heading-anchor" href="#Partitioned-ordinary-differential-equations">Partitioned ordinary differential equations</a><a id="Partitioned-ordinary-differential-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioned-ordinary-differential-equations" title="Permalink"></a></h4><p>The pendulum problem is a Hamiltonian system that can also be expressed as</p><p class="math-container">\[\dot{q} = \frac{\partial H}{\partial p} = p ,
\hspace{3em}
\dot{p} = - \frac{\partial H}{\partial q} = \sin (q) ,
\hspace{3em}
H (q,p) = \frac{1}{2} p^2 + \cos (q) .\]</p><p>This structure, namely the partitioning into two sets of variables <span>$(q,p)$</span> instead of <span>$x$</span>, can be exploited for more efficient integration. Such equations can be defined in terms of a partitioned ODE, where the vector fields are specified separately,</p><pre><code class="language-julia hljs">function q̇(v, t, q, p, params)
    v[1] = p[1]
end

function ṗ(f, t, q, p, params)
    f[1] = sin(q[1])
end

pode = PODEProblem(q̇, ṗ, (0.0, 25.0), 0.1, [acos(0.4)], [0.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PODEProblem{Float64, Float64, Vector{Float64}, PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v, :f), Tuple{GeometricEquations.var&quot;#75#76&quot;{PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}, GeometricEquations.var&quot;#77#78&quot;{PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q, :p), Tuple{Vector{Float64}, Vector{Float64}}}, NullParameters}(PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}(Main.q̇, Main.ṗ, NullInvariants(), NullParameters(), NullPeriodicity()), (v = GeometricEquations.var&quot;#75#76&quot;{PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}(Main.q̇, Main.ṗ, NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()), f = GeometricEquations.var&quot;#77#78&quot;{PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}(Main.q̇, Main.ṗ, NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters())), NamedTuple(), (0.0, 25.0), 0.1, (q = [1.1592794807274085], p = [0.0]), NullParameters())</code></pre><p>The first two arguments to the PODE constructor are the functions that determine the vector fields of the equations <span>$\dot{q} (t) = v(t, q(t), p(t))$</span> and <span>$\dot{p} (t) = f(t, q(t), p(t))$</span>. The third and fourth argument determines the initial conditions of <span>$q$</span> and <span>$p$</span>, respectively. The functions defining the vector field have to take four arguments, the current time <code>t</code>, the current solution vectors <code>q</code> and <code>p</code> and the output vector <code>v</code> or <code>f</code>.</p><h2 id="Integrators"><a class="docs-heading-anchor" href="#Integrators">Integrators</a><a id="Integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators" title="Permalink"></a></h2><p>We support a number of standard integrators (geometric and non-geometric) like explicit, implicit and partitioned Runge-Kutta methods, splitting methods and general linear methods (<em>planned</em>).</p><p>In order to instantiate many of the standard integrators, one needs to specify an ODEProblem, a method and a timestep, e.g.,</p><pre><code class="language-julia hljs">int = Integrator(ode, ExplicitEuler())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Integrator{ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, ExplicitEuler, GeometricIntegrators.Integrators.CacheDict{ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, ExplicitEuler}, NoSolver, NoInitialGuess, Nothing, SolutionStepODE{Float64, Float64, Vector{Float64}, Vector{Float64}, NamedTuple{(:t, :q, :v), Tuple{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}}}, NamedTuple{(), Tuple{}}, 2}}(ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), (v = GeometricEquations.var&quot;#13#14&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), NamedTuple(), (0.0, 10.0), 0.1, (q = [1.1592794807274085, 0.0],), NullParameters()), ExplicitEuler(), GeometricIntegrators.Integrators.CacheDict{ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, ExplicitEuler}(ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), (v = GeometricEquations.var&quot;#13#14&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), NamedTuple(), (0.0, 10.0), 0.1, (q = [1.1592794807274085, 0.0],), NullParameters()), ExplicitEuler(), Dict{UInt64, IntegratorCache}()), NoSolver(), NoInitialGuess(), nothing, SolutionStepODE{Float64, Float64, Vector{Float64}, Vector{Float64}, NamedTuple{(:t, :q, :v), Tuple{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}}}, NamedTuple{(), Tuple{}}, 2}([1.1592794807274085, 0.0], [0.0, 0.916515138991168], [1.1638635809409579, -0.09171243446016944], [-0.09171243446016944, 0.9183391428584442], [0.0, 0.0], (t = [0.0, -0.1, -0.2], q = [[1.1592794807274085, 0.0], [1.1638635809409579, -0.09171243446016944], [1.1776340310073226, -0.18378604239732177]], v = [[0.0, 0.916515138991168], [-0.09171243446016944, 0.9183391428584442], [-0.18378604239732177, 0.923702169043022]]), NamedTuple()))</code></pre><p>In order to run the integrator, the <code>integrate()</code> functions is called, passing an integrator object and the number of time steps to integrate:</p><pre><code class="language- hljs">sol = integrate(ode, int)</code></pre><p>The integrate function automatically creates an appropriate solution object, that contains the result of the integration.</p><pre><code class="language- hljs">plot(sol.q[:,1], sol.q[:,2], xlab=&quot;x(t)&quot;, ylab=&quot;y(t)&quot;, legend=:none)
savefig(&quot;images/tutorial-ode-2.png&quot;); nothing # hide</code></pre><p><img src="images/tutorial-ode-2.png" alt/></p><p>Observe that the explicit Euler method is not well suited for integrating this system. The solutions drifts away although it should follow closed orbits.</p><p>For a Hamiltonian system, defined as a PODE, a different methods might be more appropriate, for example a symplectic Euler method,</p><pre><code class="language- hljs">int = Integrator(pode, LobattoIIIAIIIB(2))
sol = integrate(pode, int)</code></pre><p>This creates a different integrator, which exploits the partitioned structure of the system. The solution return by the integrate step will also be a different solution, adapted to the partitioned system.</p><pre><code class="language- hljs">plot(sol.q[:,1], sol.p[:,1], xlab=&quot;q(t)&quot;, ylab=&quot;p(t)&quot;, legend=:none)
savefig(&quot;images/tutorial-pode-1.png&quot;); nothing # hide</code></pre><p><img src="images/tutorial-pode-1.png" alt/></p><p>Moreover, this method respects the Hamiltonian structure of the system, resulting in closed orbits following the contours of the system&#39;s energy.</p><h2 id="Overview-of-Available-Methods"><a class="docs-heading-anchor" href="#Overview-of-Available-Methods">Overview of Available Methods</a><a id="Overview-of-Available-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-Available-Methods" title="Permalink"></a></h2><p>GeometricIntegrators.jl provides a plethora of geometric integrators as well as non-geometric integrators (mainly for testing and benchmarking purposes). Most integrators can be selected by a simple method type, which also stores parameters. Some integrator families can also be selected by specifying a tableau, that is a Butcher tableau for Runge-Kutta methods, a pair of tableaus for partitioned Runge-Kutta and VPRK methods, or generalizations thereof for SPARK methods. Other integrators, such as Galerkin variational integrators require the specification of a basis and a quadrature rule.</p><p>The correct integrator is automatically selected based on the method and problem types by calling</p><pre><code class="nohighlight hljs">Integrator(problem, method)</code></pre><p>As an example, consider an ODE like the harmonic oscillator, which is included in GeometricEquations.jl:</p><pre><code class="language-julia hljs">using GeometricIntegrators
using GeometricEquations.Tests.HarmonicOscillator</code></pre><pre><code class="language- hljs">prob = harmonic_oscillator_ode()</code></pre><p>Create an explicit Euler method:</p><pre><code class="language-julia hljs">method = ExplicitEuler()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ExplicitEuler()</code></pre><p>And now create an Integrator with the general <code>Integrator</code> constructor:</p><pre><code class="language-julia hljs">int = Integrator(prob, method)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Integrator{ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, ExplicitEuler, GeometricIntegrators.Integrators.CacheDict{ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, ExplicitEuler}, NoSolver, NoInitialGuess, Nothing, SolutionStepODE{Float64, Float64, Vector{Float64}, Vector{Float64}, NamedTuple{(:t, :q, :v), Tuple{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}}}, NamedTuple{(), Tuple{}}, 2}}(ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), (v = GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), NamedTuple(), (0.0, 1.0), 0.1, (q = [1.0],), NullParameters()), ExplicitEuler(), GeometricIntegrators.Integrators.CacheDict{ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, ExplicitEuler}(ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), (v = GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), NamedTuple(), (0.0, 1.0), 0.1, (q = [1.0],), NullParameters()), ExplicitEuler(), Dict{UInt64, IntegratorCache}()), NoSolver(), NoInitialGuess(), nothing, SolutionStepODE{Float64, Float64, Vector{Float64}, Vector{Float64}, NamedTuple{(:t, :q, :v), Tuple{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}}}, NamedTuple{(), Tuple{}}, 2}([1.0], [1.0], [0.9048374180359585], [0.9048374180359585], [0.0], (t = [0.0, -0.1, -0.2], q = [[1.0], [0.9048374180359585], [0.8187307530779814]], v = [[1.0], [0.9048374180359585], [0.8187307530779814]]), NamedTuple()))</code></pre><p>We see that we obtained an <code>IntegratorERK</code>, i.e., an explicit Runge-Kutta integrator. If instead we choose the implicit Euler method:</p><pre><code class="language-julia hljs">method = ImplicitEuler()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ImplicitEuler()</code></pre><p>the general <code>Integrator</code> constructor creates a different integrator:</p><pre><code class="language-julia hljs">int = Integrator(prob, method)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Integrator{ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, ImplicitEuler, GeometricIntegrators.Integrators.CacheDict{ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, ImplicitEuler}, SimpleSolvers.NewtonSolver{Float64, Vector{Float64}, SimpleSolvers.JacobianAutodiff{Float64, ForwardDiff.JacobianConfig{Nothing, Float64, 1, Tuple{Vector{ForwardDiff.Dual{Nothing, Float64, 1}}, Vector{ForwardDiff.Dual{Nothing, Float64, 1}}}}, Vector{Float64}}, SimpleSolvers.LUSolver{Float64}, SimpleSolvers.BacktrackingState{SimpleSolvers.Options{Float64}, Float64}}, HermiteExtrapolation, Nothing, SolutionStepODE{Float64, Float64, Vector{Float64}, Vector{Float64}, NamedTuple{(:t, :q, :v), Tuple{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}}}, NamedTuple{(), Tuple{}}, 2}}(ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), (v = GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), NamedTuple(), (0.0, 1.0), 0.1, (q = [1.0],), NullParameters()), ImplicitEuler(), GeometricIntegrators.Integrators.CacheDict{ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, ImplicitEuler}(ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), (v = GeometricEquations.var&quot;#13#14&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), NamedTuple(), (0.0, 1.0), 0.1, (q = [1.0],), NullParameters()), ImplicitEuler(), Dict{UInt64, IntegratorCache}(0xf4740ba6a694e9d5 =&gt; GeometricIntegrators.Integrators.IntegratorCacheImplicitEuler{Float64, 1}([0.0], [0.0], [0.0], [0.0], [0.0]))), SimpleSolvers.NewtonSolver{Float64, Vector{Float64}, SimpleSolvers.JacobianAutodiff{Float64, ForwardDiff.JacobianConfig{Nothing, Float64, 1, Tuple{Vector{ForwardDiff.Dual{Nothing, Float64, 1}}, Vector{ForwardDiff.Dual{Nothing, Float64, 1}}}}, Vector{Float64}}, SimpleSolvers.LUSolver{Float64}, SimpleSolvers.BacktrackingState{SimpleSolvers.Options{Float64}, Float64}}(SimpleSolvers.JacobianAutodiff{Float64, ForwardDiff.JacobianConfig{Nothing, Float64, 1, Tuple{Vector{ForwardDiff.Dual{Nothing, Float64, 1}}, Vector{ForwardDiff.Dual{Nothing, Float64, 1}}}}, Vector{Float64}}(ForwardDiff.JacobianConfig{Nothing, Float64, 1, Tuple{Vector{ForwardDiff.Dual{Nothing, Float64, 1}}, Vector{ForwardDiff.Dual{Nothing, Float64, 1}}}}((Partials(1.0,),), (ForwardDiff.Dual{Nothing, Float64, 1}[Dual{Nothing}(6.9226473046145e-310,6.9226457558302e-310)], ForwardDiff.Dual{Nothing, Float64, 1}[Dual{Nothing}(NaN,6.92266764145215e-310)])), [0.0]), SimpleSolvers.LUSolver{Float64}(1, [0.0;;], [1], [1], 1), Backtracking, SimpleSolvers.NewtonSolverCache{Float64, Vector{Float64}, Matrix{Float64}}([0.0], [0.0], [0.0], [0.0], [0.0], [NaN;;]),                 x_abstol = -Inf
                x_reltol = 4.440892098500626e-16
                x_suctol = 4.440892098500626e-16
                f_abstol = 1.0e-50
                f_reltol = 4.440892098500626e-16
                f_suctol = 4.440892098500626e-16
                f_mindec = 0.0001
                g_restol = 1.4901161193847656e-8
          x_abstol_break = Inf
          x_reltol_break = Inf
          f_abstol_break = Inf
          f_reltol_break = Inf
          g_restol_break = Inf
           f_calls_limit = 0
           g_calls_limit = 0
           h_calls_limit = 0
       allow_f_increases = true
          min_iterations = 1
          max_iterations = 1000
         warn_iterations = 1000
              show_trace = false
             store_trace = false
          extended_trace = false
              show_every = 1
               verbosity = 1
,     i=   0,   rxₐ=0.00000000e+00,   rxᵣ=0.00000000e+00,   rfₐ=0.00000000e+00,   rfᵣ=0.00000000e+00), HermiteExtrapolation(), nothing, SolutionStepODE{Float64, Float64, Vector{Float64}, Vector{Float64}, NamedTuple{(:t, :q, :v), Tuple{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}, OffsetArrays.OffsetVector{Vector{Float64}, Vector{Vector{Float64}}}}}, NamedTuple{(), Tuple{}}, 2}([1.0], [1.0], [0.9048374180359585], [0.9048374180359585], [0.0], (t = [0.0, -0.1, -0.2], q = [[1.0], [0.9048374180359585], [0.8187307530779814]], v = [[1.0], [0.9048374180359585], [0.8187307530779814]]), NamedTuple()))</code></pre><p>namely an <code>IntegratorFIRK</code>, i.e., a fully implicit Runge-Kutta integrator.</p><p>GeometricIntegrators automatically detects if a Runge-Kutta tableau is explicit, diagonally implicit or fully implicity and creates the corresponding Integrator.</p><p>Certain Runge-Kutta method such as Gauß, Radau and Lobatto methods are available for an arbitrary number of stages. Here the number of stages has to be speficied</p><pre><code class="language-julia hljs">int = Integrator(prob, Gauss(1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Implicit Runge-Kutta Integrator with:
   Timestep: 0.1
   Tableau:  Gauss with 1 stage and order 2
   
 0.5 │ 0.5
─────┼─────
     │ 1.0

</code></pre><p>Special integrators, such as Vartiational Partitioned Runge-Kutta (VPRK) methods, can be initialised by providing one or two tableaus, that is</p><pre><code class="language- hljs">method = VPRK(TableauGauss(1))</code></pre><p>or</p><pre><code class="language- hljs">method = VPRK(TableauLobattoIIIA(2), TableauLobattoIIIB(2))</code></pre><p>For standard tableaus there also exist shortcuts, such as</p><pre><code class="language-julia hljs">method = VPRKGauss(1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Variational Partitioned Runge-Kutta Method with Tableau: SymplecticGauss with 1 stage and order 1

 0.5 │ 0.5
─────┼─────
     │ 1.0


 0.5 │ 0.5
─────┼─────
     │ 1.0

</code></pre><p>or</p><pre><code class="language-julia hljs">method = VPRKLobattoIIIAIIIB(2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Variational Partitioned Runge-Kutta Method with Tableau: LobattoIIIAIIIB2 with 2 stages and order 2

 0.0 │ 0.0  0.0
 1.0 │ 0.5  0.5
─────┼──────────
     │ 0.5  0.5


 0.0 │ 0.5  0.0
 1.0 │ 0.5  0.0
─────┼──────────
     │ 0.5  0.5

</code></pre><p>For the purpose of a complete example, consider again the harmonic oscillator:</p><pre><code class="language-example hljs">prob = harmonic_oscillator_iode()</code></pre><p>Create a VPRK tableau that uses Gauss-Legendre Runge-Kutta coefficients with two stages:</p><pre><code class="language-example hljs">method = VPRKGauss(2)</code></pre><p>If we call the <code>Integrator</code> constructor,</p><pre><code class="language-example hljs">int = Integrator(prob, method)</code></pre><p>we obtain a <code>IntegratorVPRK</code>.</p><p>Once an integrator is obtained, we can just call the function</p><pre><code class="nohighlight hljs">integrate(problem, integrator)</code></pre><p>to perform the actual integration steps, where <code>ntime</code> defines the number of steps to integrate:</p><pre><code class="language- hljs">int = Integrator(prob, ExplicitEuler())
sol = integrate(prob, int)</code></pre><p>The <code>integrate</code> function returns a solution object that stores the solution for each time step. If the solution object is created manually, there exists a function</p><pre><code class="nohighlight hljs">integrate!(integrator, solution)</code></pre><p>that operates on an existing solution.</p><h3 id="Integrators-for-ODEs"><a class="docs-heading-anchor" href="#Integrators-for-ODEs">Integrators for ODEs</a><a id="Integrators-for-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators-for-ODEs" title="Permalink"></a></h3><p>The main method types for ODEs currently implemented are Runge-Kutta methods and splitting methods.</p><h4 id="Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Runge-Kutta-Methods">Runge-Kutta Methods</a><a id="Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Runge-Kutta-Methods" title="Permalink"></a></h4><p>Any Runge-Kutta method can be selected by the <a href="../modules/methods/#GeometricIntegrators.Methods.RK-Tuple{Tableau}"><code>RK</code></a> method</p><pre><code class="language-julia hljs">rk = RK(tableau)</code></pre><p>where <code>tableau</code> is any tableau from <a href="../modules/rungekutta/#RungeKuttaTableaus">RungeKutta.Tableaus</a>. For most tableaus there also exist explicit shortcuts to select the method. These are listed in the following.</p><h4 id="Explicit-Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Explicit-Runge-Kutta-Methods">Explicit Runge-Kutta Methods</a><a id="Explicit-Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-Runge-Kutta-Methods" title="Permalink"></a></h4><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="@ref"><code>ExplicitEuler</code></a></td><td style="text-align: left">1</td><td style="text-align: left">Explicit / Forward Euler</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.ExplicitMidpoint"><code>ExplicitMidpoint</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Explicit Midpoint</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Heun2"><code>Heun2</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Heun&#39;s Method of order two</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Heun3"><code>Heun3</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Heun&#39;s Method of order three</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Ralston2"><code>Ralston2</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Ralston&#39;s Method of order two</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Ralston3"><code>Ralston3</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Ralston&#39;s Method of order three</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Runge2"><code>Runge2</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Runge&#39;s Method</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Kutta3"><code>Kutta3</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Kutta&#39;s Method</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RK416"><code>RK416</code></a></td><td style="text-align: left">4</td><td style="text-align: left">Explicit 4th order Runge-Kutta (1/6 rule)</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RK438"><code>RK438</code></a></td><td style="text-align: left">4</td><td style="text-align: left">Explicit 4th order Runge-Kutta (3/8 rule)</td></tr></table><h4 id="Diagonally-Implicit-Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Diagonally-Implicit-Runge-Kutta-Methods">Diagonally Implicit Runge-Kutta Methods</a><a id="Diagonally-Implicit-Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonally-Implicit-Runge-Kutta-Methods" title="Permalink"></a></h4><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.CrankNicolson"><code>CrankNicolson</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Crank-Nicholson Method</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.KraaijevangerSpijker"><code>KraaijevangerSpijker</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Kraaijevanger &amp; Spijker&#39;s Method</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.QinZhang"><code>QinZhang</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Qin &amp; Zhang&#39;s Method</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Crouzeix"><code>Crouzeix</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Crouzeix&#39;s Method</td></tr></table><h4 id="Fully-Implicit-Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Fully-Implicit-Runge-Kutta-Methods">Fully Implicit Runge-Kutta Methods</a><a id="Fully-Implicit-Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Fully-Implicit-Runge-Kutta-Methods" title="Permalink"></a></h4><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="@ref"><code>ImplicitEuler</code></a></td><td style="text-align: left">1</td><td style="text-align: left">Implicit / Backward Euler</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.ImplicitMidpoint"><code>ImplicitMidpoint</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Implicit Midpoint</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.SRK3"><code>SRK3</code></a></td><td style="text-align: left">4</td><td style="text-align: left">Symmetric Runge-Kutta s=3</td></tr></table><h4 id="Gauß,-Radau-and-Lobatto-Methods"><a class="docs-heading-anchor" href="#Gauß,-Radau-and-Lobatto-Methods">Gauß, Radau and Lobatto Methods</a><a id="Gauß,-Radau-and-Lobatto-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Gauß,-Radau-and-Lobatto-Methods" title="Permalink"></a></h4><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Gauss"><code>Gauss</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Gauss-Legendre</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIA"><code>RadauIA</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIB"><code>RadauIB</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIIA"><code>RadauIIA</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IIA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIIB"><code>RadauIIB</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IIB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIII"><code>LobattoIII</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-III</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIA"><code>LobattoIIIA</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIB"><code>LobattoIIIB</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIC"><code>LobattoIIIC</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIC</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIID"><code>LobattoIIID</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIID</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIE"><code>LobattoIIIE</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIE</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIF"><code>LobattoIIIF</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIF"><code>LobattoIIIF</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIG"><code>LobattoIIIG</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIG</td></tr></table><p>All of these tableaus are generated on the fly and take the number of stages <code>s</code> as parameter.</p><h4 id="Splitting-Methods"><a class="docs-heading-anchor" href="#Splitting-Methods">Splitting Methods</a><a id="Splitting-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Splitting-Methods" title="Permalink"></a></h4><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="@ref"><code>LieA</code></a></td><td style="text-align: left">1</td><td style="text-align: left">Lie-Trotter Splitting A</td></tr><tr><td style="text-align: left"><a href="@ref"><code>LieB</code></a></td><td style="text-align: left">1</td><td style="text-align: left">Lie-Trotter Splitting B</td></tr><tr><td style="text-align: left"><a href="@ref"><code>Strang</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Strang / Marchuk Splitting</td></tr><tr><td style="text-align: left"><a href="@ref"><code>Marchuk</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Strang / Marchuk Splitting</td></tr><tr><td style="text-align: left"><a href="@ref"><code>StrangA</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Strang / Marchuk Splitting A</td></tr><tr><td style="text-align: left"><a href="@ref"><code>StrangB</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Strang / Marchuk Splitting B</td></tr><tr><td style="text-align: left"><a href="@ref"><code>McLachlan2</code></a></td><td style="text-align: left">2</td><td style="text-align: left">McLachlan&#39;s 2nd order symmetric, minimum error composition method</td></tr><tr><td style="text-align: left"><a href="@ref"><code>McLachlan4</code></a></td><td style="text-align: left">2</td><td style="text-align: left">McLachlan&#39;s 4th order symmetric, minimum error composition method</td></tr><tr><td style="text-align: left"><a href="@ref"><code>TripleJump</code></a></td><td style="text-align: left">4</td><td style="text-align: left">4th order &quot;Triple Jump&quot; composition method</td></tr><tr><td style="text-align: left"><a href="@ref"><code>SuzukiFractal</code></a></td><td style="text-align: left">4</td><td style="text-align: left">Suzuki&#39;s 4th order &quot;fractal&quot; composition method</td></tr></table><h3 id="Integrators-for-partitioned-ODEs"><a class="docs-heading-anchor" href="#Integrators-for-partitioned-ODEs">Integrators for partitioned ODEs</a><a id="Integrators-for-partitioned-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators-for-partitioned-ODEs" title="Permalink"></a></h3><h4 id="Partitioned-Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Partitioned-Runge-Kutta-Methods">Partitioned Runge-Kutta Methods</a><a id="Partitioned-Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioned-Runge-Kutta-Methods" title="Permalink"></a></h4><p>Any partitioned Runge-Kutta method can be selected by the <a href="../modules/methods/#GeometricIntegrators.Methods.PRK-Tuple{PartitionedTableau}"><code>PRK</code></a> method</p><pre><code class="language-julia hljs">prk = PRK(tableau)</code></pre><p>where <code>tableau</code> is any tableau from <a href="../modules/rungekutta_partitioned/#PartitionedRungeKuttaTableaus">RungeKutta.PartitionedTableaus</a>. For most tableaus there also exist explicit shortcuts to select the method. These are listed in the following.</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIAIIIB"><code>LobattoIIIAIIIB</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIA-IIIB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIBIIIA"><code>LobattoIIIBIIIA</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIB-IIIA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIAIIIĀ"><code>LobattoIIIAIIIĀ</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIA-IIIĀ</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIBIIIB̄"><code>LobattoIIIBIIIB̄</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIB-IIIB̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIICIIIC̄"><code>LobattoIIICIIIC̄</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIC-IIIC̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIC̄IIIC"><code>LobattoIIIC̄IIIC</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIC̄-IIIC</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIDIIID̄"><code>LobattoIIIDIIID̄</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIID-IIID̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIEIIIĒ"><code>LobattoIIIEIIIĒ</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIE-IIIĒ</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIFIIIF̄"><code>LobattoIIIFIIIF̄</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF-IIIF̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIF̄IIIF"><code>LobattoIIIF̄IIIF</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF̄-IIIF</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIGIIIḠ"><code>LobattoIIIGIIIḠ</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIG-IIIḠ</td></tr></table><h3 id="Integrators-for-implicit-ODEs"><a class="docs-heading-anchor" href="#Integrators-for-implicit-ODEs">Integrators for implicit ODEs</a><a id="Integrators-for-implicit-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators-for-implicit-ODEs" title="Permalink"></a></h3><p>All implicit Runge-Kutta and partitioned Runge-Kutta methods can also be applied to implicit ODEs.</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="@ref"><code>ImplicitEuler</code></a></td><td style="text-align: left">1</td><td style="text-align: left">Implicit / Backward Euler</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.ImplicitMidpoint"><code>ImplicitMidpoint</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Implicit Midpoint</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.SRK3"><code>SRK3</code></a></td><td style="text-align: left">4</td><td style="text-align: left">Symmetric Runge-Kutta s=3</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Gauss"><code>Gauss</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Gauss-Legendre</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIA"><code>RadauIA</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIB"><code>RadauIB</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIIA"><code>RadauIIA</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IIA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIIB"><code>RadauIIB</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IIB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIII"><code>LobattoIII</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-III</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIA"><code>LobattoIIIA</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIB"><code>LobattoIIIB</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIC"><code>LobattoIIIC</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIC</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIID"><code>LobattoIIID</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIID</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIE"><code>LobattoIIIE</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIE</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIF"><code>LobattoIIIF</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIG"><code>LobattoIIIG</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIG</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIAIIIB"><code>LobattoIIIAIIIB</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIA-IIIB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIBIIIA"><code>LobattoIIIBIIIA</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIB-IIIA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIAIIIĀ"><code>LobattoIIIAIIIĀ</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIA-IIIĀ</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIBIIIB̄"><code>LobattoIIIBIIIB̄</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIB-IIIB̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIICIIIC̄"><code>LobattoIIICIIIC̄</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIC-IIIC̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIC̄IIIC"><code>LobattoIIIC̄IIIC</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIC̄-IIIC</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIDIIID̄"><code>LobattoIIIDIIID̄</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIID-IIID̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIEIIIĒ"><code>LobattoIIIEIIIĒ</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIE-IIIĒ</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIFIIIF̄"><code>LobattoIIIFIIIF̄</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF-IIIF̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIF̄IIIF"><code>LobattoIIIF̄IIIF</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF̄-IIIF</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIGIIIḠ"><code>LobattoIIIGIIIḠ</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIG-IIIḠ</td></tr></table><h3 id="Integrators-for-Lagrangian-ODEs"><a class="docs-heading-anchor" href="#Integrators-for-Lagrangian-ODEs">Integrators for Lagrangian ODEs</a><a id="Integrators-for-Lagrangian-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators-for-Lagrangian-ODEs" title="Permalink"></a></h3><p>Regular (non-degenerate) Lagragian ODEs can be integrated with Variational Partitioned Runge-Kutta (<a href="../modules/methods/#GeometricIntegrators.Methods.VPRK"><code>VPRK</code></a>) methods or Continuous Galerkin Variational Integrators (<a href="@ref"><code>CGVI</code></a>).</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRK"><code>VPRK</code></a></td><td style="text-align: left">Variational Partitioned Runge-Kutta integrator</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKGauss"><code>VPRKGauss</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauGauss</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKRadauIIA"><code>VPRKRadauIIA</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauRadauIIA</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKRadauIIB"><code>VPRKRadauIIB</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauRadauIIB</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIII"><code>VPRKLobattoIII</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIII</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIA"><code>VPRKLobattoIIIA</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIA</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIB"><code>VPRKLobattoIIIB</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIB</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIC"><code>VPRKLobattoIIIC</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIC</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIID"><code>VPRKLobattoIIID</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIID</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIE"><code>VPRKLobattoIIIE</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIE</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIF"><code>VPRKLobattoIIIF</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIF</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIG"><code>VPRKLobattoIIIG</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIG</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIAIIIB"><code>VPRKLobattoIIIAIIIB</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIAIIIB</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIBIIIA"><code>VPRKLobattoIIIBIIIA</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIBIIIA</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIAIIIĀ"><code>VPRKLobattoIIIAIIIĀ</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIAIIIĀ</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIBIIIB̄"><code>VPRKLobattoIIIBIIIB̄</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIBIIIB̄</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIICIIIC̄"><code>VPRKLobattoIIICIIIC̄</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIICIIIC̄</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIC̄IIIC"><code>VPRKLobattoIIIC̄IIIC</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIC̄IIIC</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIDIIID̄"><code>VPRKLobattoIIIDIIID̄</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIDIIID̄</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIEIIIĒ"><code>VPRKLobattoIIIEIIIĒ</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIEIIIĒ</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIFIIIF̄"><code>VPRKLobattoIIIFIIIF̄</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIFIIIF̄</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIF̄IIIF"><code>VPRKLobattoIIIF̄IIIF</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIF̄IIIF</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIGIIIḠ"><code>VPRKLobattoIIIGIIIḠ</code></a></td><td style="text-align: left">VPRK integrator with <a href="@ref"><code>TableauLobattoIIIGIIIḠ</code></a></td></tr></table><h3 id="Integrators-for-Degenerate-Lagrangian-ODEs"><a class="docs-heading-anchor" href="#Integrators-for-Degenerate-Lagrangian-ODEs">Integrators for Degenerate Lagrangian ODEs</a><a id="Integrators-for-Degenerate-Lagrangian-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators-for-Degenerate-Lagrangian-ODEs" title="Permalink"></a></h3><p>Degenerate Lagragian ODEs can be integrated with <a href="../integrators/dvi/">Degenerate Variational Integrators</a> (see also <a href="../modules/methods/#GeometricIntegrators.Methods.DegenerateVPRK"><code>DegenerateVPRK</code></a>) or Projected Variational Partitioned Runge-Kutta (<a href="../modules/methods/#GeometricIntegrators.Methods.ProjectedVPRK"><code>ProjectedVPRK</code></a>) methods.</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.DVIA"><code>DVIA</code></a></td><td style="text-align: left">Symplectic Euler-A Degenerate Variational Integrator</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.DVIB"><code>DVIB</code></a></td><td style="text-align: left">Symplectic Euler-B Degenerate Variational Integrator</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.CMDVI"><code>CMDVI</code></a></td><td style="text-align: left">Midpoint Degenerate Variational Integrator</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.CTDVI"><code>CTDVI</code></a></td><td style="text-align: left">Trapezoidal Degenerate Variational Integrator</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.DegenerateVPRK"><code>DegenerateVPRK</code></a></td><td style="text-align: left">Variational Partitioned Runge-Kutta integrator for degenerate Lagrangians</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.ProjectedVPRK"><code>ProjectedVPRK</code></a></td><td style="text-align: left">Projected Variational Partitioned Runge-Kutta integrator</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="@ref"><code>VPRKpInternal</code></a></td><td style="text-align: left">VPRK integrator with projection on internal stages</td></tr><tr><td style="text-align: left"><a href="@ref"><code>VPRKpLegendre</code></a></td><td style="text-align: left">VPRK integrator with Legendre projection</td></tr><tr><td style="text-align: left"><a href="@ref"><code>VPRKpMidpoint</code></a></td><td style="text-align: left">VPRK integrator with Midpoint projection</td></tr><tr><td style="text-align: left"><a href="@ref"><code>VPRKpSecondary</code></a></td><td style="text-align: left">VPRK integrator with projection on secondary constraint</td></tr><tr><td style="text-align: left"><a href="@ref"><code>VPRKpStandard</code></a></td><td style="text-align: left">VPRK integrator with standard projection</td></tr><tr><td style="text-align: left"><a href="@ref"><code>VPRKpSymmetric</code></a></td><td style="text-align: left">VPRK integrator with symmetric projection</td></tr><tr><td style="text-align: left"><a href="@ref"><code>VPRKpSymplectic</code></a></td><td style="text-align: left">VPRK integrator with symplectic projection</td></tr><tr><td style="text-align: left"><a href="@ref"><code>VPRKpVariational</code></a></td><td style="text-align: left">VPRK integrator with variational projection</td></tr><tr><td style="text-align: left"><a href="@ref"><code>VPRKpVariationalP</code></a></td><td style="text-align: left">VPRK integrator with variational projection on P</td></tr><tr><td style="text-align: left"><a href="@ref"><code>VPRKpVariationalQ</code></a></td><td style="text-align: left">VPRK integrator with variational projection on Q</td></tr></table><h3 id="Integrators-for-DAEs"><a class="docs-heading-anchor" href="#Integrators-for-DAEs">Integrators for DAEs</a><a id="Integrators-for-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators-for-DAEs" title="Permalink"></a></h3></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../problems/">Problems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 25 July 2023 11:05">Tuesday 25 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
