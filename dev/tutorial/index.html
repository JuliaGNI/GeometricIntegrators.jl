<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · GeometricIntegrators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GeometricIntegrators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Basic-usage"><span>Basic usage</span></a></li><li><a class="tocitem" href="#Equations"><span>Equations</span></a></li><li><a class="tocitem" href="#Integrators"><span>Integrators</span></a></li><li><a class="tocitem" href="#Tableaus"><span>Tableaus</span></a></li><li><a class="tocitem" href="#Solutions"><span>Solutions</span></a></li></ul></li><li><a class="tocitem" href="../equations/">Problem Types</a></li><li><span class="tocitem">Integrators</span><ul><li><a class="tocitem" href="../integrators/usage/">Usage</a></li><li><a class="tocitem" href="../integrators/overview/">Overview</a></li><li><a class="tocitem" href="../integrators/rk/">Runge-Kutta</a></li><li><a class="tocitem" href="../integrators/splitting/">Splitting</a></li><li><a class="tocitem" href="../integrators/variational/">Variational</a></li><li><a class="tocitem" href="../integrators/vprk/">VPRK</a></li><li><a class="tocitem" href="../integrators/spark/">SPARK</a></li><li><a class="tocitem" href="../integrators/cgvi/">CGVI</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../modules/integrators/">Integrators</a></li><li><a class="tocitem" href="../modules/equations/">Problems</a></li><li><a class="tocitem" href="../modules/solutions/">Solutions</a></li></ul></li><li><span class="tocitem">Tableaus</span><ul><li><a class="tocitem" href="../tableaus/rungekutta/">Runge-Kutta Methods</a></li><li><a class="tocitem" href="../tableaus/rungekutta_partitioned/">Partitioned Runge-Kutta Methods</a></li><li><a class="tocitem" href="../tableaus/splitting/">Splitting Methods</a></li><li><a class="tocitem" href="../tableaus/vprk/">VPRK Methods</a></li><li><a class="tocitem" href="../tableaus/spark/">SPARK Methods</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../developer/code_integration/">Code Integration</a></li><li><a class="tocitem" href="../developer/custom_integrators/">Custom Integrators</a></li><li><a class="tocitem" href="../developer/adaptive_time_stepping/">Adaptive Time Stepping</a></li></ul></li><li><a class="tocitem" href="../releasenotes/">Release Notes</a></li><li><a class="tocitem" href="../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../authors/">Authors</a></li><li><a class="tocitem" href="../LICENSE/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGNI/GeometricIntegrators.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>In this tutorial, we try to give an overview of the basic usage of GeometricIntegrators and its main components.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p><em>GeometricIntegrators.jl</em> can be installed using Julia&#39;s built-in package manager in the command line interface by</p><pre><code class="language-julia hljs">julia&gt; ]
(v1.8) pkg&gt; add GeometricIntegrators</code></pre><p>In a Jupyter notebook, <em>GeometricIntegrators.jl</em> can be installed by explicitly using the <code>Pkg</code> module as</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;GeometricIntegrators&quot;)</code></pre><p>This will install the library itself as well as all dependencies.</p><h2 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h2><p>In the simplest cases, the use of <code>GeometricIntegrators.jl</code> requires the construction of two objects, an equation and an integrator. For many standard methods, the integrator is implicitly selected by specifying an equation and a tableau.</p><p>Before any use, we need to load GeometricIntegrators,</p><pre><code class="language-julia hljs">using GeometricIntegrators</code></pre><p>Then we can create an ODE object for the equation <span>$\dot{x} (t) = x(t)$</span> with initial condition <span>$x(0) = 1$</span>, integration time span <span>$(0, 1)$</span> and a time step of <span>$\Delta t = 0.1$</span>,</p><pre><code class="language-julia hljs">prob = ODEProblem((ẋ, t, x, params) -&gt; ẋ[1] = x[1], (0.0, 1.0), 0.1, [1.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 1.0), 0.1, (q = [1.0],), NullParameters())</code></pre><p>create an integrator for this ODE, using the tableau for the explicit Euler method</p><pre><code class="language-julia hljs">int = Integrator(prob, TableauExplicitEuler())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">IntegratorERK{Float64, Float64, 1, 1, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#10#11&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}}(GeometricIntegrators.Integrators.ParametersERK{Float64, Float64, 1, 1, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#10#11&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}}((v = GeometricEquations.var&quot;#10#11&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), 
Runge-Kutta Tableau explicit_euler with 1 stages and order 1:

 0.0 │ 0.0
─────┼─────
     │ 1.0

, 0.1), GeometricIntegrators.Integrators.CacheDict{GeometricIntegrators.Integrators.ParametersERK{Float64, Float64, 1, 1, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#10#11&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}}}(GeometricIntegrators.Integrators.ParametersERK{Float64, Float64, 1, 1, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#10#11&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}}((v = GeometricEquations.var&quot;#10#11&quot;{ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), 
Runge-Kutta Tableau explicit_euler with 1 stages and order 1:

 0.0 │ 0.0
─────┼─────
     │ 1.0

, 0.1), Dict{UInt64, IntegratorCache}()))</code></pre><p>and compute the solution,</p><pre><code class="language-julia hljs">sol = integrate(prob, int)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GeometricSolution{Float64, Float64, NamedTuple{(:q,), Tuple{DataSeries{Float64, Vector{Float64}}}}, ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, NamedTuple{(:q,), Tuple{NullPeriodicity}}}([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0], (q = DataSeries{Float64, Vector{Float64}} with data type Float64 and array type Vector{Float64}
[[1.0], [1.1], [1.2100000000000002], [1.3310000000000002], [1.4641000000000002], [1.61051], [1.7715610000000002], [1.9487171], [2.1435888100000002], [2.357947691], [2.5937424601]],), ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 1.0), 0.1, (q = [1.0],), NullParameters()), (q = NullPeriodicity(),), 1, 10, 0)</code></pre><p>Plot and compare with the exact solution</p><pre><code class="language-julia hljs">using Plots
plot(xlims=[0,1], xlab=&quot;t&quot;, ylab=&quot;x(t)&quot;, legend=:bottomright)
plot!(sol.t, sol.q[:,1], label=&quot;numeric&quot;)
plot!(sol.t, exp.(sol.t), label=&quot;exact&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;/home/runner/work/GeometricIntegrators.jl/GeometricIntegrators.jl/docs/build/images/tutorial-ode-1.png&quot;</code></pre><p><img src="../images/tutorial-ode-1.png" alt/></p><h2 id="Equations"><a class="docs-heading-anchor" href="#Equations">Equations</a><a id="Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Equations" title="Permalink"></a></h2><p>In <em>GeometricIntegrators.jl</em> we distinguish between three basic types of equations:</p><ul><li>ordinary differential equations (ODEs),</li><li>differential algebraic equations (DAEs),</li><li>stochastic differential equations (SDEs).</li></ul><p>For each type, there are several subtypes</p><ul><li>standard equations (<a href="../modules/equations/#GeometricEquations.ODEProblem"><code>ODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.DAEProblem"><code>DAEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.SDEProblem"><code>SDEProblem</code></a>),</li><li>implicit equations (<a href="../modules/equations/#GeometricEquations.IODEProblem"><code>IODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.IDAEProblem"><code>IDAEProblem</code></a>),</li><li>partitioned equations (<a href="../modules/equations/#GeometricEquations.PODEProblem"><code>PODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.PDAEProblem"><code>PDAEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.PSDEProblem"><code>PSDEProblem</code></a>),</li><li>Hamiltonian equations (<a href="../modules/equations/#GeometricEquations.HODEProblem"><code>HODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.HDAEProblem"><code>HDAEProblem</code></a>),</li><li>Lagrangian equations (<a href="../modules/equations/#GeometricEquations.LODEProblem"><code>LODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.LDAEProblem"><code>LDAEProblem</code></a>),</li><li>split equations (<a href="../modules/equations/#GeometricEquations.SODEProblem"><code>SODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.SPDAEProblem"><code>SPDAEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.SPSDEProblem"><code>SPSDEProblem</code></a>).</li></ul><h4 id="Ordinary-differential-equations"><a class="docs-heading-anchor" href="#Ordinary-differential-equations">Ordinary differential equations</a><a id="Ordinary-differential-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Ordinary-differential-equations" title="Permalink"></a></h4><p>Consider an ODE of the form</p><p class="math-container">\[\dot{x} (t) = v(t, x(t)) ,\]</p><p>where <span>$\dot{x}$</span> denotes the derivative of <span>$x$</span> and <span>$f$</span> the vector field of the equation, which is assumed to depend on both <span>$t$</span> and <span>$x$</span>. In the following, we will solve the mathematical pendulum, whose equations are given by</p><p class="math-container">\[\begin{pmatrix}
\dot{x}_1 \\
\dot{x}_2 \\
\end{pmatrix}
=
\begin{pmatrix}
x_2 \\
\sin (x_1) \\
\end{pmatrix} .\]</p><p>Together with the integration time span <code>(t₀,t₁)</code> and the time step, an ODE defines an <code>ODEProblem</code>.</p><p>The user needs to specify a function <code>ẋ</code> that computes the vector field and must have the interface</p><pre><code class="language-julia hljs">function ẋ(v, t, x, params)
    v[1] = ...
    v[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the vector which holds the result of evaluating the vector field <span>$v$</span> on <code>t</code> and <code>q</code>, and <code>params</code> is a <code>NamedTuple</code> of constant parameters on which the vector field may depend.</p><p>For the mathematical pendulum, this could look as follows:</p><pre><code class="language-julia hljs">function ẋ(v, t, x, params)
    v[1] = x[2]
    v[2] = sin(x[1])
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ẋ (generic function with 1 method)</code></pre><p>An <code>ODEProblem</code> is instantiated by</p><pre><code class="nohighlight hljs">ODEProblem(&lt;vector field&gt;, &lt;time span&gt;, &lt;time step&gt;, &lt;initial conditions&gt;; kwargs...)</code></pre><p>so to create and <code>ODEProblem</code>, one only needs to pass the above function <code>ẋ</code>, a tuple <code>tspan</code> containing the start and end times of the integration, the time step <code>tstep</code> as well as an initial condition:</p><pre><code class="language-julia hljs">tspan = (0.0, 10.0)
tstep = 0.1
x₀ = [acos(0.4), 0.0]

ode = ODEProblem(ẋ, tspan, tstep, x₀)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 10.0), 0.1, (q = [1.1592794807274085, 0.0],), NullParameters())</code></pre><p>The full constructor would look like</p><pre><code class="language-julia hljs">ode = ODEProblem(ẋ, tspan, tstep, x₀; invariants = NullInvariants(),
                 parameters = NullParameters(), periodicity = NullPeriodicity())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 10.0), 0.1, (q = [1.1592794807274085, 0.0],), NullParameters())</code></pre><p>where all keyword arguments, namely invariants, parameters and periodicity, are by default initialized to be absent.</p><h4 id="Partitioned-ordinary-differential-equations"><a class="docs-heading-anchor" href="#Partitioned-ordinary-differential-equations">Partitioned ordinary differential equations</a><a id="Partitioned-ordinary-differential-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioned-ordinary-differential-equations" title="Permalink"></a></h4><p>The pendulum problem is a Hamiltonian system that can also be expressed as</p><p class="math-container">\[\dot{q} = \frac{\partial H}{\partial p} = p ,
\hspace{3em}
\dot{p} = - \frac{\partial H}{\partial q} = \sin (q) ,
\hspace{3em}
H (q,p) = \frac{1}{2} p^2 + \cos (q) .\]</p><p>This structure, namely the partitioning into two sets of variables <span>$(q,p)$</span> instead of <span>$x$</span>, can be exploited for more efficient integration. Such equations can be defined in terms of a partitioned ODE, where the vector fields are specified separately,</p><pre><code class="language-julia hljs">function q̇(v, t, q, p, params)
    v[1] = p[1]
end

function ṗ(f, t, q, p, params)
    f[1] = sin(q[1])
end

pode = PODEProblem(q̇, ṗ, (0.0, 25.0), 0.1, [acos(0.4)], [0.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PODEProblem{Float64, Float64, Vector{Float64}, PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q, :p), Tuple{Vector{Float64}, Vector{Float64}}}, NullParameters}(PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}(Main.q̇, Main.ṗ, NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 25.0), 0.1, (q = [1.1592794807274085], p = [0.0]), NullParameters())</code></pre><p>The first two arguments to the PODE constructor are the functions that determine the vector fields of the equations <span>$\dot{q} (t) = v(t, q(t), p(t))$</span> and <span>$\dot{p} (t) = f(t, q(t), p(t))$</span>. The third and fourth argument determines the initial conditions of <span>$q$</span> and <span>$p$</span>, respectively. The functions defining the vector field have to take four arguments, the current time <code>t</code>, the current solution vectors <code>q</code> and <code>p</code> and the output vector <code>v</code> or <code>f</code>.</p><h2 id="Integrators"><a class="docs-heading-anchor" href="#Integrators">Integrators</a><a id="Integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators" title="Permalink"></a></h2><p>We support a number of standard integrators (geometric and non-geometric) like explicit, implicit and partitioned Runge-Kutta methods, splitting methods and general linear methods (<em>planned</em>).</p><p>In order to instantiate many of the standard integrators, one needs to specify an ODEProblem, a tableau and a timestep, e.g.,</p><pre><code class="language-julia hljs">int = Integrator(ode, TableauExplicitEuler())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">IntegratorERK{Float64, Float64, 2, 1, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#10#11&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}}(GeometricIntegrators.Integrators.ParametersERK{Float64, Float64, 2, 1, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#10#11&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}}((v = GeometricEquations.var&quot;#10#11&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), 
Runge-Kutta Tableau explicit_euler with 1 stages and order 1:

 0.0 │ 0.0
─────┼─────
     │ 1.0

, 0.1), GeometricIntegrators.Integrators.CacheDict{GeometricIntegrators.Integrators.ParametersERK{Float64, Float64, 2, 1, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#10#11&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}}}(GeometricIntegrators.Integrators.ParametersERK{Float64, Float64, 2, 1, NamedTuple{(:v,), Tuple{GeometricEquations.var&quot;#10#11&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}}}}((v = GeometricEquations.var&quot;#10#11&quot;{ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), NullParameters()),), 
Runge-Kutta Tableau explicit_euler with 1 stages and order 1:

 0.0 │ 0.0
─────┼─────
     │ 1.0

, 0.1), Dict{UInt64, IntegratorCache}()))</code></pre><p>In order to run the integrator, the <code>integrate()</code> functions is called, passing an integrator object and the number of time steps to integrate:</p><pre><code class="language-julia hljs">sol = integrate(ode, int)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GeometricSolution{Float64, Float64, NamedTuple{(:q,), Tuple{DataSeries{Float64, Vector{Float64}}}}, ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, NamedTuple{(:q,), Tuple{NullPeriodicity}}}([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9  …  9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8, 9.9, 10.0], (q = DataSeries{Float64, Vector{Float64}} with data type Float64 and array type Vector{Float64}
[[1.1592794807274085, 0.0], [1.1592794807274085, 0.0916515138991168], [1.16844463211732, 0.1833030277982336], [1.1867749348971435, 0.27531729328384535], [1.214306664225528, 0.36803384468818096], [1.251110048694346, 0.4617466103173175], [1.2972847097260778, 0.5566800160960343], [1.3529527113356812, 0.6529628458243084], [1.418248995918112, 0.7505994225236635], [1.4933089381704783, 0.8494381427201427]  …  [0.43060324588079135, -0.41420434937853495], [0.38918281094293783, -0.372462443739593], [0.35193656656897854, -0.33451919746956543], [0.318484646822022, -0.30004756535686744], [0.28847989028633525, -0.26873478804782697], [0.26160641148155256, -0.2402852621015313], [0.23757788527139942, -0.2144219981539857], [0.21613568545600084, -0.19088707420851603], [0.19704697803514923, -0.1694413913726895], [0.18010283889788029, -0.14986396030881768]],), ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 10.0), 0.1, (q = [1.1592794807274085, 0.0],), NullParameters()), (q = NullPeriodicity(),), 1, 100, 0)</code></pre><p>The integrate function automatically creates an appropriate solution object, that contains the result of the integration.</p><pre><code class="language-julia hljs">plot(sol.q[:,1], sol.q[:,2], xlab=&quot;x(t)&quot;, ylab=&quot;y(t)&quot;, legend=:none)</code></pre><p><img src="../images/tutorial-ode-2.png" alt/></p><p>Observe that the explicit Euler method is not well suited for integrating this system. The solutions drifts away although it should follow closed orbits.</p><p>For a Hamiltonian system, defined as a PODE, a different tableau might be more appropriate, for example a symplectic Euler method,</p><pre><code class="language-julia hljs">int = Integrator(pode, TableauLobattoIIIAIIIB(2))
sol = integrate(pode, int)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GeometricSolution{Float64, Float64, NamedTuple{(:q, :p), Tuple{DataSeries{Float64, Vector{Float64}}, DataSeries{Float64, Vector{Float64}}}}, PODEProblem{Float64, Float64, Vector{Float64}, PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q, :p), Tuple{Vector{Float64}, Vector{Float64}}}, NullParameters}, NamedTuple{(:q, :p), Tuple{NullPeriodicity, NullPeriodicity}}}([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9  …  24.1, 24.2, 24.3, 24.4, 24.5, 24.6, 24.7, 24.8, 24.9, 25.0], (q = DataSeries{Float64, Vector{Float64}} with data type Float64 and array type Vector{Float64}
[[1.1592794807274085], [1.1638620564223643], [1.1776280175119342], [1.2006309772533845], [1.232956612393988], [1.2747169764595088], [1.3260422182739438], [1.3870694294701484], [1.4579283370345946], [1.5387236162742652]  …  [1.4573386548543024], [1.3865567080330332], [1.3256055195712921], [1.2743552413676906], [1.2326687848440545], [1.2004161028510008], [1.1774853186916494], [1.1637909863868372], [1.159279758161221], [1.1639336824352515]], p = DataSeries{Float64, Vector{Float64}} with data type Float64 and array type Vector{Float64}
[[0.0], [0.09174268392263003], [0.1838446041551023], [0.2766429744102676], [0.3704299960306214], [0.46542802939977923], [0.5617622650531963], [0.6594305938032539], [0.7582709340205847], [0.857927078132083]  …  [-0.75749799720018], [-0.6586656764150507], [-0.561007333326713], [-0.46468367363618857], [-0.36969569258344837], [-0.27591733076202446], [-0.18312558232081716], [-0.0910278026521415], [0.0007134802420715181], [0.0924575870593976]]), PODEProblem{Float64, Float64, Vector{Float64}, PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q, :p), Tuple{Vector{Float64}, Vector{Float64}}}, NullParameters}(PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}(Main.q̇, Main.ṗ, NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 25.0), 0.1, (q = [1.1592794807274085], p = [0.0]), NullParameters()), (q = NullPeriodicity(), p = NullPeriodicity()), 1, 250, 0)</code></pre><p>This creates a different integrator, which exploits the partitioned structure of the system. The solution return by the integrate step will also be a different solution, adapted to the partitioned system.</p><pre><code class="language-julia hljs">plot(sol.q[:,1], sol.p[:,1], xlab=&quot;q(t)&quot;, ylab=&quot;p(t)&quot;, legend=:none)</code></pre><p><img src="../images/tutorial-pode-1.png" alt/></p><p>Moreover, this method respects the Hamiltonian structure of the system, resulting in closed orbits following the contours of the system&#39;s energy.</p><h2 id="Tableaus"><a class="docs-heading-anchor" href="#Tableaus">Tableaus</a><a id="Tableaus-1"></a><a class="docs-heading-anchor-permalink" href="#Tableaus" title="Permalink"></a></h2><p>Many tableaus for Runge-Kutta methods are predefined and can easily be used like outlined above. For an overview see <a href="../integrators/overview/">here</a>.</p><h4 id="Custom-Tableaus"><a class="docs-heading-anchor" href="#Custom-Tableaus">Custom Tableaus</a><a id="Custom-Tableaus-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Tableaus" title="Permalink"></a></h4><p>If required, it is straight-forward to create a custom tableau. The tableau of Heun&#39;s method, for example, is defined as follows:</p><pre><code class="language-julia hljs">a = [[0.0 0.0]
     [1.0 0.0]]
b = [0.5, 0.5]
c = [0.0, 1.0]
o = 2

tab = Tableau(:heun, o, a, b, c)</code></pre><p>Runge-Kutta Tableau heun with 2 stages and order 2: \begin{array}{r|rr}   0.0 &amp; 0.0 &amp; 0.0 \
  1.0 &amp; 1.0 &amp; 0.0 \\hline    &amp; 0.5 &amp; 0.5 \
\end{array}</p><p>Here, <code>o</code> is the order of the method, <code>a</code> are the coefficients, <code>b</code> the weights and <code>c</code> the nodes. For partitioned Runge-Kutta tableaus, <code>PartitionedTableau</code> can be used. The first parameter of the constructor of each tableau assigns a name to the tableau. Such custom tableaus can be used in exactly the same as standard tableaus, e.g., by</p><pre><code class="language-julia hljs">int = Integrator(ode, tab)
sol = integrate(ode, int)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GeometricSolution{Float64, Float64, NamedTuple{(:q,), Tuple{DataSeries{Float64, Vector{Float64}}}}, ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, NamedTuple{(:q,), Tuple{NullPeriodicity}}}([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9  …  9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8, 9.9, 10.0], (q = DataSeries{Float64, Vector{Float64}} with data type Float64 and array type Vector{Float64}
[[1.1592794807274085, 0.0], [1.1638620564223643, 0.0916515138991168], [1.1776189005095832, 0.18366481323663172], [1.200603863694606, 0.2763784743977251], [1.2329029997879368, 0.37008634387686673], [1.2746289097818928, 0.46501283347717], [1.3259125035083894, 0.5612856856430376], [1.3868918995618045, 0.6589058883101588], [1.4576981743303377, 0.7577149699479593], [1.5384377274167502, 0.8573607029279458]  …  [1.4541620797452988, 0.754713612265956], [1.5345994706388935, 0.8543315553374894], [1.6250293509992746, 0.954238210516765], [1.7254458208007346, 1.053605813020732], [1.8357467300089705, 1.1513284614783446], [1.955705103604566, 1.2460154236292624], [2.0849408094100896, 1.3360062307571292], [2.222895001365226, 1.419414239796986], [2.3688104851299863, 1.49420332174862], [2.5217214667562002, 1.5582982161671592]],), ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 10.0), 0.1, (q = [1.1592794807274085, 0.0],), NullParameters()), (q = NullPeriodicity(),), 1, 100, 0)</code></pre><p>making it very easy to implement and test new methods.</p><h2 id="Solutions"><a class="docs-heading-anchor" href="#Solutions">Solutions</a><a id="Solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Solutions" title="Permalink"></a></h2><p>In what we have seen so far, the solution was always automatically created by the <code>integrate()</code> function. While this is often convenient, it is sometimes not performant, e.g., when carrying out long-time simulations with intermediate saving of the solution. In such cases, it is better to preallocate a solution object by</p><pre><code class="language-julia hljs">sol = Solution(ode)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GeometricSolution{Float64, Float64, NamedTuple{(:q,), Tuple{DataSeries{Float64, Vector{Float64}}}}, ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, NamedTuple{(:q,), Tuple{NullPeriodicity}}}([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9  …  9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8, 9.9, 10.0], (q = DataSeries{Float64, Vector{Float64}} with data type Float64 and array type Vector{Float64}
[[1.1592794807274085, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]  …  [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],), ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 10.0), 0.1, (q = [1.1592794807274085, 0.0],), NullParameters()), (q = NullPeriodicity(),), 1, 100, 0)</code></pre><p>where the first argument is an equation, the second argument is the time step and the third argument is the number of time steps that will be computed in one integration step. The call to the integrator is then made via</p><pre><code class="language-julia hljs">integrate!(int, sol)</code></pre><p>If several integration cycles shall be performed, the <code>reset!()</code> function can be used to copy the solution of the last time step to the initial conditions of the solution,</p><pre><code class="language-julia hljs">for i in 1:10
    # integrate!(int, sol)
    #
    # save or process solution
    #
    # reset!(sol)
end</code></pre><p>All solutions have a <code>t</code> field holding the series of time steps that has been computed in addition to several data fields, for example <code>q</code> for an ODE solution, <code>q</code> and <code>p</code> for a PODE solution, <code>q</code>and <code>λ</code> for a DAE solution, and <code>q</code>, <code>p</code> and <code>λ</code> for a PDAE solution.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../equations/">Problem Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 29 November 2022 22:47">Tuesday 29 November 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
