<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · GeometricIntegrators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GeometricIntegrators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Basic-usage"><span>Basic usage</span></a></li><li><a class="tocitem" href="#Equations"><span>Equations</span></a></li><li><a class="tocitem" href="#Integrators"><span>Integrators</span></a></li><li><a class="tocitem" href="#Overview-of-Available-Methods"><span>Overview of Available Methods</span></a></li></ul></li><li><a class="tocitem" href="../problems/">Problems</a></li><li><a class="tocitem" href="../methods/">Methods</a></li><li><span class="tocitem">Integrators</span><ul><li><a class="tocitem" href="../integrators/rk/">Runge-Kutta</a></li><li><a class="tocitem" href="../integrators/splitting/">Splitting</a></li><li><a class="tocitem" href="../integrators/variational/">Variational</a></li><li><a class="tocitem" href="../integrators/vprk/">VPRK</a></li><li><a class="tocitem" href="../integrators/spark/">SPARK</a></li><li><a class="tocitem" href="../integrators/dvi/">DVI</a></li><li><a class="tocitem" href="../integrators/cgvi/">CGVI</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../modules/methods/">Methods</a></li><li><a class="tocitem" href="../modules/integrators/">Integrators</a></li><li><a class="tocitem" href="../modules/equations/">Problems</a></li><li><a class="tocitem" href="../modules/solutions/">Solutions</a></li><li><a class="tocitem" href="../modules/rungekutta/">Runge-Kutta Tableaus</a></li><li><a class="tocitem" href="../modules/rungekutta_partitioned/">Partitioned Runge-Kutta Tableaus</a></li><li><a class="tocitem" href="../modules/spark/">SPARK Methods</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../developer/code_integration/">Code Integration</a></li><li><a class="tocitem" href="../developer/custom_integrators/">Custom Integrators</a></li><li><a class="tocitem" href="../developer/adaptive_time_stepping/">Adaptive Time Stepping</a></li></ul></li><li><a class="tocitem" href="../releasenotes/">Release Notes</a></li><li><a class="tocitem" href="../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../authors/">Authors</a></li><li><a class="tocitem" href="../LICENSE/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGNI/GeometricIntegrators.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>In this tutorial, we try to give an overview of the basic usage of GeometricIntegrators and its main components.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p><em>GeometricIntegrators.jl</em> can be installed using Julia&#39;s built-in package manager in the command line interface by</p><pre><code class="language-julia hljs">julia&gt; ]
(v1.8) pkg&gt; add GeometricIntegrators</code></pre><p>In a Jupyter notebook, <em>GeometricIntegrators.jl</em> can be installed by explicitly using the <code>Pkg</code> module as</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;GeometricIntegrators&quot;)</code></pre><p>This will install the library itself as well as all dependencies.</p><h2 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h2><p>In the simplest cases, the use of <code>GeometricIntegrators.jl</code> requires the construction of two objects, an equation and an integrator. For many standard methods, the integrator is implicitly selected by specifying an equation and a tableau.</p><p>Before any use, we need to load GeometricIntegrators,</p><pre><code class="language-julia hljs">using GeometricIntegrators</code></pre><p>Then we can create an ODE object for the equation <span>$\dot{x} (t) = x(t)$</span> with initial condition <span>$x(0) = 1$</span>, integration time span <span>$(0, 1)$</span> and a time step of <span>$\Delta t = 0.1$</span>,</p><pre><code class="language-julia hljs">prob = ODEProblem((ẋ, t, x, params) -&gt; ẋ[1] = x[1], (0.0, 1.0), 0.1, [1.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 1.0), 0.1, (q = [1.0],), NullParameters())</code></pre><p>create an integrator for this ODE, using the explicit Euler method</p><pre><code class="language-julia hljs">int = Integrator(prob, ExplicitEuler())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Explicit Runge-Kutta Integrator with:
   Timestep: 0.1
   Tableau:  ExplicitEuler with 1 stage and order 1
   
 0.0 │ 0.0
─────┼─────
     │ 1.0

</code></pre><p>and compute the solution,</p><pre><code class="language-julia hljs">sol = integrate(prob, int)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GeometricSolution{Float64, Float64, NamedTuple{(:q,), Tuple{DataSeries{Float64, Vector{Float64}}}}, ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, NamedTuple{(:q,), Tuple{NullPeriodicity}}}([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0], (q = DataSeries{Float64, Vector{Float64}} with data type Float64 and array type Vector{Float64}
[[1.0], [1.1], [1.2100000000000002], [1.3310000000000002], [1.4641000000000002], [1.61051], [1.7715610000000002], [1.9487171], [2.1435888100000002], [2.357947691], [2.5937424601]],), ODEProblem{Float64, Float64, Vector{Float64}, ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{Main.var&quot;#1#2&quot;, NullInvariants, NullParameters, NullPeriodicity}(Main.var&quot;#1#2&quot;(), NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 1.0), 0.1, (q = [1.0],), NullParameters()), (q = NullPeriodicity(),), 1, 10, 0)</code></pre><p>Plot and compare with the exact solution</p><pre><code class="language-julia hljs">using Plots
plot(xlims=[0,1], xlab=&quot;t&quot;, ylab=&quot;x(t)&quot;, legend=:bottomright)
plot!(sol.t, sol.q[:,1], label=&quot;numeric&quot;)
plot!(sol.t, exp.(sol.t), label=&quot;exact&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;/home/runner/work/GeometricIntegrators.jl/GeometricIntegrators.jl/docs/build/images/tutorial-ode-1.png&quot;</code></pre><p><img src="../images/tutorial-ode-1.png" alt/></p><h2 id="Equations"><a class="docs-heading-anchor" href="#Equations">Equations</a><a id="Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Equations" title="Permalink"></a></h2><p>In <em>GeometricIntegrators.jl</em> we distinguish between three basic types of equations:</p><ul><li>ordinary differential equations (ODEs),</li><li>differential algebraic equations (DAEs),</li><li>stochastic differential equations (SDEs).</li></ul><p>For each type, there are several subtypes</p><ul><li>standard equations (<a href="../modules/equations/#GeometricEquations.ODEProblem"><code>ODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.DAEProblem"><code>DAEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.SDEProblem"><code>SDEProblem</code></a>),</li><li>implicit equations (<a href="../modules/equations/#GeometricEquations.IODEProblem"><code>IODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.IDAEProblem"><code>IDAEProblem</code></a>),</li><li>partitioned equations (<a href="../modules/equations/#GeometricEquations.PODEProblem"><code>PODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.PDAEProblem"><code>PDAEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.PSDEProblem"><code>PSDEProblem</code></a>),</li><li>Hamiltonian equations (<a href="../modules/equations/#GeometricEquations.HODEProblem"><code>HODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.HDAEProblem"><code>HDAEProblem</code></a>),</li><li>Lagrangian equations (<a href="../modules/equations/#GeometricEquations.LODEProblem"><code>LODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.LDAEProblem"><code>LDAEProblem</code></a>),</li><li>split equations (<a href="../modules/equations/#GeometricEquations.SODEProblem"><code>SODEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.SPDAEProblem"><code>SPDAEProblem</code></a>, <a href="../modules/equations/#GeometricEquations.SPSDEProblem"><code>SPSDEProblem</code></a>).</li></ul><h4 id="Ordinary-differential-equations"><a class="docs-heading-anchor" href="#Ordinary-differential-equations">Ordinary differential equations</a><a id="Ordinary-differential-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Ordinary-differential-equations" title="Permalink"></a></h4><p>Consider an ODE of the form</p><p class="math-container">\[\dot{x} (t) = v(t, x(t)) ,\]</p><p>where <span>$\dot{x}$</span> denotes the derivative of <span>$x$</span> and <span>$f$</span> the vector field of the equation, which is assumed to depend on both <span>$t$</span> and <span>$x$</span>. In the following, we will solve the mathematical pendulum, whose equations are given by</p><p class="math-container">\[\begin{pmatrix}
\dot{x}_1 \\
\dot{x}_2 \\
\end{pmatrix}
=
\begin{pmatrix}
x_2 \\
\sin (x_1) \\
\end{pmatrix} .\]</p><p>Together with the integration time span <code>(t₀,t₁)</code> and the time step, an ODE defines an <code>ODEProblem</code>.</p><p>The user needs to specify a function <code>ẋ</code> that computes the vector field and must have the interface</p><pre><code class="language-julia hljs">function ẋ(v, t, x, params)
    v[1] = ...
    v[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the vector which holds the result of evaluating the vector field <span>$v$</span> on <code>t</code> and <code>q</code>, and <code>params</code> is a <code>NamedTuple</code> of constant parameters on which the vector field may depend.</p><p>For the mathematical pendulum, this could look as follows:</p><pre><code class="language-julia hljs">function ẋ(v, t, x, params)
    v[1] = x[2]
    v[2] = sin(x[1])
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ẋ (generic function with 1 method)</code></pre><p>An <code>ODEProblem</code> is instantiated by</p><pre><code class="nohighlight hljs">ODEProblem(&lt;vector field&gt;, &lt;time span&gt;, &lt;time step&gt;, &lt;initial conditions&gt;; kwargs...)</code></pre><p>so to create and <code>ODEProblem</code>, one only needs to pass the above function <code>ẋ</code>, a tuple <code>tspan</code> containing the start and end times of the integration, the time step <code>tstep</code> as well as an initial condition:</p><pre><code class="language-julia hljs">tspan = (0.0, 10.0)
tstep = 0.1
x₀ = [acos(0.4), 0.0]

ode = ODEProblem(ẋ, tspan, tstep, x₀)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 10.0), 0.1, (q = [1.1592794807274085, 0.0],), NullParameters())</code></pre><p>The full constructor would look like</p><pre><code class="language-julia hljs">ode = ODEProblem(ẋ, tspan, tstep, x₀; invariants = NullInvariants(),
                 parameters = NullParameters(), periodicity = NullPeriodicity())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 10.0), 0.1, (q = [1.1592794807274085, 0.0],), NullParameters())</code></pre><p>where all keyword arguments, namely invariants, parameters and periodicity, are by default initialized to be absent.</p><h4 id="Partitioned-ordinary-differential-equations"><a class="docs-heading-anchor" href="#Partitioned-ordinary-differential-equations">Partitioned ordinary differential equations</a><a id="Partitioned-ordinary-differential-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioned-ordinary-differential-equations" title="Permalink"></a></h4><p>The pendulum problem is a Hamiltonian system that can also be expressed as</p><p class="math-container">\[\dot{q} = \frac{\partial H}{\partial p} = p ,
\hspace{3em}
\dot{p} = - \frac{\partial H}{\partial q} = \sin (q) ,
\hspace{3em}
H (q,p) = \frac{1}{2} p^2 + \cos (q) .\]</p><p>This structure, namely the partitioning into two sets of variables <span>$(q,p)$</span> instead of <span>$x$</span>, can be exploited for more efficient integration. Such equations can be defined in terms of a partitioned ODE, where the vector fields are specified separately,</p><pre><code class="language-julia hljs">function q̇(v, t, q, p, params)
    v[1] = p[1]
end

function ṗ(f, t, q, p, params)
    f[1] = sin(q[1])
end

pode = PODEProblem(q̇, ṗ, (0.0, 25.0), 0.1, [acos(0.4)], [0.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PODEProblem{Float64, Float64, Vector{Float64}, PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q, :p), Tuple{Vector{Float64}, Vector{Float64}}}, NullParameters}(PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}(Main.q̇, Main.ṗ, NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 25.0), 0.1, (q = [1.1592794807274085], p = [0.0]), NullParameters())</code></pre><p>The first two arguments to the PODE constructor are the functions that determine the vector fields of the equations <span>$\dot{q} (t) = v(t, q(t), p(t))$</span> and <span>$\dot{p} (t) = f(t, q(t), p(t))$</span>. The third and fourth argument determines the initial conditions of <span>$q$</span> and <span>$p$</span>, respectively. The functions defining the vector field have to take four arguments, the current time <code>t</code>, the current solution vectors <code>q</code> and <code>p</code> and the output vector <code>v</code> or <code>f</code>.</p><h2 id="Integrators"><a class="docs-heading-anchor" href="#Integrators">Integrators</a><a id="Integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators" title="Permalink"></a></h2><p>We support a number of standard integrators (geometric and non-geometric) like explicit, implicit and partitioned Runge-Kutta methods, splitting methods and general linear methods (<em>planned</em>).</p><p>In order to instantiate many of the standard integrators, one needs to specify an ODEProblem, a method and a timestep, e.g.,</p><pre><code class="language-julia hljs">int = Integrator(ode, ExplicitEuler())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Explicit Runge-Kutta Integrator with:
   Timestep: 0.1
   Tableau:  ExplicitEuler with 1 stage and order 1
   
 0.0 │ 0.0
─────┼─────
     │ 1.0

</code></pre><p>In order to run the integrator, the <code>integrate()</code> functions is called, passing an integrator object and the number of time steps to integrate:</p><pre><code class="language-julia hljs">sol = integrate(ode, int)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GeometricSolution{Float64, Float64, NamedTuple{(:q,), Tuple{DataSeries{Float64, Vector{Float64}}}}, ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}, NamedTuple{(:q,), Tuple{NullPeriodicity}}}([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9  …  9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8, 9.9, 10.0], (q = DataSeries{Float64, Vector{Float64}} with data type Float64 and array type Vector{Float64}
[[1.1592794807274085, 0.0], [1.1592794807274085, 0.0916515138991168], [1.16844463211732, 0.1833030277982336], [1.1867749348971435, 0.27531729328384535], [1.214306664225528, 0.36803384468818096], [1.251110048694346, 0.4617466103173175], [1.2972847097260778, 0.5566800160960343], [1.3529527113356812, 0.6529628458243084], [1.418248995918112, 0.7505994225236635], [1.4933089381704783, 0.8494381427201427]  …  [0.43060324588079135, -0.41420434937853495], [0.38918281094293783, -0.372462443739593], [0.35193656656897854, -0.33451919746956543], [0.318484646822022, -0.30004756535686744], [0.28847989028633525, -0.26873478804782697], [0.26160641148155256, -0.2402852621015313], [0.23757788527139942, -0.2144219981539857], [0.21613568545600084, -0.19088707420851603], [0.19704697803514923, -0.1694413913726895], [0.18010283889788029, -0.14986396030881768]],), ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NullParameters}(ODE{typeof(Main.ẋ), NullInvariants, NullParameters, NullPeriodicity}(Main.ẋ, NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 10.0), 0.1, (q = [1.1592794807274085, 0.0],), NullParameters()), (q = NullPeriodicity(),), 1, 100, 0)</code></pre><p>The integrate function automatically creates an appropriate solution object, that contains the result of the integration.</p><pre><code class="language-julia hljs">plot(sol.q[:,1], sol.q[:,2], xlab=&quot;x(t)&quot;, ylab=&quot;y(t)&quot;, legend=:none)</code></pre><p><img src="../images/tutorial-ode-2.png" alt/></p><p>Observe that the explicit Euler method is not well suited for integrating this system. The solutions drifts away although it should follow closed orbits.</p><p>For a Hamiltonian system, defined as a PODE, a different methods might be more appropriate, for example a symplectic Euler method,</p><pre><code class="language-julia hljs">int = Integrator(pode, LobattoIIIAIIIB(2))
sol = integrate(pode, int)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GeometricSolution{Float64, Float64, NamedTuple{(:q, :p), Tuple{DataSeries{Float64, Vector{Float64}}, DataSeries{Float64, Vector{Float64}}}}, PODEProblem{Float64, Float64, Vector{Float64}, PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q, :p), Tuple{Vector{Float64}, Vector{Float64}}}, NullParameters}, NamedTuple{(:q, :p), Tuple{NullPeriodicity, NullPeriodicity}}}([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9  …  24.1, 24.2, 24.3, 24.4, 24.5, 24.6, 24.7, 24.8, 24.9, 25.0], (q = DataSeries{Float64, Vector{Float64}} with data type Float64 and array type Vector{Float64}
[[1.1592794807274085], [1.1638620564223643], [1.1776280175119342], [1.2006309772533845], [1.232956612393988], [1.2747169764595088], [1.3260422182739438], [1.3870694294701484], [1.4579283370345946], [1.5387236162742652]  …  [1.4573386548543024], [1.3865567080330332], [1.3256055195712921], [1.2743552413676906], [1.2326687848440545], [1.2004161028510008], [1.1774853186916494], [1.1637909863868372], [1.159279758161221], [1.1639336824352515]], p = DataSeries{Float64, Vector{Float64}} with data type Float64 and array type Vector{Float64}
[[0.0], [0.09174268392263003], [0.1838446041551023], [0.2766429744102676], [0.3704299960306214], [0.46542802939977923], [0.5617622650531963], [0.6594305938032539], [0.7582709340205847], [0.857927078132083]  …  [-0.75749799720018], [-0.6586656764150507], [-0.561007333326713], [-0.46468367363618857], [-0.36969569258344837], [-0.27591733076202446], [-0.18312558232081716], [-0.0910278026521415], [0.0007134802420715181], [0.0924575870593976]]), PODEProblem{Float64, Float64, Vector{Float64}, PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}, NamedTuple{(:q, :p), Tuple{Vector{Float64}, Vector{Float64}}}, NullParameters}(PODE{typeof(Main.q̇), typeof(Main.ṗ), NullInvariants, NullParameters, NullPeriodicity}(Main.q̇, Main.ṗ, NullInvariants(), NullParameters(), NullPeriodicity()), (0.0, 25.0), 0.1, (q = [1.1592794807274085], p = [0.0]), NullParameters()), (q = NullPeriodicity(), p = NullPeriodicity()), 1, 250, 0)</code></pre><p>This creates a different integrator, which exploits the partitioned structure of the system. The solution return by the integrate step will also be a different solution, adapted to the partitioned system.</p><pre><code class="language-julia hljs">plot(sol.q[:,1], sol.p[:,1], xlab=&quot;q(t)&quot;, ylab=&quot;p(t)&quot;, legend=:none)</code></pre><p><img src="../images/tutorial-pode-1.png" alt/></p><p>Moreover, this method respects the Hamiltonian structure of the system, resulting in closed orbits following the contours of the system&#39;s energy.</p><h2 id="Overview-of-Available-Methods"><a class="docs-heading-anchor" href="#Overview-of-Available-Methods">Overview of Available Methods</a><a id="Overview-of-Available-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-Available-Methods" title="Permalink"></a></h2><p>GeometricIntegrators.jl provides a plethora of geometric integrators as well as non-geometric integrators (mainly for testing and benchmarking purposes). Most integrators can be selected by a simple method type, which also stores parameters. Some integrator families can also be selected by specifying a tableau, that is a Butcher tableau for Runge-Kutta methods, a pair of tableaus for partitioned Runge-Kutta and VPRK methods, or generalizations thereof for SPARK methods. Other integrators, such as Galerkin variational integrators require the specification of a basis and a quadrature rule.</p><p>The correct integrator is automatically selected based on the method and problem types by calling</p><pre><code class="nohighlight hljs">Integrator(problem, method)</code></pre><p>As an example, consider an ODE like the harmonic oscillator, which is included in GeometricProblems.jl:</p><pre><code class="language-julia hljs">using GeometricIntegrators
using GeometricProblems.HarmonicOscillator</code></pre><pre><code class="language-julia hljs">prob = harmonic_oscillator_ode()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(GeometricProblems.HarmonicOscillator.oscillator_ode_v), NamedTuple{(:h,), Tuple{typeof(GeometricProblems.HarmonicOscillator.hamiltonian)}}, NamedTuple{(:k, :ω), Tuple{DataType, DataType}}, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NamedTuple{(:k, :ω), Tuple{Float64, Float64}}}(ODE{typeof(GeometricProblems.HarmonicOscillator.oscillator_ode_v), NamedTuple{(:h,), Tuple{typeof(GeometricProblems.HarmonicOscillator.hamiltonian)}}, NamedTuple{(:k, :ω), Tuple{DataType, DataType}}, NullPeriodicity}(GeometricProblems.HarmonicOscillator.oscillator_ode_v, (h = GeometricProblems.HarmonicOscillator.hamiltonian,), (k = Float64, ω = Float64), NullPeriodicity()), (0.0, 1.0), 0.1, (q = [0.5, 0.0],), (k = 0.5, ω = 0.7071067811865476))</code></pre><p>Create an explicit Euler method:</p><pre><code class="language-julia hljs">method = ExplicitEuler()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Runge-Kutta Method with Tableau: ExplicitEuler with 1 stage and order 1

 0.0 │ 0.0
─────┼─────
     │ 1.0

Reference:

    Leonhard Euler.
    Institutiones calculi differentialis cum eius vsu in analysi finitorum ac doctrina serierum.
    Imp. Acad. Imper. Scient. Petropolitanae, Opera Omnia, Vol.X, [I.6], 1755.
    In: Opera Omnia, 1st Series, Volume 11, Institutiones Calculi Integralis. Teubner, Leipzig, Pages 424-434, 1913.
    Sectio secunda. Caput VII. De integratione aequationum differentialium per approximationem. Problema 85.
</code></pre><p>And now create an Integrator with the general <code>Integrator</code> constructor:</p><pre><code class="language-julia hljs">int = Integrator(prob, method)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Explicit Runge-Kutta Integrator with:
   Timestep: 0.1
   Tableau:  ExplicitEuler with 1 stage and order 1
   
 0.0 │ 0.0
─────┼─────
     │ 1.0

</code></pre><p>We see that we obtained an <code>IntegratorERK</code>, i.e., an explicit Runge-Kutta integrator. If instead we choose the implicit Euler method:</p><pre><code class="language-julia hljs">method = ImplicitEuler()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Runge-Kutta Method with Tableau: ImplicitEuler with 1 stage and order 1

 1.0 │ 1.0
─────┼─────
     │ 1.0

Reference:

    Augustin-Louis Cauchy.
    Équations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.
    Ed. Christian Gilain, Etudes Vivantes, 1981.
    Page 102, Equation (5), Θ=1.
</code></pre><p>the general <code>Integrator</code> constructor creates a different integrator:</p><pre><code class="language-julia hljs">int = Integrator(prob, method)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Fully Implicit Runge-Kutta Integrator with:
   Timestep: 0.1
   Tableau:  ImplicitEuler with 1 stage and order 1
   
 1.0 │ 1.0
─────┼─────
     │ 1.0

</code></pre><p>namely an <code>IntegratorFIRK</code>, i.e., a fully implicit Runge-Kutta integrator.</p><p>GeometricIntegrators automatically detects if a Runge-Kutta tableau is explicit, diagonally implicit or fully implicity and creates the corresponding Integrator.</p><p>Certain Runge-Kutta method such as Gauß, Radau and Lobatto methods are available for an arbitrary number of stages. Here the number of stages has to be speficied</p><pre><code class="language-julia hljs">int = Integrator(prob, Gauss(1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Fully Implicit Runge-Kutta Integrator with:
   Timestep: 0.1
   Tableau:  Gauss with 1 stage and order 2
   
 0.5 │ 0.5
─────┼─────
     │ 1.0

</code></pre><p>Special integrators, such as Vartiational Partitioned Runge-Kutta (VPRK) methods, can be initialised by providing one or two tableaus, that is</p><pre><code class="language-julia hljs">method = VPRK(TableauGauss(1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Variational Partitioned Runge-Kutta Method with Tableau: Gauss with 1 stage and order 2

 0.5 │ 0.5
─────┼─────
     │ 1.0


 0.5 │ 0.5
─────┼─────
     │ 1.0

References:

    John C. Butcher.
    Implicit Runge-Kutta processes.
    Mathematics of Computation, Volume 18, Pages 50-64, 1964.
    doi: 10.1090/S0025-5718-1964-0159424-9.

    John C. Butcher.
    Gauss Methods. 
    In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
    doi: 10.1007/978-3-540-70529-1_115.
</code></pre><p>or</p><pre><code class="language-julia hljs">method = VPRK(TableauLobattoIIIA(2), TableauLobattoIIIB(2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Variational Partitioned Runge-Kutta Method with Tableau: LobattoIIIALobattoIIIB with 2 stages and order 2

 0.0 │ 0.0  0.0
 1.0 │ 0.5  0.5
─────┼──────────
     │ 0.5  0.5


 0.0 │ 0.5  0.0
 1.0 │ 0.5  0.0
─────┼──────────
     │ 0.5  0.5

</code></pre><p>For standard tableaus there also exist shortcuts, such as</p><pre><code class="language-julia hljs">method = VPRKGauss(1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Variational Partitioned Runge-Kutta Method with Tableau: SymplecticGauss with 1 stage and order 1

 0.5 │ 0.5
─────┼─────
     │ 1.0


 0.5 │ 0.5
─────┼─────
     │ 1.0

</code></pre><p>or</p><pre><code class="language-julia hljs">method = VPRKLobattoIIIAIIIB(2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Variational Partitioned Runge-Kutta Method with Tableau: LobattoIIIAIIIB2 with 2 stages and order 2

 0.0 │ 0.0  0.0
 1.0 │ 0.5  0.5
─────┼──────────
     │ 0.5  0.5


 0.0 │ 0.5  0.0
 1.0 │ 0.5  0.0
─────┼──────────
     │ 0.5  0.5

</code></pre><p>For the purpose of a complete example, consider again the harmonic oscillator:</p><pre><code class="language-example hljs">prob = harmonic_oscillator_iode()</code></pre><p>Create a VPRK tableau that uses Gauss-Legendre Runge-Kutta coefficients with two stages:</p><pre><code class="language-example hljs">method = VPRKGauss(2)</code></pre><p>If we call the <code>Integrator</code> constructor,</p><pre><code class="language-example hljs">int = Integrator(prob, method)</code></pre><p>we obtain a <code>IntegratorVPRK</code>.</p><p>Once an integrator is obtained, we can just call the function</p><pre><code class="nohighlight hljs">integrate(problem, integrator)</code></pre><p>to perform the actual integration steps, where <code>ntime</code> defines the number of steps to integrate:</p><pre><code class="language-julia hljs">int = Integrator(prob, ExplicitEuler())
sol = integrate(prob, int)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GeometricSolution{Float64, Float64, NamedTuple{(:q,), Tuple{DataSeries{Float64, Vector{Float64}}}}, ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(GeometricProblems.HarmonicOscillator.oscillator_ode_v), NamedTuple{(:h,), Tuple{typeof(GeometricProblems.HarmonicOscillator.hamiltonian)}}, NamedTuple{(:k, :ω), Tuple{DataType, DataType}}, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NamedTuple{(:k, :ω), Tuple{Float64, Float64}}}, NamedTuple{(:q,), Tuple{NullPeriodicity}}}([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0], (q = DataSeries{Float64, Vector{Float64}} with data type Float64 and array type Vector{Float64}
[[0.5, 0.0], [0.5, -0.025], [0.4975, -0.05], [0.4925, -0.074875], [0.4850125, -0.0995], [0.4750625, -0.123750625], [0.4626874375, -0.14750375], [0.44793706250000004, -0.170638121875], [0.43087325031250007, -0.193034975], [0.4115697528125001, -0.214578637515625], [0.3901118890609376, -0.23515712515625]],), ODEProblem{Float64, Float64, Vector{Float64}, ODE{typeof(GeometricProblems.HarmonicOscillator.oscillator_ode_v), NamedTuple{(:h,), Tuple{typeof(GeometricProblems.HarmonicOscillator.hamiltonian)}}, NamedTuple{(:k, :ω), Tuple{DataType, DataType}}, NullPeriodicity}, NamedTuple{(:q,), Tuple{Vector{Float64}}}, NamedTuple{(:k, :ω), Tuple{Float64, Float64}}}(ODE{typeof(GeometricProblems.HarmonicOscillator.oscillator_ode_v), NamedTuple{(:h,), Tuple{typeof(GeometricProblems.HarmonicOscillator.hamiltonian)}}, NamedTuple{(:k, :ω), Tuple{DataType, DataType}}, NullPeriodicity}(GeometricProblems.HarmonicOscillator.oscillator_ode_v, (h = GeometricProblems.HarmonicOscillator.hamiltonian,), (k = Float64, ω = Float64), NullPeriodicity()), (0.0, 1.0), 0.1, (q = [0.5, 0.0],), (k = 0.5, ω = 0.7071067811865476)), (q = NullPeriodicity(),), 1, 10, 0)</code></pre><p>The <code>integrate</code> function returns a solution object that stores the solution for each time step. If the solution object is created manually, there exists a function</p><pre><code class="nohighlight hljs">integrate!(integrator, solution)</code></pre><p>that operates on an existing solution.</p><h3 id="Integrators-for-ODEs"><a class="docs-heading-anchor" href="#Integrators-for-ODEs">Integrators for ODEs</a><a id="Integrators-for-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators-for-ODEs" title="Permalink"></a></h3><p>The main method types for ODEs currently implemented are Runge-Kutta methods and splitting methods.</p><h4 id="Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Runge-Kutta-Methods">Runge-Kutta Methods</a><a id="Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Runge-Kutta-Methods" title="Permalink"></a></h4><p>Any Runge-Kutta method can be selected by the <a href="../modules/methods/#GeometricIntegrators.Methods.RK"><code>RK</code></a> method</p><pre><code class="language-julia hljs">rk = RK(tableau)</code></pre><p>where <code>tableau</code> is any tableau from <a href="../modules/rungekutta/#RungeKuttaTableaus">RungeKutta.Tableaus</a>. For most tableaus there also exist explicit shortcuts to select the method. These are listed in the following.</p><h4 id="Explicit-Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Explicit-Runge-Kutta-Methods">Explicit Runge-Kutta Methods</a><a id="Explicit-Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-Runge-Kutta-Methods" title="Permalink"></a></h4><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.ExplicitEuler"><code>ExplicitEuler</code></a></td><td style="text-align: left">1</td><td style="text-align: left">Explicit / Forward Euler</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.ExplicitMidpoint"><code>ExplicitMidpoint</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Explicit Midpoint</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Heun2"><code>Heun2</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Heun&#39;s Method of order two</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Heun3"><code>Heun3</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Heun&#39;s Method of order three</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Ralston2"><code>Ralston2</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Ralston&#39;s Method of order two</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Ralston3"><code>Ralston3</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Ralston&#39;s Method of order three</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Runge2"><code>Runge2</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Runge&#39;s Method</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Kutta3"><code>Kutta3</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Kutta&#39;s Method</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RK416"><code>RK416</code></a></td><td style="text-align: left">4</td><td style="text-align: left">Explicit 4th order Runge-Kutta (1/6 rule)</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RK438"><code>RK438</code></a></td><td style="text-align: left">4</td><td style="text-align: left">Explicit 4th order Runge-Kutta (3/8 rule)</td></tr></table><h4 id="Diagonally-Implicit-Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Diagonally-Implicit-Runge-Kutta-Methods">Diagonally Implicit Runge-Kutta Methods</a><a id="Diagonally-Implicit-Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonally-Implicit-Runge-Kutta-Methods" title="Permalink"></a></h4><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.CrankNicolson"><code>CrankNicolson</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Crank-Nicholson Method</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.KraaijevangerSpijker"><code>KraaijevangerSpijker</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Kraaijevanger &amp; Spijker&#39;s Method</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.QinZhang"><code>QinZhang</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Qin &amp; Zhang&#39;s Method</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Crouzeix"><code>Crouzeix</code></a></td><td style="text-align: left">3</td><td style="text-align: left">Crouzeix&#39;s Method</td></tr></table><h4 id="Fully-Implicit-Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Fully-Implicit-Runge-Kutta-Methods">Fully Implicit Runge-Kutta Methods</a><a id="Fully-Implicit-Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Fully-Implicit-Runge-Kutta-Methods" title="Permalink"></a></h4><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.ImplicitEuler"><code>ImplicitEuler</code></a></td><td style="text-align: left">1</td><td style="text-align: left">Implicit / Backward Euler</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.ImplicitMidpoint"><code>ImplicitMidpoint</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Implicit Midpoint</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.SRK3"><code>SRK3</code></a></td><td style="text-align: left">4</td><td style="text-align: left">Symmetric Runge-Kutta s=3</td></tr></table><h4 id="Gauß,-Radau-and-Lobatto-Methods"><a class="docs-heading-anchor" href="#Gauß,-Radau-and-Lobatto-Methods">Gauß, Radau and Lobatto Methods</a><a id="Gauß,-Radau-and-Lobatto-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Gauß,-Radau-and-Lobatto-Methods" title="Permalink"></a></h4><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Gauss"><code>Gauss</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Gauss-Legendre</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIA"><code>RadauIA</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIB"><code>RadauIB</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIIA"><code>RadauIIA</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IIA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIIB"><code>RadauIIB</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IIB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIII"><code>LobattoIII</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-III</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIA"><code>LobattoIIIA</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIB"><code>LobattoIIIB</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIC"><code>LobattoIIIC</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIC</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIID"><code>LobattoIIID</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIID</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIE"><code>LobattoIIIE</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIE</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIF"><code>LobattoIIIF</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIF"><code>LobattoIIIF</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIG"><code>LobattoIIIG</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIG</td></tr></table><p>All of these tableaus are generated on the fly and take the number of stages <code>s</code> as parameter.</p><h4 id="Splitting-Methods"><a class="docs-heading-anchor" href="#Splitting-Methods">Splitting Methods</a><a id="Splitting-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Splitting-Methods" title="Permalink"></a></h4><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LieA"><code>LieA</code></a></td><td style="text-align: left">1</td><td style="text-align: left">Lie-Trotter Splitting A</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LieB"><code>LieB</code></a></td><td style="text-align: left">1</td><td style="text-align: left">Lie-Trotter Splitting B</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Strang"><code>Strang</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Strang / Marchuk Splitting</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Marchuk"><code>Marchuk</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Strang / Marchuk Splitting</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.StrangA"><code>StrangA</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Strang / Marchuk Splitting A</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.StrangB"><code>StrangB</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Strang / Marchuk Splitting B</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.McLachlan2"><code>McLachlan2</code></a></td><td style="text-align: left">2</td><td style="text-align: left">McLachlan&#39;s 2nd order symmetric, minimum error composition method</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.McLachlan4"><code>McLachlan4</code></a></td><td style="text-align: left">2</td><td style="text-align: left">McLachlan&#39;s 4th order symmetric, minimum error composition method</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.TripleJump"><code>TripleJump</code></a></td><td style="text-align: left">4</td><td style="text-align: left">4th order &quot;Triple Jump&quot; composition method</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.SuzukiFractal"><code>SuzukiFractal</code></a></td><td style="text-align: left">4</td><td style="text-align: left">Suzuki&#39;s 4th order &quot;fractal&quot; composition method</td></tr></table><h3 id="Integrators-for-partitioned-ODEs"><a class="docs-heading-anchor" href="#Integrators-for-partitioned-ODEs">Integrators for partitioned ODEs</a><a id="Integrators-for-partitioned-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators-for-partitioned-ODEs" title="Permalink"></a></h3><h4 id="Partitioned-Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Partitioned-Runge-Kutta-Methods">Partitioned Runge-Kutta Methods</a><a id="Partitioned-Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioned-Runge-Kutta-Methods" title="Permalink"></a></h4><p>Any partitioned Runge-Kutta method can be selected by the <a href="../modules/methods/#GeometricIntegrators.Methods.PRK"><code>PRK</code></a> method</p><pre><code class="language-julia hljs">prk = PRK(tableau)</code></pre><p>where <code>tableau</code> is any tableau from <a href="../modules/rungekutta_partitioned/#PartitionedRungeKuttaTableaus">RungeKutta.PartitionedTableaus</a>. For most tableaus there also exist explicit shortcuts to select the method. These are listed in the following.</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIAIIIB"><code>LobattoIIIAIIIB</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIA-IIIB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIBIIIA"><code>LobattoIIIBIIIA</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIB-IIIA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIAIIIĀ"><code>LobattoIIIAIIIĀ</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIA-IIIĀ</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIBIIIB̄"><code>LobattoIIIBIIIB̄</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIB-IIIB̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIICIIIC̄"><code>LobattoIIICIIIC̄</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIC-IIIC̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIC̄IIIC"><code>LobattoIIIC̄IIIC</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIC̄-IIIC</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIDIIID̄"><code>LobattoIIIDIIID̄</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIID-IIID̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIEIIIĒ"><code>LobattoIIIEIIIĒ</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIE-IIIĒ</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIFIIIF̄"><code>LobattoIIIFIIIF̄</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF-IIIF̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIF̄IIIF"><code>LobattoIIIF̄IIIF</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF̄-IIIF</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIGIIIḠ"><code>LobattoIIIGIIIḠ</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIG-IIIḠ</td></tr></table><h3 id="Integrators-for-implicit-ODEs"><a class="docs-heading-anchor" href="#Integrators-for-implicit-ODEs">Integrators for implicit ODEs</a><a id="Integrators-for-implicit-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators-for-implicit-ODEs" title="Permalink"></a></h3><p>All implicit Runge-Kutta and partitioned Runge-Kutta methods can also be applied to implicit ODEs.</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Order</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.ImplicitEuler"><code>ImplicitEuler</code></a></td><td style="text-align: left">1</td><td style="text-align: left">Implicit / Backward Euler</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.ImplicitMidpoint"><code>ImplicitMidpoint</code></a></td><td style="text-align: left">2</td><td style="text-align: left">Implicit Midpoint</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.SRK3"><code>SRK3</code></a></td><td style="text-align: left">4</td><td style="text-align: left">Symmetric Runge-Kutta s=3</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.Gauss"><code>Gauss</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Gauss-Legendre</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIA"><code>RadauIA</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIB"><code>RadauIB</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIIA"><code>RadauIIA</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IIA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.RadauIIB"><code>RadauIIB</code></a></td><td style="text-align: left">2s-1</td><td style="text-align: left">Radau-IIB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIII"><code>LobattoIII</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-III</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIA"><code>LobattoIIIA</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIB"><code>LobattoIIIB</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIC"><code>LobattoIIIC</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIC</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIID"><code>LobattoIIID</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIID</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIE"><code>LobattoIIIE</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIE</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIF"><code>LobattoIIIF</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIG"><code>LobattoIIIG</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIG</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIAIIIB"><code>LobattoIIIAIIIB</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIA-IIIB</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIBIIIA"><code>LobattoIIIBIIIA</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIB-IIIA</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIAIIIĀ"><code>LobattoIIIAIIIĀ</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIA-IIIĀ</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIBIIIB̄"><code>LobattoIIIBIIIB̄</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIB-IIIB̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIICIIIC̄"><code>LobattoIIICIIIC̄</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIC-IIIC̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIC̄IIIC"><code>LobattoIIIC̄IIIC</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIC̄-IIIC</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIDIIID̄"><code>LobattoIIIDIIID̄</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIID-IIID̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIEIIIĒ"><code>LobattoIIIEIIIĒ</code></a></td><td style="text-align: left">2s-2</td><td style="text-align: left">Lobatto-IIIE-IIIĒ</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIFIIIF̄"><code>LobattoIIIFIIIF̄</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF-IIIF̄</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIF̄IIIF"><code>LobattoIIIF̄IIIF</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIF̄-IIIF</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.LobattoIIIGIIIḠ"><code>LobattoIIIGIIIḠ</code></a></td><td style="text-align: left">2s</td><td style="text-align: left">Lobatto-IIIG-IIIḠ</td></tr></table><h3 id="Integrators-for-Lagrangian-ODEs"><a class="docs-heading-anchor" href="#Integrators-for-Lagrangian-ODEs">Integrators for Lagrangian ODEs</a><a id="Integrators-for-Lagrangian-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators-for-Lagrangian-ODEs" title="Permalink"></a></h3><p>Regular (non-degenerate) Lagragian ODEs can be integrated with Variational Partitioned Runge-Kutta (<a href="../modules/methods/#GeometricIntegrators.Methods.VPRK"><code>VPRK</code></a>) methods or Continuous Galerkin Variational Integrators (<a href="@ref"><code>CGVI</code></a>).</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRK"><code>VPRK</code></a></td><td style="text-align: left">Variational Partitioned Runge-Kutta integrator</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKGauss"><code>VPRKGauss</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta/#RungeKutta.Tableaus.TableauGauss-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauGauss</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKRadauIIA"><code>VPRKRadauIIA</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta/#RungeKutta.Tableaus.TableauRadauIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauRadauIIA</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKRadauIIB"><code>VPRKRadauIIB</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta/#RungeKutta.Tableaus.TableauRadauIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauRadauIIB</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIII"><code>VPRKLobattoIII</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIII-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIII</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIA"><code>VPRKLobattoIIIA</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIA</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIB"><code>VPRKLobattoIIIB</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIB</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIC"><code>VPRKLobattoIIIC</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIC-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIC</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIID"><code>VPRKLobattoIIID</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIID-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIID</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIE"><code>VPRKLobattoIIIE</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIE-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIE</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIF"><code>VPRKLobattoIIIF</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIF</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIG"><code>VPRKLobattoIIIG</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIG-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIG</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIAIIIB"><code>VPRKLobattoIIIAIIIB</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIB-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>TableauLobattoIIIAIIIB</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIBIIIA"><code>VPRKLobattoIIIBIIIA</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIA-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>TableauLobattoIIIBIIIA</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIAIIIĀ"><code>VPRKLobattoIIIAIIIĀ</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>TableauLobattoIIIAIIIĀ</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIBIIIB̄"><code>VPRKLobattoIIIBIIIB̄</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>TableauLobattoIIIBIIIB̄</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIICIIIC̄"><code>VPRKLobattoIIICIIIC̄</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIICIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>TableauLobattoIIICIIIC̄</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIC̄IIIC"><code>VPRKLobattoIIIC̄IIIC</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIC̄IIIC-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>TableauLobattoIIIC̄IIIC</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIDIIID̄"><code>VPRKLobattoIIIDIIID̄</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIDIIID̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>TableauLobattoIIIDIIID̄</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIEIIIĒ"><code>VPRKLobattoIIIEIIIĒ</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIEIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>TableauLobattoIIIEIIIĒ</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIFIIIF̄"><code>VPRKLobattoIIIFIIIF̄</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIFIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>TableauLobattoIIIFIIIF̄</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIF̄IIIF"><code>VPRKLobattoIIIF̄IIIF</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIF̄IIIF-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>TableauLobattoIIIF̄IIIF</code></a></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKLobattoIIIGIIIḠ"><code>VPRKLobattoIIIGIIIḠ</code></a></td><td style="text-align: left">VPRK integrator with <a href="../modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIGIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>TableauLobattoIIIGIIIḠ</code></a></td></tr></table><h3 id="Integrators-for-Degenerate-Lagrangian-ODEs"><a class="docs-heading-anchor" href="#Integrators-for-Degenerate-Lagrangian-ODEs">Integrators for Degenerate Lagrangian ODEs</a><a id="Integrators-for-Degenerate-Lagrangian-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators-for-Degenerate-Lagrangian-ODEs" title="Permalink"></a></h3><p>Degenerate Lagragian ODEs can be integrated with <a href="../integrators/dvi/">Degenerate Variational Integrators</a> (see also <a href="../modules/methods/#GeometricIntegrators.Methods.DegenerateVPRK"><code>DegenerateVPRK</code></a>) or Projected Variational Partitioned Runge-Kutta (<a href="../modules/methods/#GeometricIntegrators.Methods.ProjectedVPRK"><code>ProjectedVPRK</code></a>) methods.</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Method</th></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.DVIA"><code>DVIA</code></a></td><td style="text-align: left">Symplectic Euler-A Degenerate Variational Integrator</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.DVIB"><code>DVIB</code></a></td><td style="text-align: left">Symplectic Euler-B Degenerate Variational Integrator</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.CMDVI"><code>CMDVI</code></a></td><td style="text-align: left">Midpoint Degenerate Variational Integrator</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.CTDVI"><code>CTDVI</code></a></td><td style="text-align: left">Trapezoidal Degenerate Variational Integrator</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.DegenerateVPRK"><code>DegenerateVPRK</code></a></td><td style="text-align: left">Variational Partitioned Runge-Kutta integrator for degenerate Lagrangians</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.ProjectedVPRK"><code>ProjectedVPRK</code></a></td><td style="text-align: left">Projected Variational Partitioned Runge-Kutta integrator</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKpInternal-Tuple{GeometricIntegrators.Methods.VPRKMethod}"><code>VPRKpInternal</code></a></td><td style="text-align: left">VPRK integrator with projection on internal stages</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKpLegendre-Tuple{GeometricIntegrators.Methods.VPRKMethod}"><code>VPRKpLegendre</code></a></td><td style="text-align: left">VPRK integrator with Legendre projection</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKpMidpoint-Tuple{GeometricIntegrators.Methods.VPRKMethod}"><code>VPRKpMidpoint</code></a></td><td style="text-align: left">VPRK integrator with Midpoint projection</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKpSecondary-Tuple{GeometricIntegrators.Methods.VPRKMethod}"><code>VPRKpSecondary</code></a></td><td style="text-align: left">VPRK integrator with projection on secondary constraint</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKpStandard-Tuple{GeometricIntegrators.Methods.VPRKMethod}"><code>VPRKpStandard</code></a></td><td style="text-align: left">VPRK integrator with standard projection</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKpSymmetric-Tuple{GeometricIntegrators.Methods.VPRKMethod}"><code>VPRKpSymmetric</code></a></td><td style="text-align: left">VPRK integrator with symmetric projection</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKpSymplectic-Tuple{GeometricIntegrators.Methods.VPRKMethod}"><code>VPRKpSymplectic</code></a></td><td style="text-align: left">VPRK integrator with symplectic projection</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKpVariational-Tuple{GeometricIntegrators.Methods.VPRKMethod}"><code>VPRKpVariational</code></a></td><td style="text-align: left">VPRK integrator with variational projection</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKpVariationalP-Tuple{GeometricIntegrators.Methods.VPRKMethod}"><code>VPRKpVariationalP</code></a></td><td style="text-align: left">VPRK integrator with variational projection on P</td></tr><tr><td style="text-align: left"><a href="../modules/methods/#GeometricIntegrators.Methods.VPRKpVariationalQ-Tuple{GeometricIntegrators.Methods.VPRKMethod}"><code>VPRKpVariationalQ</code></a></td><td style="text-align: left">VPRK integrator with variational projection on Q</td></tr></table><h3 id="Integrators-for-DAEs"><a class="docs-heading-anchor" href="#Integrators-for-DAEs">Integrators for DAEs</a><a id="Integrators-for-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators-for-DAEs" title="Permalink"></a></h3></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../problems/">Problems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 8 December 2022 17:06">Thursday 8 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
