<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Runge-Kutta Tableaus · GeometricIntegrators.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GeometricIntegrators.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../problems/">Problems</a></li><li><a class="tocitem" href="../../methods/">Methods</a></li><li><span class="tocitem">Integrators</span><ul><li><a class="tocitem" href="../../integrators/rk/">Runge-Kutta</a></li><li><a class="tocitem" href="../../integrators/splitting/">Splitting</a></li><li><a class="tocitem" href="../../integrators/variational/">Variational</a></li><li><a class="tocitem" href="../../integrators/vprk/">VPRK</a></li><li><a class="tocitem" href="../../integrators/spark/">SPARK</a></li><li><a class="tocitem" href="../../integrators/dvi/">DVI</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../methods/">Methods</a></li><li><a class="tocitem" href="../integrators/">Integrators</a></li><li><a class="tocitem" href="../equations/">Problems</a></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li class="is-active"><a class="tocitem" href>Runge-Kutta Tableaus</a></li><li><a class="tocitem" href="../rungekutta_partitioned/">Partitioned Runge-Kutta Tableaus</a></li><li><a class="tocitem" href="../spark/">SPARK Methods</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../developer/code_integration/">Code Integration</a></li><li><a class="tocitem" href="../../developer/custom_integrators/">Custom Integrators</a></li><li><a class="tocitem" href="../../developer/adaptive_time_stepping/">Adaptive Time Stepping</a></li></ul></li><li><a class="tocitem" href="../../releasenotes/">Release Notes</a></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../authors/">Authors</a></li><li><a class="tocitem" href="../../LICENSE/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Runge-Kutta Tableaus</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Runge-Kutta Tableaus</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGNI/GeometricIntegrators.jl/blob/main/docs/src/modules/rungekutta.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="RungeKuttaTableaus"><a class="docs-heading-anchor" href="#RungeKuttaTableaus">Runge-Kutta Tableaus</a><a id="RungeKuttaTableaus-1"></a><a class="docs-heading-anchor-permalink" href="#RungeKuttaTableaus" title="Permalink"></a></h1><p>The following tableaus are all implemented in <a href="https://github.com/JuliaGNI/RungeKutta.jl">RungeKutta.jl</a>.</p><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableau" href="#RungeKutta.Tableau"><code>RungeKutta.Tableau</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Holds the tableau of a Runge-Kutta method</p><p class="math-container">\[\begin{aligned}
Q_{n,i} &amp;= q_{n} + h \sum \limits_{j=1}^{s} a_{ij} \, v(t_{n} + c_j \Delta t, Q_{n,j}) , &amp;
q_{n+1} &amp;= q_{n} + h \sum \limits_{i=1}^{s} b_{i}  \, v(t_{n} + c_j \Delta t, Q_{n,i}) , \\
\end{aligned}\]</p><p>Parameters:</p><ul><li><code>T</code>: datatype of coefficient arrays</li></ul><p>Fields:</p><ul><li><code>name</code>: symbolic name of the tableau</li><li><code>o</code>: order of the method</li><li><code>s</code>: number of stages</li><li><code>a</code>: coefficients <span>$a_{ij}$</span> with $ 1 \le i,j \le s$</li><li><code>b</code>: weights <span>$b_{i}$</span>  with $ 1 \le i \le s$</li><li><code>c</code>: nodes <span>$c_{i}$</span>  with $ 1 \le i \le s$</li><li><code>R∞</code>: stability function at infinity</li></ul><p>Constructors:</p><pre><code class="language-julia hljs">Tableau{T}(name, o, s, a, b, c)
Tableau{T}(name, o, a, b, c)
Tableau(name::Symbol, o::Int, s::Int, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)
Tableau(name::Symbol, o::Int, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)
Tableau(name::Symbol, o::Int, t::AbstractMatrix)</code></pre><p>The last constructor accepts an <span>$(s+1) \times (s+1)$</span> array that holds the whole tableau in the form of a Butcher tableau, i.e.,</p><table><tr><th style="text-align: right">c</th><th style="text-align: right">a</th></tr><tr><td style="text-align: right"></td><td style="text-align: right">b</td></tr></table></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauBackwardEuler" href="#RungeKutta.Tableaus.TableauBackwardEuler"><code>RungeKutta.Tableaus.TableauBackwardEuler</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauImplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauImplicitEuler</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauCrankNicolson-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauCrankNicolson-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauCrankNicolson</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of Crank-Nicolson two-stage, 2nd order method</p><pre><code class="language-julia hljs">TableauCrankNicolson(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">J. Crank and P. Nicolson.
A practical method for numerical evaluation of solutions of partial differential equations of the heat-conduction type.
Mathematical Proceedings of the Cambridge Philosophical Society, Volume 43, Issue 1, Pages 50-67, 1947.
doi: 10.1017/S0305004100023197</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauCrouzeix-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauCrouzeix-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauCrouzeix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of Crouzeix&#39;s two-stage, 3rd order method</p><pre><code class="language-julia hljs">TableauCrouzeix(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">M.Crouzeix.
Sur L&#39;approximation des équations différentielles opérationelles linéaires par des méthodes de Runge-Kutta.
Thesis. Université de Paris, 1975.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauExplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauExplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauExplicitEuler</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of one-stage, 1st order explicit (forward) Euler method</p><pre><code class="language-julia hljs">TableauExplicitEuler(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Leonhard Euler.
Institutiones calculi differentialis cum eius vsu in analysi finitorum ac doctrina serierum.
Imp. Acad. Imper. Scient. Petropolitanae, Opera Omnia, Vol.X, [I.6], 1755.
In: Opera Omnia, 1st Series, Volume 11, Institutiones Calculi Integralis. Teubner, Leipzig, Pages 424-434, 1913.
Sectio secunda. Caput VII. De integratione aequationum differentialium per approximationem. Problema 85.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauExplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauExplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauExplicitMidpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of explicit two-stage, 2nd order midpoint method</p><pre><code class="language-julia hljs">TableauExplicitMidpoint(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Carl Runge.
Über die numerische Auflösung von Differentialgleichungen.
Mathematische Annalen, Volume 46, Pages 167-178, 1895.
doi: 10.1007/BF01446807.
Equation (2)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauForwardEuler" href="#RungeKutta.Tableaus.TableauForwardEuler"><code>RungeKutta.Tableaus.TableauForwardEuler</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauExplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauExplicitEuler</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauGauss-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauGauss-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauGauss</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gauss tableau with s stages</p><pre><code class="language-julia hljs">TableauGauss(::Type{T}, s)
TableauGauss(s) = TableauGauss(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="nohighlight hljs">John C. Butcher.
Implicit Runge-Kutta processes.
Mathematics of Computation, Volume 18, Pages 50-64, 1964.
doi: 10.1090/S0025-5718-1964-0159424-9.

John C. Butcher.
Gauss Methods. 
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_115.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauHeun2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauHeun2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauHeun2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of Heun&#39;s two-stage, 2nd order method</p><pre><code class="language-julia hljs">TableauHeun2(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Karl Heun.
Neue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.
Zeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.
Algorithm II.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauHeun3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauHeun3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauHeun3</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of Heun&#39;s three-stage, 3rd order method</p><pre><code class="language-julia hljs">TableauHeun3(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Karl Heun.
Neue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.
Zeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.
Algorithm VI.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauImplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauImplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauImplicitEuler</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of one-stage, 1st order implicit (backward) Euler method</p><pre><code class="language-julia hljs">TableauImplicitEuler(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Augustin-Louis Cauchy.
Équations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.
Ed. Christian Gilain, Etudes Vivantes, 1981.
Page 102, Equation (5), Θ=1.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauImplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauImplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauImplicitMidpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of two-stage, 2nd order implicit midpoint method</p><pre><code class="language-julia hljs">TableauImplicitMidpoint(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Augustin-Louis Cauchy.
Équations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.
Ed. Christian Gilain, Etudes Vivantes, 1981.
Page 102, Equation (5), Θ=1/2.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauKraaijevangerSpijker-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauKraaijevangerSpijker-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauKraaijevangerSpijker</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of Kraaijevanger and Spijker&#39;s two-stage, 2nd order method</p><pre><code class="language-julia hljs">TableauKraaijevangerSpijker(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">J. F. B. M. Kraaijevanger and M. N. Spijker.
Algebraic stability and error propagation in Runge-Kutta methods.
Applied Numerical Mathematics, Volume 5, Issues 1-2, Pages 71-87, 1989.
doi: 10.1016/0168-9274(89)90025-1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauKutta-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauKutta-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauKutta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of Kutta&#39;s three-stage, 3rd order method</p><pre><code class="language-julia hljs">TableauKutta(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Wilhelm Kutta
Beitrag zur Näherungsweisen Integration totaler Differentialgleichungen
Zeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.
Page 440</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauKutta3" href="#RungeKutta.Tableaus.TableauKutta3"><code>RungeKutta.Tableaus.TableauKutta3</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauKutta-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauKutta</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIII-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIII-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIII</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto III tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIII(::Type{T}, s)
TableauLobattoIII(s) = TableauLobattoIII(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Sometimes this tableau is also referred to as Lobatto IIIC*.</p><p>References:</p><pre><code class="nohighlight hljs">John C. Butcher.
Integration processes based on Radau quadrature formulas
Mathematics of Computation, Volume 18, Pages 233-244, 1964.
doi: 10.1090/S0025-5718-1964-0165693-1.

Laurent O. Jay.
Lobatto Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_123.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIA</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIIA tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIA(::Type{T}, s)
TableauLobattoIIIA(s) = TableauLobattoIIIA(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="nohighlight hljs">Byron Leonard Ehle
On Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.
Research Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.

Laurent O. Jay.
Lobatto Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_123</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIB</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIIB tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIB(::Type{T}, s)
TableauLobattoIIIB(s) = TableauLobattoIIIB(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="nohighlight hljs">Byron Leonard Ehle.
On Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.
Research Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.

Laurent O. Jay.
Lobatto Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_123.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIB̄</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIIB̄ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIB̄(::Type{T}, s)
TableauLobattoIIIB̄(s) = TableauLobattoIIIB̄(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Lobatto IIIB̄ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIB</code></a>. On paper, its coefficients are identical to <a href="#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIA</code></a>, however, they are computed by the symplecticity condition and not by the formula for Lobatto IIIA and thus the numerical values are slightly different.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIIC-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIIC-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIIC tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIC(::Type{T}, s)
TableauLobattoIIIC(s) = TableauLobattoIIIC(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="nohighlight hljs">F. H. Chipman.
A-stable Runge-Kutta processes.
BIT, Volume 11, Pages 384-388, 1971.
doi: 10.1007/BF01939406.

Laurent O. Jay.
Lobatto Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_123.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIC̄</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIIC̄ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIC̄(::Type{T}, s)
TableauLobattoIIIC̄(s) = TableauLobattoIIIC̄(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Lobatto IIIC̄ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIIC-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIC</code></a>. On paper, its coefficients are identical to <a href="#RungeKutta.Tableaus.TableauLobattoIII-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIII</code></a>, however, they are computed by the symplecticity condition and not by the formula for Lobatto III and thus the numerical values are slightly different.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIID-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIID-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIID</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIID tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIID(::Type{T}, s)
TableauLobattoIIID(s) = TableauLobattoIIID(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="nohighlight hljs">R.P.K. Chan.
On symmetric Runge-Kutta methods of high order.
Computing, Volume 45, Pages 301-309, 1990.
doi: 10.1007/BF02238798

Laurent O. Jay.
Lobatto Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_123.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIID̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIID̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIID̄</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIID̄ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIID̄(::Type{T}, s)
TableauLobattoIIID̄(s) = TableauLobattoIIID̄(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Lobatto IIID̄ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIID-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIID</code></a>. On paper, the coefficients of the Lobatto IIID tableau are symplectic, however, the Lobatto IIID̄ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIID and thus the numerical values are slightly different.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIIE-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIIE-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIIE tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIE(::Type{T}, s)
TableauLobattoIIIE(s) = TableauLobattoIIIE(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="nohighlight hljs">R.P.K. Chan.
On symmetric Runge-Kutta methods of high order.
Computing, Volume 45, Pages 301-309, 1990.
doi: 10.1007/BF02238798

Laurent O. Jay.
Lobatto Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_123.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIIF tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIF(::Type{T}, s)
TableauLobattoIIIF(s) = TableauLobattoIIIF(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="nohighlight hljs">Wang Fangzong and Liao Xiaobing.
A Class of Lobatto Methods of Order 2s.
Journal of Applied Mathematics, Volume 46, Pages 6-10, 2016.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIF̄</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIIF̄ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIF̄(::Type{T}, s)
TableauLobattoIIIF̄(s) = TableauLobattoIIIF̄(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>The Lobatto IIIF̄ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIF</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIIG-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIIG-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIIG tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIG(::Type{T}, s)
TableauLobattoIIIG(s) = TableauLobattoIIIG(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Symplectizied algorithm for <a href="#RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIF</code></a></p><p>Coefficients are taken as <span>$a^G = \frac{1}{2} ( a^F + \bar{a}^F )$</span> where the coefficients <span>$\bar{a}^F$</span> are computed such that the symplecticity conditions <span>$b_{i} \bar{a}_{i,j} + \bar{b}_{j} a_{j,i} = b_{i} \bar{b}_{j}$</span> and <span>$b_{i} = \bar{b}_i$</span> hold for all <span>$1 \le i,j \le s$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIĀ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIIĀ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIĀ(::Type{T}, s)
TableauLobattoIIIĀ(s) = TableauLobattoIIIĀ(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Lobatto IIIĀ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIA</code></a>. On paper, its coefficients are identical to <a href="#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIB</code></a>, however, they are computed by the symplecticity condition and not by the formula for Lobatto IIIB and thus the numerical values are slightly different.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIĒ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIIĒ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIĒ(::Type{T}, s)
TableauLobattoIIIĒ(s) = TableauLobattoIIIĒ(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Lobatto IIIĒ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIIE-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIE</code></a>. On paper, the coefficients of the Lobatto IIIE tableau are symplectic, however, the Lobatto IIIĒ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIIE and thus the numerical values are slightly different.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauLobattoIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauLobattoIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIḠ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Lobatto IIIḠ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIḠ(::Type{T}, s)
TableauLobattoIIIḠ(s) = TableauLobattoIIIḠ(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Lobatto IIIḠ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIIG-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIG</code></a>. On paper, the coefficients of the Lobatto IIIG tableau are symplectic, however, the Lobatto IIIḠ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIIG and thus the numerical values are slightly different.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauQinZhang-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauQinZhang-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauQinZhang</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of Qin and Zhang&#39;s symplectic two-stage, 2nd order method</p><pre><code class="language-julia hljs">TableauQinZhang(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">M.-Z. Qin and M.-Q. Zhang.
Symplectic Runge-Kutta algorithms for Hamilton systems.
Journal of Computational Mathematics, Supplementary Issue, Pages 205-215, 1992.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRK21" href="#RungeKutta.Tableaus.TableauRK21"><code>RungeKutta.Tableaus.TableauRK21</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauHeun2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauHeun2</code></a>     according to</p><pre><code class="nohighlight hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 99</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRK22" href="#RungeKutta.Tableaus.TableauRK22"><code>RungeKutta.Tableaus.TableauRK22</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauRunge-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauRunge</code></a>     according to</p><pre><code class="nohighlight hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 99</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRK31-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauRK31-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRK31</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of a three-stage, 3rd order method</p><pre><code class="language-julia hljs">TableauKutta(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 99</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRK32" href="#RungeKutta.Tableaus.TableauRK32"><code>RungeKutta.Tableaus.TableauRK32</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauKutta-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauKutta</code></a> according to</p><pre><code class="nohighlight hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 99</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRK4" href="#RungeKutta.Tableaus.TableauRK4"><code>RungeKutta.Tableaus.TableauRK4</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauRK416-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauRK416</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRK41" href="#RungeKutta.Tableaus.TableauRK41"><code>RungeKutta.Tableaus.TableauRK41</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauRK416-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauRK416</code></a> according to</p><pre><code class="nohighlight hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 102</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRK416-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauRK416-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRK416</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of explicit Runge-Kutta method of order four (1/6 rule)</p><pre><code class="language-julia hljs">TableauRK416(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Wilhelm Kutta
Beitrag zur Näherungsweisen Integration totaler Differentialgleichungen
Zeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.
Page 443</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRK42-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauRK42-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRK42</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of explicit Runge-Kutta method of order four with four stages</p><pre><code class="language-julia hljs">TableauRK42(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 102</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRK438-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauRK438-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRK438</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of explicit Runge-Kutta method of order four (3/8 rule)</p><pre><code class="language-julia hljs">TableauRK438(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Wilhelm Kutta
Beitrag zur Näherungsweisen Integration totaler Differentialgleichungen
Zeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.
Page 441</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRK5-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauRK5-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRK5</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of explicit Runge-Kutta method of order five with six stages</p><pre><code class="language-julia hljs">TableauRK5(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 103</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRadauIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauRadauIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauRadauIA</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Radau IA tableau with s stages</p><pre><code class="language-julia hljs">TableauRadauIA(::Type{T}, s)
TableauRadauIA(s) = TableauRadauIA(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="nohighlight hljs">Byron Leonard Ehle
On Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.
Research Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRadauIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauRadauIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauRadauIB</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Radau IB tableau with s stages</p><pre><code class="language-julia hljs">TableauRadauIB(::Type{T}, s)
TableauRadauIB(s) = TableauRadauIB(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Coefficients are taken as <span>$a^B = \frac{1}{2} ( a^A + \bar{a}^A )$</span> where <span>$a^A$</span> are the coefficients of the Radau IA method and <span>$\bar{a}^A$</span> are computed such that the symplecticity conditions <span>$b_{i} \bar{a}_{i,j} + \bar{b}_{j} a_{j,i} = b_{i} \bar{b}_{j}$</span> and <span>$b_{i} = \bar{b}_i$</span> hold for all <span>$1 \le i,j \le s$</span>.</p>reference(Val(:RadauIB))</div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRadauIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauRadauIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauRadauIIA</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Radau IIA tableau with s stages</p><pre><code class="language-julia hljs">TableauRadauIIA(::Type{T}, s)
TableauRadauIIA(s) = TableauRadauIIA(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="nohighlight hljs">Byron Leonard Ehle
On Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.
Research Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.

Owe Axelsson.
A class of A-stable methods.
BIT, Volume 9, Pages 185-199, 1969.
doi: 10.1007/BF01946812.

Ernst Hairer and Gerhard Wanner.
Radau Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_139.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRadauIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.TableauRadauIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauRadauIIB</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Radau IIB tableau with s stages</p><pre><code class="language-julia hljs">TableauRadauIIB(::Type{T}, s)
TableauRadauIIB(s) = TableauRadauIIB(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Coefficients are taken as <span>$a^B = \frac{1}{2} ( a^A + \bar{a}^A )$</span> where <span>$a^A$</span> are the coefficients of the Radau IIA method and <span>$\bar{a}^A$</span> are computed such that the symplecticity conditions <span>$b_{i} \bar{a}_{i,j} + \bar{b}_{j} a_{j,i} = b_{i} \bar{b}_{j}$</span> and <span>$b_{i} = \bar{b}_i$</span> hold for all <span>$1 \le i,j \le s$</span>.</p>reference(Val(:RadauIIB))</div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRalston2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauRalston2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRalston2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of Ralston&#39;s two-stage, 2nd order method</p><pre><code class="language-julia hljs">TableauRalston2(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Anthony Ralston.
Runge-Kutta Methods with Minimum Error Bounds.
Mathematics of Computation, Volume 16, Pages 431-437, 1962.
doi: 10.1090/S0025-5718-1962-0150954-0.
Equation (3.5)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRalston3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauRalston3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRalston3</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of Ralston&#39;s three-stage, 3rd order method</p><pre><code class="language-julia hljs">TableauRalston3(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Anthony Ralston.
Runge-Kutta Methods with Minimum Error Bounds.
Mathematics of Computation, Volume 16, Pages 431-437, 1962.
doi: 10.1090/S0025-5718-1962-0150954-0.
Equation (4.10)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRunge-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauRunge-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRunge</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of Runge&#39;s two-stage, 2nd order method</p><pre><code class="language-julia hljs">TableauRunge(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Carl Runge
Über die numerische Auflösung von Differentialgleichungen.
Mathematische Annalen, Volume 46, Pages 167-178, 1895.
doi: 10.1007/BF01446807.
Equation (3)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauRunge2" href="#RungeKutta.Tableaus.TableauRunge2"><code>RungeKutta.Tableaus.TableauRunge2</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauRunge-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauRunge</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauSRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauSRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauSRK3</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of symmetric and symplectic three-stage, 4th order Runge-Kutta method</p><pre><code class="language-julia hljs">TableauSRK3(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Shan Zhao and Guo-Wei Wei.
A unified discontinuous Galerkin framework for time integration.
Mathematical Methods in the Applied Sciences, Volume 37, Issue 7, Pages 1042-1071, 2014.
doi: 10.1002/mma.2863.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauSSPRK2-Tuple" href="#RungeKutta.Tableaus.TableauSSPRK2-Tuple"><code>RungeKutta.Tableaus.TableauSSPRK2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of 2rd order Strong Stability Preserving method with two stages and CFL ≤ 1</p><pre><code class="language-julia hljs">TableauSSPRK2(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>This is the same tableau as <a href="#RungeKutta.Tableaus.TableauHeun2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauHeun2</code></a>.</p><p>Reference:</p><pre><code class="nohighlight hljs">Chi-Wang Shu, Stanley Osher.
Efficient implementation of essentially non-oscillatory shock-capturing schemes.
Journal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.
doi: 10.1016/0021-9991(88)90177-5.
Equation (2.16)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.TableauSSPRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T" href="#RungeKutta.Tableaus.TableauSSPRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauSSPRK3</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tableau of 3rd order Strong Stability Preserving method with three stages and CFL ≤ 1</p><pre><code class="language-julia hljs">TableauSSPRK3(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="nohighlight hljs">Chi-Wang Shu, Stanley Osher.
Efficient implementation of essentially non-oscillatory shock-capturing schemes.
Journal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.
doi: 10.1016/0021-9991(88)90177-5.
Equation (2.18)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_gauss_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_gauss_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_gauss_coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The Gauss coefficients are implicitly given by the so-called simplifying assumption <span>$C(s)$</span>:</p><p class="math-container">\[\sum \limits_{j=1}^{s} a_{ij} c_{j}^{k-1} = \frac{c_i^k}{k}  \qquad i = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s .\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_gauss_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_gauss_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_gauss_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The Gauss nodes are given by the roots of the shifted Legendre polynomial <span>$P_s (2x-1)$</span> with <span>$s$</span> the number of stages.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_gauss_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_gauss_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_gauss_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The Gauss weights are given by the following integrals</p><p class="math-container">\[b_i = \bigg( \frac{dP}{dx} (c_i) \bigg)^{-2} \int \limits_0^1 \bigg( \frac{P(x)}{x - c_i} \bigg)^2 dx ,\]</p><p>where <span>$P(x)$</span> denotes the shifted Legendre polynomial <span>$P(x) = P_s (2x-1)$</span> with <span>$s$</span> the number of stages.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_lobatto_a_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_lobatto_a_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_a_coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The Lobatto IIIA coefficients are implicitly given by the so-called simplifying assumption <span>$C(s)$</span>:</p><p class="math-container">\[\sum \limits_{j=1}^{s} a_{ij} c_{j}^{k-1} = \frac{c_i^k}{k}  \qquad i = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s .\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_lobatto_b_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_lobatto_b_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_b_coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The Lobatto IIIB coefficients are implicitly given by the so-called simplifying assumption <span>$D(s)$</span>:</p><p class="math-container">\[\sum \limits_{i=1}^{s} b_i c_{i}^{k-1} a_{ij} = \frac{b_j}{k} ( 1 - c_j^k)  \qquad j = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s .\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_lobatto_c_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_lobatto_c_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_c_coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The Lobatto IIIC coefficients are determined by setting <span>$a_{i,1} = b_1$</span> and solving the so-called simplifying assumption <span>$C(s-1)$</span>, given by</p><p class="math-container">\[\sum \limits_{j=1}^{s} a_{ij} c_{j}^{k-1} = \frac{c_i^k}{k}  \qquad i = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s-1 ,\]</p><p>for <span>$a_{i,j}$</span> with <span>$i = 1, ..., s$</span> and <span>$j = 2, ..., s$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_lobatto_c̄_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_lobatto_c̄_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_c̄_coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The Lobatto IIIC̄ coefficients are determined by setting <span>$a_{i,s} = 0$</span> and solving the so-called simplifying assumption <span>$C(s-1)$</span>, given by</p><p class="math-container">\[\sum \limits_{j=1}^{s} a_{ij} c_{j}^{k-1} = \frac{c_i^k}{k}  \qquad i = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s-1 ,\]</p><p>for <span>$a_{i,j}$</span> with <span>$i = 1, ..., s$</span> and <span>$j = 1, ..., s-1$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_lobatto_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_lobatto_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The s-stage Lobatto nodes are defined as the roots of the following polynomial of degree <span>$s$</span>:</p><p class="math-container">\[\frac{d^{s-2}}{dx^{s-2}} \big( (x - x^2)^{s-1} \big) .\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_lobatto_nullvector-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_lobatto_nullvector-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_nullvector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_lobatto_nullvector(::Type, s; normalize=false)
get_lobatto_nullvector(s; kwargs...)</code></pre><p>Computes the nullvector of the matrix containing the derivatives of the Lagrange basis on the <code>s</code> Lobatto nodes evaluated on these nodes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_lobatto_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_lobatto_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The Lobatto weights can be explicitly computed by the formula</p><p class="math-container">\[b_j = \frac{1}{s (s-1) P_{s-1}(2 c_j - 1)^2} \qquad j = 1 , \, ... , \, s ,\]</p><p>where <span>$P_k$</span> is the <span>$k$</span>th Legendre polynomial, given by</p><p class="math-container">\[P_k (x) = \frac{1}{k! 2^k} \big( \frac{d^k}{dx^k} (x^2 - 1)^k \big) .\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_radau_1_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_radau_1_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_radau_1_coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The Radau IA coefficients are implicitly given by the so-called simplifying assumption <span>$D(s)$</span>:</p><p class="math-container">\[\sum \limits_{i=1}^{s} b_i c_{i}^{k-1} a_{ij} = \frac{b_j}{k} ( 1 - c_j^k)  \qquad j = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s .\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_radau_1_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_radau_1_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_radau_1_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The s-stage Radau IA nodes are defined as the roots of the following polynomial of degree <span>$s$</span>:</p><p class="math-container">\[\frac{d^{s-1}}{dx^{s-1}} \big( x^s (x - 1)^{s-1} \big) .\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_radau_1_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_radau_1_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_radau_1_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The Radau IA weights are implicitly given by the so-called simplifying assumption <span>$B(s)$</span>:</p><p class="math-container">\[\sum \limits_{j=1}^{s} b_{j} c_{j}^{k-1} = \frac{1}{k}  \qquad k = 1 , \, ... , \, s .\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_radau_2_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_radau_2_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_radau_2_coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The Radau IIA coefficients are implicitly given by the so-called simplifying assumption <span>$C(s)$</span>:</p><p class="math-container">\[\sum \limits_{j=1}^{s} a_{ij} c_{j}^{k-1} = \frac{c_i^k}{k}  \qquad i = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s .\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_radau_2_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_radau_2_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_radau_2_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The s-stage Radau IIA nodes are defined as the roots of the following polynomial of degree <span>$s$</span>:</p><p class="math-container">\[\frac{d^{s-1}}{dx^{s-1}} \big( x^{s-1} (x - 1)^s \big) .\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RungeKutta.Tableaus.get_radau_2_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#RungeKutta.Tableaus.get_radau_2_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_radau_2_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The Radau IIA weights are implicitly given by the so-called simplifying assumption <span>$B(s)$</span>:</p><p class="math-container">\[\sum \limits_{j=1}^{s} b_{j} c_{j}^{k-1} = \frac{1}{k}  \qquad k = 1 , \, ... , \, s .\]</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../solutions/">« Solutions</a><a class="docs-footer-nextpage" href="../rungekutta_partitioned/">Partitioned Runge-Kutta Tableaus »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 25 July 2023 13:25">Tuesday 25 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
