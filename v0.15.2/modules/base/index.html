<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Base · GeometricIntegrators.jl</title><meta name="title" content="Base · GeometricIntegrators.jl"/><meta property="og:title" content="Base · GeometricIntegrators.jl"/><meta property="twitter:title" content="Base · GeometricIntegrators.jl"/><meta name="description" content="Documentation for GeometricIntegrators.jl."/><meta property="og:description" content="Documentation for GeometricIntegrators.jl."/><meta property="twitter:description" content="Documentation for GeometricIntegrators.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GeometricIntegrators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../problems/">Problems</a></li><li><a class="tocitem" href="../../methods/">Methods</a></li><li><span class="tocitem">Integrators</span><ul><li><a class="tocitem" href="../../integrators/rk/">Runge-Kutta</a></li><li><a class="tocitem" href="../../integrators/splitting/">Splitting</a></li><li><a class="tocitem" href="../../integrators/variational/">Variational</a></li><li><a class="tocitem" href="../../integrators/vprk/">VPRK</a></li><li><a class="tocitem" href="../../integrators/spark/">SPARK</a></li><li><a class="tocitem" href="../../integrators/dvi/">DVI</a></li><li><a class="tocitem" href="../../integrators/hpi/">Hamilton-Pontryagin</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li class="is-active"><a class="tocitem" href>Base</a></li><li><a class="tocitem" href="../equations/">Equations</a></li><li><a class="tocitem" href="../integrators/">Integrators</a></li><li><a class="tocitem" href="../methods/">Methods</a></li><li><a class="tocitem" href="../problems/">Problems</a></li><li><a class="tocitem" href="../projections/">Projections</a></li><li><a class="tocitem" href="../rungekutta/">Runge-Kutta Tableaus</a></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li><a class="tocitem" href="../spark/">SPARK Methods</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../developer/integrators/">Integrators</a></li><li><a class="tocitem" href="../../developer/projections/">Projections</a></li><li><a class="tocitem" href="../../developer/code_integration/">Code Integration</a></li><li><a class="tocitem" href="../../developer/custom_integrators/">Custom Integrators</a></li><li><a class="tocitem" href="../../developer/adaptive_time_stepping/">Adaptive Time Stepping</a></li></ul></li><li><a class="tocitem" href="../../releasenotes/">Release Notes</a></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../authors/">Authors</a></li><li><a class="tocitem" href="../../LICENSE/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Base</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Base</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/GeometricIntegrators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGNI/GeometricIntegrators.jl/blob/main/docs/src/modules/base.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Base"><a class="docs-heading-anchor" href="#Base">Base</a><a id="Base-1"></a><a class="docs-heading-anchor-permalink" href="#Base" title="Permalink"></a></h1><p>The following data structures are all implemented in <a href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl">GeometricIntegratorsBase.jl</a>.</p><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.EulerExtrapolation"><a class="docstring-binding" href="#GeometricIntegratorsBase.EulerExtrapolation"><code>GeometricIntegratorsBase.EulerExtrapolation</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Euler extrapolation method with arbitrary order p.</p><p>Solves the ordinary differential equation</p><p class="math-container">\[\begin{aligned}
\dot{x} &amp;= v(t, x) , &amp;
x(t_0) &amp;= x_0 ,
\end{aligned}\]</p><p>for <span>$x_1 = x(t_1)$</span>, and is called with</p><pre><code class="language-julia hljs">extrapolate!(t₀, x₀, t₁, x₁, problem, EulerExtrapolation(s))</code></pre><p>where</p><ul><li><code>t₀</code>: initial time</li><li><code>t₁</code>: final   time</li><li><code>x₀</code>: initial value <span>$x_0 = x(t_0)$</span></li><li><code>x₁</code>: final   value <span>$x_1 = x(t_1)$</span></li><li><code>problem</code>: <a href="../problems/#GeometricEquations.ODEProblem"><code>ODEProblem</code></a> whose solution to extrapolate</li><li><code>s</code>:  number of interpolations (order <span>$p=s+1$</span>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/extrapolation/euler.jl#L1-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.ExplicitEuler"><a class="docstring-binding" href="#GeometricIntegratorsBase.ExplicitEuler"><code>GeometricIntegratorsBase.ExplicitEuler</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Explicit Euler Method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/euler/explicit_euler.jl#L1-L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.ExplicitEulerCache"><a class="docstring-binding" href="#GeometricIntegratorsBase.ExplicitEulerCache"><code>GeometricIntegratorsBase.ExplicitEulerCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Explicit Euler integrator cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/euler/explicit_euler.jl#L13-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.GeometricIntegrator"><a class="docstring-binding" href="#GeometricIntegratorsBase.GeometricIntegrator"><code>GeometricIntegratorsBase.GeometricIntegrator</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>GeometricIntegrator</p><p>Collects all data structures needed by an integrator:</p><ul><li><code>problem</code>: <a href="../problems/#GeometricEquations.EquationProblem"><code>EquationProblem</code></a> to solve</li><li><code>method</code>: integration method</li><li><code>cache</code>: temprary data structures needed by method</li><li><code>solver</code>: linear or nonlinear solver needed by method</li><li><code>iguess</code>: initial guess for implicit methods</li><li><code>projection</code>: optional projection method</li></ul><p>Constructors:</p><pre><code class="language-julia hljs">GeometricIntegrator(problem::EquationProblem, method::GeometricMethod; solver = default_solver(method), iguess = default_iguess(method), projection = default_projection(method))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/integrator.jl#L2-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.GeometricMethod"><a class="docstring-binding" href="#GeometricIntegratorsBase.GeometricMethod"><code>GeometricIntegratorsBase.GeometricMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><code>GeometricMethod</code> is the abstract supertype for all integration methods implemented in GeometricIntegrators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/method.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.HermiteExtrapolation"><a class="docstring-binding" href="#GeometricIntegratorsBase.HermiteExtrapolation"><code>GeometricIntegratorsBase.HermiteExtrapolation</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><strong>Hermite&#39;s Interpolating Polynomials</strong></p><p>Implements a two point Hermite inter-/extrapolation function which passes through the function and its first derivative for the interval <span>$[0,1]$</span>. The polynomial is determined by four constraint equations, matching the function and its derivative at the points <span>$0$</span> and <span>$1$</span>.</p><p>Call with one of the following methods</p><pre><code class="language-julia hljs">extrapolate!(t₀, x₀, ẋ₀, t₁, x₁, ẋ₁, t, x, HermiteExtrapolation())
extrapolate!(t₀, x₀, ẋ₀, t₁, x₁, ẋ₁, t, x, ẋ, HermiteExtrapolation())
extrapolate!(t₀, x₀, t₁, x₁, t, x, v, HermiteExtrapolation())
extrapolate!(t₀, x₀, t₁, x₁, t, x, ẋ, v, HermiteExtrapolation())
extrapolate!(t₀, x₀, t₁, x₁, t, x, problem, HermiteExtrapolation())
extrapolate!(t₀, x₀, t₁, x₁, t, x, ẋ, problem, HermiteExtrapolation())</code></pre><p>where</p><ul><li><code>t₀</code>: first  sample time <span>$t_0$</span></li><li><code>x₀</code>: first  solution value <span>$x_0 = x(t_0)$</span></li><li><code>ẋ₀</code>: first  vector field value <span>$ẋ_0 = v(t_0, x(t_0))$</span></li><li><code>t₁</code>: second sample time <span>$t_1$</span></li><li><code>x₁</code>: second solution value <span>$x_1 = x(t_1)$</span></li><li><code>ẋ₁</code>: second vector field value <span>$ẋ_1 = v(t_1, x(t_1))$</span></li><li><code>t</code>:  time <span>$t$</span> to extrapolate</li><li><code>x</code>:  extrapolated solution value <span>$x(t)$</span></li><li><code>ẋ</code>:  extrapolated vector field value <span>$ẋ(t)$</span></li><li><code>v</code>:  function to compute vector field with signature <code>v(ẋ,t,x)</code></li><li><code>problem</code>: <a href="../problems/#GeometricEquations.ODEProblem"><code>ODEProblem</code></a> whose vector field to use</li></ul><p><strong>Derivation</strong></p><p>The interpolation works as follows: Start by defining the 3rd degree polynomial and its derivative by</p><p class="math-container">\[\begin{aligned}
g(x) &amp;= a_0 + a_1 x + a_2 x^2 + a_3 x^3 , \\
g&#39;(x) &amp;= a_1 + 2 a_2 x + 3 a_3 x^2 ,
\end{aligned}\]</p><p>and apply the constraints</p><p class="math-container">\[\begin{aligned}
g(0) &amp;= f_0 &amp; &amp; \Rightarrow &amp; a_0 &amp;= f_0 , \\
g(1) &amp;= f_1 &amp; &amp; \Rightarrow &amp; a_0 + a_1 + a_2 + a_3 &amp;= f_1 , \\
g&#39;(0) &amp;= f&#39;_0 &amp; &amp; \Rightarrow &amp; a_1 &amp;= f&#39;_0 , \\
g&#39;(1) &amp;= f&#39;_1 &amp; &amp; \Rightarrow &amp; a_1 + 2 a_2 + 3 a_3 &amp;= f&#39;_1 . \\
\end{aligned}\]</p><p>Solving for <span>$a_0, a_1, a_2, a_3$</span> leads to</p><p class="math-container">\[\begin{aligned}
a_0 &amp;= f_0 , &amp;
a_1 &amp;= f&#39;_0 , &amp;
a_2 &amp;= - 3 f_0 + 3 f_1 - 2 f&#39;_0 - f&#39;_1 , &amp;
a_3 &amp;= 2 f_0 - 2 f_1 + f&#39;_0 + f&#39;_1 ,
\end{aligned}\]</p><p>so that the polynomial <span>$g(x)$</span> reads</p><p class="math-container">\[g(x) = f_0 + f&#39;_0 x + (- 3 f_0 + 3 f_1 - 2 f&#39;_0 - f&#39;_1) x^2 + (2 f_0 - 2 f_1 + f&#39;_0 + f&#39;_1) x^3 .\]</p><p>The function and derivative values can be factored out, so that <span>$g(x)$</span> can be rewritten as</p><p class="math-container">\[g(x) = f_0 (1 - 3 x^2 + 2 x^3) + f_1 (3 x^2 - 2 x^3) + f&#39;_0 (x - 2 x^2 + x^3) + f&#39;_1 (- x^2 + x^3) ,\]</p><p>or in generic form as</p><p class="math-container">\[g(x) = f_0 a_0(x) + f_1 a_1(x) + f&#39;_0 b_0(x) + f&#39;_1 b_1(x) ,\]</p><p>with basis functions</p><p class="math-container">\[\begin{aligned}
a_0 (x) &amp;= 1 - 3 x^2 + 2 x^3 , &amp;
b_0 (x) &amp;= x - 2 x^2 + x^3 , \\
a_1 (x) &amp;= 3 x^2 - 2 x^3 , &amp;
b_1 (x) &amp;= - x^2 + x^3 .
\end{aligned}\]</p><p>The derivative <span>$g&#39;(x)$</span> accordingly reads</p><p class="math-container">\[g&#39;(x) = f_0 a&#39;_0(x) + f_1 a&#39;_1(x) + f&#39;_0 b&#39;_0(x) + f&#39;_1 b&#39;_1(x) ,\]</p><p>with</p><p class="math-container">\[\begin{aligned}
a&#39;_0 (x) &amp;= - 6 x + 6 x^2 , &amp;
b&#39;_0 (x) &amp;= 1 - 4 x + 3 x^2 , \\
a&#39;_1 (x) &amp;= 6 x - 6 x^2 , &amp;
b&#39;_1 (x) &amp;= - 2 x + 3 x^2 .
\end{aligned}\]</p><p>The basis functions <span>$a_0$</span>and <span>$a_1$</span> are associated with the function values at <span>$x_0$</span> and <span>$x_1$</span>, respectively, while the basis functions <span>$b_0$</span> and <span>$b_1$</span> are associated with the derivative values at <span>$x_0$</span> and <span>$x_1$</span>. The basis functions satisfy the following relations,</p><p class="math-container">\[\begin{aligned}
a_i (x_j) &amp;= \delta_{ij} , &amp;
b_i (x_j) &amp;= 0 , &amp;
a&#39;_i (x_j) &amp;= 0 , &amp;
b&#39;_i (x_j) &amp;= \delta_{ij} , &amp;
i,j &amp;= 0, 1 ,
\end{aligned}\]</p><p>where <span>$\delta_{ij}$</span> denotes the Kronecker-delta, so that</p><p class="math-container">\[\begin{aligned}
g(0) &amp;= f_0 , &amp;
g(1) &amp;= f_1 , &amp;
g&#39;(0) &amp;= f&#39;_0 , &amp;
g&#39;(1) &amp;= f&#39;_1 .
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/extrapolation/hermite.jl#L1-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.ImplicitEuler"><a class="docstring-binding" href="#GeometricIntegratorsBase.ImplicitEuler"><code>GeometricIntegratorsBase.ImplicitEuler</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Implicit Euler Method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/euler/implicit_euler.jl#L1-L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.ImplicitEulerCache"><a class="docstring-binding" href="#GeometricIntegratorsBase.ImplicitEulerCache"><code>GeometricIntegratorsBase.ImplicitEulerCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Implicit Euler integrator cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/euler/implicit_euler.jl#L14-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.MidpointExtrapolation"><a class="docstring-binding" href="#GeometricIntegratorsBase.MidpointExtrapolation"><code>GeometricIntegratorsBase.MidpointExtrapolation</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Midpoint extrapolation method with arbitrary order p.</p><p>For an <a href="../problems/#GeometricEquations.ODEProblem"><code>ODEProblem</code></a>, this solves the ordinary differential equation</p><p class="math-container">\[\begin{aligned}
\dot{x} &amp;= v(t, x) , &amp;
x(t_0) &amp;= x_0 ,
\end{aligned}\]</p><p>for <span>$x_1 = x(t_1)$</span>, and is called with</p><pre><code class="language-julia hljs">extrapolate!(t₀, x₀, t₁, x₁, ::ODEProblem, MidpointExtrapolation(s))</code></pre><p>where</p><ul><li><code>t₀</code>: initial time</li><li><code>x₀</code>: initial value <span>$x_0 = x(t_0)$</span></li><li><code>t₁</code>: final   time</li><li><code>x₁</code>: final   value <span>$x_1 = x(t_1)$</span></li><li><code>s</code>:  number of interpolations (order <span>$p=2s+2$</span>)</li></ul><p>For a <a href="../problems/#GeometricEquations.PODEProblem"><code>PODEProblem</code></a> or <a href="../problems/#GeometricEquations.HODEProblem"><code>HODEProblem</code></a>, this solves the partitioned ordinary differential equation</p><p class="math-container">\[\begin{aligned}
\dot{q} &amp;= v(t, q, p) , &amp;
q(t_0) &amp;= q_0 , \\
\dot{p} &amp;= f(t, q, p) , &amp;
p(t_0) &amp;= p_0 ,
\end{aligned}\]</p><p>for <span>$q_1 = q(t_1)$</span> and <span>$p_1 = p(t_1)$</span>m and is called with</p><pre><code class="language-julia hljs">extrapolate!(t₀, q₀, p₀, t₁, q₁, p₁, ::PODEProblem, MidpointExtrapolation(s))
extrapolate!(t₀, q₀, p₀, t₁, q₁, p₁, ::HODEProblem, MidpointExtrapolation(s))</code></pre><p>where</p><ul><li><code>t₀</code>: initial time</li><li><code>q₀</code>: initial position <span>$q_0 = q(t_0)$</span></li><li><code>p₀</code>: initial momentum <span>$p_0 = p(t_0)$</span></li><li><code>t₁</code>: final   time</li><li><code>q₁</code>: final   position <span>$q_1 = q(t_1)$</span></li><li><code>p₁</code>: final   momentum <span>$p_1 = p(t_1)$</span></li><li><code>s</code>:  number of interpolations (order <span>$p=2s+2$</span>)</li></ul><p>Similarly, for a <a href="../problems/#GeometricEquations.IODEProblem"><code>IODEProblem</code></a> or <a href="../problems/#GeometricEquations.LODEProblem"><code>LODEProblem</code></a>, this solves the explicit dynamical equation</p><p class="math-container">\[\begin{aligned}
\dot{q} &amp;= v(t, q) , &amp;
q(t_0) &amp;= q_0 , \\
\dot{p} &amp;= f(t, q, v) , &amp;
p(t_0) &amp;= p_0 ,
\end{aligned}\]</p><p>corresponding to the implicit problem, for <span>$q_1 = q(t_1)$</span> and <span>$p_1 = p(t_1)$</span>, and is called with</p><pre><code class="language-julia hljs">extrapolate!(t₀, q₀, p₀, t₁, q₁, p₁, ::IODEProblem, MidpointExtrapolation(s))
extrapolate!(t₀, q₀, p₀, t₁, q₁, p₁, ::LODEProblem, MidpointExtrapolation(s))</code></pre><p>where</p><ul><li><code>t₀</code>: initial time</li><li><code>q₀</code>: initial position <span>$q_0 = q(t_0)$</span></li><li><code>p₀</code>: initial momentum <span>$p_0 = p(t_0)$</span></li><li><code>t₁</code>: final   time</li><li><code>q₁</code>: final   position <span>$q_1 = q(t_1)$</span></li><li><code>p₁</code>: final   momentum <span>$p_1 = p(t_1)$</span></li><li><code>s</code>:  number of interpolations (order <span>$p=2s+2$</span>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/extrapolation/midpoint.jl#L1-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.ProjectionMethod"><a class="docstring-binding" href="#GeometricIntegratorsBase.ProjectionMethod"><code>GeometricIntegratorsBase.ProjectionMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A <code>ProjectionMethod</code> is an algorithm that is applied together with a geometric integrator to enforce constraints which are not automatically satisfied by the integrator. Examples include conservation of invariants like energy or the Dirac constraint in <a href="../equations/#GeometricEquations.IODE"><code>IODE</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/projection.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.SolutionStep"><a class="docstring-binding" href="#GeometricIntegratorsBase.SolutionStep"><code>GeometricIntegratorsBase.SolutionStep</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Holds the solution of a geometric equation at a single time step.</p><p>It stores all the information that is passed from one time step to the next. This includes the current solution, the vectorfield of the equation, and solution data from previous time steps.</p><p><strong>Type Parameters</strong></p><ul><li><code>equationType</code>: type of the geometric equation</li><li><code>solutionType</code>: type of the solution tuple</li><li><code>vectorfieldType</code>: type of the vectorfield tuple</li><li><code>historyType</code>: type of the history tuple</li><li><code>internalType</code>: type of the internal variables tuple</li><li><code>paramsType</code>: type of the parameters</li><li><code>nHistory</code>: number of previous time steps to store</li></ul><p><strong>Fields</strong></p><ul><li><code>solution</code>: a <code>NamedTuple</code> of <code>OffsetVector</code>s holding the solution of the current and previous <code>nHistory</code> time steps. The indices of the <code>OffsetVector</code> are <code>0...nHistory</code>. <code>solution[k][0]</code> is the current solution for variable <code>k</code>, <code>solution[k][1]</code> the solution at the previous time step, and so on.</li><li><code>vectorfield</code>: a <code>NamedTuple</code> of <code>OffsetVector</code>s holding the vector field of the current and previous <code>nHistory</code> time steps.</li><li><code>history</code>: a <code>NamedTuple</code> that provides convenient access to solution and vectorfield of the current and previous time steps.</li><li><code>internal</code>: a <code>NamedTuple</code> for integrator-specific internal variables.</li><li><code>parameters</code>: the parameters of the equation.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SolutionStep{equType}(ics::NamedTuple, parameters::OptionalParameters; nhistory=1, internal=NamedTuple())
SolutionStep(problem::GeometricProblem; kwargs...)</code></pre><p>The constructor <code>SolutionStep{equType}(...)</code> automatically constructs the appropriate solution step object from the given initial conditions <code>ics</code> and <code>parameters</code>. The <code>internal</code> field of the solution step is for integrator-specific internal state. The <code>solutionstep(integrator, ...)</code> function is a convenient wrapper to construct a <code>SolutionStep</code> with the correct internal variables for a given integrator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L34-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy!-Tuple{SolutionStep, EquationProblem}"><a class="docstring-binding" href="#Base.copy!-Tuple{SolutionStep, EquationProblem}"><code>Base.copy!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Copy the initial conditions of a <code>EquationProblem</code> to the current state of a solution step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L344-L346">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy!-Tuple{SolutionStep, NamedTuple}"><a class="docstring-binding" href="#Base.copy!-Tuple{SolutionStep, NamedTuple}"><code>Base.copy!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">copy!(solstep::SolutionStep, sol::NamedTuple)</code></pre><p>Copy the values from a <code>NamedTuple</code> <code>sol</code> to the current time step of the solution step.</p><p>The keys of <code>sol</code> must be a subset of the keys of the solution step. Only the current time step (index 0) of the solution step is modified.</p><p><strong>Arguments</strong></p><ul><li><code>solstep</code>: the solution step to copy into</li><li><code>sol</code>: the named tuple containing the solution values to copy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L318-L329">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.keys-Tuple{SolutionStep}"><a class="docstring-binding" href="#Base.keys-Tuple{SolutionStep}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">keys(solstep::SolutionStep)</code></pre><p>Return the keys of the solution variables in the solution step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L238-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.integrate!-Tuple{GeometricSolution, AbstractIntegrator, Int64, Int64}"><a class="docstring-binding" href="#GeometricBase.integrate!-Tuple{GeometricSolution, AbstractIntegrator, Int64, Int64}"><code>GeometricBase.integrate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Solve for time steps n with n₁ ≤ n ≤ n₂.</p><pre><code class="language-julia hljs">integrate!(solution, integrator, n₁, n₂)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/integrate.jl#L34-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.integrate!-Tuple{GeometricSolution, AbstractIntegrator}"><a class="docstring-binding" href="#GeometricBase.integrate!-Tuple{GeometricSolution, AbstractIntegrator}"><code>GeometricBase.integrate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Solve for all time steps n:</p><pre><code class="language-julia hljs">integrate!(solution, integrator)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/integrate.jl#L80-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.integrate!-Tuple{SolutionStep, AbstractIntegrator}"><a class="docstring-binding" href="#GeometricBase.integrate!-Tuple{SolutionStep, AbstractIntegrator}"><code>GeometricBase.integrate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Parts of one integration step that are common to most if not all typical integrators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/integrate.jl#L6-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.parameters-Tuple{SolutionStep}"><a class="docstring-binding" href="#GeometricBase.parameters-Tuple{SolutionStep}"><code>GeometricBase.parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parameters(solstep::SolutionStep)</code></pre><p>Return the parameters field of the solution step, which contains the parameters of the geometric equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L230-L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.reset!-Tuple{SolutionStep, Any}"><a class="docstring-binding" href="#GeometricBase.reset!-Tuple{SolutionStep, Any}"><code>GeometricBase.reset!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset!(solstep::SolutionStep, Δt)</code></pre><p>Reset the solution step for the next time step by shifting the solution history backward and advancing the time by <code>Δt</code>.</p><p>This function moves the current solution to the previous time step position, the previous solution to the one before that, and so on. The time variable is incremented by <code>Δt</code>. This prepares the solution step for computing the next time step.</p><p><strong>Arguments</strong></p><ul><li><code>solstep</code>: the solution step to reset</li><li><code>Δt</code>: the time step size to advance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L289-L303">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricBase.update!-Tuple{SolutionStep, NamedTuple}"><a class="docstring-binding" href="#GeometricBase.update!-Tuple{SolutionStep, NamedTuple}"><code>GeometricBase.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(solstep::SolutionStep, Δ::NamedTuple)</code></pre><p>Update the current solution in the solution step by adding increments.</p><p>This function applies increments to the current solution variables (at index 0) in the solution step. The increments are added using the appropriate <code>add!</code> method for each variable type, which handles different variable types correctly (e.g., compensated summation for StateWithError variables).</p><p><strong>Arguments</strong></p><ul><li><code>solstep::SolutionStep</code>: The solution step to update</li><li><code>Δ::NamedTuple</code>: Named tuple containing increments for each variable to update. Keys must be a subset of the solution step&#39;s variable keys.</li></ul><p><strong>Returns</strong></p><ul><li><code>solstep</code>: The updated solution step (for method chaining)</li></ul><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If any key in <code>Δ</code> is not present in the solution step</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a solution step
solstep = SolutionStep{MyEquation}(initial_conditions, parameters)

# Update with increments
update!(solstep, (q = [0.1, 0.2], p = [0.05, 0.1]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L361-L390">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.aitken_neville!-Union{Tuple{TT}, Tuple{AbstractArray, TT, AbstractVector{TT}, AbstractVector}} where TT"><a class="docstring-binding" href="#GeometricIntegratorsBase.aitken_neville!-Union{Tuple{TT}, Tuple{AbstractArray, TT, AbstractVector{TT}, AbstractVector}} where TT"><code>GeometricIntegratorsBase.aitken_neville!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute p(x) where p is the unique polynomial of degree length(xi), such that p(x[i]) = y[i]) for all i. Call with</p><pre><code class="language-julia hljs">aitken_neville!(x::AbstractVector, t::Real, ti::AbstractVector, xi::AbstractMatrix)</code></pre><p>where</p><ul><li><code>x</code>:  evaluation value</li><li><code>t</code>:  evaluation point</li><li><code>ti</code>: interpolation nodes</li><li><code>xi</code>: interpolation values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/extrapolation/aitken_neville.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.current-Tuple{SolutionStep}"><a class="docstring-binding" href="#GeometricIntegratorsBase.current-Tuple{SolutionStep}"><code>GeometricIntegratorsBase.current</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Returns a NamedTuple with the solution of the current time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L275-L277">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.enforce_periodicity!-Tuple{SolutionStep, OffsetArrays.OffsetVector{var&quot;#s131&quot;, AA} where {var&quot;#s131&quot;&lt;:GeometricBase.AbstractVariable, AA&lt;:AbstractVector{var&quot;#s131&quot;}}}"><a class="docstring-binding" href="#GeometricIntegratorsBase.enforce_periodicity!-Tuple{SolutionStep, OffsetArrays.OffsetVector{var&quot;#s131&quot;, AA} where {var&quot;#s131&quot;&lt;:GeometricBase.AbstractVariable, AA&lt;:AbstractVector{var&quot;#s131&quot;}}}"><code>GeometricIntegratorsBase.enforce_periodicity!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enforce_periodicity!(solstep::SolutionStep, ::OffsetVector{&lt;:AbstractVariable})</code></pre><p>No-op method for non-periodic variables.</p><p>This method is called for variable types that do not support periodicity constraints and performs no operation.</p><p><strong>Arguments</strong></p><ul><li><code>solstep::SolutionStep</code>: The solution step (unused)</li><li><code>::OffsetVector{&lt;:AbstractVariable}</code>: The variable vector (unused)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L403-L414">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.enforce_periodicity!-Tuple{SolutionStep, OffsetArrays.OffsetVector{var&quot;#s30&quot;, AA} where {var&quot;#s30&quot;&lt;:(Union{var&quot;#s7&quot;, var&quot;#s4&quot;} where {var&quot;#s7&quot;&lt;:StateVariable, var&quot;#s4&quot;&lt;:(StateVariableWithError)}), AA&lt;:AbstractVector{var&quot;#s30&quot;}}}"><a class="docstring-binding" href="#GeometricIntegratorsBase.enforce_periodicity!-Tuple{SolutionStep, OffsetArrays.OffsetVector{var&quot;#s30&quot;, AA} where {var&quot;#s30&quot;&lt;:(Union{var&quot;#s7&quot;, var&quot;#s4&quot;} where {var&quot;#s7&quot;&lt;:StateVariable, var&quot;#s4&quot;&lt;:(StateVariableWithError)}), AA&lt;:AbstractVector{var&quot;#s30&quot;}}}"><code>GeometricIntegratorsBase.enforce_periodicity!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enforce_periodicity!(solstep::SolutionStep, s::OffsetVector{&lt;:Union{&lt;:StateVariable,&lt;:StateVariableWithError}})</code></pre><p>Enforce periodic boundary conditions on a state variable.</p><p>This function checks each component of the state variable for periodic boundary conditions and adjusts values that fall outside the specified range by adding or subtracting the range size. The adjustment is applied to both the current solution and all historical values to maintain consistency for initial guesses in iterative solvers.</p><p><strong>Arguments</strong></p><ul><li><code>solstep::SolutionStep</code>: The solution step containing the variable</li><li><code>s::OffsetVector{&lt;:Union{&lt;:StateVariable,&lt;:StateVariableWithError}}</code>: The state variable to enforce periodicity on</li></ul><p><strong>Details</strong></p><p>For each component <code>i</code> of the state variable:</p><ul><li>If <code>isperiodic(s[0], i)</code> is true, check if <code>s[0][i]</code> is within <code>range(s[0], i)</code></li><li>If below the range, add the range size until within bounds</li><li>If above the range, subtract the range size until within bounds</li><li>Apply the same adjustment to all historical values <code>s[j][i]</code> for consistency</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L418-L440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.enforce_periodicity!-Tuple{SolutionStep}"><a class="docstring-binding" href="#GeometricIntegratorsBase.enforce_periodicity!-Tuple{SolutionStep}"><code>GeometricIntegratorsBase.enforce_periodicity!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enforce_periodicity!(solstep::SolutionStep)</code></pre><p>Enforce periodic boundary conditions on all solution variables.</p><p>This function iterates through all variables in the solution step and calls <code>enforce_periodicity!</code> on each one. Variables that support periodicity will have their boundary conditions enforced, while others will be unaffected.</p><p><strong>Arguments</strong></p><ul><li><code>solstep::SolutionStep</code>: The solution step to enforce periodicity on</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L469-L481">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.history-Tuple{SolutionStep, Int64}"><a class="docstring-binding" href="#GeometricIntegratorsBase.history-Tuple{SolutionStep, Int64}"><code>GeometricIntegratorsBase.history</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">history(solstep::SolutionStep, i::Int)</code></pre><p>Return a NamedTuple with the history (solution and vectorfield) at time step <code>i</code>, where <code>i=0</code> is the current time step, <code>i=1</code> is the previous time step, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L265-L270">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.history-Tuple{SolutionStep}"><a class="docstring-binding" href="#GeometricIntegratorsBase.history-Tuple{SolutionStep}"><code>GeometricIntegratorsBase.history</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">history(solstep::SolutionStep)</code></pre><p>Return the history field of the solution step, which provides convenient access to both solution and vectorfield data at the current and previous time steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L214-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.integrate_step!"><a class="docstring-binding" href="#GeometricIntegratorsBase.integrate_step!"><code>GeometricIntegratorsBase.integrate_step!</code></a> — <span class="docstring-category">Function</span></summary><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/integrator.jl#L100-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.internal-Tuple{SolutionStep}"><a class="docstring-binding" href="#GeometricIntegratorsBase.internal-Tuple{SolutionStep}"><code>GeometricIntegratorsBase.internal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">internal(solstep::SolutionStep)</code></pre><p>Return the internal field of the solution step, which contains integrator-specific internal variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L222-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.internal_variables-Tuple{GeometricIntegrator}"><a class="docstring-binding" href="#GeometricIntegratorsBase.internal_variables-Tuple{GeometricIntegrator}"><code>GeometricIntegratorsBase.internal_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">internal_variables(::Integrator) = NamedTuple()</code></pre><p>Returns a <code>NamedTuple</code> containing all internal variables of an integrator that shall be stored in an <a href="#GeometricIntegratorsBase.SolutionStep"><code>SolutionStep</code></a>. If there is no method for a specific integrator implemented an empty <code>NamedTuple()</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/integrator.jl#L106-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.nhistory-Union{Tuple{SolutionStep{ET, ST, VT, HT, IT, PT, NT}}, Tuple{NT}, Tuple{PT}, Tuple{IT}, Tuple{HT}, Tuple{VT}, Tuple{ST}, Tuple{ET}} where {ET, ST, VT, HT, IT, PT, NT}"><a class="docstring-binding" href="#GeometricIntegratorsBase.nhistory-Union{Tuple{SolutionStep{ET, ST, VT, HT, IT, PT, NT}}, Tuple{NT}, Tuple{PT}, Tuple{IT}, Tuple{HT}, Tuple{VT}, Tuple{ST}, Tuple{ET}} where {ET, ST, VT, HT, IT, PT, NT}"><code>GeometricIntegratorsBase.nhistory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nhistory(solstep::SolutionStep)</code></pre><p>Return the number of previous time steps stored in the solution step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L191-L195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.previous-Tuple{SolutionStep}"><a class="docstring-binding" href="#GeometricIntegratorsBase.previous-Tuple{SolutionStep}"><code>GeometricIntegratorsBase.previous</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Returns a NamedTuple with the solution of the previous time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L280-L282">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.solution-Tuple{SolutionStep, Int64}"><a class="docstring-binding" href="#GeometricIntegratorsBase.solution-Tuple{SolutionStep, Int64}"><code>GeometricIntegratorsBase.solution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solution(solstep::SolutionStep, i::Int)</code></pre><p>Return a NamedTuple with the solution at time step <code>i</code>, where <code>i=0</code> is the current time step, <code>i=1</code> is the previous time step, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L245-L250">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.solution-Tuple{SolutionStep}"><a class="docstring-binding" href="#GeometricIntegratorsBase.solution-Tuple{SolutionStep}"><code>GeometricIntegratorsBase.solution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solution(solstep::SolutionStep)</code></pre><p>Return the solution field of the solution step, which contains the solution vectors for all variables at the current and previous time steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L198-L203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.vectorfield-Tuple{SolutionStep, Int64}"><a class="docstring-binding" href="#GeometricIntegratorsBase.vectorfield-Tuple{SolutionStep, Int64}"><code>GeometricIntegratorsBase.vectorfield</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vectorfield(solstep::SolutionStep, i::Int)</code></pre><p>Return a NamedTuple with the vectorfield at time step <code>i</code>, where <code>i=0</code> is the current time step, <code>i=1</code> is the previous time step, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L255-L260">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GeometricIntegratorsBase.vectorfield-Tuple{SolutionStep}"><a class="docstring-binding" href="#GeometricIntegratorsBase.vectorfield-Tuple{SolutionStep}"><code>GeometricIntegratorsBase.vectorfield</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vectorfield(solstep::SolutionStep)</code></pre><p>Return the vectorfield field of the solution step, which contains the vectorfield evaluations for all variables at the current and previous time steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricIntegratorsBase.jl/blob/v0.1.7/src/solutionstep.jl#L206-L211">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../integrators/hpi/">« Hamilton-Pontryagin</a><a class="docs-footer-nextpage" href="../equations/">Equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 10 December 2025 20:31">Wednesday 10 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
