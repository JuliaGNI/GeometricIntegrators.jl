<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · GeometricIntegrators.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GeometricIntegrators.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Tutorial</a><ul class="internal"><li><a class="toctext" href="#Equations-1">Equations</a></li><li><a class="toctext" href="#Integrators-1">Integrators</a></li><li><a class="toctext" href="#Tableaus-1">Tableaus</a></li><li><a class="toctext" href="#Solutions-1">Solutions</a></li></ul></li><li><span class="toctext">Integrators</span><ul><li><a class="toctext" href="../integrators/">Overview</a></li><li><a class="toctext" href="../integrators/splitting/">Splitting</a></li><li><a class="toctext" href="../integrators/rk/">Runge-Kutta</a></li><li><a class="toctext" href="../integrators/vprk/">VPRK</a></li><li><a class="toctext" href="../integrators/spark/">SPARK</a></li><li><a class="toctext" href="../integrators/cgvi/">CGVI</a></li><li><a class="toctext" href="../integrators/dgvi/">DGVI</a></li><li><a class="toctext" href="../integrators/hpg/">HPG</a></li></ul></li><li><span class="toctext">Modules</span><ul><li><a class="toctext" href="../modules/basis_functions/">Basis Functions</a></li><li><a class="toctext" href="../modules/discontinuities/">Discontinuities</a></li><li><a class="toctext" href="../modules/equations/">Equations</a></li><li><a class="toctext" href="../modules/integrators/">Integrators</a></li><li><a class="toctext" href="../modules/interpolation/">Interpolation</a></li><li><a class="toctext" href="../modules/solvers_linear/">Linear Solvers</a></li><li><a class="toctext" href="../modules/solvers_nonlinear/">Nonlinear Solvers</a></li><li><a class="toctext" href="../modules/quadratures/">Quadrature Rules</a></li><li><a class="toctext" href="../modules/solutions/">Solutions</a></li><li><a class="toctext" href="../modules/tableaus/">Tableaus</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial</a></li></ul><a class="edit-page" href="https://github.com/DDMGNI/GeometricIntegrators.jl/blob/master/docs/src/tutorial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-1" href="#Tutorial-1">Tutorial</a></h1><p>In the simplest cases, the use of <code>GeometricIntegrators.jl</code> requires the construction of two objects, an equation and an integrator. The integrator is usually implicitly selected by specifying an equation and a tableau.</p><h2><a class="nav-anchor" id="Equations-1" href="#Equations-1">Equations</a></h2><p>In <em>GeometricIntegrators.jl</em> we distinguish between three basic types of equations: ordinary differential equations (ODEs), differential algebraic equations (DAEs) and stochastic differential equations (SDEs). For each type, there are several subtypes like implicit equations (IODE, etc.), partitioned equations (PODE, etc.) or split equations (SODE, etc.).</p><p>Instantiating an ODE object for the pendulum problem \[ \dot{x}<em>1 = x</em>2 , \hspace{3em} \dot{x}<em>2 = \sin (x</em>1) , \] can be achieved by</p><pre><code class="language-julia">function pendulum_rhs(t, x, f)
    f[1] = x[2]
    f[2] = sin(x[1])
end

ode = ODE(pendulum_rhs, [acos(0.4), 0.0])</code></pre><p>The first argument to the ODE constructor is the function that determines the vector field of the equation <span>$\dot{x} (t) = f(t, x(t))$</span>, and the second argument determines the initial conditions. The function defining the vector field has to take three arguments, the current time <code>t</code>, the current solution vector <code>x</code> and the output vector <code>f</code>.</p><p>The pendulum problem is a Hamiltonian system that can also be expressed as \[ \dot{q} = \frac{\partial H}{\partial p} = p , \hspace{3em} \dot{p} = - \frac{\partial H}{\partial q} = \sin (q) , \hspace{3em} H (q,p) = \frac{1}{2} p^2 + \cos (q) . \] This structure, namely the partitioning into two sets of variables <span>$(q,p)$</span> instead of <span>$x$</span>, can be exploited for more efficient integration. Such equations can be defined in terms of a partitioned ODE, where the vector fields are specified separately,</p><pre><code class="language-julia">function pendulum_v(t, q, p, v)
    v[1] = p[1]
end

function pendulum_f(t, q, p, f)
    f[1] = sin(q[1])
end

pode = PODE(pendulum_v, pendulum_f, [acos(0.4)], [0.0])</code></pre><p>The first two arguments to the PODE constructor are the functions that determine the vector fields of the equations <span>$\dot{q} (t) = v(t, q(t), p(t))$</span> and <span>$\dot{p} (t) = f(t, q(t), p(t))$</span>. The third and fourth argument determines the initial conditions of <span>$q$</span> and <span>$p$</span>, respectively. The functions defining the vector field have to take four arguments, the current time <code>t</code>, the current solution vectors <code>q</code> and <code>p</code> and the output vector <code>v</code> or <code>f</code>.</p><h2><a class="nav-anchor" id="Integrators-1" href="#Integrators-1">Integrators</a></h2><p>We support a number of standard integrators (geometric and non-geometric) like explicit, implicit and partitioned Runge-Kutta methods, splitting methods and general linear methods (<em>planned</em>).</p><p>In order to instantiate many of the standard integrators, one needs to specify an ODE, a tableau and a timestep, e.g.,</p><pre><code class="language-julia">int = Integrator(ode, getTableauExplicitEuler(), 0.1)</code></pre><p>In order to run the integrator, the <code>integrate()</code> functions is called, passing an integrator object and the number of time steps to integrate:</p><pre><code class="language-julia">sol = integrate(int, 10)</code></pre><p>The integrate function automatically creates an appropriate solution object, that contains the result of the integration.</p><p>For a Hamiltonian system, defined as a PODE, a different tableau might be more appropriate, for example a symplectic Euler method,</p><pre><code class="language-julia">int = Integrator(pode, getTableauSymplecticEulerA(), 0.1)
sol = integrate(int, 10)</code></pre><p>This creates a different integrator, which exploits the partitioned structure of the system. The solution return by the integrate step will also be a different solution, adapted to the partitioned system.</p><h2><a class="nav-anchor" id="Tableaus-1" href="#Tableaus-1">Tableaus</a></h2><p>Many tableaus for Runge-Kutta methods are predefined and can easily be used like outlined above. In particular, this includes the following methods:</p><h4><a class="nav-anchor" id="Explicit-Runge-Kutta-Methods-1" href="#Explicit-Runge-Kutta-Methods-1">Explicit Runge-Kutta Methods</a></h4><table><tr><th>Function</th><th>Order</th><th>Method</th></tr><tr><td><code>getTableauExplicitEuler()</code></td><td>1</td><td>Explicit / Forward Euler</td></tr><tr><td><code>getTableauExplicitMidpoint()</code></td><td>2</td><td>Explicit Midpoint</td></tr><tr><td><code>getTableauHeun()</code></td><td>2</td><td>Heun&#39;s Method</td></tr><tr><td><code>getTableauKutta()</code></td><td>3</td><td>Kutta&#39;s Method</td></tr><tr><td><code>getTableauERK4()</code></td><td>4</td><td>Explicit 4th order Runge-Kutta (1/6 rule)</td></tr><tr><td><code>getTableauERK438()</code></td><td>4</td><td>Explicit 4th order Runge-Kutta (3/8 rule)</td></tr></table><h4><a class="nav-anchor" id="Fully-Implicit-Runge-Kutta-Methods-1" href="#Fully-Implicit-Runge-Kutta-Methods-1">Fully Implicit Runge-Kutta Methods</a></h4><table><tr><th>Function</th><th>Order</th><th>Method</th></tr><tr><td><code>getTableauImplicitEuler()</code></td><td>1</td><td>Implicit / Backward Euler</td></tr><tr><td><code>getTableauImplicitMidpoint()</code></td><td>2</td><td>Implicit Midpoint</td></tr><tr><td><code>getTableauRadIIA2()</code></td><td>3</td><td>Radau-IIA s=2</td></tr><tr><td><code>getTableauRadIIA3()</code></td><td>5</td><td>Radau-IIA s=3</td></tr><tr><td><code>getTableauSRK3()</code></td><td>4</td><td>Symmetric Runge-Kutta s=3</td></tr><tr><td><code>getTableauGLRK(s)</code></td><td>2s</td><td>Gauss-Legendre Runge-Kutta</td></tr></table><h4><a class="nav-anchor" id="Explicit-Partitioned-Runge-Kutta-Methods-1" href="#Explicit-Partitioned-Runge-Kutta-Methods-1">Explicit Partitioned Runge-Kutta Methods</a></h4><table><tr><th>Function</th><th>Order</th><th>Method</th></tr><tr><td><code>getTableauSymplecticEulerA()</code></td><td>1</td><td>Symplectic Euler A</td></tr><tr><td><code>getTableauSymplecticEulerB()</code></td><td>1</td><td>Symplectic Euler B</td></tr><tr><td><code>getTableauLobattoIIIAIIIB2()</code></td><td>2</td><td>Lobatto-IIIA-IIIB</td></tr><tr><td><code>getTableauLobattoIIIBIIIA2()</code></td><td>2</td><td>Lobatto-IIIB-IIIA</td></tr></table><h4><a class="nav-anchor" id="Custom-Tableaus-1" href="#Custom-Tableaus-1">Custom Tableaus</a></h4><p>If required, it is straight-forward to create a custom tableau. The tableau of Heun&#39;s method, for example, is defined as follows:</p><pre><code class="language-julia">a = [[0.0 0.0]
     [1.0 0.0]]
b = [0.5, 0.5]
c = [0.0, 1.0]
o = 2

tab = TableauERK(:heun, o, a, b, c)</code></pre><p>Here, <code>o</code> is the order of the method, <code>a</code> are the coefficients, <code>b</code> the weights and <code>c</code> the nodes. <code>TableauERK</code> states that the method is explicit. Other choices include <code>TableauFIRK</code> for fully implicit Runge-Kutta methods, <code>TableauDIRK</code> for diagonally implicit and <code>TableauSIRK</code> for singly implicit Runge-Kutta methods. <code>TableauEPRK</code> and <code>TableauIPRK</code> can be used for explicit and implicit partitioned Runge-Kutta methods. The first parameter of the constructor of each tableau assigns a name to the tableau. Such custom tableaus can be used in exactly the same as standard tableaus, e.g., by</p><pre><code class="language-julia">int = Integrator(ode, tab, 0.1)
sol = integrate(int, 10)</code></pre><p>making it very easy to implement and test new methods.</p><h2><a class="nav-anchor" id="Solutions-1" href="#Solutions-1">Solutions</a></h2><p>In what we have seen so far, the solution was always automatically created by the <code>integrate()</code> function. While this is often convenient, it is sometimes not performant, e.g., when carrying out long-time simulations with intermediate saving of the solution. In such cases, it is better to preallocate a solution object by</p><pre><code class="language-julia">sol = Solution(ode, 0.1, 10)</code></pre><p>where the first argument is an equation, the second argument is the time step and the third argument is the number of time steps that will be computed in one integration step. The call to the integrator is then made via</p><pre><code class="language-julia">integrate!(int, sol)</code></pre><p>If several integration cycles shall be performed, the <code>reset!()</code> function can be used to copy the solution of the last time step to the initial conditions of the solution,</p><pre><code class="language-julia">for i in 1:10
    integrate!(int, sol)
    #
    # save or process solution
    #
    reset!(sol)
end</code></pre><p>All solutions have a <code>t</code> field holding the series of time steps that has been computed in addition to several data fields, for example <code>q</code> for an ODE solution, <code>q</code> and <code>p</code> for a PODE solution, <code>q</code>and <code>λ</code> for a DAE solution, and <code>q</code>, <code>p</code> and <code>λ</code> for a PDAE solution.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../integrators/"><span class="direction">Next</span><span class="title">Overview</span></a></footer></article></body></html>
