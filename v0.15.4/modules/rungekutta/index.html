<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Runge-Kutta Tableaus · GeometricIntegrators.jl</title><meta name="title" content="Runge-Kutta Tableaus · GeometricIntegrators.jl"/><meta property="og:title" content="Runge-Kutta Tableaus · GeometricIntegrators.jl"/><meta property="twitter:title" content="Runge-Kutta Tableaus · GeometricIntegrators.jl"/><meta name="description" content="Documentation for GeometricIntegrators.jl."/><meta property="og:description" content="Documentation for GeometricIntegrators.jl."/><meta property="twitter:description" content="Documentation for GeometricIntegrators.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GeometricIntegrators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../problems/">Problems</a></li><li><a class="tocitem" href="../../methods/">Methods</a></li><li><span class="tocitem">Integrators</span><ul><li><a class="tocitem" href="../../integrators/rk/">Runge-Kutta</a></li><li><a class="tocitem" href="../../integrators/splitting/">Splitting</a></li><li><a class="tocitem" href="../../integrators/variational/">Variational</a></li><li><a class="tocitem" href="../../integrators/vprk/">VPRK</a></li><li><a class="tocitem" href="../../integrators/spark/">SPARK</a></li><li><a class="tocitem" href="../../integrators/dvi/">DVI</a></li><li><a class="tocitem" href="../../integrators/hpi/">Hamilton-Pontryagin</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../base/">Base</a></li><li><a class="tocitem" href="../equations/">Equations</a></li><li><a class="tocitem" href="../integrators/">Integrators</a></li><li><a class="tocitem" href="../methods/">Methods</a></li><li><a class="tocitem" href="../problems/">Problems</a></li><li><a class="tocitem" href="../projections/">Projections</a></li><li class="is-active"><a class="tocitem" href>Runge-Kutta Tableaus</a><ul class="internal"><li><a class="tocitem" href="#ordinary-runge-kutta_tableaus"><span>Ordinary Runge-Kutta Tableaus</span></a></li><li><a class="tocitem" href="#partitioned-runge-kutta-rableaus"><span>Partitioned Runge-Kutta Tableaus</span></a></li></ul></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li><a class="tocitem" href="../spark/">SPARK Methods</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../developer/integrators/">Integrators</a></li><li><a class="tocitem" href="../../developer/projections/">Projections</a></li><li><a class="tocitem" href="../../developer/code_integration/">Code Integration</a></li><li><a class="tocitem" href="../../developer/custom_integrators/">Custom Integrators</a></li><li><a class="tocitem" href="../../developer/adaptive_time_stepping/">Adaptive Time Stepping</a></li></ul></li><li><a class="tocitem" href="../../releasenotes/">Release Notes</a></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../authors/">Authors</a></li><li><a class="tocitem" href="../../LICENSE/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Runge-Kutta Tableaus</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Runge-Kutta Tableaus</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/GeometricIntegrators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGNI/GeometricIntegrators.jl/blob/main/docs/src/modules/rungekutta.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="RungeKuttaTableaus"><a class="docs-heading-anchor" href="#RungeKuttaTableaus">Runge-Kutta Tableaus</a><a id="RungeKuttaTableaus-1"></a><a class="docs-heading-anchor-permalink" href="#RungeKuttaTableaus" title="Permalink"></a></h1><p>The following tableaus are all implemented in <a href="https://github.com/JuliaGNI/RungeKutta.jl">RungeKutta.jl</a>.</p><h2 id="ordinary-runge-kutta_tableaus"><a class="docs-heading-anchor" href="#ordinary-runge-kutta_tableaus">Ordinary Runge-Kutta Tableaus</a><a id="ordinary-runge-kutta_tableaus-1"></a><a class="docs-heading-anchor-permalink" href="#ordinary-runge-kutta_tableaus" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RungeKutta.Tableau"><a class="docstring-binding" href="#RungeKutta.Tableau"><code>RungeKutta.Tableau</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Holds the tableau of a Runge-Kutta method</p><p class="math-container">\[\begin{aligned}
Q_{n,i} &amp;= q_{n} + h \sum \limits_{j=1}^{s} a_{ij} \, v(t_{n} + c_j \Delta t, Q_{n,j}) , &amp;
q_{n+1} &amp;= q_{n} + h \sum \limits_{i=1}^{s} b_{i}  \, v(t_{n} + c_j \Delta t, Q_{n,i}) , \\
\end{aligned}\]</p><p>Parameters:</p><ul><li><code>T</code>: datatype of coefficient arrays</li></ul><p>Fields:</p><ul><li><code>name</code>: symbolic name of the tableau</li><li><code>o</code>: order of the method</li><li><code>s</code>: number of stages</li><li><code>a</code>: coefficients <span>$a_{ij}$</span> with $ 1 \le i,j \le s$</li><li><code>b</code>: weights <span>$b_{i}$</span>  with $ 1 \le i \le s$</li><li><code>c</code>: nodes <span>$c_{i}$</span>  with $ 1 \le i \le s$</li><li><code>R∞</code>: stability function at infinity</li></ul><p>Constructors:</p><pre><code class="language-julia hljs">Tableau{T}(name, o, s, a, b, c)
Tableau{T}(name, o, a, b, c)
Tableau(name::Symbol, o::Int, s::Int, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)
Tableau(name::Symbol, o::Int, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)
Tableau(name::Symbol, o::Int, t::AbstractMatrix)</code></pre><p>The last constructor accepts an <span>$(s+1) \times (s+1)$</span> array that holds the whole tableau in the form of a Butcher tableau, i.e.,</p><table><tr><th style="text-align: right">c</th><th style="text-align: right">a</th></tr><tr><td style="text-align: right"></td><td style="text-align: right">b</td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableau.jl#L1-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauBackwardEuler"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauBackwardEuler"><code>RungeKutta.Tableaus.TableauBackwardEuler</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauImplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauImplicitEuler</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/firk.jl#L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauCrankNicolson-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauCrankNicolson-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauCrankNicolson</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of Crank-Nicolson two-stage, 2nd order method</p><pre><code class="language-julia hljs">TableauCrankNicolson(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">J. Crank and P. Nicolson.
A practical method for numerical evaluation of solutions of partial differential equations of the heat-conduction type.
Mathematical Proceedings of the Cambridge Philosophical Society, Volume 43, Issue 1, Pages 50-67, 1947.
doi: 10.1017/S0305004100023197</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/dirk.jl#L11-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauCrouzeix-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauCrouzeix-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauCrouzeix</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of Crouzeix&#39;s two-stage, 3rd order method</p><pre><code class="language-julia hljs">TableauCrouzeix(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">M.Crouzeix.
Sur L&#39;approximation des équations différentielles opérationelles linéaires par des méthodes de Runge-Kutta.
Thesis. Université de Paris, 1975.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/dirk.jl#L99-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauExplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauExplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauExplicitEuler</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of one-stage, 1st order explicit (forward) Euler method</p><pre><code class="language-julia hljs">TableauExplicitEuler(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Leonhard Euler.
Institutiones calculi differentialis cum eius vsu in analysi finitorum ac doctrina serierum.
Imp. Acad. Imper. Scient. Petropolitanae, Opera Omnia, Vol.X, [I.6], 1755.
In: Opera Omnia, 1st Series, Volume 11, Institutiones Calculi Integralis. Teubner, Leipzig, Pages 424-434, 1913.
Sectio secunda. Caput VII. De integratione aequationum differentialium per approximationem. Problema 85.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L12-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauExplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauExplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauExplicitMidpoint</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of explicit two-stage, 2nd order midpoint method</p><pre><code class="language-julia hljs">TableauExplicitMidpoint(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Carl Runge.
Über die numerische Auflösung von Differentialgleichungen.
Mathematische Annalen, Volume 46, Pages 167-178, 1895.
doi: 10.1007/BF01446807.
Equation (2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L46-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauForwardEuler"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauForwardEuler"><code>RungeKutta.Tableaus.TableauForwardEuler</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauExplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauExplicitEuler</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauGauss-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauGauss-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauGauss</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Gauss tableau with s stages</p><pre><code class="language-julia hljs">TableauGauss(::Type{T}, s)
TableauGauss(s) = TableauGauss(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="language-julia hljs">John C. Butcher.
Implicit Runge-Kutta processes.
Mathematics of Computation, Volume 18, Pages 50-64, 1964.
doi: 10.1090/S0025-5718-1964-0159424-9.

John C. Butcher.
Gauss Methods. 
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_115.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/gauss.jl#L64-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauHeun2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauHeun2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauHeun2</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of Heun&#39;s two-stage, 2nd order method</p><pre><code class="language-julia hljs">TableauHeun2(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Karl Heun.
Neue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.
Zeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.
Algorithm II.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L76-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauHeun3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauHeun3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauHeun3</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of Heun&#39;s three-stage, 3rd order method</p><pre><code class="language-julia hljs">TableauHeun3(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Karl Heun.
Neue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.
Zeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.
Algorithm VI.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L117-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauImplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauImplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauImplicitEuler</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of one-stage, 1st order implicit (backward) Euler method</p><pre><code class="language-julia hljs">TableauImplicitEuler(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Augustin-Louis Cauchy.
Équations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.
Ed. Christian Gilain, Etudes Vivantes, 1981.
Page 102, Equation (5), Θ=1.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/firk.jl#L11-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauImplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauImplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauImplicitMidpoint</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of two-stage, 2nd order implicit midpoint method</p><pre><code class="language-julia hljs">TableauImplicitMidpoint(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Augustin-Louis Cauchy.
Équations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.
Ed. Christian Gilain, Etudes Vivantes, 1981.
Page 102, Equation (5), Θ=1/2.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/firk.jl#L44-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauKraaijevangerSpijker-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauKraaijevangerSpijker-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauKraaijevangerSpijker</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of Kraaijevanger and Spijker&#39;s two-stage, 2nd order method</p><pre><code class="language-julia hljs">TableauKraaijevangerSpijker(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">J. F. B. M. Kraaijevanger and M. N. Spijker.
Algebraic stability and error propagation in Runge-Kutta methods.
Applied Numerical Mathematics, Volume 5, Issues 1-2, Pages 71-87, 1989.
doi: 10.1016/0168-9274(89)90025-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/dirk.jl#L41-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauKutta-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauKutta-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauKutta</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of Kutta&#39;s three-stage, 3rd order method</p><pre><code class="language-julia hljs">TableauKutta(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Wilhelm Kutta
Beitrag zur Näherungsweisen Integration totaler Differentialgleichungen
Zeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.
Page 440</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L257-L266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauKutta3"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauKutta3"><code>RungeKutta.Tableaus.TableauKutta3</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauKutta-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauKutta</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L278">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIII-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIII-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIII</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto III tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIII(::Type{T}, s)
TableauLobattoIII(s) = TableauLobattoIII(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Sometimes this tableau is also referred to as Lobatto IIIC*.</p><p>References:</p><pre><code class="language-julia hljs">John C. Butcher.
Integration processes based on Radau quadrature formulas
Mathematics of Computation, Volume 18, Pages 233-244, 1964.
doi: 10.1090/S0025-5718-1964-0165693-1.

Laurent O. Jay.
Lobatto Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_123.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L203-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIA</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIIA tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIA(::Type{T}, s)
TableauLobattoIIIA(s) = TableauLobattoIIIA(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="language-julia hljs">Byron Leonard Ehle
On Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.
Research Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.

Laurent O. Jay.
Lobatto Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_123</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L234-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIB</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIIB tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIB(::Type{T}, s)
TableauLobattoIIIB(s) = TableauLobattoIIIB(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="language-julia hljs">Byron Leonard Ehle.
On Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.
Research Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.

Laurent O. Jay.
Lobatto Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_123.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L285-L295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIB̄</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIIB̄ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIB̄(::Type{T}, s)
TableauLobattoIIIB̄(s) = TableauLobattoIIIB̄(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Lobatto IIIB̄ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIB</code></a>. On paper, its coefficients are identical to <a href="#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIA</code></a>, however, they are computed by the symplecticity condition and not by the formula for Lobatto IIIA and thus the numerical values are slightly different.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L301-L314">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIIC-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIIC-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIC</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIIC tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIC(::Type{T}, s)
TableauLobattoIIIC(s) = TableauLobattoIIIC(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="language-julia hljs">F. H. Chipman.
A-stable Runge-Kutta processes.
BIT, Volume 11, Pages 384-388, 1971.
doi: 10.1007/BF01939406.

Laurent O. Jay.
Lobatto Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_123.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L337-L347">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIC̄</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIIC̄ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIC̄(::Type{T}, s)
TableauLobattoIIIC̄(s) = TableauLobattoIIIC̄(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Lobatto IIIC̄ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIIC-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIC</code></a>. On paper, its coefficients are identical to <a href="#RungeKutta.Tableaus.TableauLobattoIII-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIII</code></a>, however, they are computed by the symplecticity condition and not by the formula for Lobatto III and thus the numerical values are slightly different.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L353-L366">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIID-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIID-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIID</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIID tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIID(::Type{T}, s)
TableauLobattoIIID(s) = TableauLobattoIIID(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="language-julia hljs">R.P.K. Chan.
On symmetric Runge-Kutta methods of high order.
Computing, Volume 45, Pages 301-309, 1990.
doi: 10.1007/BF02238798

Laurent O. Jay.
Lobatto Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_123.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L389-L399">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIID̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIID̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIID̄</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIID̄ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIID̄(::Type{T}, s)
TableauLobattoIIID̄(s) = TableauLobattoIIID̄(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Lobatto IIID̄ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIID-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIID</code></a>. On paper, the coefficients of the Lobatto IIID tableau are symplectic, however, the Lobatto IIID̄ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIID and thus the numerical values are slightly different.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L405-L418">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIIE-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIIE-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIE</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIIE tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIE(::Type{T}, s)
TableauLobattoIIIE(s) = TableauLobattoIIIE(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="language-julia hljs">R.P.K. Chan.
On symmetric Runge-Kutta methods of high order.
Computing, Volume 45, Pages 301-309, 1990.
doi: 10.1007/BF02238798

Laurent O. Jay.
Lobatto Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_123.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L441-L452">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIF</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIIF tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIF(::Type{T}, s)
TableauLobattoIIIF(s) = TableauLobattoIIIF(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="language-julia hljs">Wang Fangzong and Liao Xiaobing.
A Class of Lobatto Methods of Order 2s.
Journal of Applied Mathematics, Volume 46, Pages 6-10, 2016.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L488-L498">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIF̄</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIIF̄ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIF̄(::Type{T}, s)
TableauLobattoIIIF̄(s) = TableauLobattoIIIF̄(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>The Lobatto IIIF̄ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L504-L514">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIIG-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIIG-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIG</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIIG tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIG(::Type{T}, s)
TableauLobattoIIIG(s) = TableauLobattoIIIG(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Symplectizied algorithm for <a href="#RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIF</code></a></p><p>Coefficients are taken as <span>$a^G = \frac{1}{2} ( a^F + \bar{a}^F )$</span> where the coefficients <span>$\bar{a}^F$</span> are computed such that the symplecticity conditions <span>$b_{i} \bar{a}_{i,j} + \bar{b}_{j} a_{j,i} = b_{i} \bar{b}_{j}$</span> and <span>$b_{i} = \bar{b}_i$</span> hold for all <span>$1 \le i,j \le s$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L523-L537">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIĀ</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIIĀ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIĀ(::Type{T}, s)
TableauLobattoIIIĀ(s) = TableauLobattoIIIĀ(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Lobatto IIIĀ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIA</code></a>. On paper, its coefficients are identical to <a href="#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIB</code></a>, however, they are computed by the symplecticity condition and not by the formula for Lobatto IIIB and thus the numerical values are slightly different.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L250-L263">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIĒ</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIIĒ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIĒ(::Type{T}, s)
TableauLobattoIIIĒ(s) = TableauLobattoIIIĒ(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Lobatto IIIĒ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIIE-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIE</code></a>. On paper, the coefficients of the Lobatto IIIE tableau are symplectic, however, the Lobatto IIIĒ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIIE and thus the numerical values are slightly different.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L458-L471">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauLobattoIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauLobattoIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauLobattoIIIḠ</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Lobatto IIIḠ tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIḠ(::Type{T}, s)
TableauLobattoIIIḠ(s) = TableauLobattoIIIḠ(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Lobatto IIIḠ tableau is the conjugate symplectic to <a href="#RungeKutta.Tableaus.TableauLobattoIIIG-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIG</code></a>. On paper, the coefficients of the Lobatto IIIG tableau are symplectic, however, the Lobatto IIIḠ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIIG and thus the numerical values are slightly different.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L543-L556">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauQinZhang-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauQinZhang-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauQinZhang</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of Qin and Zhang&#39;s symplectic two-stage, 2nd order method</p><pre><code class="language-julia hljs">TableauQinZhang(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">M.-Z. Qin and M.-Q. Zhang.
Symplectic Runge-Kutta algorithms for Hamilton systems.
Journal of Computational Mathematics, Supplementary Issue, Pages 205-215, 1992.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/dirk.jl#L70-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRK21"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRK21"><code>RungeKutta.Tableaus.TableauRK21</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauHeun2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauHeun2</code></a>     according to</p><pre><code class="language-julia hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 99</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L96-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRK22"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRK22"><code>RungeKutta.Tableaus.TableauRK22</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauRunge-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauRunge</code></a>     according to</p><pre><code class="language-julia hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 99</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L236-L243">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRK31-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRK31-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRK31</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of a three-stage, 3rd order method</p><pre><code class="language-julia hljs">TableauKutta(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 99</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L301-L310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRK32"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRK32"><code>RungeKutta.Tableaus.TableauRK32</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauKutta-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauKutta</code></a> according to</p><pre><code class="language-julia hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 99</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L282-L288">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRK4"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRK4"><code>RungeKutta.Tableaus.TableauRK4</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauRK416-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauRK416</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L364">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRK41"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRK41"><code>RungeKutta.Tableaus.TableauRK41</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauRK416-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauRK416</code></a> according to</p><pre><code class="language-julia hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 102</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L354-L360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRK416-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRK416-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRK416</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of explicit Runge-Kutta method of order four (1/6 rule)</p><pre><code class="language-julia hljs">TableauRK416(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Wilhelm Kutta
Beitrag zur Näherungsweisen Integration totaler Differentialgleichungen
Zeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.
Page 443</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L332-L341">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRK42-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRK42-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRK42</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of explicit Runge-Kutta method of order four with four stages</p><pre><code class="language-julia hljs">TableauRK42(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 102</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L377-L386">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRK438-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRK438-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRK438</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of explicit Runge-Kutta method of order four (3/8 rule)</p><pre><code class="language-julia hljs">TableauRK438(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Wilhelm Kutta
Beitrag zur Näherungsweisen Integration totaler Differentialgleichungen
Zeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.
Page 441</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L409-L418">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRK5-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRK5-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRK5</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of explicit Runge-Kutta method of order five with six stages</p><pre><code class="language-julia hljs">TableauRK5(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">John C. Butcher
Numerical Methods for Ordinary Differential Equations. Wiley, 2016.
Page 103</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L440-L449">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRadauIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRadauIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauRadauIA</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Radau IA tableau with s stages</p><pre><code class="language-julia hljs">TableauRadauIA(::Type{T}, s)
TableauRadauIA(s) = TableauRadauIA(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="language-julia hljs">Byron Leonard Ehle
On Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.
Research Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/radau.jl#L112-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRadauIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRadauIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauRadauIB</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Radau IB tableau with s stages</p><pre><code class="language-julia hljs">TableauRadauIB(::Type{T}, s)
TableauRadauIB(s) = TableauRadauIB(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Coefficients are taken as <span>$a^B = \frac{1}{2} ( a^A + \bar{a}^A )$</span> where <span>$a^A$</span> are the coefficients of the Radau IA method and <span>$\bar{a}^A$</span> are computed such that the symplecticity conditions <span>$b_{i} \bar{a}_{i,j} + \bar{b}_{j} a_{j,i} = b_{i} \bar{b}_{j}$</span> and <span>$b_{i} = \bar{b}_i$</span> hold for all <span>$1 \le i,j \le s$</span>.</p><p>Reference:</p><pre><code class="language-julia hljs">Sun Geng
Construction of high order symplectic Runge-Kutta methods
Journal of Computational Mathematics, Volume 11, Pages 250-260, 1993.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/radau.jl#L138-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRadauIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRadauIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauRadauIIA</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Radau IIA tableau with s stages</p><pre><code class="language-julia hljs">TableauRadauIIA(::Type{T}, s)
TableauRadauIIA(s) = TableauRadauIIA(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>References:</p><pre><code class="language-julia hljs">Byron Leonard Ehle
On Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.
Research Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.

Owe Axelsson.
A class of A-stable methods.
BIT, Volume 9, Pages 185-199, 1969.
doi: 10.1007/BF01946812.

Ernst Hairer and Gerhard Wanner.
Radau Methods.
In: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.
doi: 10.1007/978-3-540-70529-1_139.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/radau.jl#L183-L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRadauIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRadauIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.TableauRadauIIB</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Radau IIB tableau with s stages</p><pre><code class="language-julia hljs">TableauRadauIIB(::Type{T}, s)
TableauRadauIIB(s) = TableauRadauIIB(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>Coefficients are taken as <span>$a^B = \frac{1}{2} ( a^A + \bar{a}^A )$</span> where <span>$a^A$</span> are the coefficients of the Radau IIA method and <span>$\bar{a}^AV are computed such that the symplecticity conditions$</span>b<em>{i} \bar{a}</em>{i,j} + \bar{b}<em>{j} a</em>{j,i} = b<em>{i} \bar{b}</em>{j}<span>$and$</span>b<em>{i} = \bar{b}</em>i<span>$hold for all$</span>1 \le i,j \le s``.</p><p>Reference:</p><pre><code class="language-julia hljs">Sun Geng
Construction of high order symplectic Runge-Kutta methods
Journal of Computational Mathematics, Volume 11, Pages 250-260, 1993.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/radau.jl#L209-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRalston2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRalston2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRalston2</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of Ralston&#39;s two-stage, 2nd order method</p><pre><code class="language-julia hljs">TableauRalston2(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Anthony Ralston.
Runge-Kutta Methods with Minimum Error Bounds.
Mathematics of Computation, Volume 16, Pages 431-437, 1962.
doi: 10.1090/S0025-5718-1962-0150954-0.
Equation (3.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L149-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRalston3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRalston3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRalston3</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of Ralston&#39;s three-stage, 3rd order method</p><pre><code class="language-julia hljs">TableauRalston3(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Anthony Ralston.
Runge-Kutta Methods with Minimum Error Bounds.
Mathematics of Computation, Volume 16, Pages 431-437, 1962.
doi: 10.1090/S0025-5718-1962-0150954-0.
Equation (4.10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L180-L189">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRunge-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRunge-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauRunge</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of Runge&#39;s two-stage, 2nd order method</p><pre><code class="language-julia hljs">TableauRunge(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Carl Runge
Über die numerische Auflösung von Differentialgleichungen.
Mathematische Annalen, Volume 46, Pages 167-178, 1895.
doi: 10.1007/BF01446807.
Equation (3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L212-L221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauRunge2"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauRunge2"><code>RungeKutta.Tableaus.TableauRunge2</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Alias for <a href="#RungeKutta.Tableaus.TableauRunge-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauRunge</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L232">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauSRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauSRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauSRK3</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of symmetric and symplectic three-stage, 4th order Runge-Kutta method</p><pre><code class="language-julia hljs">TableauSRK3(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Shan Zhao and Guo-Wei Wei.
A unified discontinuous Galerkin framework for time integration.
Mathematical Methods in the Applied Sciences, Volume 37, Issue 7, Pages 1042-1071, 2014.
doi: 10.1002/mma.2863.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/firk.jl#L73-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauSSPRK2-Tuple"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauSSPRK2-Tuple"><code>RungeKutta.Tableaus.TableauSSPRK2</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of 2rd order Strong Stability Preserving method with two stages and CFL ≤ 1</p><pre><code class="language-julia hljs">TableauSSPRK2(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>This is the same tableau as <a href="#RungeKutta.Tableaus.TableauHeun2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>TableauHeun2</code></a>.</p><p>Reference:</p><pre><code class="language-julia hljs">Chi-Wang Shu, Stanley Osher.
Efficient implementation of essentially non-oscillatory shock-capturing schemes.
Journal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.
doi: 10.1016/0021-9991(88)90177-5.
Equation (2.16)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L475-L486">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.TableauSSPRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.TableauSSPRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T"><code>RungeKutta.Tableaus.TableauSSPRK3</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau of 3rd order Strong Stability Preserving method with three stages and CFL ≤ 1</p><pre><code class="language-julia hljs">TableauSSPRK3(::Type{T}=Float64) where {T}</code></pre><p>The constructor takes one optional argument, that is the element type of the tableau.</p><p>Reference:</p><pre><code class="language-julia hljs">Chi-Wang Shu, Stanley Osher.
Efficient implementation of essentially non-oscillatory shock-capturing schemes.
Journal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.
doi: 10.1016/0021-9991(88)90177-5.
Equation (2.18)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/erk.jl#L503-L512">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_gauss_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_gauss_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_gauss_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Gauss coefficients are implicitly given by the so-called simplifying assumption <span>$C(s)$</span>:</p><p class="math-container">\[\sum \limits_{j=1}^{s} a_{ij} c_{j}^{k-1} = \frac{c_i^k}{k}  \qquad i = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s .\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/gauss.jl#L37-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_gauss_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_gauss_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_gauss_nodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Gauss nodes are given by the roots of the shifted Legendre polynomial <span>$P_s (2x-1)$</span> with <span>$s$</span> the number of stages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/gauss.jl#L2-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_gauss_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_gauss_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_gauss_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Gauss weights are given by the following integrals</p><p class="math-container">\[b_i = \bigg( \frac{dP}{dx} (c_i) \bigg)^{-2} \int \limits_0^1 \bigg( \frac{P(x)}{x - c_i} \bigg)^2 dx ,\]</p><p>where <span>$P(x)$</span> denotes the shifted Legendre polynomial <span>$P(x) = P_s (2x-1)$</span> with <span>$s$</span> the number of stages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/gauss.jl#L13-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_lobatto_a_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_lobatto_a_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_a_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Lobatto IIIA coefficients are implicitly given by the so-called simplifying assumption <span>$C(s)$</span>:</p><p class="math-container">\[\sum \limits_{j=1}^{s} a_{ij} c_{j}^{k-1} = \frac{c_i^k}{k}  \qquad i = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s .\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L71-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_lobatto_b_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_lobatto_b_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_b_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Lobatto IIIB coefficients are implicitly given by the so-called simplifying assumption <span>$D(s)$</span>:</p><p class="math-container">\[\sum \limits_{i=1}^{s} b_i c_{i}^{k-1} a_{ij} = \frac{b_j}{k} ( 1 - c_j^k)  \qquad j = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s .\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L84-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_lobatto_c_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_lobatto_c_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_c_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Lobatto IIIC coefficients are determined by setting <span>$a_{i,1} = b_1$</span> and solving the so-called simplifying assumption <span>$C(s-1)$</span>, given by</p><p class="math-container">\[\sum \limits_{j=1}^{s} a_{ij} c_{j}^{k-1} = \frac{c_i^k}{k}  \qquad i = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s-1 ,\]</p><p>for <span>$a_{i,j}$</span> with <span>$i = 1, ..., s$</span> and <span>$j = 2, ..., s$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L98-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_lobatto_c̄_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_lobatto_c̄_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_c̄_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Lobatto IIIC̄ coefficients are determined by setting <span>$a_{i,s} = 0$</span> and solving the so-called simplifying assumption <span>$C(s-1)$</span>, given by</p><p class="math-container">\[\sum \limits_{j=1}^{s} a_{ij} c_{j}^{k-1} = \frac{c_i^k}{k}  \qquad i = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s-1 ,\]</p><p>for <span>$a_{i,j}$</span> with <span>$i = 1, ..., s$</span> and <span>$j = 1, ..., s-1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L123-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_lobatto_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_lobatto_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_nodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The s-stage Lobatto nodes are defined as the roots of the following polynomial of degree <span>$s$</span>:</p><p class="math-container">\[\frac{d^{s-2}}{dx^{s-2}} \big( (x - x^2)^{s-1} \big) .\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L6-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_lobatto_nullvector-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_lobatto_nullvector-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_nullvector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_lobatto_nullvector(::Type, s; normalize=false)
get_lobatto_nullvector(s; kwargs...)</code></pre><p>Computes the nullvector of the matrix containing the derivatives of the Lagrange basis on the <code>s</code> Lobatto nodes evaluated on these nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L47-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_lobatto_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_lobatto_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_lobatto_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Lobatto weights can be explicitly computed by the formula</p><p class="math-container">\[b_j = \frac{1}{s (s-1) P_{s-1}(2 c_j - 1)^2} \qquad j = 1 , \, ... , \, s ,\]</p><p>where <span>$P_k$</span> is the <span>$k$</span>th Legendre polynomial, given by</p><p class="math-container">\[P_k (x) = \frac{1}{k! 2^k} \big( \frac{d^k}{dx^k} (x^2 - 1)^k \big) .\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/lobatto.jl#L25-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_radau_1_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_radau_1_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_radau_1_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Radau IA coefficients are implicitly given by the so-called simplifying assumption <span>$D(s)$</span>:</p><p class="math-container">\[\sum \limits_{i=1}^{s} b_i c_{i}^{k-1} a_{ij} = \frac{b_j}{k} ( 1 - c_j^k)  \qquad j = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s .\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/radau.jl#L72-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_radau_1_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_radau_1_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_radau_1_nodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The s-stage Radau IA nodes are defined as the roots of the following polynomial of degree <span>$s$</span>:</p><p class="math-container">\[\frac{d^{s-1}}{dx^{s-1}} \big( x^s (x - 1)^{s-1} \big) .\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/radau.jl#L2-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_radau_1_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_radau_1_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_radau_1_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Radau IA weights are implicitly given by the so-called simplifying assumption <span>$B(s)$</span>:</p><p class="math-container">\[\sum \limits_{j=1}^{s} b_{j} c_{j}^{k-1} = \frac{1}{k}  \qquad k = 1 , \, ... , \, s .\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/radau.jl#L40-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_radau_2_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_radau_2_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_radau_2_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Radau IIA coefficients are implicitly given by the so-called simplifying assumption <span>$C(s)$</span>:</p><p class="math-container">\[\sum \limits_{j=1}^{s} a_{ij} c_{j}^{k-1} = \frac{c_i^k}{k}  \qquad i = 1 , \, ... , \, s , \; k = 1 , \, ... , \, s .\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/radau.jl#L88-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_radau_2_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_radau_2_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_radau_2_nodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The s-stage Radau IIA nodes are defined as the roots of the following polynomial of degree <span>$s$</span>:</p><p class="math-container">\[\frac{d^{s-1}}{dx^{s-1}} \big( x^{s-1} (x - 1)^s \big) .\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/radau.jl#L21-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.Tableaus.get_radau_2_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#RungeKutta.Tableaus.get_radau_2_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>RungeKutta.Tableaus.get_radau_2_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Radau IIA weights are implicitly given by the so-called simplifying assumption <span>$B(s)$</span>:</p><p class="math-container">\[\sum \limits_{j=1}^{s} b_{j} c_{j}^{k-1} = \frac{1}{k}  \qquad k = 1 , \, ... , \, s .\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/radau.jl#L56-L61">source</a></section></details></article><h2 id="partitioned-runge-kutta-rableaus"><a class="docs-heading-anchor" href="#partitioned-runge-kutta-rableaus">Partitioned Runge-Kutta Tableaus</a><a id="partitioned-runge-kutta-rableaus-1"></a><a class="docs-heading-anchor-permalink" href="#partitioned-runge-kutta-rableaus" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RungeKutta.PartitionedTableau"><a class="docstring-binding" href="#RungeKutta.PartitionedTableau"><code>RungeKutta.PartitionedTableau</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Tableau of a Partitioned Runge-Kutta method</p><p class="math-container">\[\begin{aligned}
Q_{n,i} &amp;= q_{n} + h \sum \limits_{j=1}^{s} a_{ij} \, v(t_{n} + c_j \Delta t, Q_{n,j}, P_{n,j}) , &amp;
q_{n+1} &amp;= q_{n} + h \sum \limits_{i=1}^{s} b_{i}  \, v(t_{n} + c_j \Delta t, Q_{n,i}, P_{n,i}) , \\
P_{n,i} &amp;= p_{n} + h  \sum \limits_{i=1}^{s} \bar{a}_{ij} \, f(t_{n} + c_j \Delta t, Q_{n,j}, P_{n,j}) , &amp;
p_{n+1} &amp;= p_{n} + h \sum \limits_{i=1}^{s} \bar{b}_{i}   \, f(t_{n} + c_j \Delta t, Q_{n,i}, P_{n,i}) .
\end{aligned}\]</p><p>Parameters:</p><ul><li><code>T</code>: datatype of coefficient arrays</li></ul><p>Fields:</p><ul><li><code>name</code>: symbolic name of the tableau</li><li><code>o</code>: order of the method</li><li><code>s</code>: number of stages</li><li><code>q</code>: Tableau for <code>q</code></li><li><code>p</code>: Tableau for <code>p</code></li><li><code>R∞</code>: stability function at infinity</li></ul><p>The actual tableaus are stored in <code>q</code> and <code>p</code>:</p><ul><li><code>a</code>: coefficients <span>$a_{ij}$</span> with $ 1 \le i,j \le s$</li><li><code>b</code>: weights <span>$b_{i}$</span>  with $ 1 \le i \le s$</li><li><code>c</code>: nodes <span>$c_{i}$</span>  with $ 1 \le i \le s$</li></ul><p>Constructors:</p><pre><code class="language-julia hljs">PartitionedTableau{T}(name, o, q, p)
PartitionedTableau{T}(name, q, p)
PartitionedTableau(name::Symbol, q::Tableau, p::Tableau)
PartitionedTableau(name::Symbol, q::Tableau)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableau_partitioned.jl#L1-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.PartitionedTableaus.PartitionedTableauGauss-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><a class="docstring-binding" href="#RungeKutta.PartitionedTableaus.PartitionedTableauGauss-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>RungeKutta.PartitionedTableaus.PartitionedTableauGauss</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Partitioned Gauss-Legendre Runge-Kutta tableau with s stages</p><pre><code class="language-julia hljs">PartitionedTableauGauss(::Type{T}, s)
PartitionedTableauGauss(s) = PartitionedTableauGauss(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>This <a href="#RungeKutta.PartitionedTableau"><code>PartitionedTableau</code></a> uses <a href="#RungeKutta.Tableaus.TableauGauss-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauGauss</code></a> for both coefficients <code>a</code> and <code>ā</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/prk.jl#L2-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIB-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><a class="docstring-binding" href="#RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIB-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIB</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Partitioned Gauss-Lobatto IIIA-IIIB tableau with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIAIIIB(::Type{T}, s)
TableauLobattoIIIAIIIB(s) = TableauLobattoIIIAIIIB(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>This <a href="#RungeKutta.PartitionedTableau"><code>PartitionedTableau</code></a> uses <a href="#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIA</code></a> for <code>a</code> and <a href="#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIB</code></a> for <code>ā</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/prk.jl#L21-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><a class="docstring-binding" href="#RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIĀ</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau for Gauss-Lobatto IIIA-IIIĀ method with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIAIIIĀ(::Type{T}, s)
TableauLobattoIIIAIIIĀ(s) = TableauLobattoIIIAIIIĀ(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>This <a href="#RungeKutta.PartitionedTableau"><code>PartitionedTableau</code></a> uses <a href="#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIA</code></a> for <code>a</code> and <a href="#RungeKutta.Tableaus.TableauLobattoIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIĀ</code></a> for <code>ā</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/prk.jl#L55-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIA-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><a class="docstring-binding" href="#RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIA-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIA</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau for Gauss-Lobatto IIIB-IIIA method with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIBIIIA(::Type{T}, s)
TableauLobattoIIIBIIIA(s) = TableauLobattoIIIBIIIA(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>This <a href="#RungeKutta.PartitionedTableau"><code>PartitionedTableau</code></a> uses <a href="#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIB</code></a> for <code>a</code> and <a href="#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIA</code></a> for <code>ā</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/prk.jl#L38-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><a class="docstring-binding" href="#RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIB̄</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau for Gauss-Lobatto IIIB-IIIB̄ method with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIBIIIB̄(::Type{T}, s)
TableauLobattoIIIBIIIB̄(s) = TableauLobattoIIIBIIIB̄(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>This <a href="#RungeKutta.PartitionedTableau"><code>PartitionedTableau</code></a> uses <a href="#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIB</code></a> for <code>a</code> and <a href="#RungeKutta.Tableaus.TableauLobattoIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIB̄</code></a> for <code>ā</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/prk.jl#L72-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.PartitionedTableaus.TableauLobattoIIICIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><a class="docstring-binding" href="#RungeKutta.PartitionedTableaus.TableauLobattoIIICIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>RungeKutta.PartitionedTableaus.TableauLobattoIIICIIIC̄</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau for Gauss-Lobatto IIIC-IIIC̄ method with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIICIIIC̄(::Type{T}, s)
TableauLobattoIIICIIIC̄(s) = TableauLobattoIIICIIIC̄(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>This <a href="#RungeKutta.PartitionedTableau"><code>PartitionedTableau</code></a> uses <a href="#RungeKutta.Tableaus.TableauLobattoIIIC-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIC</code></a> for <code>a</code> and <a href="#RungeKutta.Tableaus.TableauLobattoIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIC̄</code></a> for <code>ā</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/prk.jl#L89-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.PartitionedTableaus.TableauLobattoIIIC̄IIIC-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><a class="docstring-binding" href="#RungeKutta.PartitionedTableaus.TableauLobattoIIIC̄IIIC-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>RungeKutta.PartitionedTableaus.TableauLobattoIIIC̄IIIC</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau for Gauss-Lobatto IIIC̄-IIIC method with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIC̄IIIC(::Type{T}, s)
TableauLobattoIIIC̄IIIC(s) = TableauLobattoIIIC̄IIIC(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>This <a href="#RungeKutta.PartitionedTableau"><code>PartitionedTableau</code></a> uses <a href="#RungeKutta.Tableaus.TableauLobattoIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIC̄</code></a> for <code>a</code> and <a href="#RungeKutta.Tableaus.TableauLobattoIIIC-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIC</code></a> for <code>ā</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/prk.jl#L106-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.PartitionedTableaus.TableauLobattoIIIDIIID̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><a class="docstring-binding" href="#RungeKutta.PartitionedTableaus.TableauLobattoIIIDIIID̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>RungeKutta.PartitionedTableaus.TableauLobattoIIIDIIID̄</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau for Gauss-Lobatto IIID-IIID̄ method with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIDIIID̄(::Type{T}, s)
TableauLobattoIIIDIIID̄(s) = TableauLobattoIIIDIIID̄(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>This <a href="#RungeKutta.PartitionedTableau"><code>PartitionedTableau</code></a> uses <a href="#RungeKutta.Tableaus.TableauLobattoIIID-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIID</code></a> for <code>a</code> and <a href="#RungeKutta.Tableaus.TableauLobattoIIID̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIID̄</code></a> for <code>ā</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/prk.jl#L123-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.PartitionedTableaus.TableauLobattoIIIEIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><a class="docstring-binding" href="#RungeKutta.PartitionedTableaus.TableauLobattoIIIEIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>RungeKutta.PartitionedTableaus.TableauLobattoIIIEIIIĒ</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau for Gauss-Lobatto IIIE-IIIĒ method with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIEIIIĒ(::Type{T}, s)
TableauLobattoIIIEIIIĒ(s) = TableauLobattoIIIEIIIĒ(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>This <a href="#RungeKutta.PartitionedTableau"><code>PartitionedTableau</code></a> uses <a href="#RungeKutta.Tableaus.TableauLobattoIIIE-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIE</code></a> for <code>a</code> and <a href="#RungeKutta.Tableaus.TableauLobattoIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIĒ</code></a> for <code>ā</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/prk.jl#L140-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.PartitionedTableaus.TableauLobattoIIIFIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><a class="docstring-binding" href="#RungeKutta.PartitionedTableaus.TableauLobattoIIIFIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>RungeKutta.PartitionedTableaus.TableauLobattoIIIFIIIF̄</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau for Gauss-Lobatto IIIF-IIIF̄ method with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIFIIIF̄(::Type{T}, s)
TableauLobattoIIIFIIIF̄(s) = TableauLobattoIIIFIIIF̄(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>This <a href="#RungeKutta.PartitionedTableau"><code>PartitionedTableau</code></a> uses <a href="#RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIF</code></a> for <code>a</code> and <a href="#RungeKutta.Tableaus.TableauLobattoIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIF̄</code></a> for <code>ā</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/prk.jl#L157-L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.PartitionedTableaus.TableauLobattoIIIF̄IIIF-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><a class="docstring-binding" href="#RungeKutta.PartitionedTableaus.TableauLobattoIIIF̄IIIF-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>RungeKutta.PartitionedTableaus.TableauLobattoIIIF̄IIIF</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau for Gauss-Lobatto IIIF̄-IIIF method with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIF̄IIIF(::Type{T}, s)
TableauLobattoIIIF̄IIIF(s) = TableauLobattoIIIF̄IIIF(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>This <a href="#RungeKutta.PartitionedTableau"><code>PartitionedTableau</code></a> uses <a href="#RungeKutta.Tableaus.TableauLobattoIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIF̄</code></a> for <code>a</code> and <a href="#RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIF</code></a> for <code>ā</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/prk.jl#L174-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RungeKutta.PartitionedTableaus.TableauLobattoIIIGIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><a class="docstring-binding" href="#RungeKutta.PartitionedTableaus.TableauLobattoIIIGIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T"><code>RungeKutta.PartitionedTableaus.TableauLobattoIIIGIIIḠ</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Tableau for Gauss-Lobatto IIIG-IIIḠ method with s stages</p><pre><code class="language-julia hljs">TableauLobattoIIIGIIIḠ(::Type{T}, s)
TableauLobattoIIIGIIIḠ(s) = TableauLobattoIIIGIIIḠ(Float64, s)</code></pre><p>The constructor takes the number of stages <code>s</code> and optionally the element type <code>T</code> of the tableau.</p><p>This <a href="#RungeKutta.PartitionedTableau"><code>PartitionedTableau</code></a> uses <a href="#RungeKutta.Tableaus.TableauLobattoIIIG-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIG</code></a> for <code>a</code> and <a href="#RungeKutta.Tableaus.TableauLobattoIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>TableauLobattoIIIḠ</code></a> for <code>ā</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/RungeKutta.jl/blob/v0.5.18/src/tableaus/prk.jl#L191-L202">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../projections/">« Projections</a><a class="docs-footer-nextpage" href="../solutions/">Solutions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 13 December 2025 15:38">Saturday 13 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
