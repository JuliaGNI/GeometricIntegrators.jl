var documenterSearchIndex = {"docs":
[{"location":"#GeometricIntegrators.jl","page":"Home","title":"GeometricIntegrators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia library of geometric integrators for differential equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: PkgEval Status) (Image: CI) (Image: Build Status) (Image: Coverage Status) (Image: codecov Status) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl is a library of geometric integrators for ordinary differential equations, stochastic differential equations and differential algebraic equations in Julia. Its main purpose is the democratization and proliferation of geometric integrators by providing a comprehensive collection of structure-preserving as well as standard algorithms under a unified interface.  GeometricIntegrators.jl can be used either interactively or as computational core in other codes. It provides both, a high-level interface that requires only very few lines of code to solve an actual problem, and a lean low-level interface that allows for straightforward integration into application codes via the exchange of minimalistic data structures. In both, the library leaves maximum control to the user. While trying to pick sensible defaults, all settings are accessible to and modifiable by the user. Suitable abstraction layers allow to choose between different linear and nonlinear solvers, auto-differentiation packages or custom routines for the computation of Jacobians and the like.","category":"page"},{"location":"#Statement-of-need","page":"Home","title":"Statement of need","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Differential equations are ubiquitous in science and engineering. Many equations possess geometric features or abstract mathematical structures that need to be preserved in the discretisation in order to obtain reliable simulation results, especially for nonlinear problems and long-time simulations. The preservation of such properties improves stability, bounds global error growth and reduces numerical artefacts. Robust, performant and structure-preserving solvers for different types of differential equations are thus needed across many disciplines. GeometricIntegrators.jl provides such solvers and makes them available for both direct use as well as integration into other codes. Furthermore, the implemented algorithms can also be used within the DifferentialEquations.jl ecosystem [Christopher Rackauckas , Qing Nie  (2017)], which is the defacto standard differential equation solver for the Julia programming language [Jeff Bezanson , Alan Edelman , Stefan Karpinski , Viral B. Shah  (2017)].","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl provides a comprehensive library of existing geometric integration as well as non-geometric algorithms, such as explicit, implicit, partitioned and stochastic Runge-Kutta methods, SPARK methods, splitting methods, symplectic methods and variational integrators. Most methods are implemented in an abstract way that allows for the flexible choice of tableaus, approximation spaces, basis functions, quadrature rules, and thus order of convergence. GeometricIntegrators.jl also serves as a testbed for the development and analysis of novel algorithms. Due to the modular structure and the use of the multiple dispatch paradigm, the library can easily be extended, e.g., towards new algorithms or new types of equations. The library is designed to minimize overhead and maximize performance in order to be able to perform simulations with millions or even billions of time steps to facilitate the study of the long-time behaviour of both numerical algorithms and dynamical systems.","category":"page"},{"location":"#Other-Software","page":"Home","title":"Other Software","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package closely related to GeometricIntegrators.jl is DifferentialEquations.jl [Christopher Rackauckas , Qing Nie  (2017)]. However, the scope of the two libraries is rather different. While DifferentialEquations.jl provides a feature-rich ecosystem for the solution of differential equations, the focus of GeometricIntegrators.jl is on algorithms. In fact, GeometricIntegrators.jl can be used as backend for DifferentialEquations.jl via GeometricIntegratorsDiffEq.jl.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"tutorial/tutorial.md\",\n         \"integrators.md\"]","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"modules/basis_functions.md\",\n         \"modules/equations.md\",\n         \"modules/integrators.md\",\n         \"modules/interpolation.md\",\n         \"modules/quadratures.md\",\n         \"modules/discontinuities.md\",\n         \"modules/simulations.md\",\n         \"modules/solvers_linear.md\",\n         \"modules/solvers_nonlinear.md\",\n         \"modules/solutions.md\",\n         \"modules/tableaus.md\"\n]","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use GeometricIntegrators.jl in your work, please consider citing it by","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{Kraus:2020:GeometricIntegrators,\n  title={GeometricIntegrators.jl: Geometric Numerical Integration in Julia},\n  author={Kraus, Michael},\n  year={2020},\n  howpublished={\\url{https://github.com/JuliaGNI/GeometricIntegrators.jl}},\n  doi={10.5281/zenodo.3648325}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl contains reference implementation for the methods described in the following articles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Michael Kraus. Hamilton-Pontryagin-Galerkin Integrators.\nMichael Kraus. Projected Variational Integrators for Degenerate Lagrangian Systems. arXiv:1708.07356.\nMichael Kraus. SPARK Methods for Degenerate Lagrangian Systems.\nMichael Kraus. SPARK Methods for Hamiltonian Systems subject to Dirac Constraints.\nMichael Kraus. Symplectic Runge-Kutta Methods for Degenerate Lagrangian Systems.\nMichael Kraus. Variational Integrators for Noncanonical Hamiltonian Systems.\nMichael Kraus and Tomasz M. Tyranowski. Variational Integrators for Stochastic Dissipative Hamiltonian Systems. arXiv:1909.07202, Journal.\nMichael Kraus, Joshua Burby. Conservation of Poincaré Integral Invariants in Numerical Simulations.","category":"page"},{"location":"#Background-Material","page":"Home","title":"Background Material","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ernst Hairer and Christian Lubich. Numerical Solution of Ordinary Differential Equations. The Princeton Companion to Applied Mathematics, 293-305, 2015. Princeton University Press. (Author's Web Site)\nErnst Hairer, Christian Lubich and Gerhard Wanner. Geometric Numerical Integration Illustrated by the Störmer–Verlet Method. Acta Numerica 12, 399-450, 2003. (Journal)\nLaurent O. Jay. Lobatto Methods. Encyclopedia of Applied and Computational Mathematics, 817–826. Springer, 2015. (Article)","category":"page"},{"location":"#Books-on-Geometric-Numerical-Integration","page":"Home","title":"Books on Geometric Numerical Integration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sergio Blanes, Fernando Casas. A Concise Introduction to Geometric Numerical Integration. CRC Press, 2016. (eBook)\nErnst Hairer, Christian Lubich and Gerhard Wanner. Geometric Numerical Integration. Springer, 2006. (eBook)\nBenedict Leimkuhler and Sebastian Reich. Simulating Hamiltonian Dynamics. Cambridge University Press, 2005. (eBook)\nJesús Maria Sanz-Serna, Manuel P. Calvo. Numerical Hamiltonian Problems. Chapman Hall, 1994.","category":"page"},{"location":"#Books-on-the-Numerical-Integration-of-Differential-Equations","page":"Home","title":"Books on the Numerical Integration of Differential Equations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ernst Hairer, Syvert P. Nørsett and Gerhard Wanner. Solving Ordinary Differential Equations I: Nonstiff Problems. Springer, 1993. (eBook)\nErnst Hairer and Gerhard Wanner. Solving Ordinary Differential Equations II: Stiff and Differential-Algebraic Problems. Springer, 1996. (eBook)\nErnst Hairer, Christian Lubich, Michel Roche. The Numerical Solution of Differential-Algebraic Systems by Runge-Kutta Methods. Springer, 1989. (eBook)\nPeter Deuflhard, Folkmar Bornemann. Scientific Computing with Ordinary Differential Equations. Springer, 2002. (eBook)\nJohn C. Butcher. Numerical Methods for Ordinary Differential Equations. Wiley, 2016. (eBook)","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Copyright (c) Michael Kraus <michael.kraus@ipp.mpg.de>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"CurrentModule = GeometricIntegrators","category":"page"},{"location":"integrators/#Integrators","page":"Overview","title":"Integrators","text":"","category":"section"},{"location":"integrators/","page":"Overview","title":"Overview","text":"GeometricIntegrators.jl provides a plethora of geometric and non-geometric integrators. Most integrators are specified by a tableau, that is a Butcher tableau for Runge-Kutta methods, a pair of tableaus for partitioned Runge-Kutta and VPRK methods, or generalizations thereof for SPARK methods. Other integrators, such as Galerkin variational integrators require the specification of a basis and a quadrature rule.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"In many cases, the correct integrator is automatically selected based on the tableau and equation types by calling","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"Integrator(equation, tableau, Δt)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"where Δt is the time step.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"As an example, consider an ODE like the harmonic oscillator, which is included as an example problem:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"using GeometricIntegrators","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"ode = TestProblems.HarmonicOscillatorProblem.harmonic_oscillator_ode()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"Create an explicit Euler tableau:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"tab = TableauExplicitEuler()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"And now create an Integrator with the general Integrator constructor:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"int = Integrator(ode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"We see that we obtained an IntegratorERK, i.e., an explicit Runge-Kutta integrator. If instead we choose the implicit Euler tableau:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"tab = TableauImplicitEuler()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"the general Integrator constructor creates a different integrator:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"int = Integrator(ode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"namely an IntegratorFIRK, i.e., a fully implicit Runge-Kutta integrator.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"This is possible because most integrators come with a dedicated tableau type, so that Integrator can dispatch on that.","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"In some cases, in particular the VPRK integrators, the integrator has to be explicitly specified as there are different integrators that use the same tableau type and operate on the same equation type, here TableauVPRK and IODE. Consider again the harmonic oscillator:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"using GeometricIntegrators","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"iode = harmonic_oscillator_iode","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"Create a VPRK tableau that uses Gauss-Legendre Runge-Kutta coefficients with two stages:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"tab = TableauVPGLRK(2)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"If we just call the Integrator constructor,","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"int = Integrator(iode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"we obtain a plain IntegratorVPRK. If we want to use any of the projection methods, we have to explicitly specify the corresponding integrator type:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"int = IntegratorVPRKpStandard(iode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"or","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"int = IntegratorVPRKpSymmetric(iode, tab, 0.1)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"Once an integrator is obtained, we can just call the function","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"integrate(equation, integrator, ntime)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"to perform the actual integration steps, where ntime defines the number of steps to integrate:","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"using GeometricIntegrators\node = TestProblems.HarmonicOscillatorProblem.harmonic_oscillator_ode()","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"tab = TableauExplicitEuler()\nint = Integrator(ode, tab, 0.1)\nsol = integrate(ode, int, 100)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"The integrate function returns a solution object that stores the solution for each of the ntime time steps. There is also a convenience function that combines all of the above steps in one single call, namely","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"integrate(equation, tableau, Δt, ntime)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"If the solution object is created manually, there exists a function","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"integrate!(integrator, solution)","category":"page"},{"location":"integrators/","page":"Overview","title":"Overview","text":"that operates on an existing solution.","category":"page"},{"location":"modules/quadratures/#Quadratures","page":"Quadrature Rules","title":"Quadratures","text":"","category":"section"},{"location":"modules/quadratures/","page":"Quadrature Rules","title":"Quadrature Rules","text":"Modules = [GeometricIntegrators.Quadratures]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/basis_functions/#Basis-Functions","page":"Basis Functions","title":"Basis Functions","text":"","category":"section"},{"location":"modules/basis_functions/","page":"Basis Functions","title":"Basis Functions","text":"Modules = [GeometricIntegrators.BasisFunctions]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/solvers_nonlinear/#Nonlinear-Solvers","page":"Nonlinear Solvers","title":"Nonlinear Solvers","text":"","category":"section"},{"location":"modules/solvers_nonlinear/","page":"Nonlinear Solvers","title":"Nonlinear Solvers","text":"Modules = [GeometricIntegrators.Solvers]\nPages   = [\"solvers/nonlinear/nonlinear_solvers.jl\",\n           \"solvers/nonlinear/jacobian.jl\",\n           \"solvers/nonlinear/abstract_fixed_point_solver.jl\",\n           \"solvers/nonlinear/fixed_point_solver.jl\",\n           \"solvers/nonlinear/abstract_newton_solver.jl\",\n           \"solvers/nonlinear/nlsolve_newton.jl\",\n           \"solvers/nonlinear/newton_solver.jl\",\n           \"solvers/nonlinear/quasi_newton_solver.jl\"]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"CurrentModule = GeometricIntegrators.Tableaus","category":"page"},{"location":"integrators/rk/#Runge-Kutta-Methods","page":"Runge-Kutta","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Runge-Kutta methods exploit the Fundamental Theorem of Calculus, which states that the solution of an initial-value problem","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\ndotx (t) = f(t x(t))  \nx(t_n) = x_n \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"at time t_n+1 is given by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"x (t_n+1) = x (t_n) + int limits_t_n^t_n+1 dotx (t)  dt ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Runge-Kutta methods are constructed by approximating the integral by some quadrature formula with s nodes c_i and corresponding weights b_i to obtain x_n+1 approx x (t_n+1) by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nx_n+1 = x_n + h sum limits_i=1^s b_i dotX_ni  \ndotX_ni = f(t_n + c_i h X_ni) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"where the internal stage values X_ni approx x(t_n + c_i h) for i = 1  s are determined by another quadrature formula, approximating the integral","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"x(t_n + c_i h) = x (t_n) + int limits_t_n^t_n + c_i h dotx (t)  dt ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"namely","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"X_ni = x_n + h sum limits_j=1^s a_ij dotX_nj ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"with the same vector field values dotX_nj used for the computation of x_n+1.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Definition: Runge-Kutta methods are numerical one-step methods","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nX_ni = x_n + h sum limits_j=1^s a_ij  f(t_n + c_j h X_nj)  \nx_n+1 = x_n + h sum limits_j=1^s b_j   f(t_n + c_j h X_nj) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"defined by a set of nodes c_i, weights b_i and coefficients a_ij with ij = 1  s, summarized in the Butcher tableau","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginarraycc\nc  a     \nhline\n   b^T \nendarray\n=\nbeginarrayccccc\nc_1   a_11  a_12  dots  a_1s \nc_2   a_21  a_22  dots  a_2s \nvdots  vdots  vdots  ddots  vdots \nc_s   a_s1  a_s2  dots  a_ss \nhline\n        b_1   b_2   dots  b_s  \nendarray","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Most properties of the methods, such as order or stability, can be analysed just by posing conditions on the Butcher tableau.","category":"page"},{"location":"integrators/rk/#Common-Runge-Kutta-Methods","page":"Runge-Kutta","title":"Common Runge-Kutta Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"GeometricIntegrators.jl provides various explicit and implicit (both diagonally and fully implicit) Runge-Kutta methods. For many methods, tabulated coefficients are included, namely","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Function and Aliases Stages Order\nExplicit Methods  \nTableauExplicitEuler, TableauForwardEuler 1 1\nTableauExplicitMidpoint 2 2\nTableauHeun2 2 2\nTableauHeun3 3 3\nTableauRalston2 2 2\nTableauRalston3 3 3\nTableauRunge, TableauRunge2 2 2\nTableauKutta, TableauKutta3 3 3\nTableauRK416, TableauRK4 4 4\nTableauRK438 4 4\nTableauSSPRK3 3 3\nDiagonally Implicit Methods  \nTableauCrankNicolson 2 2\nTableauKraaijevangerSpijker 2 2\nTableauQinZhang 2 2\nTableauCrouzeix 2 3\nFully Implicit Methods  \nTableauImplicitEuler, TableauBackwardEuler 1 1\nTableauImplicitMidpoint 2 2\nTableauSRK3 3 4","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The coefficients of other methods are computed on-the-fly as described in the following.","category":"page"},{"location":"integrators/rk/#Simplifying-Assumptions","page":"Runge-Kutta","title":"Simplifying Assumptions","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The construction of many Runge-Kutte methods, in particular the Gauß, Radau and Lobatto methods, relies on the so-called simplifying assumptions:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nB(sigma)  sum limits_i=1^s b_i c_i^k-1 = frac1k  \nk = 1      sigma  \n\nC(eta)  sum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  \ni = 1     s   k = 1      eta  \n\nD(zeta)  sum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k )  \nj = 1     s   k = 1      zeta \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"These assumptions provide order conditions for a Runge-Kutta method given by (a_ij b_i c_i). The condition B(p) implies that the quadrature rule (b_i c_i) is of order p. Furthermore, the following theorem holds:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Theorem (Butcher 1964): If the coefficients (a_ij b_i c_i) of a Runge-Kutta method satisfy B(sigma), C(eta), D(zeta) with sigma le eta + zeta + 1 and sigma le 2 eta + 2, then the method is of order sigma.","category":"page"},{"location":"integrators/rk/#Gauß,-Lobatto-and-Radau-Methods","page":"Runge-Kutta","title":"Gauß, Lobatto and Radau Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Gauß methods are collocation methods using the nodes and weights of Gaußian quadrature formulas. The nodes are the zeros of the shifted Legendre polynomials of degree s,","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"fracd^sdx^s big( x^s (x-1)^s big) ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"In a similar fashion, the nodes of the Radau I and II and the Lobatto III methods are defined as the roots of the polynomials","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\n fracd^s-1dx^s-1 big( x^s (x-1)^s-1 big)      text(Radau I)  \n fracd^s-1dx^s-1 big( x^s-1 (x-1)^s big)      text(Radau II)  \n fracd^s-2dx^s-2 big( x^s-1 (x-1)^s-1 big)  text(Lobatto III) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The weights b_1  b_s are chosen such that the methods satisfy B(sigma), that is B(s), for the Gauß methods, B(s-1) for the Radau methods, and B(s-2) for the Lobatto methods.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The coefficients a_ij for ij = 1  s are obtained by the simplifying assumption C(s) for the Gauß, Radau IIA and Lobatto IIIA methods, and by the simplifying assumption D(s) for the Radau IA and Lobatto IIIB methods. The coefficients of the Lobatto IIIC methods are determined by setting a_i1 = b_1 for i = 1  s and solving the simplifying assumption C(s-1), while the coefficients of the Lobatto IIIC̄ methods are determined by setting a_is = 0 and solving C(s-1). Note that the Lobatto IIIC̄ methods are sometimes also called Lobatto III or Lobatto III*. For reasons of code symmetry we chose to stick with the less common name Lobatto IIIC̄. The Lobatto IIID and IIIE methods are obtained by combining the tableaus of the Lobatto IIIC and IIIC̄ and the Lobatto IIIA and IIIB methods, respectively, i.e., ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\na_ij^D = tfrac12 ( a_ij^C + a_ij^C ) \n textand \na_ij^E = tfrac12 ( a_ij^A + a_ij^B ) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"While the Lobatto IIIA, IIIB, IIIC and IIIC̄ methods are not symplectic on their own (although the Lobatto IIIA-IIIB and IIIC-IIIC̄ pairs constitute symplectic partitioned Runge-Kutta methods), the Lobatto IIID and IIIE methods are each symplectic by themselves.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The Gauß methods are of order 2s, the Radau methods or order 2s-1 and the Lobatto methods are of order 2s-2, with the exception of the Lobatto IIIF method. This method has been specifically constructed to be of order 2s as described in [Wang Fangzong , Liao Xiaobing  (2016)]. The Lobatto IIIG method is constructed in a similar fashion as the Lobatto IIID and IIIE methods by averaging the coefficients of the Lobatto IIIF method with its symplectic complement, i.e.,","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"a_ij^G = tfrac12 ( a_ij^F + bara_ij^F ) ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"where the coffiecients bara_ij^F are determined by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nb_i bara^F_ij + barb_j a^F_ji = b_i barb_j  \n textand \nbarb_i = b_i \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The tableaus of all of the above methods can be computed for an arbitrary number of stages s and thus to arbitrary order.","category":"page"},{"location":"integrators/rk/#Constructors","page":"Runge-Kutta","title":"Constructors","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The following methods are provided for the construction of the tableaus for the previously described methods:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Function Method\nTableauGLRK(s, T=Float64) Gauß-Legendre with s stages\nTableauLobattoIIIA(s, T=Float64) Lobatto IIIA with s stages\nTableauLobattoIIIB(s, T=Float64) Lobatto IIIB with s stages\nTableauLobattoIIIC(s, T=Float64) Lobatto IIIC with s stages\nTableauLobattoIIIC̄(s, T=Float64) Lobatto IIIC̄ with s stages\nTableauLobattoIIID(s, T=Float64) Lobatto IIID with s stages\nTableauLobattoIIIE(s, T=Float64) Lobatto IIIE with s stages\nTableauLobattoIIIF(s, T=Float64) Lobatto IIIF with s stages\nTableauLobattoIIIG(s, T=Float64) Lobatto IIIG with s stages\nTableauRadauIA(s, T=Float64) Radau IA with s stages\nTableauRadauIIA(s, T=Float64) Radau IIA with s stages","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The first argument s refers to the number of stages (s ge 1 for Gauß and s ge 2 for all other methods). The second argument specifies the number type of the coefficients. Internally, all coefficients are computed using BigFloat and then converted to the requested number type, defaulting to Float64.","category":"page"},{"location":"modules/integrators/#Integrators","page":"Integrators","title":"Integrators","text":"","category":"section"},{"location":"modules/integrators/#Common","page":"Integrators","title":"Common","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/abstract_coefficients.jl\",\n           \"integrators/abstract_integrator.jl\",\n           \"integrators/abstract_tableau.jl\",\n           \"integrators/integrator_cache.jl\",\n           \"integrators/integrators_common.jl\",\n           \"integrators/integrators.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionDAE,Integrator}","page":"Integrators","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionODE,Integrator}","page":"Integrators","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionPDAE,Integrator}","page":"Integrators","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionPODE,Integrator}","page":"Integrators","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{AT}, Tuple{TT}, Tuple{DT}, Tuple{SolutionPSDE{AT,TT,wType,NQ,NW,CONV} where CONV where NW where NQ where wType,Integrator}} where AT<:(AbstractArray{DT,N} where N) where TT where DT","page":"Integrators","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned SDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{AT}, Tuple{TT}, Tuple{DT}, Tuple{SolutionSDE{AT,TT,wType,NQ,NW,CONV} where CONV where NW where NQ where wType,Integrator}} where AT<:(AbstractArray{DT,N} where N) where TT where DT","page":"Integrators","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for SDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableau","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableau","text":"Holds the information for the various methods' tableaus.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_matrix-NTuple{4,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_matrix","text":"Create a vector of S solution matrices of type DT to store the solution of S internal stages for a problem with DxM dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector-Tuple{Any,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector","text":"Create a vector of S solution vectors of type DT to store the solution of S internal stages for a problem with D dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero-NTuple{4,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero","text":"Create a vector of (S,M+1) solution vectors of type DT to store the solution of S internal stages and M random processes for a problem with D dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero-Tuple{Any,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero","text":"Create a vector of S+1 solution vectors of type DT to store the solution of S internal stages and the solution of the previous timestep for a problem with D     dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_nonlinear_solver","page":"Integrators","title":"GeometricIntegrators.Integrators.create_nonlinear_solver","text":"Create nonlinear solver object for a system of N equations with data type DT. The function f(x)=0 to be solved for is determined by a julia function function_stages!(x, b, params), where x is the current solution and b is the output vector, s.th. b = f(x). params are a set of parameters depending on the equation and integrator that is used. The solver type is obtained from the config dictionary (:nls_solver).\n\n\n\n\n\n","category":"function"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{Equation,AbstractTableau,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Print error for integrators not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:spark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for special partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:vpark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:vspark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational special partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:vspark_primary,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational special partitioned additive Runge-Kutta tableau with projection on primary constraint.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IODE,CoefficientsPGLRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for Projected Gauss-Legendre Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IODE,GeometricIntegrators.Integrators.VPRK.TableauVPRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational partitioned Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{ODE,TableauDIRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for diagonally implicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{ODE,TableauERK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for explicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{ODE,TableauFIRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for fully implicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:hpark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for Hamiltonian partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:hspark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for Hamiltonian special partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:hspark_primary,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for Hamiltonian special partitioned additive Runge-Kutta tableau with projection on primary constraint.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PODE,TableauEPRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for explicit partitioned Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PODE,TableauIPRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for implicit partitioned Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PSDE,GeometricIntegrators.Integrators.Stochastic.TableauSIPRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for stochastic fully implicit partitioned Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{SDE,GeometricIntegrators.Integrators.Stochastic.TableauSERK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for stochastic explicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{SDE,GeometricIntegrators.Integrators.Stochastic.TableauSIRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for stochastic fully implicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{SDE,GeometricIntegrators.Integrators.Stochastic.TableauWERK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for weak explicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{SDE,GeometricIntegrators.Integrators.Stochastic.TableauWIRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for weak fully implicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{SODE,AbstractTableauSplitting,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for splitting tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{SPSDE,GeometricIntegrators.Integrators.Stochastic.TableauSISPRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for stochastic fully implicit split partitioned Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{VDAE,GeometricIntegrators.Integrators.SPARK.TableauVSPARKsecondary,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational special partitioned additive Runge-Kutta tableau with projection on secondary constraint.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{VODE,TableauFIRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for formal Lagrangian Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorConstructor-Tuple{Any,Any,TableauDIRK}","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorConstructor","text":"Create integrator constructor for diagonally implicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorConstructor-Tuple{Any,Any,TableauERK}","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorConstructor","text":"Create integrator constructor for explicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorConstructor-Tuple{Any,Any,TableauFIRK}","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorConstructor","text":"Create integrator constructor for fully implicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorConstructor-Tuple{Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorConstructor","text":"Create integrator constructor for exact solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate!-Tuple{Integrator,Solution,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate!","text":"Integrate ODE for initial conditions m with m₁ ≤ m ≤ m₂.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate!-Tuple{Integrator,Solution}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate!","text":"Integrate equation for all initial conditions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate!-Union{Tuple{AT}, Tuple{TT}, Tuple{DT}, Tuple{Integrator{DT,TT},Solution{AT,TT,N} where N,Int64,Int64,Int64,Int64}} where AT<:(AbstractArray{DT,N} where N) where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate!","text":"Integrate ODE for initial conditions m with m₁ ≤ m ≤ m₂ for time steps n with n₁ ≤ n ≤ n₂.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate-Tuple{Equation,AbstractTableau,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate","text":"Integrate given equation with given tableau for ntime time steps and return solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate-Tuple{Equation,Integrator,Int64}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate","text":"Apply integrator for ntime time steps and return solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate-Tuple{Function,Array{T,1} where T,AbstractTableau,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate","text":"Integrate ODE specified by vector field and initial condition with given tableau for ntime time steps and return solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate-Tuple{Function,Function,Array{T,1} where T,Array{T,1} where T,AbstractTableau,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate","text":"Integrate PODE specified by two vector fields and initial conditions with given tableau for ntime time steps and return solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Initial-Guesses","page":"Integrators","title":"Initial Guesses","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/initial_guess/extrapolation.jl\",\n           \"integrators/initial_guess/initial_guess_ode.jl\",\n           \"integrators/initial_guess/initial_guess_pode.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.aitken_neville-Union{Tuple{TT}, Tuple{Array{TT,1},Array{T,2} where T,TT,Array{T,1} where T}} where TT","page":"Integrators","title":"GeometricIntegrators.Integrators.aitken_neville","text":"Compute p(x) where p is the unique polynomial of degree length(xi), such that p(x[i]) = y[i]) for all i.\n\nti: interpolation nodes\nxi: interpolation values\nt:  evaluation point\nx:  evaluation value\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.euler_extrapolation-Union{Tuple{TT}, Tuple{Function,TT,TT,Array{T,1} where T,Array{T,1} where T,Int64}} where TT","page":"Integrators","title":"GeometricIntegrators.Integrators.euler_extrapolation","text":"Euler extrapolation method with arbitrary order p.\n\nv:  function to compute vector field\nt₀: initial time\nt₁: final   time\nx₀: initial value\nx₁: final   value\ns:  number of interpolations (order p=s+1)\n\nTODO This is probably broken!\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.midpoint_extrapolation-Union{Tuple{DT}, Tuple{TT}, Tuple{Function,Function,TT,TT,Array{DT,1},Array{DT,1},Array{DT,1},Array{DT,1},Int64}} where DT where TT","page":"Integrators","title":"GeometricIntegrators.Integrators.midpoint_extrapolation","text":"Midpoint extrapolation method with arbitrary order p.\n\nv:  function to compute vector field\nf:  function to compute force  field\nt₀: initial time\nt₁: final   time\nq₀: initial positions\np₀: initial momenta\nq₁: final   positions\np₁: final   momenta\ns:  number of interpolations (order p=2s+2)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.midpoint_extrapolation-Union{Tuple{TT}, Tuple{DT}, Tuple{Function,TT,TT,Array{DT,1},Array{DT,1},Int64}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.midpoint_extrapolation","text":"Midpoint extrapolation method with arbitrary order p.\n\nv:  function to compute vector field\nt₀: initial time\nt₁: final   time\nx₀: initial value\nx₁: final   value\ns:  number of interpolations (order p=2s+2)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.InitialGuessODE","page":"Integrators","title":"GeometricIntegrators.Integrators.InitialGuessODE","text":"InitialGuessODE: Initial guess for ordinary differential equations\n\nFields\n\nint: interpolation structure\nv:   vector  field\nΔt:  time step\ns:   number of extrapolation stages (for initialisation)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initialize!-Union{Tuple{TT}, Tuple{DT}, Tuple{InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT,TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}}}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.initialize!","text":"Initialise initial guess, i.e., given t₀, t₁, q₁ compute q₀, v₀, v₁.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.update_vector_fields!-Union{Tuple{TT}, Tuple{DT}, Tuple{InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT,TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Array{DT,1}}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.update_vector_fields!","text":"compute vector field of new solution\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.InitialGuessPODE","page":"Integrators","title":"GeometricIntegrators.Integrators.InitialGuessPODE","text":"InitialGuessPODE: Initial guess for partitioned ordinary differential equations\n\nFields\n\nint: interpolation structure\nv:   vector field for q\nf:   vector field for p\nΔt:  time step\ns:   number of extrapolation stages (for initialisation)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initialize!-Union{Tuple{TT}, Tuple{DT}, Tuple{InitialGuessPODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT,TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}}}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.initialize!","text":"Initialise initial guess, i.e., given t₀, t₁, q₁ compute q₀, v₀, v₁.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Splitting-Methods","page":"Integrators","title":"Splitting Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/splitting/integrators_splitting.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorSplitting","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorSplitting","text":"Splitting integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorSplitting-Union{Tuple{ST}, Tuple{TT}, Tuple{DT}, Tuple{SODE{DT,TT,arrayType,vType,qType,pType} where pType<:Union{Nothing, NamedTuple} where qType<:Union{Nothing, Tuple} where vType<:Union{Nothing, Tuple} where arrayType<:(AbstractArray{DT,N} where N),ST,TT}} where ST<:AbstractTableauSplitting{TT} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorSplitting","text":"Construct splitting integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorSplitting{DT,TT,D,S,QT} where QT<:Tuple where S where D,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with splitting integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Runge-Kutta-Methods","page":"Integrators","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/rk/bstract_integrator_rk.jl\",\n           \"integrators/rk/coefficients.jl\",\n           \"integrators/rk/tableaus.jl\",\n           \"integrators/rk/integrators_erk.jl\",\n           \"integrators/rk/integrators_dirk.jl\",\n           \"integrators/rk/integrators_firk.jl\",\n           \"integrators/rk/integrators_eprk.jl\",\n           \"integrators/rk/integrators_iprk.jl\",\n           \"integrators/rk/integrators_flrk.jl\",\n           \"integrators/rk/integrators_pglrk.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.CoefficientsRK","page":"Integrators","title":"GeometricIntegrators.Integrators.CoefficientsRK","text":"Holds the coefficients of a Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Base.show-Tuple{IO,CoefficientsRK}","page":"Integrators","title":"Base.show","text":"Print Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableauERK","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableauERK","text":"Holds the tableau of an explicit Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableauIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableauIRK","text":"Holds the tableau of an implicit Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableauPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableauPRK","text":"Holds the tableau of a partitioned Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableauRK","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableauRK","text":"Holds the tableau of a Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.readTableauRKHeaderFromFile-Tuple{Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.readTableauRKHeaderFromFile","text":"Reads and parses Tableau metadata from file.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.writeTableauToFile-Union{Tuple{T}, Tuple{AbstractString,AbstractTableauRK{T}}} where T","page":"Integrators","title":"GeometricIntegrators.Integrators.writeTableauToFile","text":"Write Runge-Kutta tableau to file.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheERK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheERK","text":"Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorERK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorERK","text":"Explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersERK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersERK","text":"Parameters for right-hand side function of explicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauERK","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauERK","text":"Holds the tableau of an explicit Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorERK{DT,TT,D,S,ET} where ET where S where D,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{IntegratorERK{DT,TT,D,S,ET} where ET where S where D,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.IntegratorCacheERK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.readTableauERKFromFile-Tuple{AbstractString,AbstractString}","page":"Integrators","title":"GeometricIntegrators.Integrators.readTableauERKFromFile","text":"Read explicit Runge-Kutta tableau from file.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheDIRK","text":"Diagonally implicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorDIRK","text":"Diagonally implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersDIRK","text":"Parameters for right-hand side function of diagonally implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauDIRK","text":"Holds the tableau of a diagonally implicit Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict,Int64}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initial_guess!-Union{Tuple{DT}, Tuple{IntegratorDIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT) where ST where PT<:(GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D where TT,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N) where TT<:Real}, Tuple{IntegratorDIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT) where ST where PT<:(GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D where TT,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N) where TT<:Real,GeometricIntegrators.Integrators.IntegratorCacheDIRK{DT,D,S} where S where D}} where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.initial_guess!","text":"Compute initial guess for internal stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initialize!-Tuple{IntegratorDIRK,GeometricIntegrators.Integrators.IntegratorCacheDIRK}","page":"Integrators","title":"GeometricIntegrators.Integrators.initialize!","text":"Initialise initial guess\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorDIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT) where ST where PT<:(GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{IntegratorDIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT) where ST where PT<:(GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.IntegratorCacheDIRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with diagonally implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheFIRK","text":"Fully implicit Runge-Kutta integrator cache.\n\nFields\n\nq̃: initial guess of solution\nṽ: initial guess of vector field\ns̃: holds shift due to periodicity of solution\nQ: internal stages of solution\nV: internal stages of vector field\nY: vector field of internal stages\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorFIRK","text":"Fully implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersFIRK","text":"Parameters for right-hand side function of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauFIRK","text":"Holds the tableau of a fully implicit Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersFIRK{DT,TT,D,S,ET,FT,JT} where JT where FT where ET<:NamedTuple where S,GeometricIntegrators.Integrators.CacheDict}} where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorFIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersFIRK{DT,TT,D,S,ET,FT,JT} where JT where FT where ET<:NamedTuple where S where D) where S where D,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{IntegratorFIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersFIRK{DT,TT,D,S,ET,FT,JT} where JT where FT where ET<:NamedTuple where S where D) where S where D,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.IntegratorCacheFIRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with fully implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.jacobian!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{Array{DT,1},Array{DT,2},GeometricIntegrators.Integrators.IntegratorCacheFIRK{DT,D,S},GeometricIntegrators.Integrators.ParametersFIRK{DT,TT,D,S,ET,FT,JT} where JT where FT where ET<:NamedTuple}} where S where D where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.jacobian!","text":"Compute stages of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheEPRK","text":"Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorEPRK","text":"Explicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersEPRK","text":"Parameters for right-hand side function of explicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauEPRK","text":"TableauEPRK: Tableau of an Explicit Partitioned Runge-Kutta method\n\nbeginaligned\nV_ni = hphantom- dfracpartial Hpartial p (Q_ni P_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = - dfracpartial Hpartial q (Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nusually satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + b_j a_ji = b_i b_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.computeStageP!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorEPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D,GeometricIntegrators.Integrators.IntegratorCacheEPRK{DT,D,S} where S where D,Int64,Int64,TT}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.computeStageP!","text":"Compute P stages of explicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.computeStageQ!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorEPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D,GeometricIntegrators.Integrators.IntegratorCacheEPRK{DT,D,S} where S where D,Int64,Int64,TT}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.computeStageQ!","text":"Compute Q stages of explicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorEPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{IntegratorEPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.IntegratorCacheEPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate partitioned ODE with explicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheIPRK","text":"Implicit partitioned Runge-Kutta integrator cache.\n\nFields\n\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: vector field of internal stages of q\nZ: vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorIPRK","text":"Implicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersIPRK","text":"Parameters for right-hand side function of implicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauIPRK","text":"TableauIPRK: Tableau of an Implicit Partitioned Runge-Kutta method\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nusually satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + b_j a_ji = b_i b_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersIPRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of implicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorIPRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessPODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersIPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{IntegratorIPRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessPODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersIPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.IntegratorCacheIPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with implicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorFLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorFLRK","text":"Formal Lagrangian Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersFLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersFLRK","text":"Parameters for right-hand side function of formal Lagrangian Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersFLRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of formal Lagrangian Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.CoefficientsPGLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.CoefficientsPGLRK","text":"Holds the coefficients of a projected Gauss-Legendre Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorPGLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorPGLRK","text":"Projected Gauss-Legendre Runge-Kutta integrator.\n\nReference: LUIGI BRUGNANO, FELICE IAVERNARO, AND DONATO TRIGIANTE.\n    ENERGY- AND QUADRATIC INVARIANTS–PRESERVING INTEGRATORS BASED\n    UPON GAUSS COLLOCATION FORMULAE.\n    SIAM J. NUMER. ANAL. Vol. 50, No. 6, pp. 2897–2916, 2012.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersPGLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersPGLRK","text":"Parameters for right-hand side function of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Base.show-Tuple{IO,CoefficientsPGLRK}","page":"Integrators","title":"Base.show","text":"Print Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersPGLRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorPGLRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersPGLRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{IntegratorPGLRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{TT,VT,IT} where IT<:Interpolator{TT} where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersPGLRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.IntegratorCachePGLRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with projected Gauss-Legendre Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#SPARK-Methods","page":"Integrators","title":"SPARK Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators.SPARK]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK","text":"Parameters for right-hand side function of Specialised Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsARK","text":"Holds the coefficients of an additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsIRK","text":"Holds the coefficients of an additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsMRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsMRK","text":"Holds the multiplier Runge-Kutta coefficients.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsPRK","text":"Holds the coefficients of a projective Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsSPARK","text":"Holds the coefficients of a SPARK method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorCacheSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorCacheSPARK","text":"Cache of a Specialised Partitioned Additive Runge-Kutta integrator.\n\nFields\n\nn: time step number\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\np: current solution of p\np̅: previous solution of p\nv: vector field of q\nv̅: vector field of q̅\nf: vector field of p\nf̅: vector field of p̅\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: vector field of internal stages of q\nZ: vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHPARK","text":"Partitioned Additive Runge-Kutta integrator for Hamiltonian systems subject to Dirac constraints EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \ntildePhi_ni = 0   i = 1  r \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKprimary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKprimary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKsecondary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems subject to Dirac constraints with projection on secondary constraint EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorSLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorSLRK","text":"Specialised Partitioned Additive Runge-Kutta integrator for degenerate variational systems with projection on secondary constraint.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a^1_ij V_nj + h sum limits_j=1^sigma a^2_ij tildeLambda_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s bara^1_ij F^1_nj + h sum limits_j=1^s bara^2_ij F^2_nj + h sum limits_j=1^sigma bara^3_ij tildeF^3_nj   i = 1  s  \n0 = Phi_ni   i = 1  s \nendaligned\n\nthe projective stages\n\nbeginaligned\ntildeQ_ni = q_n + h sum limits_j=1^s alpha^1_ij tildeV_nj + h sum limits_j=1^sigma alpha^2_ij tildeLambda_nj   i = 1  sigma  \ntildeP_ni = p_n + h sum limits_j=1^s baralpha^1_ij F^1_nj + h sum limits_j=1^s baralpha^2_ij tildeF^2_nj + h sum limits_j=1^sigma baralpha^3_ij tildeF^3_nj   i = 1  sigma  \n0 = tildePhi_ni   i = 1  sigma  \n0 = sum limits_j=1^sigma omega_ij tildePsi_ni   i = 1  sigma-1 \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b^1_i V_ni + h sum limits_i=1^sigma b^2_i tildeLambda_ni  \np_n+1 = p_n + h sum limits_i=1^s b^1_i F^1_ni + h sum limits_i=1^s b^2_i F^2_ni + h sum limits_i=1^sigma b^3_i tildeF^3_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nwith definitions\n\nbeginaligned\nF^1_ni = nabla H (Q_ni)   i = 1  s  \nF^2_ni = nabla vartheta (Q_ni) cdot V_ni   i = 1  s  \ntildeF^3_ni = nabla phi (tildeQ_ni tildeP_ni) cdot tildeLambda_ni   i = 1  sigma  \nPhi_ni = phi (Q_ni P_ni) = P_ni - vartheta (Q_ni)   i = 1  s  \ntildePhi_ni = phi (tildeQ_ni tildeP_ni) = tildeP_ni - vartheta (tildeQ_ni)   i = 1  sigma  \ntildePsi_ni = psi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla vartheta (tildeQ_ni)   i = 1  sigma \nendaligned\n\nso that\n\nbeginaligned\nF^1_ni + F^2_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nphi (Q_ni P_ni) = P_ni - fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \npsi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla fracpartial Lpartial v (tildeQ_ni tildeV_ni)   i = 1  sigma \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for index-two DAE systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVPARK","text":"Variational partitioned additive Runge-Kutta integrator.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \ntildePhi_ni = 0   i = 1  r \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for Variational systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKprimary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKprimary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Variational systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1  \n0 = sum limits_i=1^r tilded_i  Lambda_ni \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKsecondary","text":"Specialised Partitioned Additive Runge-Kutta integrator for degenerate variational systems with projection on secondary constraint.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a^1_ij V_nj + h sum limits_j=1^sigma a^2_ij tildeLambda_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s bara^1_ij F^1_nj + h sum limits_j=1^s bara^2_ij F^2_nj + h sum limits_j=1^sigma bara^3_ij tildeF^3_nj   i = 1  s  \n0 = Phi_ni   i = 1  s \nendaligned\n\nthe projective stages\n\nbeginaligned\ntildeQ_ni = q_n + h sum limits_j=1^s alpha^1_ij tildeV_nj + h sum limits_j=1^sigma alpha^2_ij tildeLambda_nj   i = 1  sigma  \ntildeP_ni = p_n + h sum limits_j=1^s baralpha^1_ij F^1_nj + h sum limits_j=1^s baralpha^2_ij tildeF^2_nj + h sum limits_j=1^sigma baralpha^3_ij tildeF^3_nj   i = 1  sigma  \n0 = tildePhi_ni   i = 1  sigma  \n0 = sum limits_j=1^sigma omega_ij tildePsi_ni   i = 1  sigma-1 \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b^1_i V_ni + h sum limits_i=1^sigma b^2_i tildeLambda_ni  \np_n+1 = p_n + h sum limits_i=1^s b^1_i F^1_ni + h sum limits_i=1^s b^2_i F^2_ni + h sum limits_i=1^sigma b^3_i tildeF^3_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nwith definitions\n\nbeginaligned\nF^1_ni = nabla H (Q_ni)   i = 1  s  \nF^2_ni = nabla vartheta (Q_ni) cdot V_ni   i = 1  s  \ntildeF^3_ni = nabla phi (tildeQ_ni tildeP_ni) cdot tildeLambda_ni   i = 1  sigma  \nPhi_ni = phi (Q_ni P_ni) = P_ni - vartheta (Q_ni)   i = 1  s  \ntildePhi_ni = phi (tildeQ_ni tildeP_ni) = tildeP_ni - vartheta (tildeQ_ni)   i = 1  sigma  \ntildePsi_ni = psi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla vartheta (tildeQ_ni)   i = 1  sigma \nendaligned\n\nso that\n\nbeginaligned\nF^1_ni + F^2_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nphi (Q_ni P_ni) = P_ni - fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \npsi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla fracpartial Lpartial v (tildeQ_ni tildeV_ni)   i = 1  sigma \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersHPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersHPARK","text":"Parameters for right-hand side function of Hamiltonian Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersSLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersSLRK","text":"Parameters for right-hand side function of Specialised Partitioned Additive Runge-Kutta methods for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersVPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersVPARK","text":"Parameters for right-hand side function of Variational Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersVSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersVSPARKsecondary","text":"Parameters for right-hand side function of Specialised Partitioned Additive Runge-Kutta methods for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauHPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauHPARK","text":"Holds the tableau of a Hamiltonian Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauSLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauSLRK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauSPARK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauVPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauVPARK","text":"Holds the tableau of an Variational Partitioned Additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauVSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauVSPARKsecondary","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsARK}","page":"Integrators","title":"Base.show","text":"Print additive Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsIRK}","page":"Integrators","title":"Base.show","text":"Print additive Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsMRK}","page":"Integrators","title":"Base.show","text":"Print multiplier Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsPRK}","page":"Integrators","title":"Base.show","text":"Print projective Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsSPARK}","page":"Integrators","title":"Base.show","text":"Print SPARK coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hspark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hspark_primary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:spark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vspark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vspark_primary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hpark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned additive Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hspark_secondary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vpark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned additive Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vspark_secondary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:slrk,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P where R,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.SPARK.AbstractIntegratorSPARK{DT,TT,D,S,R} where R where S where D,AtomicSolutionPDAE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.SPARK.AbstractIntegratorSPARK{DT,TT,D,S,R} where R where S where D,AtomicSolutionPDAE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.SPARK.IntegratorCacheSPARK{DT,D,S,R} where R where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate an implicit DAE with a specialised partitioned additive Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#VPRK-Methods","page":"Integrators","title":"VPRK Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators.VPRK]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK","text":"Parameters for right-hand side function of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK","text":"Variational partitioned Runge-Kutta integrator cache.\n\nFields\n\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: integral of vector field of internal stages of q\nZ: integral of vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRK","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKdegenerate","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKdegenerate","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpInternal","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpInternal","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpLegendre","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpLegendre","text":"Variational special partitioned additive Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpMidpoint","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpMidpoint","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary","text":"Variational partitioned Runge-Kutta integrator with projection on secondary constraint.\n\nThe VPRK integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  big( V_nj + Lambda_nj big)  \nP_ni = p_n + h sum limits_i=1^s bara_ij  big( F_nj + nabla vartheta (Q_nj)^T cdot Lambda_nj big) - d_i lambda  \n0 = sum limits_i=1^s d_i V_i  \n0 = sum limits_j=1^s omega_ij Psi_nj \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nPsi_ni = psi(Q_ni V_ni P_ni F_ni) \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i  big( V_ni + Lambda_ni big)  \np_n+1 = p_n + h sum limits_i=1^s barb_i  big( F_ni + nabla vartheta (Q_nj)^T cdot Lambda_nj big)  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nsatisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\nthe primary constraint,\n\nbeginaligned\nphi(qp) = p - vartheta (q) = 0 \nendaligned\n\nat the final solution (q_n+1 p_n+1), and super positions of the secondary constraints,\n\nbeginaligned\npsi(qdotqpdotp)\n= dotp - dotq cdot nabla vartheta (q)\n= big( nabla vartheta (q) - nabla vartheta^T (q) big) cdot dotq - nabla H (q)\n= 0\nendaligned\n\nwhich, evaluated at the internal stages, read\n\nbeginaligned\nPsi_nj = big( nabla vartheta (Q_nj) - nabla vartheta^T (Q_nj) big) cdot V_nj - nabla H (Q_nj) \nendaligned\n\nHere, omega is a (s-1) times s matrix, chosen such that the resulting method has optimal order. The vector d is zero for Gauss-Legendre methods and needs to be chosen appropriately for Gauss-Lobatto methods (for details see documentation of VPRK methods).\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard-Tuple","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard","text":"Variational partitioned Runge-Kutta integrator with standard projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymmetric","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymmetric","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpTableau","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpTableau","text":"Projected Variational Gauss-Legendre Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariational","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariational","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRK","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKdegenerate","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKdegenerate","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpInternal","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpInternal","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpLegendre","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpLegendre","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpMidpoint","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpMidpoint","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSecondary","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpStandard","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpStandard","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSymmetric","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSymmetric","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau","text":"Parameters for right-hand side function of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpVariational","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpVariational","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.TableauVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.TableauVPRK","text":"TableauVPRK: Tableau of a Variational Partitioned Runge-Kutta method\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nP_ni = p_n + h sum limits_i=1^s bara_ij  F_nj - d_i lambda  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni  \n\n0 = sum limits_i=1^s d_i V_i  \nendaligned\n\nsatisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + b_j a_ji = b_i b_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymplectic-Tuple","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymplectic","text":"Variational partitioned Runge-Kutta integrator with symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalP-Tuple","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalP","text":"Variational partitioned Runge-Kutta integrator with variational projection on (p_n q_n+1).\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalQ-Tuple","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariationalQ","text":"Variational partitioned Runge-Kutta integrator with variational projection on (q_n p_n+1).\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_degenerate,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute solution of degenerate symplectic partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pinternal,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_plegendre,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational special partitioned additive Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pmidpoint,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psecondary,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pstandard,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psymmetric,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pvariational,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKdegenerate{DT,TT,D,S,PT,PPT,ST,PST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where PST<:SimpleSolvers.NonlinearSolver{DT} where ST<:SimpleSolvers.NonlinearSolver{DT} where PPT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_degenerate,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKdegenerate{DT,TT,D,S,PT,PPT,ST,PST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where PST<:SimpleSolvers.NonlinearSolver{DT} where ST<:SimpleSolvers.NonlinearSolver{DT} where PPT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_degenerate,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpInternal{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pinternal,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpInternal{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pinternal,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpLegendre{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_plegendre,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpLegendre{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_plegendre,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate DAE with variational special partitioned additive Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpMidpoint{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pmidpoint,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpMidpoint{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pmidpoint,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psecondary,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psecondary,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard{DT,TT,D,S,PT,PPT,ST,PST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where PST<:SimpleSolvers.NonlinearSolver{DT} where ST<:SimpleSolvers.NonlinearSolver{DT} where PPT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pstandard,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard{DT,TT,D,S,PT,PPT,ST,PST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where PST<:SimpleSolvers.NonlinearSolver{DT} where ST<:SimpleSolvers.NonlinearSolver{DT} where PPT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pstandard,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymmetric{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psymmetric,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymmetric{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psymmetric,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpTableau{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpTableau{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with projected Gauss-Legendre Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariational{DT,TT,D,S,PT,PPT,ST,PST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where PST<:SimpleSolvers.NonlinearSolver{DT} where ST<:SimpleSolvers.NonlinearSolver{DT} where PPT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pvariational,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariational{DT,TT,D,S,PT,PPT,ST,PST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where PST<:SimpleSolvers.NonlinearSolver{DT} where ST<:SimpleSolvers.NonlinearSolver{DT} where PPT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pvariational,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Galerkin-Variational-Integrators","page":"Integrators","title":"Galerkin Variational Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/cgvi/integrators_cgvi.jl\",\n           \"integrators/dgvi/integrators_dgvi.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCGVI","text":"Continuous Galerkin Variational Integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersCGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersCGVI","text":"ParametersCGVI: Parameters for right-hand side function of continuous Galerkin variational Integrator.\n\nParameters\n\nΘ: function of the noncanonical one-form (∂L/∂v)\nf: function of the force (∂L/∂q)\nΔt: time step\nb: weights of the quadrature rule\nc: nodes of the quadrature rule\nx: nodes of the basis\nm: mass matrix\na: derivative matrix\nr₀: reconstruction coefficients at the beginning of the interval\nr₁: reconstruction coefficients at the end of the interval\nt: initial time\nq: solution of q at time t\np: solution of p at time t\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersCGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorCGVI{DT,TT,D,S,R,BT,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersCGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple) where BT<:ContinuumArrays.Basis where R where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{IntegratorCGVI{DT,TT,D,S,R,BT,PT,ST,IT} where IT<:(InitialGuessIODE{TT,VT,FT,IT} where IT<:Interpolator{TT} where FT where VT) where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersCGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple) where BT<:ContinuumArrays.Basis where R where S where D,AtomicSolutionPODE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.IntegratorCacheCGVI{DT,D,S,R} where R where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheDGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheDGVI","text":"Nonlinear function cache for Discontinuous Galerkin Variational Integrator.\n\nParameters\n\nST: data type\nD: number of dimensions\nS: number of degrees of freedom\nR: number of nodes of quadrature formula\n\nFields\n\nX: degrees of freedom\nQ: solution at quadrature nodes\nV: velocity at quadrature nodes\nP: one-form at quadrature nodes\nF: forces at quadrature nodes\nq:  current solution of q_n\nq⁻: current solution of q_n^-\nq⁺: current solution of q_n^+\nq̅:  current solution of q_n+1\nq̅⁻: current solution of q_n+1^-\nq̅⁺: current solution of q_n+1^+\nϕ:  average of the solution at t_n\nϕ̅:  average of the solution at t_n+1\nλ:  jump of the solution at t_n\nλ̅:  jump of the solution at t_n+1\nθ:  one-form evaluated across at t_n\nΘ̅:  one-form evaluated across at t_n+1\ng:  projection evaluated across at t_n\ng̅:  projection evaluated across at t_n+1\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorDGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorDGVI","text":"IntegratorDGVI: Discontinuous Galerkin Variational Integrator.\n\nThe DGVI integrators arise from the discretization of the action integral\n\nmathcalA q = int limits_0^T L(q(t) dotq(t))  dt \n\nwith L a fully degenerate Lagrangian of the form\n\nL(q dotq) = vartheta (q) cdot dotq - H(q) \n\nwhere vartheta (q) denotes the Cartan one-form and H(q) the Hamiltonian, which is usually given by the total energy of the system.\n\nDiscretization\n\nWithin each interval (t_n t_n+1) a piecewise-polynomial approximation q_h of the trajectory q is constructed using S basis functions varphi_i,\n\nq_h(t) vert_(t_n t_n+1) = sum limits_i=1^S x_ni  barvarphi_ni (t) \n\nwhere barvarphi_ni (t) is a rescaled basis function, defined by\n\nbarvarphi_ni (t) = varphi_i bigg( fract - t_nt_n+1 - t_n bigg) \n\nand it is assumed that varphi_i is compactly supported on 01. These approximations q_h(t) are not assumed to be continuous across interval boundaries t_n but usuaslly have jumps.\n\nThe integral over (t_n t_n+1) is approximated by a quadrature rule with R nodes c_i and weights b_i. Denote by m and a mass and derivative matrices, respectively, whose elements  are given by\n\nm_ij = varphi_j (c_i) \nqquad\na_ij = varphi_j (c_i) \nqquad\ni = 1  R \n\nj = 1  S \n\nWith that, the solution and its time derivative at the quadrature points can be written as\n\nQ_ni equiv q_h(t_n + c_i h) = m_ij x_nj \nqquad\nV_ni equiv dotq_h (t_n + c_i h) = a_ij x_nj \n\nwhere\n\nx_n = ( x_n1  x_nS )^T\n\nis the vector containing the degrees of freedom of q_h vert_t_n t_n+1. The limits of q_h(t) at t_n and t_n+1 are given by\n\nq_n^+ = lim limits_t downarrow t_n q_h(t) = sum limits_j=1^S r^+_j delta x_nj \nhspace3em\nq_n+1^- = lim limits_t uparrow t_n+1 q_h(t) = sum limits_j=1^S r^-_j delta x_nj \n\nThe discrete action reads\n\nmathcalA_d x_d = h sum limits_n=0^N-1 bigg\n     sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big \n     + fracvartheta (q_n) + vartheta (q_n^+)2 cdot (q_n^+ - q_n)\n     + fracvartheta (q_n+1^-) + vartheta (q_n+1)2 cdot (q_n+1 - q_n+1^-)\nbigg \n\nso that using the relations\n\ndelta Q_ni = m_ij delta x_nj \nqquad\ndelta V_ni = fraca_ijh delta x_nj \nqquad\ndelta q_n^- = r^-_j delta x_n-1j \nqquad\ndelta q_n^+ = r^+_j delta x_nj \n\nthe discrete action principle leads to the discrete equations of motion,\n\n0 = sum limits_i=1^R b_i big h m_ij nabla vartheta (Q_ni) cdot V_ni + a_ij vartheta (Q_ni) - h m_ij nabla H(Q_ni) big \n+ r^+_j  frac vartheta ( q_n     ) + vartheta( q_n  ^+ ) 2\n- r^-_j  frac vartheta ( q_n+1^- ) + vartheta( q_n+1   ) 2\n   big \n+ h r^+_j  nabla vartheta (q_n  ^+) cdot (q_n  ^+ - q_n    )\n+ h r^-_j  nabla vartheta (q_n+1^-) cdot (q_n+1   - q_n+1^-) \n\nand\n\nvartheta(q_n^+) = vartheta (q_n^-) + nabla vartheta (q_n) cdot (q_n^+ - q_n^-) \n\nfor all n and all j. Let us introduce the variable p_n as\n\np_n = vartheta (q_n^-) + nabla vartheta (q_n) cdot (q_n - q_n^-) \n\nso that\n\nvartheta(q_n^+) = p_n + nabla vartheta (q_n) cdot (q_n^+ - q_n) \n\nThen the above equations provide a map (q_n p_n) mapsto (q_n+1 p_n+1). In order to solve these equations, initial conditions q_0 and p_0 = vartheta(q_0) have to be prescribed.\n\nFields\n\nequation: Implicit Ordinary Differential Equation\nbasis: piecewise polynomial basis\nquadrature: numerical quadrature rule\nΔt: time step\nparams: ParametersDGVI\nsolver: nonlinear solver\niguess: initial guess\nq: current solution vector for trajectory\np: current solution vector for one-form\ncache: temporary variables for nonlinear solver\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersDGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersDGVI","text":"ParametersDGVI: Parameters for right-hand side function of Discontinuous Galerkin Variational Integrator.\n\nParameters\n\nDT: data type\nTT: parameter type\nD: dimension of the system\nS: number of basis nodes\nR: number of quadrature nodes\n\nFields\n\nΘ:  function of the noncanonical one-form (∂L/∂v)\nf:  function of the force (∂L/∂q)\ng:  function of the projection ∇ϑ(q)⋅v\nΔt: time step\nb:  quadrature weights\nc:  quadrature nodes\nm:  mass matrix\na:  derivative matrix\nr⁻: reconstruction coefficients, jump lhs value\nr⁺: reconstruction coefficients, jump rhs value\nt:  initial time\nq:  solution of q  at time t\nq⁻: solution of q⁻ at time t\nq⁺: solution of q⁺ at time t\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.compute_stages_p!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{GeometricIntegrators.Integrators.IntegratorCacheDGVI{ST,D,S,R},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.compute_stages_p!","text":"Compute one-form and forces at quadrature nodes.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.compute_stages_q!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{GeometricIntegrators.Integrators.IntegratorCacheDGVI{ST,D,S,R},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.compute_stages_q!","text":"Compute solution at quadrature nodes and across jump.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.compute_stages_v!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{GeometricIntegrators.Integrators.IntegratorCacheDGVI{ST,D,S,R},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.compute_stages_v!","text":"Compute velocities at quadrature nodes.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Stochastic-Integrators","page":"Integrators","title":"Stochastic Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators.Stochastic]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSERK","text":"Stochastic Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIPRK","text":"Structure for holding the internal stages Q, the values of the drift vector and the diffusion matrix evaluated at the internal stages V=v(Q), B=B(Q), and the increments Y = Δt*a_drift*v(Q) + a_diff*B(Q)*ΔW.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIRK","text":"Structure for holding the internal stages Q, the values of the drift vector and the diffusion matrix evaluated at the internal stages V=v(Q), B=B(Q), and the increments Y = a_drift*v(Q)*Δt + a_diff*B(Q)*ΔW.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSISPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSISPRK","text":"Structure for holding the internal stages Q, the values of the drift vector and the diffusion matrix evaluated at the internal stages V=v(Q), B=B(Q), and the increments Y = Δt*a_drift*v(Q) + a_diff*B(Q)*ΔW.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWERK","text":"Weak Stochastic Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWIRK","text":"Structure for holding the internal stages Q0, and Q1 the values of the drift vector and the diffusion matrix evaluated at the internal stages V=v(Q0), B=B(Q1), and the increments Y = Δt*a_drift*v(Q) + a_diff*B(Q)*ΔW.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorSERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorSERK","text":"Stochastic Explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorSIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorSIPRK","text":"Stochastic implicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorSIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorSIRK","text":"Stochastic implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorSISPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorSISPRK","text":"Stochastic implicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorWERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorWERK","text":"Weak Stochastic Explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorWIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorWIRK","text":"Stochastic implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.ParametersSERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.ParametersSERK","text":"Parameters for stochastic explicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK","text":"Parameters for right-hand side function of implicit Runge-Kutta methods.\n\nA - if positive, the upper bound of the Wiener process increments; if A=0.0, no truncation\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.ParametersSIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.ParametersSIRK","text":"Parameters for right-hand side function of implicit Runge-Kutta methods.\n\nA - if positive, the upper bound of the Wiener process increments; if A=0.0, no truncation\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK","text":"Parameters for right-hand side function of implicit Runge-Kutta methods.\n\nA - if positive, the upper bound of the Wiener process increments; if A=0.0, no truncation.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.ParametersWERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.ParametersWERK","text":"Parameters for weak stochastic explicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.ParametersWIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.ParametersWIRK","text":"Parameters for right-hand side function of weak implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.TableauSERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.TableauSERK","text":"Holds the tableau of a stochastic explicit Runge-Kutta method.\n\nOrder of the tableau is not included, because unlike in the deterministic setting, it depends on the properties of the noise (e.g., the dimension of the Wiener process and the commutativity properties of the diffusion matrix).\n\nOrders stored in qdrift, qdiff and qdiff2 are understood as the classical orders of these methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.TableauSIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.TableauSIPRK","text":"Holds the tableau of a stochastic implicit partitioned Runge-Kutta method. qdrift, pdrift hold the RK coefficients for the drift part, and qdiff, pdiff hold the RK coefficients for the diffusion part of the SDE.\n\nOrder of the tableau is not included, because unlike in the deterministic setting, it depends on the properties of the noise (e.g., the dimension of the Wiener process and the commutativity properties of the diffusion matrix).\n\nOrders stored in qdrift and qdiff are understood as the classical orders of these methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.TableauSIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.TableauSIRK","text":"Holds the tableau of a stochastic implicit Runge-Kutta method.\n\nqdrift holds the RK coefficients for the drift part, qdiff holds the RK coefficients for the diffusion part of the SDE.\n\nOrder of the tableau is not included, because unlike in the deterministic setting, it depends on the properties of the noise (e.g., the dimension of the Wiener process and the commutativity properties of the diffusion matrix).\n\nOrders stored in qdrift and qdiff are understood as the classical orders of these methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.TableauSISPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.TableauSISPRK","text":"Holds the tableau of a stochastic implicit split partitioned Runge-Kutta method.\n\nqdrift, pdrift1, pdrift2 hold the RK coefficients for the drift parts, and qdiff, pdiff1, pdiff2 hold the RK coefficients for the diffusion part of the SDE.\n\nOrder of the tableau is not included, because unlike in the deterministic setting, it depends on the properties of the noise (e.g., the dimension of the Wiener process and the commutativity properties of the diffusion matrix)\n\nOrders stored in qdrift and qdiff are understood as the classical orders of these methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.TableauWERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.TableauWERK","text":"Holds the tableau of a weak explicit Runge-Kutta method.\n\nReference: Andreas Rossler, \"Second order Runge-Kutta methods for Stratonovich stochastic differential equations\",\nBIT Numerical Mathematics (2007) 47, equation (5.1).\n\nOrder of the tableau is not included, because unlike in the deterministic setting, it depends on the properties of the noise (e.g., the dimension of the Wiener process and the commutativity properties of the diffusion matrix)\n\nOrders stored in qdrift, qdiff are irrelevant and set to 0.\n\nqdrift0, qdrift1, qdrift2 correspond to A0, A1, A2 in the paper qdiff0, qdiff1, qdiff2, qdiff3 correspond to B0, B1, B2, B3 qdrift0.b = alpha qdiff0.b  = beta1 qdiff3.b  = beta2 qdrift0.c = c0 qdrift1.c = c1 qdrift2.c = c2\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.TableauWIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.TableauWIRK","text":"Holds the tableau of a weak implicit Runge-Kutta method.\n\nReference: Wang, Hong, Xu, \"Construction of Symplectic Runge-Kutta Methods for Stochastic Hamiltonian Systems\",\nCommun. Comput. Phys. 21(1), 2017.\n\nOrder of the tableau is not included, because unlike in the deterministic setting, it depends on the properties of the noise (e.g., the dimension of the Wiener process and the commutativity properties of the diffusion matrix)\n\nOrders stored in qdrift and qdiff are understood as the classical orders of these methods.\n\nqdrift0, qdrift1 correspond to A0, A1 in the paper qdiff0, qdiff1, qdiff3 correspond to B0, B1, B3 qdrift0.b = alpha qdiff0.b  = beta qdrift0.c = c0 qdrift1.c = c1\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.compute_stages!-Union{Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{Array{ST,1},1},Array{Array{ST,1},1},Array{Array{ST,2},1},Array{Array{ST,1},1},GeometricIntegrators.Integrators.Stochastic.ParametersSIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M}} where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.compute_stages!","text":"Unpacks the data stored in x = (Y[1][1], Y[1][2], ... Y[1][D], Y[2][1], ...) into Y, calculates the internal stages Q, the values of the RHS of the SDE ( v(Q) and B(Q) ), and assigns them to V and B. Unlike for FIRK, here Y = a v(Q) Δt + â B(Q) ΔW\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.compute_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},AbstractArray{Array{ST,1},2},Array{Array{ST,1},1},Array{Array{ST,2},1},AbstractArray{Array{ST,1},2},GeometricIntegrators.Integrators.Stochastic.ParametersWIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.compute_stages!","text":"Unpacks the data stored in x = (Y0[1][1], Y0[1][2]], ... Y0[1][D], ... Y0[S][D], Y1[1][1,1], Y1[1][2,1], ... Y1[1][D,1], Y1[1][1,2], Y1[1][2,2], ... Y1[1][D,2], ... Y1[S][D,M] ) into Y0 and Y1, calculates the internal stages Q0 and Q1, the values of the RHS of the SDE ( v(Q0) and B(Q1) ), and assigns them to V and B. Unlike for FIRK, here Y = Δt a v(Q) + â B(Q) ΔW.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.compute_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{Array{ST,1},1},Array{Array{ST,1},1},Array{Array{ST,1},1},Array{Array{ST,1},1},Array{Array{ST,2},1},Array{Array{ST,2},1},Array{Array{ST,1},1},Array{Array{ST,1},1},GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.compute_stages!","text":"Unpacks the data stored in x = (Y[1][1], Y[1][2], ... Y[1][D], Y[2][1], ..., Z[1][1], Z[1][2], ... Z[1][D], Z[2][1], ...) into Y, Z, calculates the internal stages Q, P, the values of the RHS of the SDE ( v(Q,P), f(Q,P), B(Q,P) and G(Q,P) ), and assigns them to V, F, B and G. Unlike for FIRK, here Y = Δt a_drift v(Q,P) + a_diff B(Q,P) ΔW, Z = Δt â_drift v(Q,P) + â_diff B(Q,P) ΔW.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.compute_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSISPRK{ST,D,M,S} where S where M where D,GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.compute_stages!","text":"Unpacks the data stored in x = (Y[1][1], Y[1][2], ... Y[1][D], Y[2][1], ..., Z[1][1], Z[1][2], ... Z[1][D], Z[2][1], ...) into Y, Z, calculates the internal stages Q, P, the values of the RHS of the SDE ( vi(Q,P), fi(Q,P), Bi(Q,P) and Gi(Q,P) ), and assigns them to V[i], F[i], B[i] and G[i]. Unlike for FIRK, here Y = Δt a_drift v(Q,P) + a_diff B(Q,P) ΔW, Z = Δt â1_drift f1(Q,P) + Δt â2_drift f2(Q,P) + â1_diff G1(Q,P) ΔW + â2_diff G2(Q,P) ΔW.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.initial_guess!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIPRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIPRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIPRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.initial_guess!","text":"This function computes initial guesses for Y, Z and assigns them to int.solver.x The prediction is calculated using an explicit integrator.\n\nSIMPLE SOLUTION The simplest initial guess for Y, Z is 0: int.solver.x .= zeros(eltype(int), 2*tableau(int).s*ndims(int))\n\nUSING AN EXPLICIT INTEGRATOR TO COMPUTE AN INITIAL GUESS Below we use the R2 method of Burrage & Burrage to calculate the internal stages at the times c[1]...c[s]. This approach seems to give very good approximations if the time step and magnitude of noise are not too large. If the noise intensity is too big, one may have to perform a few iterations of the explicit method with a smaller time step, use a higher-order explicit method (e.g. CL or G5), or use the simple solution above.\n\nWhen calling this function, int.params should contain the data: int.params.q - the q solution at the previous time step int.params.p - the p solution at the previous time step int.params.t - the time of the previous step int.params.ΔW- the increment of the Brownian motion for the current step\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.initial_guess!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.initial_guess!","text":"This function computes initial guesses for Y and assigns them to int.solver.x. The prediction is calculated using an explicit integrator.\n\nSIMPLE SOLUTION The simplest initial guess for Y is 0: int.solver.x .= zeros(eltype(int), tableau(int).s*ndims(int))\n\nUSING AN EXPLICIT INTEGRATOR TO COMPUTE AN INITIAL GUESS Below we use the R2 method of Burrage & Burrage to calculate the internal stages at the times c[1]...c[s]. This approach seems to give very good approximations if the time step and magnitude of noise are not too large. If the noise intensity is too big, one may have to perform a few iterations of the explicit method with a smaller time step, use a higher-order explicit method (e.g. CL or G5), or use the simple solution above.\n\nWhen calling this function, int.params should contain the data: int.params.q  - the solution at the previous time step int.params.t  - the time of the previous step int.params.ΔW - the increment of the Brownian motion for the current step\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.initial_guess!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSISPRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSISPRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSISPRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.initial_guess!","text":"This function computes initial guesses for Y, Z and assigns them to int.solver.x.\n\nFor SISPRK we are NOT IMPLEMENTING an InitialGuess.\n\nSIMPLE SOLUTION The simplest initial guess for Y, Z is 0.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.initial_guess!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorWIRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersWIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorWIRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersWIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWIRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.initial_guess!","text":"This function computes initial guesses for Y and assigns them to int.solver.x For WIRK we are NOT IMPLEMENTING an InitialGuess.\n\nUsing an explicit integrator to predict the next step's value (like in SIRK) does not seem to be a good idea here, because the integrators are convergent in the weak sense only, and there is no guarantee that the explicit integrator will produce anything close to the desired solution...\n\nThe simplest initial guess for Y is 0.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.update_solution!-Union{Tuple{T}, Tuple{AtomicSolutionPSDE{T,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{T,N} where N) where TT<:Real,Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1}}, Tuple{AtomicSolutionPSDE{T,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{T,N} where N) where TT<:Real,Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1}}, Tuple{AtomicSolutionPSDE{T,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{T,N} where N) where TT<:Real,Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1},Array{T,1}}} where T","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.update_solution!","text":"Update solution for stochastic split partitioned Runge-Kutta methods\n\nq, p: the solution vector to be updated\nV, F1, F2: the matrix containing the drift vectors evaluated at the internal stages v(Qi), fi(Qi)\nB, G1, G2: the array containing the diffusion matrices evaluated at the internal stages B(Qi), Gi(Qi)\nbqdrift, bpdrift1, bpdrift2: the Runge-Kutta coefficients for the drift parts of the q and p equations\nbqdiff, bpdiff1, bpdiff2:    the Runge-Kutta coefficients for the diffusion parts of the q and p equations\nΔt: the time step\nΔW: the increments of the Brownian motion\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.update_solution!-Union{Tuple{T}, Tuple{AtomicSolutionPSDE{T,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{T,N} where N) where TT<:Real,Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1}}, Tuple{AtomicSolutionPSDE{T,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{T,N} where N) where TT<:Real,Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1}}, Tuple{AtomicSolutionPSDE{T,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{T,N} where N) where TT<:Real,Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1},Array{T,1}}} where T","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.update_solution!","text":"Update solution for stochastic partitioned Runge-Kutta methods\n\nq, p: the solution vector to be updated\nV, F: the matrix containing the drift vectors evaluated at the internal stages v(Qi), f(Qi)\nB, G: the array containing the diffusion matrices evaluated at the internal stages B(Qi), G(Qi)\nbqdrift, bpdrift: the Runge-Kutta coefficients for the drift parts of the q and p equations\nbqdiff, bpdiff:   the Runge-Kutta coefficients for the diffusion parts of the q and p equations\nΔt: the time step\nΔW: the increments of the Brownian motion\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.update_solution!-Union{Tuple{T}, Tuple{AtomicSolutionSDE{T,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{T,N} where N) where TT<:Real,Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1}}, Tuple{AtomicSolutionSDE{T,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{T,N} where N) where TT<:Real,Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1}}} where T","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.update_solution!","text":"Update solution for weak Runge-Kutta methods WERK\n\nx:  the solution vector to be updated\nV:  the matrix containing the drift vector evaluated at the internal stages v(Q_i)\nB1: the array containing the diffusion matrix evaluated at the internal stages H^(l)i, such that B1[:,l,i] is evaluated at H^(l)i\nB2: the array containing the diffusion matrix evaluated at the internal stages Ĥ^(l)i, such that B2[:,l,i] is evaluated at Ĥ^(l)i\nα:  the Runge-Kutta coefficients for the drift part\nβ1: the Runge-Kutta coefficients for the diffusion term with the random increments\nβ2: the Runge-Kutta coefficients for the second diffusion term\nΔt: the time step\nΔW: the increments of the Brownian motion represented by the random variables Î^(k)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.update_solution!-Union{Tuple{T}, Tuple{AtomicSolutionSDE{T,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{T,N} where N) where TT<:Real,Array{Array{T,1},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1}}, Tuple{AtomicSolutionSDE{T,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{T,N} where N) where TT<:Real,Array{Array{T,1},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1},Array{T,1}}} where T","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.update_solution!","text":"Update solution for stochastic Runge-Kutta methods (SERK)\n\nx: the solution vector to be updated\nV: the matrix containing the drift vector evaluated at the internal stages v(Q_i)\nB: the array containing the diffusion matrix evaluated at the internal stages B(Q_i)\nbdrift: the Runge-Kutta coefficients for the drift part\nbdiff:  the Runge-Kutta coefficients for the ΔW terms of the diffusion part\nbdiff2: the Runge-Kutta coefficients for the ΔZ terms of the diffusion part\nΔt: the time step\nΔW: the increments of the Brownian motion\nΔZ: the integrals of the increments of the Brownian motion\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.update_solution!-Union{Tuple{T}, Tuple{AtomicSolutionSDE{T,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{T,N} where N) where TT<:Real,Array{Array{T,1},1},Array{Array{T,2},1},Array{T,1},Array{T,1},T,Array{T,1}}, Tuple{AtomicSolutionSDE{T,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{T,N} where N) where TT<:Real,Array{Array{T,1},1},Array{Array{T,2},1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1}}} where T","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.update_solution!","text":"Update solution for stochastic Runge-Kutta methods (SIRK and WIRK)\n\nx: the solution vector to be updated\nV: the matrix containing the drift vector evaluated at the internal stages v(Qi) (SIRK) or v(Q0i) (WIRK)\nB: the array containing the diffusion matrix evaluated at the internal stages B(Qi) (SIRK) or B(Q1^(l)i) (WIRK)\nbdrift: the Runge-Kutta coefficients for the drift part\nbdiff:  the Runge-Kutta coefficients for the diffusion part\nΔt: the time step\nΔW: the increments of the Brownian motion (SFIRK) or the increments represented by the random variables Î^(k) (WFIRK)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.Stochastic.ParametersSIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of stochastic implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of stochastic implicit split partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.Stochastic.ParametersWIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of weak implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSERK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D,AtomicSolutionSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSERK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D,AtomicSolutionSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSERK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate SDE with explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIPRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIPRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIPRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate PSDE with a stochastic implicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate SDE with a stochastic implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSISPRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSISPRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSISPRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate PSDE with a stochastic implicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorWERK{DT,TT,D,M,S,ET} where ET where S where M where D,AtomicSolutionSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorWERK{DT,TT,D,M,S,ET} where ET where S where M where D,AtomicSolutionSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWERK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate SDE with explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorWIRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersWIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N)}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorWIRK{DT,TT,D,M,S,PT,ST} where ST<:SimpleSolvers.NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersWIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT,AT,IT} where IT<:NamedTuple where AT<:(AbstractArray{DT,N} where N),GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWIRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate SDE with a stochastic implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"integrators/dgvi/#Discontinuous-Galerkin-Variational-Integrators","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Discontinuous Galerkin Variational Integrators (DGVIs) are a family of integrators for degenerate Lagrangian systems and for Hamiltonian systems subject to Dirac constraints. For integrators for non-degenerate (regular) Lagrangian and unconstrained Hamiltonian systems see Hamilton-Pontryagin-Galerkin (HPG) Integrators.","category":"page"},{"location":"integrators/dgvi/#Degenerate-Lagrangian-Systems","page":"Discontinuous Galerkin Variational Integrators","title":"Degenerate Lagrangian Systems","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Consider a fully degenerate Lagrangian system of the form","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"L(q dotq) = vartheta (q) cdot dotq - H(q) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where vartheta (q) denotes the Cartan one-form and H(q) the Hamiltonian, that is usually given by the total energy of the system.","category":"page"},{"location":"integrators/dgvi/#Discrete-Trajectories-and-Numerical-Quadrature","page":"Discontinuous Galerkin Variational Integrators","title":"Discrete Trajectories and Numerical Quadrature","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The first step in the derivation of variational integrators is the discretization of the action integral","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q = int limits_0^T L(q(t) dotq(t))  dt ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"To this end, the interval 0T is split into N sub-intervals t_n t_n+1 with t_n = nh and h the time step size, so that t_N = T and the action can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q = sum limits_n=0^N-1 int limits_t_n t_n+1 L(q(t) dotq(t))  dt ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Within each interval (t_n t_n+1) a piecewise-polynomial approximation q_h of the trajectory q is constructed using S basis functions varphi_i,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_h(t) vert_(t_n t_n+1) = sum limits_i=1^S x_ni  barvarphi_ni (t) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where barvarphi_ni (t) is a rescaled basis function, defined by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"barvarphi_ni (t) = varphi_i bigg( fract - t_nt_n+1 - t_n bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and it is assumed that varphi_i is compactly supported on 01. These approximations q_h(t) do not need to be continuous across interval boundaries but are indeed allowed to have jumps. Replacing the continuous trajectory q in the action with q_h, we obtain","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q_h = sum limits_n=0^N-1 int limits_(t_n t_n+1) big vartheta (q_h (t)) cdot dotq_h (t) - H(q_h (t)) big  dt\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n  ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The integral of the Hamiltonian H(q_h) over the interval boundaries does not contribute to the integral, differently from the term vartheta (q_h) cdot dotq_h, which will determine the numerical flux  cdot _n at t_n of the Discontinuous Galerkin method. The approximation of this term will be discussed below. In order to obtain a fully discrete action, a numerical quadrature rule with R nodes c_i and weights b_i is introduced for the approximation of the integral,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (q_h(t_n + c_i h)) cdot dotq_h (t_n + c_i h) - H(q_h(t_n + c_i h)) big\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Here, x_d denotes the vector of all the degrees of freedom, i.e.,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"x_d = ( x_01  x_0S  x_11  x_N-2S  x_N-11  x_N-1S )^T ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In order to write the discrete action in a more explicit form, mass and derivative matrices m and a are introduced, whose elements are given by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"m_ij = varphi_j (c_i) \nqquad\na_ij = varphi_j (c_i) \nqquad\ni = 1  R \n\nj = 1  S ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"so that the solution and its time derivative at the quadrature points can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Q_ni equiv q_h(t_n + c_i h) = m_ij x_nj \nqquad\nV_ni equiv dotq_h (t_n + c_i h) = a_ij x_nj ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"x_n = ( x_n1  x_nS )^T","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"is the vector containing the degrees of freedom of q_h vert_t_n t_n+1. Using these definitions, the discrete action can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n ","category":"page"},{"location":"integrators/dgvi/#Numerical-Fluxes","page":"Discontinuous Galerkin Variational Integrators","title":"Numerical Fluxes","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In the following, the solution values \"left\" and \"right\" of the jump will be needed. This will be denoted by q_n^- and q_n^+, respectively. Usually, these just correspond to the polynomials on the left and right, evaluated at t_n, i.e.,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_n^- = lim_t uparrow t_n q_h (t) = q_h vert_t_n-1 t_n (t_n) \nqquad\nq_n^+ = lim_t downarrow t_n q_h (t) = q_h vert_t_n t_n+1 (t_n) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In principle, however, more general reconstructions of the solution could be used. In the following, it will be assumed, that q_n^- is given by some linear combinations of the degrees of freedom of the polynomial on the left interval and correspondingly that q_n^+ is given by some linear combinations of the degrees of freedom of the polynomial on the right interval, specifically","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_n^- = r^- cdot x_n \nqquad\nq_n^+ = r^+ cdot x_n+1 ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where r^pm are appropriate coefficient vectors.","category":"page"},{"location":"integrators/dgvi/#Gauge-Terms","page":"Discontinuous Galerkin Variational Integrators","title":"Gauge Terms","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The Lagrangian L can be augmented with any total time derivative without changing the (continuous) Euler-Lagrange equations. In particular, one can consider the modified Lagrangian","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"L(q dotq) = vartheta (q) cdot dotq - H(q) - nu dfracddt bigg( vartheta (q) cdot q bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"While this gauge term vanishes in the continuous case, it takes a finite value across jumps of the discontinuous discrete solution, so that the modified discrete action reads","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big\n+ sum limits_n=1^N-1 biggbigg vartheta (q_h (t)) cdot dotq_h (t) - nu dfracddt bigg( vartheta (q) cdot q bigg) biggbigg_t=t_n ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In the following, only the modified Lagrangian and action will be considered, in order to obtain a sufficiently general framework for constructing numerical fluxes. For brevity of notation, the prime will be dropped.","category":"page"},{"location":"integrators/dgvi/#Total-Time-Derivatives-Across-Jumps","page":"Discontinuous Galerkin Variational Integrators","title":"Total Time Derivatives Across Jumps","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The computation of the total time derivative in the gauge term is simple, at least in the distributional sense. Even though both, vartheta (q_h) and q_h have a jump, the jump occurs at the same position in time, so that the derivative can be computed as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"dfracddt bigg( vartheta (q_h) cdot q_h bigg) biggvert_t=t_n\n= dfracddt bigg( vartheta (q_n^-) cdot q_n^-  Theta (t_n - t) + vartheta (q_n^+) cdot q_n^+  Theta (t - t_n) bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where Theta denotes the Heaviside function. This can be explicitly computed as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"dfracddt bigg( vartheta (q_h) cdot q_h bigg) biggvert_t=t_n\n= - vartheta (q_n^-) cdot q_n^-  delta (t_n) + vartheta (q_n^+) cdot q_n^+  delta (t_n)\n=  vartheta (q_h) cdot q_h _t=t_n  delta (t_n) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"with delta (t_n) the Dirac delta-function at t_n.","category":"page"},{"location":"integrators/dgvi/#Non-conservative-Products","page":"Discontinuous Galerkin Variational Integrators","title":"Non-conservative Products","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Simple means for integrating the Lagrangian across jumps are provided by discretisations of the integral","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"int limits_0^1 vartheta (Phi(tau q^- q^+)) cdot dfracd Phi(tau q^- q^+)dtau  dtau ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where Phi is a path connecting the solution values q^- and q^+ on the left and the right of the jump. Upon picking a quadrature rule with sigma nodes gamma_i and corresponding weights beta_i, the discrete product takes the form","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"sum limits_i=1^sigma beta_i  vartheta big( Phi (gamma_i q_n^-  q_n^+) big) cdot dfracdPhidtau (gamma_i q_n^-  q_n^+) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"For a compact notation, \"mass\" and \"derivative\" vectors mu^pm and alpha^pm are introduced, so that","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Phi (gamma_i q_n^-  q_n^+) = mu^-_i q_n^- + mu^+_i q_n^+\nqquad\nPhi (gamma_i q_n^-  q_n^+) = alpha^-_i q_n^- + alpha^+_i q_n^+ ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and the discrete product can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"sum limits_i=1^sigma beta_i  vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Providing the path Phi by two functions phi^pm(tau), so that","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"phi(tau q^- q^+) = q^- phi^-(tau) + q^+ phi^+(tau) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"the components of the \"mass\" and \"derivative\" vectors are given by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mu^-_i = phi^- (gamma_i) \nqquad\nmu^+_i = phi^+ (gamma_i) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"alpha^-_i = fracdphi^-dtau (gamma_i) \nqquad\nalpha^+_i = fracdphi^+dtau (gamma_i) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"respectively.","category":"page"},{"location":"integrators/dgvi/#Discrete-Variational-Principle","page":"Discontinuous Galerkin Variational Integrators","title":"Discrete Variational Principle","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Using the construction of the previous sections, the discrete action reads","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma beta_i  vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ )\n- nu big vartheta (q_n^+) cdot q_n^+ - vartheta (q_n^-) cdot q_n^- big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The discrete Euler-Lagrange equations are obtained by applying Hamilton's principle of stationary action to mathcalA_d x_d, that is requiring that delta mathcalA_d x_d = 0. The variations of the discrete action are computed as follows,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta mathcalA_d x_d\n= h sum limits_n=0^N-1 sum limits_i=1^R b_i big delta Q_ni cdot nabla vartheta (Q_ni) cdot V_ni + vartheta (Q_ni) cdot delta V_ni - delta Q_ni cdot nabla H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma beta_i  big ( mu^-_i delta q_n^- + mu^+_i delta q_n^+ ) cdot nabla vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) + vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i delta q_n^- + alpha^+_i delta q_n^+ ) big \n- nu big delta q_n^+ cdot nabla vartheta (q_n^+) cdot q_n^+  + vartheta (q_n^+) cdot delta q_n^+ - delta q_n^- cdot nabla vartheta (q_n^-) cdot q_n^- - vartheta (q_n^-) cdot delta q_n^- big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Using the relations","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta Q_ni = m_ij delta x_nj \nqquad\ndelta V_ni = fraca_ijh delta x_nj \nqquad\ndelta q_n^- = r^-_j delta x_n-1j \nqquad\ndelta q_n^+ = r^+_j delta x_nj ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"the variations of the discrete action become","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta mathcalA_d x_d\n= sum limits_n=0^N-1 sum limits_i=1^R sum limits_j=1^S b_i big h m_ij delta x_nj cdot nabla vartheta (Q_ni) cdot V_ni + vartheta (Q_ni) cdot a_ij delta x_nj - h m_ij delta x_nj cdot nabla H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma sum limits_j=1^S beta_i  big ( mu^-_i r^-_j delta x_n-1j + mu^+_i r^+_j delta x_nj ) cdot nabla vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) + vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i r^-_j delta x_n-1j + alpha^+_i r^+_j delta x_nj ) big \n- nu big r^+_j delta x_nj cdot nabla vartheta (q_n^+) cdot q_n^+  + vartheta (q_n^+) cdot r^+_j delta x_nj - r^-_j delta x_n-1j cdot nabla vartheta (q_n^-) cdot q_n^- - vartheta (q_n^-) cdot r^-_j delta x_n-1j big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Requiring the variation of the discrete action to vanish yields the discrete equations of motion,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"0 = sum limits_i=1^R b_i big h m_ij nabla vartheta (Q_ni) cdot V_ni + a_ij vartheta (Q_ni) - h m_ij nabla H(Q_ni) big \n+ bigg sum limits_i=1^sigma beta_i  big\n   mu^-_i r^-_j nabla vartheta ( mu^-_i q_n+1^- + mu^+_i q_n+1^+ ) cdot ( alpha^-_i q_n+1^- + alpha^+_i q_n+1^+ )\n + mu^+_i r^+_j nabla vartheta ( mu^-_i q_n  ^- + mu^+_i q_n  ^+ ) cdot ( alpha^-_i q_n  ^- + alpha^+_i q_n  ^+ ) \n + vartheta ( mu^-_i q_n+1^- + mu^+_i q_n+1^+ ) alpha^-_i r^-_j\n + vartheta ( mu^-_i q_n  ^- + mu^+_i q_n  ^+ ) alpha^+_i r^+_j\n   big \n - nu big\n     r^+_j nabla vartheta (q_n  ^+) cdot q_n  ^+ + r^+_j vartheta (q_n  ^+)\n   - r^-_j nabla vartheta (q_n+1^-) cdot q_n+1^- - r^-_j vartheta (q_n+1^-)\n   big\n bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"for all n and all j.","category":"page"},{"location":"modules/solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"modules/solutions/","page":"Solutions","title":"Solutions","text":"Modules = [GeometricIntegrators.Solutions]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Abstract atomistic or single-step solution.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{AbstractEquationDAE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{AbstractEquationODE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{AbstractEquationPDAE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{AbstractEquationPODE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{Equation}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Print error for AtomicSolutions of equations not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionDAE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionODE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionPDAE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{SolutionPODE}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{Solution}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Print error for AtomicSolutions of solution not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{AbstractEquationPSDE{DT,TT}}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned SDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{AbstractEquationSDE{DT,TT}}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for SDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{SolutionPSDE{AT,TT,wType,NQ,NW,CONV} where CONV where NW where NQ where wType}, Tuple{AT}, Tuple{TT}, Tuple{DT}} where AT<:(AbstractArray{DT,N} where N) where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned SDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{SolutionSDE{AT,TT,wType,NQ,NW,CONV} where CONV where NW where NQ where wType}, Tuple{AT}, Tuple{TT}, Tuple{DT}} where AT<:(AbstractArray{DT,N} where N) where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for SDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionDAE","text":"Atomic solution for an DAE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\nλ: current solution of λ\nλ̅: previous solution of λ\nv: vector field of q\nv̅: vector field of q̅\nu: projective vector field of q\nu̅: projective vector field of q̅\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionODE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionODE","text":"Atomic solution for an ODE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\nv: vector field of q\nv̅: vector field of q̅\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionPDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionPDAE","text":"Atomic solution for an PDAE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\np: current solution of p\np̅: previous solution of p\np̃: compensated summation error of p\nλ: current solution of λ\nλ̅: previous solution of λ\nv: vector field of q\nv̅: vector field of q̅\nf: vector field of p\nf̅: vector field of p̅\nu: projective vector field of q\nu̅: projective vector field of q̅\ng: projective vector field of p\ng̅: projective vector field of p̅\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionPODE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionPODE","text":"Atomic solution for an PODE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\np: current solution of p\np̅: previous solution of p\np̃: compensated summation error of p\nv: vector field of q\nv̅: vector field of q̅\nf: vector field of p\nf̅: vector field of p̅\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionPSDE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionPSDE","text":"Atomic solution for an SDE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\np: current solution of p\np̅: previous solution of p\np̃: compensated summation error of p\nΔW: Wiener process driving the stochastic process q\nΔZ: Wiener process driving the stochastic process q\nK:  integer parameter defining the truncation of the increments of the Wiener process (for strong solutions)\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionSDE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionSDE","text":"Atomic solution for an SDE.\n\nParameters\n\nDT: data type\nTT: time step type\nAT: array type\nIT: internal variable types\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\nΔW: Wiener process driving the stochastic process q\nΔZ: Wiener process driving the stochastic process q\nK:  integer parameter defining the truncation of the increments of the Wiener process (for strong solutions)\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{AbstractEquationDAE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{AbstractEquationODE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{AbstractEquationPDAE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{AbstractEquationPODE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{Equation,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Print error for solutions of equations not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{SDE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for SDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{Union{PSDE, SPSDE},Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for PSDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionDAE","text":"SolutionDAE: Solution of a differential algebraic equation\n\nContains all fields necessary to store the solution of an DAE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnm: dimension of the constraint submanifold\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\nλ:  Lagrange multiplier λ[nd, nt+1, ni]\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionODE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionODE","text":"SolutionODE: Solution of an ordinary differential equation\n\nContains all fields necessary to store the solution of an ODE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionPDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionPDAE","text":"SolutionPDAE: Solution of a partitioned differential algebraic equation\n\nContains all fields necessary to store the solution of an PDAE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnm: dimension of the constraint submanifold\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\np:  solution p[nd, nt+1, ni] with p[:,0,:] the initial conditions\nλ:  Lagrange multiplier λ[nd, nt+1, ni]\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionPODE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionPODE","text":"SolutionPODE: Solution of a partitioned ordinary differential equation\n\nContains all fields necessary to store the solution of an PODE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\np:  solution p[nd, nt+1, ni] with p[:,0,:] the initial conditions\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionPSDE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionPSDE","text":"SolutionPSDE: Solution of a partitioned stochastic differential equation\n\nContains all fields necessary to store the solution of a PSDE or SPSDE\n\nFields\n\nconv: type of the solution: :strong or :weak\nnd: dimension of the dynamical variable q\nnm: dimension of the Wiener process\nnt: number of time steps to store\nns: number of sample paths\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ns, ni] with q[:,0,:,:] the initial conditions\np:  solution p[nd, nt+1, ns, ni] with p[:,0,:,:] the initial conditions\nW:  Wiener process driving the stochastic processes q and p\nK:  integer parameter defining the truncation of the increments of the Wiener process (for strong solutions),\n  A = √(2 K Δt |log Δt|) due to Milstein & Tretyakov; if K=0 no truncation\nntime: number of time steps to compute\nnsave: save every nsave'th time step\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionSDE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionSDE","text":"SolutionSDE: Solution of a stochastic differential equation\n\nContains all fields necessary to store the solution of an SDE.\n\nFields\n\nconv: type of the solution: :strong or :weak\nnd: dimension of the dynamical variable q\nnm: dimension of the Wiener process\nnt: number of time steps to store\nns: number of sample paths\nt:  time steps\nq:  solution q[nd, nt+1, ns] with q[:,0,:] the initial conditions\nW:  Wiener process driving the stochastic process q\nK:  integer parameter defining the truncation of the increments of the Wiener process (for strong solutions),\n  A = √(2 K Δt |log Δt|) due to Milstein & Tretyakov; if K=0 no truncation\nntime: number of time steps to compute\nnsave: save every nsave'th time step\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.WienerProcess","page":"Solutions","title":"GeometricIntegrators.Solutions.WienerProcess","text":"Type for holding the increments of a Wiener process\n\nFields:\n\nnd: dimension of the Wiener process\nnt: number of increments in the DataSeries\nns: number of sample paths of the Wiener process\nΔt: time increment of the TimeSeries\nΔW: variable storing the increments of the Wiener process over Δt, or the discrete random variable \\hat{I}\nΔZ: variable holding the time integral of the Wiener process \\int_{tk}^{tk+1} (W(t)-W(tk))dt, or the discrete random variable \\tilde{I}\n\nParameters:\n\ndType: type of the elements of the increments of the Wiener process\ntType: type of the time steps\nN:     the number of dimensions of the arrays holding data in ΔW and ΔZ\nCONV:  mode of convergence: :strong or :weak\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Common.write_to_hdf5","page":"Solutions","title":"GeometricIntegrators.Common.write_to_hdf5","text":"Append solution to HDF5 file.\n\n\n\n\n\n","category":"function"},{"location":"modules/solutions/#GeometricIntegrators.Common.write_to_hdf5-2","page":"Solutions","title":"GeometricIntegrators.Common.write_to_hdf5","text":"Append solution to HDF5 file.\n\n\n\n\n\n","category":"function"},{"location":"modules/solutions/#GeometricIntegrators.Common.write_to_hdf5-3","page":"Solutions","title":"GeometricIntegrators.Common.write_to_hdf5","text":"Append solution to HDF5 file.   soffset - start writing the solution q at the position soffset+2   woffset - start writing the increments ΔW, ΔZ at the position woffset+1\n\n\n\n\n\n","category":"function"},{"location":"modules/solutions/#GeometricIntegrators.Common.write_to_hdf5-Tuple{Solution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Common.write_to_hdf5","text":"Creates HDF5 file, writes solution to file, and closes file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Common.write_to_hdf5-Tuple{Solution}","page":"Solutions","title":"GeometricIntegrators.Common.write_to_hdf5","text":"writetohdf5: Wrapper for saving Solution to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{AbstractEquationDAE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{AbstractEquationODE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{AbstractEquationPDAE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{AbstractEquationPODE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{Equation,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Print error for parallel solutions of equations not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{SDE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for SDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{Union{PSDE, SPSDE},Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for PSDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.copy_solution!-Tuple{Solution,AtomicSolution,Any,Any}","page":"Solutions","title":"GeometricIntegrators.Solutions.copy_solution!","text":"Copy solution from atomistic solution to solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.createHDF5-Tuple{Solution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.createHDF5","text":"createHDF5: Creates or opens HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.create_hdf5!-Tuple{Solution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.create_hdf5!","text":"Creates HDF5 file and initialises datasets for solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.create_hdf5-Tuple{DeterministicSolution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.create_hdf5","text":"Creates HDF5 file and initialises datasets for deterministic solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.create_hdf5-Tuple{StochasticSolution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.create_hdf5","text":"Creates HDF5 file and initialises datasets for stochastic solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.save_attributes-Tuple{DeterministicSolution,HDF5.File}","page":"Solutions","title":"GeometricIntegrators.Solutions.save_attributes","text":"save_attributes: Saves attributes of Deterministic Solutions to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.save_attributes-Tuple{Solution}","page":"Solutions","title":"GeometricIntegrators.Solutions.save_attributes","text":"save_attributes: Saves common attributes of Solution to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.save_attributes-Tuple{StochasticSolution,HDF5.File}","page":"Solutions","title":"GeometricIntegrators.Solutions.save_attributes","text":"save_attributes: Saves attributes of Stochastic Solutions to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solvers_linear/#Linear-Solvers","page":"Linear Solvers","title":"Linear Solvers","text":"","category":"section"},{"location":"modules/solvers_linear/","page":"Linear Solvers","title":"Linear Solvers","text":"Modules = [GeometricIntegrators.Solvers]\nPages   = [\"solvers/linear/linear_solvers.jl\",\n           \"solvers/linear/lu_solver.jl\",\n           \"solvers/linear/lu_solver_lapack.jl\"]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/discontinuities/#Discontinuities","page":"Discontinuities","title":"Discontinuities","text":"","category":"section"},{"location":"modules/discontinuities/","page":"Discontinuities","title":"Discontinuities","text":"Modules = [GeometricIntegrators.Discontinuities]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/discontinuities/#GeometricIntegrators.Discontinuities.PathIntegralLinear","page":"Discontinuities","title":"GeometricIntegrators.Discontinuities.PathIntegralLinear","text":"PathIntegralLinear is a path integral along a linear path\n\nphi (tau q^- q^+) = (1-tau) q^- + tau q^+ \n\n\n\n\n\n","category":"type"},{"location":"modules/discontinuities/#GeometricIntegrators.Discontinuities.PathIntegralTrigonometric","page":"Discontinuities","title":"GeometricIntegrators.Discontinuities.PathIntegralTrigonometric","text":"PathIntegralTrigonometric is a path integral along a cos^2/sin^2 path\n\nphi (tau q^- q^+) = cos^2 (pi tau  2) q^- + sin^2 (pi tau  2) q^+ \n\n\n\n\n\n","category":"type"},{"location":"integrators/stochastic/#Stochastic-Integrators","page":"Stochastic","title":"Stochastic Integrators","text":"","category":"section"},{"location":"modules/interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"modules/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [GeometricIntegrators.Interpolation]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/interpolation/#GeometricIntegrators.Interpolation.HermiteInterpolation","page":"Interpolation","title":"GeometricIntegrators.Interpolation.HermiteInterpolation","text":"Hermite's Interpolating Polynomials\n\nHere, we implement a two point Hermite interpolation function which passes through the function and its first derivative for the interval 01. The polynomial is determined by four constraint equations, matching the function and its derivative at the points 0 and 1.\n\nStart by defining the 3rd degree polynomial and its derivative by\n\nbeginaligned\ng(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3  \ng(x) = a_1 + 2 a_2 x + 3 a_3 x^2 \nendaligned\n\nand apply the constraints\n\nbeginaligned\ng(0) = f_0   Rightarrow  a_0 = f_0  \ng(1) = f_1   Rightarrow  a_0 + a_1 + a_2 + a_3 = f_1  \ng(0) = f_0   Rightarrow  a_1 = f_0  \ng(1) = f_1   Rightarrow  a_1 + 2 a_2 + 3 a_3 = f_1  \nendaligned\n\nSolving for a_0 a_1 a_2 a_3 leads to\n\nbeginaligned\na_0 = f_0  \na_1 = f_0  \na_2 = - 3 f_0 + 3 f_1 - 2 f_0 - f_1  \na_3 = 2 f_0 - 2 f_1 + f_0 + f_1 \nendaligned\n\nso that the polynomial g(x) reads\n\ng(x) = f_0 + f_0 x + (- 3 f_0 + 3 f_1 - 2 f_0 - f_1) x^2 + (2 f_0 - 2 f_1 + f_0 + f_1) x^3 \n\nThe function and derivative values can be factored out, so that g(x) can be rewritten as\n\ng(x) = f_0 (1 - 3 x^2 + 2 x^3) + f_1 (3 x^2 - 2 x^3) + f_0 (x - 2 x^2 + x^3) + f_1 (- x^2 + x^3) \n\nor in generic form as\n\ng(x) = f_0 a_0(x) + f_1 a_1(x) + f_0 b_0(x) + f_1 b_1(x) \n\nwith basis functions\n\nbeginaligned\na_0 (x) = 1 - 3 x^2 + 2 x^3  \nb_0 (x) = x - 2 x^2 + x^3  \na_1 (x) = 3 x^2 - 2 x^3  \nb_1 (x) = - x^2 + x^3 \nendaligned\n\nThe derivative g(x) accordingly reads\n\ng(x) = f_0 a_0(x) + f_1 a_1(x) + f_0 b_0(x) + f_1 b_1(x) \n\nwith\n\nbeginaligned\na_0 (x) = - 6 x + 6 x^2  \nb_0 (x) = 1 - 4 x + 3 x^2  \na_1 (x) = 6 x - 6 x^2  \nb_1 (x) = - 2 x + 3 x^2 \nendaligned\n\nThe basis functions a_0and a_1 are associated with the function values at x_0 and x_1, respectively, while the basis functions b_0 and b_1 are associated with the derivative values at x_0 and x_1. The basis functions satisfy the following relations,\n\nbeginaligned\na_i (x_j) = delta_ij  \nb_i (x_j) = 0  \na_i (x_j) = 0  \nb_i (x_j) = delta_ij  \nij = 0 1 \nendaligned\n\nwhere delta_ij denotes the Kronecker-delta, so that\n\nbeginaligned\ng(0) = f_0  \ng(1) = f_1  \ng(0) = f_0  \ng(1) = f_1 \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/#Modules","page":"Modules","title":"Modules","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Pages = [\"modules/basis_functions.md\",\n         \"modules/quadratures.md\",\n         \"modules/discontinuities.md\",\n         \"modules/equations.md\",\n         \"modules/solutions.md\",\n         \"modules/integrators.md\",\n         \"modules/integrators_stochastic.md\",\n         \"modules/integrators_spark.md\",\n         \"modules/integrators_vprk.md\",\n         \"modules/interpolation.md\",\n         \"modules/solvers_linear.md\",\n         \"modules/solvers_nonlinear.md\",\n         \"modules/simulations.md\",\n         \"modules/tableaus.md\"]\nDepth = 3","category":"page"},{"location":"releasenotes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"releasenotes/#.7.0","page":"Release Notes","title":"0.7.0","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"use CompactBasisFunctions.jl instead of BasisFunctions submodule\nuse QuadratureRules.jl instead of Quadratures submodule\nUse SimpleSolvers.jl instead of Solvers submodule\nUse GeometricProblems.jl instead of TestProblems submodule","category":"page"},{"location":"releasenotes/#.6.2","page":"Release Notes","title":"0.6.2","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bugfix release","category":"page"},{"location":"releasenotes/#.6.1","page":"Release Notes","title":"0.6.1","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bugfix release","category":"page"},{"location":"releasenotes/#.6.0","page":"Release Notes","title":"0.6.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Revise tableaus: align constructor names with RungeKutta.jl","category":"page"},{"location":"releasenotes/#New-Features","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Add new Runge-Kutta tableaus\nGeneralise Lobatto and Radau tableaus to arbitrary number of stages\nExtend documentation on integrators and tableaus","category":"page"},{"location":"releasenotes/#.5.1","page":"Release Notes","title":"0.5.1","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Update documentation\nFix HDF5 v0.14 deprecations","category":"page"},{"location":"releasenotes/#.5.0","page":"Release Notes","title":"0.5.0","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Moved repository to JuliaGNI\nMoved CI from Travis to GitHub","category":"page"},{"location":"releasenotes/#Breaking-Changes-2","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Functions for initial guesses are now called v̄ and f̄ and can be prescribed separately from v and f in PDAE, HDAE, etc.\nRename SPARK tableau constructors and unify distinct constructors for Lobatto tableaus with different number of stages","category":"page"},{"location":"releasenotes/#New-Features-2","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Implement SPARK integrator for index-two DAEs\nImplement infrastructure for storing internal variables and solver output to atomic solutions\nStore internal variables of SPARK and VPRK integrators in atomic solution\nAdd various five-stage Lobatto tableaus\nAdd and clean up SPARK tableaus and add docstrings\nAdd functions for checking symplecticity conditions of SPARK tableaus\nAdd Aqua.jl tests","category":"page"},{"location":"releasenotes/#Fixes","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Fix initial guess warnings in tests by prescribing proper functions for v̄ and f̄ in example problems\nFix update_multiplier() method for SPARK integrators","category":"page"},{"location":"releasenotes/#.4.1","page":"Release Notes","title":"0.4.1","text":"","category":"section"},{"location":"releasenotes/#New-Features-3","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Atomic solutions can now store a NamedTuple of internal variables of the integrator, including nonlinear solver output\nOutput of internal variables has been added to VPRK integrators\nAdd Gauss-Legendre tableaus for implicit partitioned Runge-Kutta methods","category":"page"},{"location":"releasenotes/#Fixes-2","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Revision of integrator type hierarchy","category":"page"},{"location":"releasenotes/#.4.0","page":"Release Notes","title":"0.4.0","text":"","category":"section"},{"location":"releasenotes/#New-Integrators","page":"Release Notes","title":"New Integrators","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Runge-Kutta integrators for implicit ODEs (FIRKimplicit and SRKimplicit)\nVariational Partitioned Runge-Kutta integrator with projection based on internal stages","category":"page"},{"location":"releasenotes/#Fixes-3","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Computation of initial guess in all implicit integrators","category":"page"},{"location":"integrators/hpg/#Hamilton-Pontryagin-Galerkin-Integrators","page":"Hamilton-Pontryagin-Galerkin Integrators","title":"Hamilton-Pontryagin-Galerkin Integrators","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = GeometricIntegrators","category":"page"},{"location":"tutorial/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we try to give an overview of the basic usage of GeometricIntegrators and its main components.","category":"page"},{"location":"tutorial/tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"GeometricIntegrators.jl can be installed using Julia's built-in package manager in the command line interface by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ]\n(v1.5) pkg> add GeometricIntegrators","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In a Jupyter notebook, GeometricIntegrators.jl can be installed by explicitly using the Pkg module as","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg\nPkg.add(\"GeometricIntegrators\")","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"This will install the library itself as well as all dependencies.","category":"page"},{"location":"tutorial/tutorial/#Basic-usage","page":"Tutorial","title":"Basic usage","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In the simplest cases, the use of GeometricIntegrators.jl requires the construction of two objects, an equation and an integrator. For many standard methods, the integrator is implicitly selected by specifying an equation and a tableau.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Before any use, we need to load GeometricIntegrators,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeometricIntegrators","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Then we can create an ODE object for the equation dotx (t) = x(t) with initial condition x(0) = 1,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ode = ODE((t, x, ẋ) -> ẋ[1] = x[1], [1.0]);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"create an integrator for this ODE, using the tableau for the explicit Euler method and a time step of Delta t = 01,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(ode, TableauExplicitEuler(), 0.1);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"and compute the solution for n_t = 10 time steps,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = integrate(ode, int, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Plot and compare with the exact solution","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplot(xlims=[0,1], xlab=\"t\", ylab=\"x(t)\", legend=:bottomright)\nplot!(sol.t, sol.q[1,:], label=\"numeric\")\nplot!(sol.t, exp.(sol.t), label=\"exact\")","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Error: BoundsError: attempt to access 11-element OffsetArray(::Array{Float6\n4,1}, 0:10) with eltype Float64 with indices 0:10 at index [0:11]","category":"page"},{"location":"tutorial/tutorial/#Equations","page":"Tutorial","title":"Equations","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In GeometricIntegrators.jl we distinguish between three basic types of equations:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ordinary differential equations (ODEs),\ndifferential algebraic equations (DAEs),\nstochastic differential equations (SDEs).","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"For each type, there are several subtypes","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\"normal\" equations (ODE, DAE, SDE),\nimplicit equations (IODE, IDAE),\nvariational equations (VODE, VDAE),\nHamiltonian equations (HODE, HDAE),\npartitioned equations (PODE, PDAE, PSDE),\nsplit equations (SODE, SPDAE).","category":"page"},{"location":"tutorial/tutorial/#Ordinary-differential-equations","page":"Tutorial","title":"Ordinary differential equations","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Consider an ODE of the form","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"dotx (t) = f(t x(t)) ","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"where dotx denotes the derivative of x and f the vector field of the equation, which is assumed to depend on both t and x. In the following, we will solve the mathematical pendulum, whose equations are given by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"beginpmatrix\ndotx_1 \ndotx_2 \nendpmatrix\n=\nbeginpmatrix\nx_2 \nsin (x_1) \nendpmatrix ","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Creating an ODE object requires the prescription of a function that computes the vector field f, e.g.,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"function ẋ(t, x, v)\n    v[1] = x[2]\n    v[2] = sin(x[1])\nend","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ẋ (generic function with 1 method)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"which has to take three arguments, the current time t, the current solution vector x and the output vector f. Moreover, we need a set of initial conditions,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"x₀ = [acos(0.4), 0.0]","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"2-element Array{Float64,1}:\n 1.1592794807274085\n 0.0","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"An ODE object is than instantiated by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ODE(<vector field>, <initial conditions>; kwargs...)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"specifically,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ode = ODE(ẋ, x₀);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The initial time, ode.t₀ is assumed to be 0 be default. It can also be specified explicitly by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"t₀  = 1.0\node = ODE(ẋ, t₀, x₀);","category":"page"},{"location":"tutorial/tutorial/#Partitioned-ordinary-differential-equations","page":"Tutorial","title":"Partitioned ordinary differential equations","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The pendulum problem is a Hamiltonian system that can also be expressed as","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"dotq = fracpartial Hpartial p = p \nhspace3em\ndotp = - fracpartial Hpartial q = sin (q) \nhspace3em\nH (qp) = frac12 p^2 + cos (q) ","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"This structure, namely the partitioning into two sets of variables (qp) instead of x, can be exploited for more efficient integration. Such equations can be defined in terms of a partitioned ODE, where the vector fields are specified separately,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"function q̇(t, q, p, v)\n    v[1] = p[1]\nend\n\nfunction ṗ(t, q, p, f)\n    f[1] = sin(q[1])\nend\n\npode = PODE(q̇, ṗ, [acos(0.4)], [0.0]);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The first two arguments to the PODE constructor are the functions that determine the vector fields of the equations dotq (t) = v(t q(t) p(t)) and dotp (t) = f(t q(t) p(t)). The third and fourth argument determines the initial conditions of q and p, respectively. The functions defining the vector field have to take four arguments, the current time t, the current solution vectors q and p and the output vector v or f.","category":"page"},{"location":"tutorial/tutorial/#Integrators","page":"Tutorial","title":"Integrators","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"We support a number of standard integrators (geometric and non-geometric) like explicit, implicit and partitioned Runge-Kutta methods, splitting methods and general linear methods (planned).","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to instantiate many of the standard integrators, one needs to specify an ODE, a tableau and a timestep, e.g.,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(ode, TableauExplicitEuler(), 0.1);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to run the integrator, the integrate() functions is called, passing an integrator object and the number of time steps to integrate:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = integrate(ode, int, 250);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The integrate function automatically creates an appropriate solution object, that contains the result of the integration.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sol.q[1,:], sol.q[2,:], xlab=\"x(t)\", ylab=\"y(t)\", legend=:none)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Observe that the explicit Euler method is not well suited for integrating this system. The solutions drifts away although it should follow closed orbits.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"For a Hamiltonian system, defined as a PODE, a different tableau might be more appropriate, for example a symplectic Euler method,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(pode, TableauSymplecticEulerA(), 0.1)\nsol = integrate(pode, int, 250);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"This creates a different integrator, which exploits the partitioned structure of the system. The solution return by the integrate step will also be a different solution, adapted to the partitioned system.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sol.q[1,:], sol.p[1,:], xlab=\"q(t)\", ylab=\"p(t)\", legend=:none)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Moreover, this method respects the Hamiltonian structure of the system, resulting in closed orbits following the contours of the system's energy.","category":"page"},{"location":"tutorial/tutorial/#Tableaus","page":"Tutorial","title":"Tableaus","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Many tableaus for Runge-Kutta methods are predefined and can easily be used like outlined above. In particular, this includes the following methods:","category":"page"},{"location":"tutorial/tutorial/#Explicit-Runge-Kutta-Methods","page":"Tutorial","title":"Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauExplicitEuler 1 Explicit / Forward Euler\nTableauExplicitMidpoint 2 Explicit Midpoint\nTableauHeun2 2 Heun's Method of order two\nTableauHeun3 3 Heun's Method of order three\nTableauRalston2 2 Ralston's Method of order two\nTableauRalston3 3 Ralston's Method of order three\nTableauRunge 2 Runge's Method\nTableauKutta 3 Kutta's Method\nTableauRK416 4 Explicit 4th order Runge-Kutta (1/6 rule)\nTableauRK438 4 Explicit 4th order Runge-Kutta (3/8 rule)","category":"page"},{"location":"tutorial/tutorial/#Diagonally-Implicit-Runge-Kutta-Methods","page":"Tutorial","title":"Diagonally Implicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauCrankNicolson 3 Crank-Nicholson Method\nTableauKraaijevangerSpijker 3 Kraaijevanger & Spijker's Method\nTableauQinZhang 3 Qin & Zhang's Method\nTableauCrouzeix 3 Crouzeix's Method","category":"page"},{"location":"tutorial/tutorial/#Fully-Implicit-Runge-Kutta-Methods","page":"Tutorial","title":"Fully Implicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauImplicitEuler 1 Implicit / Backward Euler\nTableauImplicitMidpoint 2 Implicit Midpoint\nTableauSRK3 4 Symmetric Runge-Kutta s=3","category":"page"},{"location":"tutorial/tutorial/#Gauß,-Radau-and-Lobatto-Methods","page":"Tutorial","title":"Gauß, Radau and Lobatto Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauGLRK) 2s Gauss-Legendre\nTableauRadauIA 2s-1 Radau-IA\nTableauRadauIIA 2s-1 Radau-IIA\nTableauLobattoIIIA 2s-2 Lobatto-IIIA\nTableauLobattoIIIB 2s-2 Lobatto-IIIB\nTableauLobattoIIIC 2s-2 Lobatto-IIIC\nTableauLobattoIIIC̄ 2s-2 Lobatto-IIIC̄\nTableauLobattoIIID 2s-2 Lobatto-IIID\nTableauLobattoIIIE 2s-2 Lobatto-IIIE\nTableauLobattoIIIF 2s Lobatto-IIIF\nTableauLobattoIIIG 2s Lobatto-IIIG","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"All of these tableaus are generated on the fly and take the number of stages s as parameter.","category":"page"},{"location":"tutorial/tutorial/#Explicit-Partitioned-Runge-Kutta-Methods","page":"Tutorial","title":"Explicit Partitioned Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nTableauSymplecticEulerA 1 Symplectic Euler A\nTableauSymplecticEulerB 1 Symplectic Euler B\nTableauLobattoIIIAIIIB2 2 Lobatto-IIIA-IIIB\nTableauLobattoIIIBIIIA2 2 Lobatto-IIIB-IIIA","category":"page"},{"location":"tutorial/tutorial/#Custom-Tableaus","page":"Tutorial","title":"Custom Tableaus","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"If required, it is straight-forward to create a custom tableau. The tableau of Heun's method, for example, is defined as follows:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"a = [[0.0 0.0]\n     [1.0 0.0]]\nb = [0.5, 0.5]\nc = [0.0, 1.0]\no = 2\n\ntab = TableauERK(:heun, o, a, b, c)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"TableauERK{Float64}(:heun, 2, 2, Runge-Kutta Coefficients heun with 2 stage\ns and order 2  a = [0.0 0.0; 1.0 0.0]  b = [0.5, 0.5]  c = [0.0, 1.0])","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, o is the order of the method, a are the coefficients, b the weights and c the nodes. TableauERK states that the method is explicit. Other choices include TableauFIRK for fully implicit Runge-Kutta methods, TableauDIRK for diagonally implicit and TableauSIRK for singly implicit Runge-Kutta methods. TableauEPRK and TableauIPRK can be used for explicit and implicit partitioned Runge-Kutta methods. The first parameter of the constructor of each tableau assigns a name to the tableau. Such custom tableaus can be used in exactly the same as standard tableaus, e.g., by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(ode, tab, 0.1)\nsol = integrate(ode, int, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"making it very easy to implement and test new methods.","category":"page"},{"location":"tutorial/tutorial/#Solutions","page":"Tutorial","title":"Solutions","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In what we have seen so far, the solution was always automatically created by the integrate() function. While this is often convenient, it is sometimes not performant, e.g., when carrying out long-time simulations with intermediate saving of the solution. In such cases, it is better to preallocate a solution object by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = Solution(ode, 0.1, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"where the first argument is an equation, the second argument is the time step and the third argument is the number of time steps that will be computed in one integration step. The call to the integrator is then made via","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"integrate!(int, sol)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"If several integration cycles shall be performed, the reset!() function can be used to copy the solution of the last time step to the initial conditions of the solution,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"for i in 1:10\n    # integrate!(int, sol)\n    #\n    # save or process solution\n    #\n    # reset!(sol)\nend","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"All solutions have a t field holding the series of time steps that has been computed in addition to several data fields, for example q for an ODE solution, q and p for a PODE solution, qand λ for a DAE solution, and q, p and λ for a PDAE solution.","category":"page"},{"location":"modules/equations/#Equations","page":"Equations","title":"Equations","text":"","category":"section"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"Modules = [GeometricIntegrators.Equations]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/equations/#GeometricIntegrators.Equations.DAE","page":"Equations","title":"GeometricIntegrators.Equations.DAE","text":"DAE: Differential Algebraic Equation\n\nDefines a differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))   q(t_0) = q_0  \n0 = phi (t q(t) lambda(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector field v, projection u, algebraic constraint phi=0, initial conditions q_0 and lambda_0, the dynamical variable q taking values in mathbbR^m and the algebraic variable lambda taking values in mathbbR^n.\n\nFields\n\nd: dimension of dynamical variable q and the vector field v\nm: dimension of algebraic variable lambda and the constraint phi\nn: number of initial conditions\nv: function computing the vector field\nu: function computing the projection\nϕ: algebraic constraint\nv̄: function computing an initial guess for the velocity field v (optional)\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition for dynamical variable q\nλ₀: initial condition for algebraic variable lambda\n\nThe function v, providing the vector field, takes three arguments, v(t, q, v), the functions u and ϕ, providing the projection and the algebraic constraint take four arguments, u(t, q, λ, u) and ϕ(t, q, λ, ϕ), where t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nExample\n\n    function v(t, q, v)\n        v[1] = q[1]\n        v[2] = q[2]\n    end\n\n    function u(t, q, λ, u)\n        u[1] = +λ[1]\n        u[2] = -λ[1]\n    end\n\n    function ϕ(t, q, λ, ϕ)\n        ϕ[1] = q[2] - q[1]\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ₀ = [0.]\n\n    dae = DAE(v, u, ϕ, t₀, q₀, λ₀)\n\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.HDAE","page":"Equations","title":"GeometricIntegrators.Equations.HDAE","text":"HDAE: Hamiltonian Differential Algebraic Equation EXPERIMENTAL\n\nDefines a Hamiltonian differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + barg(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barf(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qplambda)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^n times mathbbR^d.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nm: dimension of algebraic variables lambda and gamma and the constraints phi and psi\nv: function computing the Hamiltonian vector field v\nf: function computing the Hamiltonian vector field f\nu: function computing the primary projection field u\ng: function computing the primary projection field g\nu̅: function computing the secondary projection field baru\ng̅: function computing the secondary projection field barg\nϕ: primary constraints\nψ: secondary constraints\nv̄: function computing an initial guess for the velocity field v` (optional)\nf̄: function computing an initial guess for the force field f (optional)\nh: function computing the Hamiltonian H\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable λ\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.HODE","page":"Equations","title":"GeometricIntegrators.Equations.HODE","text":"HODE: Hamiltonian Ordinary Differential Equation EXPERIMENTAL\n\nDefines a Hamiltonian ordinary differential initial value problem, that is a canonical Hamiltonian system of equations,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))   p(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, given by\n\nbeginaligned\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendaligned\n\ninitial conditions (q_0 p_0) and the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nv: function computing the vector field v\nf: function computing the vector field f\nh: function computing the Hamiltonian H\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.IDAE","page":"Equations","title":"GeometricIntegrators.Equations.IDAE","text":"IDAE: Implicit Differential Algebraic Equation\n\nDefines a partitioned differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + r(t q(t) p(t) lambda(t))   p(t_0) = p_0  \np(t) = p(t q(t) v(t))   \n0 = phi (t q(t) p(t) lambda(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector field f, the momentum defined by p, projection u and r, algebraic constraint phi=0, conditions (q_0 p_0) and lambda_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variable lambda taking values in mathbbR^n.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nm: dimension of algebraic variable lambda and the constraint phi\nϑ: function determining the momentum\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraint\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable lambda\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.IODE","page":"Equations","title":"GeometricIntegrators.Equations.IODE","text":"IODE: Implicit Ordinary Differential Equation\n\nDefines an implicit initial value problem\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith vector field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (q) cdot lambda\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nh: function computing the Hamiltonian (optional)\nt₀: initial time (optional)\nq₀: initial condition for q\np₀: initial condition for p\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(t, q, v, p)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. In addition, the functions g, v̄ and f̄ are specified by\n\n    function g(t, q, λ, g)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\n    function v̄(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n    function f̄(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.ODE","page":"Equations","title":"GeometricIntegrators.Equations.ODE","text":"ODE: Ordinary Differential Equation\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d.\n\nFields\n\nd: dimension of dynamical variable q and the vector field v\nv: function computing the vector field\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition\n\nThe function v providing the vector field must have the interface\n\n    function v(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, and v is the vector which holds the result of evaluating the vector field v on t and q.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.PDAE","page":"Equations","title":"GeometricIntegrators.Equations.PDAE","text":"PDAE: Partitioned Differential Algebraic Equation\n\nDefines a partitioned differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + r(t q(t) p(t) lambda(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t) lambda(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector fields v and f, projection u and r, algebraic constraint phi=0, conditions (q_0 p_0) and lambda_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variable lambda taking values in mathbbR^n.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nm: dimension of algebraic variable lambda and the constraint phi\nv: function computing the vector field v\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraint\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable lambda\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.PODE","page":"Equations","title":"GeometricIntegrators.Equations.PODE","text":"PODE: Partitioned Ordinary Differential Equation\n\nDefines a partitioned initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))  \np(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nv: function computing the vector field v\nf: function computing the vector field f\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition for q\np₀: initial condition for p\n\nThe functions v and f must have the interface\n\n    function v(t, q, p, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, p, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q and p are the current solution vectors and v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.PSDE","page":"Equations","title":"GeometricIntegrators.Equations.PSDE","text":"PSDE: Stratonovich Partitioned Stochastic Differential Equation\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0  \ndp (t) = f(t q(t))  dt + G(t q(t)) circ dW   p(t_0) = p_0\nendaligned\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nFields\n\nd:  dimension of dynamical variable q and the vector field v\nm:  dimension of the Wiener process\nns: number of sample paths\nv:  function computing the drift vector field for the position variable q\nf:  function computing the drift vector field for the momentum variable p\nB:  function computing the d x m diffusion matrix for the position variable q\nG:  function computing the d x m diffusion matrix for the momentum variable p\nt₀: initial time\nq₀: initial condition for dynamical variable q (may be a random variable itself)\np₀: initial condition for dynamical variable p (may be a random variable itself)\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, take four arguments, v(t, q, p, v), f(t, q, p, f), B(t, q, p,  B) and G(t, q, p, G), where t is the current time, (q, p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p).\n\nExample\n\n    function v(λ, t, q, v)\n        v[1] = λ*q[1]\n        v[2] = λ*q[2]\n    end\n\n    function B(μ, t, q, B)\n        B[1] = μ*q[1]\n        B[2] = μ*q[2]\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ  = 2.\n    μ  = 1.\n\n    v_sde = (t, q, v) -> v(λ, t, q, v)\n    B_sde = (t, q, B) -> B(μ, t, q, B)\n\n    sde = SDE(v_sde, B_sde, t₀, q₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SDE","page":"Equations","title":"GeometricIntegrators.Equations.SDE","text":"SDE: Stratonovich Stochastic Differential Equation\n\nDefines a stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendaligned\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nFields\n\nd:  dimension of dynamical variable q and the vector field v\nm:  dimension of the Wiener process\nns: number of sample paths\nv:  function computing the deterministic vector field\nB:  function computing the d x m diffusion matrix\nt₀: initial time\nq₀: initial condition for dynamical variable q (may be a random variable itself)\n\nParameters\n\nN: dimension of nitial condition array: N=1 - single, N=2 - multiple\n\nThe functions v and B, providing the drift vector field and diffusion matrix, v(t, q, v) and B(t, q, B, col=0), where t is the current time, q is the current solution vector, and v and B are the variables which hold the result of evaluating the vector field v and the matrix B on t and q (if col==0), or the column col of the matrix B (if col>0).\n\nExample\n\n    function v(t, q, v, p)\n        λ = p[:λ]\n        v[1] = λ*q[1]\n        v[2] = λ*q[2]\n    end\n\n    function B(t, q, B, p, col=0)\n        μ = p[:μ]\n        if col==0 #whole matrix\n            B[1,1] = μ*q[1]\n            B[2,1] = μ*q[2]\n        elseif col==1\n            #just first column\n        end\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ  = 2.\n    μ  = 1.\n    p = (λ=λ, μ=μ)\n\n    sde = SDE(v, B, t₀, q₀; parameters=p)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SODE","page":"Equations","title":"GeometricIntegrators.Equations.SODE","text":"SODE: Split Ordinary Differential Equation\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nFields\n\nd: dimension of dynamical variable q and the vector field v\nv: tuple of functions computing the vector field\nq: tuple of functions computing the solution\nt₀: initial time\nq₀: initial condition\n\nThe functions v_i providing the vector field must have the interface\n\n    function v_i(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nand the functions q_i providing the solutions must have the interface\n\n    function q_i(t, q₀, q₁, h)\n        q₁[1] = q₀[1] + ...\n        q₁[2] = q₀[2] + ...\n        ...\n    end\n\nwhere t is the current time, q₀ is the current solution vector, q₁ is the new solution vector which holds the result of computing one substep with the vector field v_i on t and q₀, and h is the (sub-)timestep to compute the update for.\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SPDAE","page":"Equations","title":"GeometricIntegrators.Equations.SPDAE","text":"SPDAE: Split Partitioned Differential Algebraic Equation EXPERIMENTAL\n\nDefines a split differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v_1(t q(t) p(t)) + v_2(t q(t) p(t) lambda(t)) + v_3(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f_1(t q(t) p(t)) + f_2(t q(t) p(t) lambda(t)) + f_3(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v_i and f_i for i = 1  3, primary constraint phi(qp)=0 and secondary constraint psi(qplambda)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^n times mathbbR^d.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nm: dimension of algebraic variables lambda and gamma and the constraints phi and psi\nn: number of initial conditions\nv: tuple of functions computing the vector fields v_i, i = 1  3\nf: tuple of functions computing the vector fields f_i, i = 1  3\nϕ: primary constraints\nψ: secondary constraints\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable λ\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SPSDE","page":"Equations","title":"GeometricIntegrators.Equations.SPSDE","text":"SPSDE: Stratonovich Split Partitioned Stochastic Differential Equation\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) =   v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0  \ndp (t) =  f_1(t q(t)) + f_2(t q(t))   dt +  G_1(t q(t)) + G_2(t q(t))  circ dW   p(t_0) = p_0 \nendaligned\n\nwith the drift vector fields v and f_i, diffusion matrices B and G_i, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nFields\n\nd:  dimension of dynamical variable q and the vector fields vi\nm:  dimension of the Wiener process\nni: number of initial conditions\nns: number of sample paths\nv :  function computing the drift vector field for the position variable q\nf1:  function computing the drift vector field for the momentum variable p\nf2:  function computing the drift vector field for the momentum variable p\nB :  function computing the d x m diffusion matrix for the position variable q\nG1:  function computing the d x m diffusion matrix for the momentum variable p\nG2:  function computing the d x m diffusion matrix for the momentum variable p\nt₀: initial time\nq₀: initial condition for dynamical variable q (may be a random variable itself)\np₀: initial condition for dynamical variable p (may be a random variable itself)\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, take four arguments, v(t, q, p, v), f(t, q, p, f), B(t, q, p,  B) and G(t, q, p, G), where t is the current time, (q, p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p).\n\nExample\n\n    function v(λ, t, q, v)\n        v[1] = λ*q[1]\n        v[2] = λ*q[2]\n    end\n\n    function B(μ, t, q, B)\n        B[1] = μ*q[1]\n        B[2] = μ*q[2]\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ  = 2.\n    μ  = 1.\n\n    v_sde = (t, q, v) -> v(λ, t, q, v)\n    B_sde = (t, q, B) -> B(μ, t, q, B)\n\n    sde = SDE(v_sde, B_sde, t₀, q₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.VDAE","page":"Equations","title":"GeometricIntegrators.Equations.VDAE","text":"VDAE: Variational Differential Algebraic Equation EXPERIMENTAL\n\nDefines an implicit initial value problem\n\nbeginaligned\ndotq (t) = v(t) + lambda(t) \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) lambda(t)) + barg (t q(t) mu(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (v lambda mu) taking values in mathbbR^d times mathbbR^d times mathbbR^m. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and mu.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the primary projection, usually given by nabla vartheta (q) cdot lambda\ng̅: function determining the secondary projection, usually given by lambda cdot nabla vartheta (q)\nϕ: primary constraints, usually given by p - vartheta (q)\nψ: secondary constraints, usually given by dotp - dotq cdot nabla vartheta (q)\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nh: function computing the Hamiltonian (optional)\nΩ: symplectic matrix (optional)\n∇H: gradient of the Hamiltonian (optional)\nt₀: initial time (optional)\nq₀: initial condition for q\np₀: initial condition for p\nλ₀: initial condition for λ (optional)\nμ₀: initial condition for μ (optional)\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(t, q, v, p)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\n    function g(t, q, λ, g)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\n    function v̄(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n    function f̄(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.VODE","page":"Equations","title":"GeometricIntegrators.Equations.VODE","text":"VODE: Variational Ordinary Differential Equation EXPERIMENTAL\n\nDefines an implicit initial value problem\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith vector field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (q) cdot lambda\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nh: function computing the Hamiltonian (optional)\nΩ: symplectic matrix (optional)\n∇H: gradient of the Hamiltonian (optional)\nt₀: initial time (optional)\nq₀: initial condition for q\np₀: initial condition for p\nλ₀: initial condition for λ (optional)\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(t, q, v, p)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g and v are specified by\n\n    function g(t, q, λ, g)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\nand\n\n    function v(t, q, p, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n\n\n\n\n","category":"type"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"CurrentModule = GeometricIntegrators.Integrators.VPRK","category":"page"},{"location":"integrators/vprk/#Variational-Partitioned-Runge-Kutta-Integrators","page":"VPRK","title":"Variational Partitioned Runge-Kutta Integrators","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Variational partitioned Runge-Kutta methods solve Lagranian systems in implicit form, i.e.,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\np       = dfracpartial Lpartial dotq (q dotq)  \ndotp = dfracpartial Lpartial q       (q dotq)  \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"by the following scheme,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nP_ni = dfracpartial Lpartial dotq (Q_ni V_ni)  \nF_ni = dfracpartial Lpartial q       (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij        V_nj  \nP_ni = p_n + h sum limits_j=1^s bara_ij  F_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i         V_ni  \np_n+1 = p_n + h sum limits_i=1^s barb_i   F_ni \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Here, s denotes the number of internal stages, a_ij and bara_ij are the coefficients of the Runge-Kutta method and b_i and barb_i the corresponding weights. If the coefficients satisfy the symplecticity conditions,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j \n textand \nbarb_i = b_i \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"these methods correspond to the position-momentum form of the discrete Lagrangian [Matthew Marsden Jerrold E. AND West (2001)]","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"L_d (q_n q_n+1) = h sum limits_i=1^s b_i  L big( Q_ni V_ni big) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"While these integrators show favourable properties for systems with regular Lagrangian, they are usually not applicable for degenerate Lagrangian systems, in particular those with Lagrangians of the form L (q dotq) = vartheta(q) cdot dotq - H(q). While variational integrators are still applicable in the case of vartheta being a linear function of q, they are often found to be unstable when vartheta is a nonlinear function of q as is the case with Lotka-Volterra systems, guiding centre dynamics and various nonlinear oscillators. To mitigate this problem, projection methods have been developed, which when applied to variational integrators provide long-time stable integrators for general degenerate Lagrangian systems that maintain conservation of energy and momenta [Michael Kraus  (2017)].","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"GeometricIntegrators.jl provides the following VPRK methods (some are still experimental):","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Integrator Description\nIntegratorVPRK Variational Partitioned Runge-Kutta (VPRK) integrator without projection\nIntegratorVPRKpStandard VPRK integrator with standard projection\nIntegratorVPRKpSymmetric VPRK integrator with symmetric projection\nIntegratorVPRKpMidpoint VPRK integrator with midpoint projection\nIntegratorVPRKpVariational VPRK integrator with variational projection\nIntegratorVPRKpSecondary VPRK integrator with projection on secondary constraint\nIntegratorVPRKpInternal Gauss-Legendre VPRK integrator with projection on internal stages of Runge-Kutta method\nIntegratorVPRKpTableau Gauss-Legendre VPRK integrator with projection in tableau of Runge-Kutta method","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For testing purposes IntegratorVPRKpStandard provides some additional constructors (these methods are generally unstable):","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Integrator Description\nIntegratorVPRKpVariationalQ VPRK integrator with variational projection on (q_n p_n+1)\nIntegratorVPRKpVariationalP VPRK integrator with variational projection on (p_n q_n+1)\nIntegratorVPRKpSymplectic VPRK integrator with symplectic projection","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"All of the above integrators are applied to an IODE.","category":"page"},{"location":"modules/tableaus/#Tableaus","page":"Tableaus","title":"Tableaus","text":"","category":"section"},{"location":"modules/tableaus/","page":"Tableaus","title":"Tableaus","text":"Modules = [GeometricIntegrators.Tableaus]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.CoefficientsLobattoIIIA","page":"Tableaus","title":"GeometricIntegrators.Tableaus.CoefficientsLobattoIIIA","text":"Lobatto IIIA coefficients with s stages\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.CoefficientsLobattoIIIB","page":"Tableaus","title":"GeometricIntegrators.Tableaus.CoefficientsLobattoIIIB","text":"Lobatto IIIB coefficients with s stages\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.CoefficientsLobattoIIIC","page":"Tableaus","title":"GeometricIntegrators.Tableaus.CoefficientsLobattoIIIC","text":"Lobatto IIIC coefficients with s stages\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.CoefficientsLobattoIIIC̄","page":"Tableaus","title":"GeometricIntegrators.Tableaus.CoefficientsLobattoIIIC̄","text":"Lobatto IIIC̄ coefficients with s stages\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.CoefficientsLobattoIIID","page":"Tableaus","title":"GeometricIntegrators.Tableaus.CoefficientsLobattoIIID","text":"Lobatto IIID coefficients with s stages\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.CoefficientsLobattoIIIE","page":"Tableaus","title":"GeometricIntegrators.Tableaus.CoefficientsLobattoIIIE","text":"Lobatto IIIE coefficients with s stages\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.CoefficientsLobattoIIIF","page":"Tableaus","title":"GeometricIntegrators.Tableaus.CoefficientsLobattoIIIF","text":"Lobatto IIIF coefficients with s stages\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.CoefficientsLobattoIIIG","page":"Tableaus","title":"GeometricIntegrators.Tableaus.CoefficientsLobattoIIIG","text":"Lobatto IIIG coefficients with s stages\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.CoefficientsRadauIA","page":"Tableaus","title":"GeometricIntegrators.Tableaus.CoefficientsRadauIA","text":"Radau IA tableau with s stages\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.CoefficientsRadauIIA","page":"Tableaus","title":"GeometricIntegrators.Tableaus.CoefficientsRadauIIA","text":"Radau IIA tableau with s stages\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauBackwardEuler","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauBackwardEuler","text":"Alias for TableauImplicitEuler\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauBurrageCL-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauBurrageCL","text":"Tableau for the explicit 4-stage CL method due to K. Burrage and P. Burrage   Method cited in Eq. (56) in    K. Burrage, P. Burrage (1996) \"High strong order explicit Runge-Kutta methods for stochastic ordinary differential equations\".   According to the paper, the method has strong order 1.5 for one-dimensional Brownian motion. Reduces to the classical R-K method   of order 4 when noise is zero.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauBurrageE1-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauBurrageE1","text":"Tableau for the explicit 4-stage E1 method due to K. Burrage and P. Burrage   Method cited in Eq. (4.2)-(4.3) in    K. Burrage, P. Burrage (2000) \"Order conditions for stochastic Runge-Kutta methods by B-series\".   According to the paper, the method has strong order 1.0 for one-dimensional Brownian motion.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauBurrageG5-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauBurrageG5","text":"Tableau for the explicit 5-stage G5 method due to K. Burrage and P. Burrage   Method cited in Section 4 of    K. Burrage, P. Burrage (2000) \"Order conditions for stochastic Runge-Kutta methods by B-series\".   According to the paper, the method has strong order 1.5 for one-dimensional Brownian motion.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauBurrageR2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauBurrageR2","text":"Tableau for the explicit 2-stage R2 method due to K. Burrage and P. Burrage   Method cited in Eq. (51) in    K. Burrage, P. Burrage (1996) \"High strong order explicit Runge-Kutta methods for stochastic ordinary differential equations\".   According to the paper, the method has strong order 1.0 for one-dimensional Brownian motion\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauCrankNicolson-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauCrankNicolson","text":"Tableau of Crank-Nicolson two-stage, 2nd order method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauCrouzeix-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauCrouzeix","text":"Tableau of Crouzeix's two-stage, 3rd order method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauExplicitEuler-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauExplicitEuler","text":"Tableau for explicit Euler method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauExplicitMidpoint-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauExplicitMidpoint","text":"Tableau for explicit midpoint method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauForwardEuler","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauForwardEuler","text":"Alias for TableauExplicitEuler\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauGLRK-Tuple{Int64}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauGLRK","text":"Gauss-Legendre Runge-Kutta\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauGLRKpSymplectic-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauGLRKpSymplectic","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauHPARKGLRK-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauHPARKGLRK","text":"Tableau for Gauss-Legendre HPARK method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauHPARKLobattoIIIAIIIB-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauHPARKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Lobatto IIIA-IIIB HPARK method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauHPARKLobattoIIIBIIIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauHPARKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Lobatto IIIB-IIIA  method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauHSPARKGLRKpSymmetric-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauHSPARKGLRKpSymmetric","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauHSPARKLobattoIIIAIIIBpSymmetric-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauHSPARKLobattoIIIAIIIBpSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauHSPARKLobattoIIIBIIIApSymmetric-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauHSPARKLobattoIIIBIIIApSymmetric","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauHeun2","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauHeun2","text":"Tableau of Heun's two-stage, 2nd order method\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauHeun3","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauHeun3","text":"Tableau of Heun's three-stage, 3rd order method\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauImplicitEuler-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauImplicitEuler","text":"Implicit Euler\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauImplicitMidpoint-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauImplicitMidpoint","text":"Implicit Midpoint\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauKraaijevangerSpijker-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauKraaijevangerSpijker","text":"Tableau of Kraaijevanger and Spijker's two-stage, 2nd order method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauKutta-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauKutta","text":"Tableau for Kutta's method of order three\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauKutta3","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauKutta3","text":"Alias for TableauKutta\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauLobattoIIIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIA","text":"Gauss-Lobatto-IIIA Runge-Kutta tableau with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauLobattoIIIAIIIB2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIAIIIB2","text":"Tableau for Gauss-Lobatto IIIAIIIB method with s=2 stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauLobattoIIIAIIIBpSymplectic-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIAIIIBpSymplectic","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauLobattoIIIB-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIB","text":"Gauss-Lobatto-IIIB Runge-Kutta tableau with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauLobattoIIIBIIIA2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIBIIIA2","text":"Tableau for Gauss-Lobatto IIIBIIIA method with s=2 stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauLobattoIIIBIIIApSymplectic-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIBIIIApSymplectic","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauLobattoIIIC-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIC","text":"Gauss-Lobatto-IIIC Runge-Kutta tableau with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauLobattoIIIC̄-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIC̄","text":"Gauss-Lobatto-IIIC̄ Runge-Kutta tableau with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauLobattoIIID-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauLobattoIIID","text":"Gauss-Lobatto-IIID Runge-Kutta tableau with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauLobattoIIIE-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIE","text":"Gauss-Lobatto-IIIE Runge-Kutta tableau with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauLobattoIIIF-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIF","text":"Gauss-Lobatto-IIIF Runge-Kutta tableau with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauLobattoIIIG-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauLobattoIIIG","text":"Gauss-Lobatto-IIIG Runge-Kutta tableau with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauModifiedStochasticStormerVerlet","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauModifiedStochasticStormerVerlet","text":"Tableau for the 2-stage modified stochastic LobattoIIIA-IIIB method   Tableau for the 2-stage modified stochastic LobattoIIIA-IIIB method   Satisfies the conditions for Lagrange-d'Alembert integrators   and the conditions for convergence of order 1.0 for one Wiener process\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauPlaten-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauPlaten","text":"Tableau for the explicit Platen method   Platen's method cited in Eq. (52) in    K. Burrage, P. Burrage (1996) \"High strong order explicit Runge-Kutta methods for stochastic ordinary differential equations\".   According to the paper, the method has strong order 1.0 for one-dimensional Brownian motion.   Appears to have a rather poor long-time performance.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauQinZhang-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauQinZhang","text":"Tableau of Qin and Zhang's symplectic two-stage, 2nd order method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauRK4","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauRK4","text":"Alias for TableauRK416\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauRK416-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauRK416","text":"Tableau for explicit Runge-Kutta method of order four (1/6 rule)\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauRK438-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauRK438","text":"Tableau for explicit Runge-Kutta method of order four (3/8 rule)\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauRadauIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauRadauIA","text":"Gauss-Radau-IIA Runge-Kutta tableau with s=2 stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauRadauIIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauRadauIIA","text":"Gauss-Radau-IIA Runge-Kutta tableau with s=3 stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauRalston2","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauRalston2","text":"Tableau of Ralston's two-stage, 2nd order method\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauRalston3","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauRalston3","text":"Tableau of Ralston's three-stage, 3rd order method\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauRosslerRS1-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauRosslerRS1","text":"Tableau for the explicit 4-stage RS1 method due to Andreas Rossler   Method cited in Table 5.2 in   Andreas Rossler, \"Second order Runge-Kutta methods for Stratonovich stochastic differential equations\",   BIT Numerical Mathematics (2007) 47   According to the paper, the method has weak order 2.0.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauRosslerRS2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauRosslerRS2","text":"Tableau for the explicit 4-stage RS2 method due to Andreas Rossler   Method cited in Table 5.3 in   Andreas Rossler, \"Second order Runge-Kutta methods for Stratonovich stochastic differential equations\",   BIT Numerical Mathematics (2007) 47   According to the paper, the method has weak order 2.0.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauRunge-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauRunge","text":"Tableau for Runge's method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauRunge2","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauRunge2","text":"Alias for TableauRunge\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSPARKGLRK-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSPARKGLRK","text":"SPARK tableau for Gauss-Legendre Runge-Kutta method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSPARKGLRKLobattoIIIAIIIB","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSPARKGLRKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Legendre/Gauss-Lobatto-IIIA-IIIB methods.\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSPARKGLRKLobattoIIIBIIIA","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSPARKGLRKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Legendre/Gauss-Lobatto-IIIB-IIIA methods.\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSPARKGLVPRK-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSPARKGLVPRK","text":"Tableau for Variational Gauss-Legendre method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSPARKLobABC-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSPARKLobABC","text":"Tableau for Gauss-Lobatto IIIA-IIIB-IIIC method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSPARKLobABD-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSPARKLobABD","text":"Tableau for Gauss-Lobatto IIIA-IIIB-IIID method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSPARKLobatto-Tuple{Any,Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSPARKLobatto","text":"SPARK tableau for Gauss-Lobatto methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSPARKLobattoIIIAIIIB-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSPARKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Lobatto IIIA-IIIB method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSPARKLobattoIIIBIIIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSPARKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Lobatto IIIB-IIIA method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSPARKVPRK-Union{Tuple{T}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T}}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T},Any}} where T","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSPARKVPRK","text":"SPARK Tableau for Variational Partitioned Runge-Kutta Methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSRK3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSRK3","text":"Symmetric Runge-Kutta tableau with three stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSRKw1","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSRKw1","text":"Tableau for the 1-stage SRKw1 method due to Wang, Hong & Xu   Method cited in   Wang, Hong, Xu, \"Construction of Symplectic Runge-Kutta Methods for Stochastic Hamiltonian Systems\",   Commun. Comput. Phys. 21(1), 2017   According to the paper, the method has weak order 1.0.\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSRKw2","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSRKw2","text":"Tableau for the 4-stage SRKw2 method due to Wang, Hong & Xu   Method cited in   Wang, Hong, Xu, \"Construction of Symplectic Runge-Kutta Methods for Stochastic Hamiltonian Systems\",   Commun. Comput. Phys. 21(1), 2017   According to the paper, the method has weak order 2.0 when applied to systems   driven by one-dimensional noise.\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSSPRK3","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSSPRK3","text":"Tableau of 3rd order Strong Stability Preserving method with three stages\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauStochasticDIRK","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauStochasticDIRK","text":"Tableau for the 2-stage stochastic symplectic DIRK method   Tableau for the stochastic symplectic DIRK method   Satisfies the conditions for Lagrange-d'Alembert integrators.   Satisfies the conditions for strong convergence of order 1.0 for one Wiener process\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauStochasticEuler-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauStochasticEuler","text":"Tableau for the explicit 1-stage stochastic Euler method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauStochasticGLRK-Tuple{Int64}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauStochasticGLRK","text":"Tableau for the s-stage Gauss-Lobatto SFIRK method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauStochasticHeun-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauStochasticHeun","text":"Tableau for the explicit 2-stage stochastic Heun method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauStochasticLobattoIIIABD2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauStochasticLobattoIIIABD2","text":"Tableau for the 2-stage stochastic LobattoIIIA-IIIB-IIID method   Tableau for the 2-stage stochastic LobattoIIIA-IIIB-IIID method   (based on the deterministic LobattoIIIA-IIIB-IIID due to L. Jay)   It satisfies the conditions for convergence of order 1.0 for one Wiener process,   but it doesn't satisfy the conditions for Lagrange-d'Alembert integrators\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauStochasticStormerVerlet-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauStochasticStormerVerlet","text":"Tableau for the 2-stage stochastic LobattoIIA-IIB method (Stormer-Verlet)\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauStochasticSymplecticEuler-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauStochasticSymplecticEuler","text":"Tableau for the stochastic symplectic Euler method   Tableau for the stochastic symplectic Euler method   Satisfies the conditions for Lagrange-d'Alembert integrators.   Satisfies the conditions for strong convergence of order 1.0 for one Wiener process   for special choices of the stochastic Hamiltonians and forces, e.g., h=h(q), f=0.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSymplecticEulerA-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSymplecticEulerA","text":"Tableau for symplectic Euler-A method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauSymplecticEulerB-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauSymplecticEulerB","text":"Tableau for symplectic Euler-B method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVPGLRK-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVPGLRK","text":"Tableau for variational Gauss-Legendre method with s stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIA","text":"Tableau for variational Gauss-Lobatto IIIA-IIIB method with s stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIAIIIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIAIIIA","text":"Tableau for Gauss-Lobatto IIIA-IIIA method with s stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIB-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIB","text":"Tableau for variational Gauss-Lobatto IIIA-IIIB method with s stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIBIIIB-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIBIIIB","text":"Tableau for Gauss-Lobatto IIIB-IIIB method with s stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIC-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIC","text":"Tableau for variational Gauss-Lobatto IIIC-III method with s stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVPLobattoIIID-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIID","text":"Tableau for variational Gauss-Lobatto IIID method with s stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIE-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIE","text":"Tableau for variational Gauss-Lobatto IIIE method with s stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIF-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIF","text":"Tableau for variational Gauss-Lobatto IIIF method with s stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVPLobattoIIIG-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVPLobattoIIIG","text":"Tableau for variational Gauss-Lobatto IIIG method with s stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVPRadauIIAIIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVPRadauIIAIIA","text":"Tableau for Gauss-Radau IIA-IIA method with two stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVPSRK3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVPSRK3","text":"Tableau for variational symmetric Runge-Kutta method with 3 stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpInternal-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpInternal","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpLobattoIIIAIIIB-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpLobattoIIIAIIIB","text":"Tableau for Gauss-Legendre method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpLobattoIIIBIIIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpLobattoIIIBIIIA","text":"Tableau for Gauss-Legendre method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpMidpoint-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpMidpoint","text":"Tableau for Gauss-Legendre method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedInternal-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedInternal","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedLobattoIIIAIIIB-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedLobattoIIIBIIIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedMidpoint-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpModifiedMidpoint","text":"Tableau for Gauss-Legendre method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKGLRKpSymmetric-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKGLRKpSymmetric","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKInternalProjection-Union{Tuple{T}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T}}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T},Any}} where T","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKInternalProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. Use the same tableaus for tildea^1 and tildea^3, so that tildes = s, as well as\n\nbeginaligned\nbeginarrayccc\n tfrac12 b^1 \n vdots \n tfrac12 b^1 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \n vdots \n tfrac12 b^3 \nhline\na^4  \nendarray\n\nbeginarrayccc\n tfrac12 b^1 \nc^1  vdots \n tfrac12 b^1 \nhline\ntildea^2  tfrac12 (1 + R(infty))  b^1 \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \nc^3  vdots \n tfrac12 b^3 \nhline\ntildea^4  tfrac12 (1 + R(infty))  b^3 \nendarray\nendaligned\n\nSet omega = 0  0 1 and\n\ndelta_ij = begincases\n+1  j = i  \n-1  j = tildes  \n 0  textelse \nendcases\n\nso that Lambda_1 = Lambda_2 =  = Lambda_tildes.\n\nThis methods is constructed to satisfy the constraint on the projective stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes. Note, however, that it violates the symplecticity conditions b^1_i b^4_j = b^1_i a^4_ij + b^4_j tildea^1_ji and b^2_i b^3_j = b^2_i tildea^3_ij + b^3_j a^2_ji.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBProjection-Union{Tuple{T}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T}}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T},Any}} where T","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^4 b^4) and (tildea^2 b^2), respectively, and choose tildea^1 and tildea^3 such that the projective stages correspond to the initial condition and the solution, i.e.,\n\nbeginaligned\nbeginarrayccc\n0  0 \n1  b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\n0  tfrac12  0 \n1  tfrac12  0 \nhline\ntildea^2  \nendarray\n\nbeginarrayccc\n0  0 \n1  b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\n0  0  0 \n1  tfrac12  tfrac12 \nhline\ntildea^4  \nendarray\nendaligned\n\nand compute a^2 and a^4 by the symplecticity conditions, that is a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i and a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i. Finally choose omega = 0 0 1 and delta = -1 R_infty, implying that rho = 1. By construction, this method satisfies all symplecticity conditions, but the constraint on the projection stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, is not satisfied exactly, but only approximately, although with bounded error.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpLobattoIIIAIIIB-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpLobattoIIIBIIIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpMidpoint-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpMidpoint","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIAIIIB-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIBIIIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedMidpoint-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpModifiedMidpoint","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpSymmetric-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIAIIIBpSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIAProjection-Union{Tuple{T}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T}}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T},Any}} where T","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIAProjection","text":"This methods is the same as TableauVSPARKLobattoIIIAIIIBProjection, except for using Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^2 b^2), and (tildea^4 b^4) respectively, instead of the other way around.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApLobattoIIIAIIIB-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApLobattoIIIBIIIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApMidpoint-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApMidpoint","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIAIIIB-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIBIIIA-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedMidpoint-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApModifiedMidpoint","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApSymmetric-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKLobattoIIIBIIIApSymmetric","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKMidpointProjection-Union{Tuple{T}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T}}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T},Any}} where T","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKMidpointProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 1 and rho = 0, such that tildeQ_n1 = tfrac12 ( q_n + q_n+1), tildeP_n1 = tfrac12 ( p_n + p_n+1), i.e.,\n\nbeginaligned\nbeginarrayccc\n tfrac12 \n vdots \n tfrac12 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 \n vdots \n tfrac12 \nhline\na^4  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^2  tfrac12 (1 + R(infty))\nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^4  tfrac12 (1 + R(infty))\nendarray\nendaligned\n\nThe coefficients tildea^1 and tildea^3 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i, and omega = 0 1.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKModifiedInternalProjection","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKModifiedInternalProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s, and set\n\nbeginaligned\nbeginarrayccc\n tfrac12 b^1 \n vdots \n tfrac12 b^1 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 b^4 \n vdots \n tfrac12 b^4 \nhline\na^4  \nendarray\n\nbeginarrayccc\n tfrac12 b^1 \nc^1  vdots \n tfrac12 b^1 \nhline\ntildea^2  tfrac12 (1 + R(infty))  b^1 \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \nc^3  vdots \n tfrac12 b^3 \nhline\ntildea^4  tfrac12 (1 + R(infty))  b^3 \nendarray\nendaligned\n\nNote that by this definition tildes = s. The coefficients tildea^1 and tildea^3 are determined by the (modified) symplecticity conditions, specifically a^4_ij = b^3_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^1_j ( b^3_i - tildea^3_ji )  b^3_i, where b^2 has been replaced with b^1 and b^4 with b^3, respectively. Set omega = 0  0 1 and\n\ndelta_ij = begincases\n+1  j = i  \n-1  j = tildes  \n 0  textelse \nendcases\n\nso that Lambda_1 = Lambda_2 =  = Lambda_tildes.\n\nNote that this method satisfies the symplecticity conditions b^1_i b^4_j = b^1_i a^4_ij + b^4_j tildea^1_ji and b^2_i b^3_j = b^2_i tildea^3_ij + b^3_j a^2_ji only if R(infty) = 1 due to the definitions of b^2 and b^4. Moreover, it does usually not satisfy the constraint on the projective stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, exactly, but only approximately with bounded error, thus implying a residual in the symplecticity equation even if R(infty) = 1.\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKModifiedLobattoIIIAIIIBProjection-Union{Tuple{T}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T}}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T},Any}} where T","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKModifiedLobattoIIIAIIIBProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^4 b^4) and (tildea^2 b^2), respectively.\n\nThe coefficients tildea^1 and tildea^3 are determined by the relations\n\nbeginaligned\nsum limits_j=1^s tildea^1_ij (c_j^1)^k-1 = frac(c_i^2)^kk  qquad \nsum limits_j=1^s tildea^3_ij (c_j^3)^k-1 = frac(c_i^4)^kk  qquad \ni = 1      tildes  qquad \nk = 1      s \nendaligned\n\nThe coefficients a^2 and a^4 by the symplecticity conditions, that is a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i and a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i. Finally choose omega = 0 0 1 and delta = -1 R_infty, implying that rho = 1. By construction, this method satisfies all symplecticity conditions, but the constraint on the projection stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, is not satisfied exactly, but only approximately, although with bounded error.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKModifiedLobattoIIIBIIIAProjection-Union{Tuple{T}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T}}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T},Any}} where T","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKModifiedLobattoIIIBIIIAProjection","text":"This methods is the same as TableauVSPARKModifiedLobattoIIIAIIIBProjection, except for using Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^2 b^2), and (tildea^4 b^4) respectively, instead of the other way around.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKModifiedMidpointProjection-Union{Tuple{T}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T}}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T},Any}} where T","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKModifiedMidpointProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 1 and rho = 0, such that tildeQ_n1 = tfrac12 ( q_n + q_n+1), tildeP_n1 = tfrac12 ( p_n + p_n+1), i.e.,\n\nbeginaligned\nbeginarrayccc\ntfrac12  tfrac12 b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^2  tfrac12 ( 1 + R (infty) ) \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^4  tfrac12 ( 1 + R (infty) ) \nendarray\nendaligned\n\nThe coefficients a^2 and a^4 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i, and omega = 0 1.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.TableauVSPARKSymmetricProjection-Union{Tuple{T}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T}}, Tuple{Any,CoefficientsRK{T},CoefficientsRK{T},Any}} where T","page":"Tableaus","title":"GeometricIntegrators.Tableaus.TableauVSPARKSymmetricProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 2 and rho = 1, such that tildeQ_n1 = q_n, tildeQ_n2 = q_n+1, tildeP_n1 = p_n, tildeP_n2 = p_n+1, i.e.,\n\nbeginaligned\nbeginarrayccc\n0  0 \n1  b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\n 0  0 \n tfrac12  tfrac12 \nhline\ntildea^2  tfrac12  tfrac12 \nendarray\n\nbeginarrayccc\n0  0 \n1  b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\n 0  0 \n tfrac12  tfrac12 \nhline\ntildea^4  tfrac12  tfrac12 \nendarray\nendaligned\n\nThe coefficients a^2 and a^4 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i. Further choose omega = 1 1 0 and delta = -1 R_infty, so that tildeLambda_n1 = R_infty tildeLambda_n2 and\n\ntildeP_n1 - vartheta (tildeQ_n1) + R_infty ( tildeP_n2 - vartheta (tildeQ_n2) ) = 0 \n\nDue to the particular choice of projective stages, this is equivalent to\n\np_n - vartheta (q_n) + R_infty ( p_n+1 - vartheta (q_n+1) ) = 0 \n\nso that the constraint phi(q_n+1 p_n+1) = 0 is satisfied if phi(q_n p_n) = 0. Note that the choice of tildea^2 and tildea^4 violates the symplecticity condition b^2_i b^4_j = b^2_i tildea^4_ij + b^4_j tildea^2_ji.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus._legendre-Union{Tuple{T}, Tuple{Int64,T}} where T","page":"Tableaus","title":"GeometricIntegrators.Tableaus._legendre","text":"Legendre polynomial P_s(x) of degree s defined on the interval [-1..+1].\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus._shifted_legendre","page":"Tableaus","title":"GeometricIntegrators.Tableaus._shifted_legendre","text":"Legendre polynomial of degree s shifted to the interval [0..1], i.e., P_s(2x-1).\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauIPGLRK-Tuple{Int64}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauIPGLRK","text":"Gauss-Legendre Runge-Kutta\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_glrk_coefficients","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_glrk_coefficients","text":"The Gauss coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_glrk_nodes","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_glrk_nodes","text":"The Gauss nodes are given by the roots of the shifted Legendre polynomial P_s (2x-1) with s the number of stages.\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_glrk_weights","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_glrk_weights","text":"The Gauss weights are given by the following integrals\n\nb_i = bigg( fracdPdx (c_i) bigg)^-2 int limits_0^1 bigg( fracP(x)x - c_i bigg)^2 dx \n\nwhere P(x) denotes the shifted Legendre polynomial P(x) = P_s (2x-1) with s the number of stages.\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_lobatto_a_coefficients","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_lobatto_a_coefficients","text":"The Lobatto IIIA coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_lobatto_b_coefficients","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_lobatto_b_coefficients","text":"The Lobatto IIIB coefficients are implicitly given by the so-called simplifying assumption D(s):\n\nsum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k)  qquad j = 1      s   k = 1      s \n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_lobatto_c_coefficients","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_lobatto_c_coefficients","text":"The Lobatto IIIC coefficients are determined by setting a_i1 = b_1 and solving the so-called simplifying assumption C(s-1), given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s-1 \n\nfor a_ij with i = 1  s and j = 2  s.\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_lobatto_c̄_coefficients","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_lobatto_c̄_coefficients","text":"The Lobatto IIIC̄ coefficients are determined by setting a_is = 0 and solving the so-called simplifying assumption C(s-1), given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s-1 \n\nfor a_ij with i = 1  s and j = 1  s-1.\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_lobatto_glrk_coefficients","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_lobatto_glrk_coefficients","text":"The projective Lobatto-GLRK coefficients are implicitly given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracbarc_i^kk  qquad i = 1      sigma   k = 1      s \n\nwhere c are Gauß-Legendre nodes with s stages and barc are Gauß-Lobatto nodes with sigma stages.\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_lobatto_nodes","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_lobatto_nodes","text":"The s-stage Lobatto nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-2dx^s-2 big( (x - x^2)^s-1 big) \n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_lobatto_weights","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_lobatto_weights","text":"The Lobatto weights can be explicitly computed by the formula\n\nb_j = frac1s (s-1) P_s-1(2 c_j - 1)^2 qquad j = 1      s \n\nwhere P_k is the kth Legendre polynomial, given by\n\nP_k (x) = frac1k 2^k big( fracd^kdx^k (x^2 - 1)^k big) \n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_radau_1_coefficients","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_radau_1_coefficients","text":"The Radau IA coefficients are implicitly given by the so-called simplifying assumption D(s):\n\nsum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k)  qquad j = 1      s   k = 1      s \n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_radau_1_nodes","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_radau_1_nodes","text":"The s-stage Radau IA nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-1dx^s-1 big( x^s (x - 1)^s-1 big) \n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_radau_1_weights","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_radau_1_weights","text":"The Radau IA weights are implicitly given by the so-called simplifying assumption B(s):\n\nsum limits_j=1^s b_j c_j^k-1 = frac1k  qquad k = 1      s \n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_radau_2_coefficients","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_radau_2_coefficients","text":"The Radau IIA coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_radau_2_nodes","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_radau_2_nodes","text":"The s-stage Radau IIA nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-1dx^s-1 big( x^s-1 (x - 1)^s big) \n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.get_radau_2_weights","page":"Tableaus","title":"GeometricIntegrators.Tableaus.get_radau_2_weights","text":"The Radau IIA weights are implicitly given by the so-called simplifying assumption B(s):\n\nsum limits_j=1^s b_j c_j^k-1 = frac1k  qquad k = 1      s \n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.solve_simplifying_assumption_b-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T","page":"Tableaus","title":"GeometricIntegrators.Tableaus.solve_simplifying_assumption_b","text":"Compute the weights by solving the simplifying assumption B(s):\n\nsum limits_j=1^s b_j c_j^k-1 = frac1k  qquad k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.solve_simplifying_assumption_c-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T","page":"Tableaus","title":"GeometricIntegrators.Tableaus.solve_simplifying_assumption_c","text":"Compute the coefficients by solving the simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.solve_simplifying_assumption_d-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where T","page":"Tableaus","title":"GeometricIntegrators.Tableaus.solve_simplifying_assumption_d","text":"Compute the coefficients by solving the simplifying assumption D(s):\n\nsum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k)  qquad j = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"integrators/splitting/#Splitting-Methods","page":"Splitting","title":"Splitting Methods","text":"","category":"section"},{"location":"modules/simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"modules/simulations/","page":"Simulations","title":"Simulations","text":"Modules = [GeometricIntegrators.Simulations]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/simulations/#GeometricIntegrators.Simulations.ParallelSimulation","page":"Simulations","title":"GeometricIntegrators.Simulations.ParallelSimulation","text":"ParallelSimulation: collects all data structures that are necessary for a    simulation run in parallel.\n\nWARNING: Many integrators are not thread-safe at this point!\n\n\n\n\n\n","category":"type"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"","category":"page"},{"location":"integrators/cgvi/#Continuous-Galerkin-Variational-Integrators","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"CurrentModule = GeometricIntegrators.Integrators.SPARK","category":"page"},{"location":"integrators/spark/#Special-Partitioned-Additive-Runge-Kutta-Integrators","page":"SPARK","title":"Special Partitioned Additive Runge-Kutta Integrators","text":"","category":"section"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"SPARK or Special Partitioned Additive Runge-Kutta Integrators are a family of integrators that have been introduced by Laurent O. Jay for the integration of differential algebraic equations and in particular systems subject to holonomic and nonholonomic constraints [Laurent O. Jay  (1998), Laurent O. Jay  (2003), Laurent O. Jay  (2006), Laurent O. Jay  (2007), Laurent O. Jay  (2007)]. Recently, the idea of SPARK methods has been generalized and adapted to facilitate the integration of degenerate Lagrangian systems as well as Hamiltonian systems subject to Dirac constraints [Michael Kraus  (2020)].","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"GeometricIntegrators.jl provides several flavours of such SPARK methods (some are still experimental):","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"Integrator Description\nIntegratorHPARK Partitioned additive methods for Hamiltonian system subject to a general constraint phi(qp) = 0\nIntegratorVPARK Partitioned additive methods for Lagrangian system subject to a general constraint phi(qp) = 0\nIntegratorSPARK SPARK methods for general index-two differential algebraic equations\nIntegratorHSPARK Hamiltonian system subject to a general constraint phi(qp) = 0\nIntegratorHSPARKprimary Hamiltonian system subject primary constraint in the sense of Dirac\nIntegratorHSPARKsecondary Hamiltonian system enforcing primary & secondary Dirac constraint\nIntegratorVSPARK Lagrangian system in implicit form subject to a general constraint phi(qp) = 0\nIntegratorVSPARKprimary Degenerate Lagrangian system subject primary constraint in the sense of Dirac\nIntegratorVSPARKsecondary Degenerate Lagrangian system enforcing primary & secondary Dirac constraint","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"These integrators are applied to either an IDAE, HDAE or VDAE.","category":"page"}]
}
