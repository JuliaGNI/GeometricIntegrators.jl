var documenterSearchIndex = {"docs":
[{"location":"integrators/#Integrators","page":"Overview","title":"Integrators","text":"","category":"section"},{"location":"modules/quadratures/#Quadratures","page":"Quadrature Rules","title":"Quadratures","text":"","category":"section"},{"location":"modules/quadratures/","page":"Quadrature Rules","title":"Quadrature Rules","text":"Modules = [GeometricIntegrators.Quadratures]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/quadratures/#GeometricIntegrators.Quadratures.quadrature-Tuple{Quadrature,Function}","page":"Quadrature Rules","title":"GeometricIntegrators.Quadratures.quadrature","text":"Integrate a function f(x) over the interval [0,1] using the quadrature quad.\n\n\n\n\n\n","category":"method"},{"location":"modules/quadratures/#GeometricIntegrators.Quadratures.shift!-Tuple{Any,Any}","page":"Quadrature Rules","title":"GeometricIntegrators.Quadratures.shift!","text":"Scale nodes and weights from the interval [-1,+1] to the interval [0,1].\n\n\n\n\n\n","category":"method"},{"location":"modules/quadratures/#GeometricIntegrators.Quadratures.unshift!-Tuple{Any,Any}","page":"Quadrature Rules","title":"GeometricIntegrators.Quadratures.unshift!","text":"Scale nodes and weights from the interval [0,1] to the interval [-1,+1].\n\n\n\n\n\n","category":"method"},{"location":"modules/basis_functions/#Basis-Functions","page":"Basis Functions","title":"Basis Functions","text":"","category":"section"},{"location":"modules/basis_functions/","page":"Basis Functions","title":"Basis Functions","text":"Modules = [GeometricIntegrators.BasisFunctions]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/basis_functions/#GeometricIntegrators.BasisFunctions.Basis","page":"Basis Functions","title":"GeometricIntegrators.BasisFunctions.Basis","text":"Abstract basis\n\nT: data type   N: number of nodes\n\n\n\n\n\n","category":"type"},{"location":"modules/basis_functions/#GeometricIntegrators.BasisFunctions.PolynomialBasis","page":"Basis Functions","title":"GeometricIntegrators.BasisFunctions.PolynomialBasis","text":"Abstract polynomial basis.\n\n\n\n\n\n","category":"type"},{"location":"modules/solvers_nonlinear/#Nonlinear-Solvers","page":"Nonlinear Solvers","title":"Nonlinear Solvers","text":"","category":"section"},{"location":"modules/solvers_nonlinear/","page":"Nonlinear Solvers","title":"Nonlinear Solvers","text":"Modules = [GeometricIntegrators.Solvers]\nPages   = [\"solvers/nonlinear/nonlinear_solvers.jl\",\n           \"solvers/nonlinear/jacobian.jl\",\n           \"solvers/nonlinear/abstract_fixed_point_solver.jl\",\n           \"solvers/nonlinear/fixed_point_solver.jl\",\n           \"solvers/nonlinear/abstract_newton_solver.jl\",\n           \"solvers/nonlinear/nlsolve_newton.jl\",\n           \"solvers/nonlinear/newton_solver.jl\",\n           \"solvers/nonlinear/quasi_newton_solver.jl\"]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"integrators/rk/#Runge-Kutta-Methods","page":"Runge-Kutta","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"integrators/rk/#Gauss-Lobatto-Runge-Kutta-Methods","page":"Runge-Kutta","title":"Gauss-Lobatto Runge-Kutta Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Function Order Method\ngetTableauLobIIIA2() 2 Gauss-Lobatto IIIA s=2\ngetTableauLobIIIA3() 4 Gauss-Lobatto IIIA s=3\ngetTableauLobIIIA4() 6 Gauss-Lobatto IIIA s=4\ngetTableauLobIIIB2() 2 Gauss-Lobatto IIIB s=2\ngetTableauLobIIIB3() 4 Gauss-Lobatto IIIB s=3\ngetTableauLobIIIB4() 6 Gauss-Lobatto IIIB s=4\ngetTableauLobIIIC2() 2 Gauss-Lobatto IIIC s=2\ngetTableauLobIIIC3() 4 Gauss-Lobatto IIIC s=3\ngetTableauLobIIIC4() 6 Gauss-Lobatto IIIC s=4\ngetTableauLobIIID2() 2 Gauss-Lobatto IIID s=2\ngetTableauLobIIID3() 4 Gauss-Lobatto IIID s=3\ngetTableauLobIIID4() 6 Gauss-Lobatto IIID s=4\ngetTableauLobIIIE2() 2 Gauss-Lobatto IIIE s=2\ngetTableauLobIIIE3() 4 Gauss-Lobatto IIIE s=3\ngetTableauLobIIIE4() 6 Gauss-Lobatto IIIE s=4\ngetTableauLobIIIF2() 4 Gauss-Lobatto IIIF s=2\ngetTableauLobIIIF3() 6 Gauss-Lobatto IIIF s=3\ngetTableauLobIIIF4() 8 Gauss-Lobatto IIIF s=4","category":"page"},{"location":"modules/integrators/#Integrators","page":"Integrators","title":"Integrators","text":"","category":"section"},{"location":"modules/integrators/#Common","page":"Integrators","title":"Common","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/abstract_coefficients.jl\",\n           \"integrators/abstract_integrator.jl\",\n           \"integrators/abstract_tableau.jl\",\n           \"integrators/integrator_cache.jl\",\n           \"integrators/integrators_common.jl\",\n           \"integrators/integrators.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableau","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableau","text":"Holds the information for the various methods' tableaus.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_matrix-NTuple{4,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_matrix","text":"Create a vector of S solution matrices of type DT to store the solution of S internal stages for a problem with DxM dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector-Tuple{Any,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector","text":"Create a vector of S solution vectors of type DT to store the solution of S internal stages for a problem with D dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero-NTuple{4,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero","text":"Create a vector of (S,M+1) solution vectors of type DT to store the solution of S internal stages and M random processes for a problem with D dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero-Tuple{Any,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_internal_stage_vector_with_zero","text":"Create a vector of S+1 solution vectors of type DT to store the solution of S internal stages and the solution of the previous timestep for a problem with D     dimensions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.create_nonlinear_solver-NTuple{4,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.create_nonlinear_solver","text":"Create nonlinear solver object for a system of N equations with data type DT. The function f(x)=0 to be solved for is determined by a julia function function_stages!(x, b, params), where x is the current solution and b is the output vector, s.th. b = f(x). params are a set of parameters depending on the equation and integrator that is used. The solver type is obtained from the config dictionary (:nls_solver).\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{Equation,AbstractTableau,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Print error for integrators not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:vpark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:vspark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational special partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:vspark_primary,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational special partitioned additive Runge-Kutta tableau with projection on primary constraint.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IODE,CoefficientsPGLRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for Projected Gauss-Legendre Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{IODE,GeometricIntegrators.Integrators.VPRK.TableauVPRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational partitioned Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{ODE,TableauDIRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for diagonally implicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{ODE,TableauERK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for explicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{ODE,TableauFIRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for fully implicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:hpark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for Hamiltonian partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:hspark,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for Hamiltonian special partitioned additive Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PDAE,GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK{:hspark_primary,DT} where DT<:Number,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for Hamiltonian special partitioned additive Runge-Kutta tableau with projection on primary constraint.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PODE,TableauEPRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for explicit partitioned Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PODE,TableauIPRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for implicit partitioned Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{PSDE,GeometricIntegrators.Integrators.Stochastic.TableauSIPRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for stochastic fully implicit partitioned Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{SDE,GeometricIntegrators.Integrators.Stochastic.TableauSERK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for stochastic explicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{SDE,GeometricIntegrators.Integrators.Stochastic.TableauSIRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for stochastic fully implicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{SDE,GeometricIntegrators.Integrators.Stochastic.TableauWERK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for weak explicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{SDE,GeometricIntegrators.Integrators.Stochastic.TableauWIRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for weak fully implicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{SODE,AbstractTableauSplitting,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for splitting tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{SPSDE,GeometricIntegrators.Integrators.Stochastic.TableauSISPRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for stochastic fully implicit split partitioned Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{VDAE,GeometricIntegrators.Integrators.SPARK.TableauVSPARKsecondary,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for variational special partitioned additive Runge-Kutta tableau with projection on secondary constraint.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Integrator-Tuple{VODE,TableauFIRK,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.Integrator","text":"Create integrator for formal Lagrangian Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorConstructor-Tuple{Any,Any,TableauDIRK}","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorConstructor","text":"Create integrator constructor for diagonally implicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorConstructor-Tuple{Any,Any,TableauERK}","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorConstructor","text":"Create integrator constructor for explicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorConstructor-Tuple{Any,Any,TableauFIRK}","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorConstructor","text":"Create integrator constructor for fully implicit Runge-Kutta tableau.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorConstructor-Tuple{Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorConstructor","text":"Create integrator constructor for exact solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate!-Tuple{Integrator,Solution,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate!","text":"Integrate ODE for initial conditions m with m₁ ≤ m ≤ m₂.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate!-Tuple{Integrator,Solution}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate!","text":"Integrate equation for all initial conditions.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate!-Union{Tuple{TT}, Tuple{DT}, Tuple{Integrator{DT,TT},Solution{DT,TT,N} where N,Int64,Int64,Int64,Int64}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate!","text":"Integrate ODE for initial conditions m with m₁ ≤ m ≤ m₂ for time steps n with n₁ ≤ n ≤ n₂.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate-Tuple{Equation,AbstractTableau,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate","text":"Integrate given equation with given tableau for ntime time steps and return solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate-Tuple{Equation,Integrator,Int64}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate","text":"Apply integrator for ntime time steps and return solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate-Tuple{Function,Array{T,1} where T,AbstractTableau,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate","text":"Integrate ODE specified by vector field and initial condition with given tableau for ntime time steps and return solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate-Tuple{Function,Function,Array{T,1} where T,Array{T,1} where T,AbstractTableau,Any,Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate","text":"Integrate PODE specified by two vector fields and initial conditions with given tableau for ntime time steps and return solution.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Initial-Guesses","page":"Integrators","title":"Initial Guesses","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/initial_guess/extrapolation.jl\",\n           \"integrators/initial_guess/initial_guess_ode.jl\",\n           \"integrators/initial_guess/initial_guess_pode.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.aitken_neville-Union{Tuple{TT}, Tuple{Array{TT,1},Array{T,2} where T,TT,Array{T,1} where T}} where TT","page":"Integrators","title":"GeometricIntegrators.Integrators.aitken_neville","text":"Compute p(x) where p is the unique polynomial of degree length(xi), such that p(x[i]) = y[i]) for all i.\n\nti: interpolation nodes\nxi: interpolation values\nt:  evaluation point\nx:  evaluation value\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.euler_extrapolation-Union{Tuple{TT}, Tuple{Function,TT,TT,Array{T,1} where T,Array{T,1} where T,Int64}} where TT","page":"Integrators","title":"GeometricIntegrators.Integrators.euler_extrapolation","text":"Euler extrapolation method with arbitrary order p.\n\nv:  function to compute vector field\nt₀: initial time\nt₁: final   time\nx₀: initial value\nx₁: final   value\ns:  number of interpolations (order p=s+1)\n\nTODO This is probably broken!\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.midpoint_extrapolation-Union{Tuple{DT}, Tuple{TT}, Tuple{Function,Function,TT,TT,Array{DT,1},Array{DT,1},Array{DT,1},Array{DT,1},Int64}} where DT where TT","page":"Integrators","title":"GeometricIntegrators.Integrators.midpoint_extrapolation","text":"Midpoint extrapolation method with arbitrary order p.\n\nv:  function to compute vector field\nf:  function to compute force  field\nt₀: initial time\nt₁: final   time\nq₀: initial positions\np₀: initial momenta\nq₁: final   positions\np₁: final   momenta\ns:  number of interpolations (order p=2s+2)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.midpoint_extrapolation-Union{Tuple{TT}, Tuple{DT}, Tuple{Function,TT,TT,Array{DT,1},Array{DT,1},Int64}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.midpoint_extrapolation","text":"Midpoint extrapolation method with arbitrary order p.\n\nv:  function to compute vector field\nt₀: initial time\nt₁: final   time\nx₀: initial value\nx₁: final   value\ns:  number of interpolations (order p=2s+2)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.InitialGuessODE","page":"Integrators","title":"GeometricIntegrators.Integrators.InitialGuessODE","text":"InitialGuessODE: Initial guess for ordinary differential equations\n\nFields\n\nint: interpolation structure\nv:   vector  field\nΔt:  time step\ns:   number of extrapolation stages (for initialisation)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initialize!-Union{Tuple{IT}, Tuple{VT}, Tuple{TT}, Tuple{DT}, Tuple{InitialGuessODE{DT,TT,VT,IT},TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}}}} where IT where VT where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.initialize!","text":"Initialise initial guess, i.e., given t₀, t₁, q₁ compute q₀, v₀, v₁.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.update_vector_fields!-Union{Tuple{TT}, Tuple{DT}, Tuple{InitialGuessODE{DT,TT,VT,IT} where IT<:Interpolator where VT,TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Array{DT,1}}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.update_vector_fields!","text":"compute vector field of new solution\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.InitialGuessPODE","page":"Integrators","title":"GeometricIntegrators.Integrators.InitialGuessPODE","text":"InitialGuessPODE: Initial guess for partitioned ordinary differential equations\n\nFields\n\nint: interpolation structure\nv:   vector field for q\nf:   vector field for p\nΔt:  time step\ns:   number of extrapolation stages (for initialisation)\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initialize!-Union{Tuple{IT}, Tuple{VT}, Tuple{TT}, Tuple{DT}, Tuple{InitialGuessPODE{DT,TT,VT,IT,IT1} where IT1<:Interpolator,TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},TT,Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}},Union{Array{DT,1}, Array{Base.TwicePrecision{DT},1}}}} where IT where VT where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.initialize!","text":"Initialise initial guess, i.e., given t₀, t₁, q₁ compute q₀, v₀, v₁.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Splitting-Methods","page":"Integrators","title":"Splitting Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/splitting/integrators_splitting.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorSplitting","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorSplitting","text":"Splitting integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorSplitting-Union{Tuple{ST}, Tuple{TT}, Tuple{DT}, Tuple{SODE{DT,TT,vType,qType,pType,N} where N where pType<:Union{Nothing, NamedTuple} where qType<:Union{Nothing, Tuple} where vType<:Tuple,ST,TT}} where ST<:AbstractTableauSplitting{TT} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorSplitting","text":"Construct splitting integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorSplitting{DT,TT,D,S,QT} where QT<:Tuple where S where D,AtomicSolutionODE{DT,TT}}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with splitting integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Runge-Kutta-Methods","page":"Integrators","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/rk/bstract_integrator_rk.jl\",\n           \"integrators/rk/coefficients.jl\",\n           \"integrators/rk/tableaus.jl\",\n           \"integrators/rk/integrators_erk.jl\",\n           \"integrators/rk/integrators_dirk.jl\",\n           \"integrators/rk/integrators_firk.jl\",\n           \"integrators/rk/integrators_eprk.jl\",\n           \"integrators/rk/integrators_iprk.jl\",\n           \"integrators/rk/integrators_flrk.jl\",\n           \"integrators/rk/integrators_pglrk.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.CoefficientsRK","page":"Integrators","title":"GeometricIntegrators.Integrators.CoefficientsRK","text":"Holds the coefficients of a Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Base.show-Tuple{IO,CoefficientsRK}","page":"Integrators","title":"Base.show","text":"Print Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableauERK","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableauERK","text":"Holds the tableau of an explicit Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableauIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableauIRK","text":"Holds the tableau of an implicit Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableauPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableauPRK","text":"Holds the tableau of a partitioned Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.AbstractTableauRK","page":"Integrators","title":"GeometricIntegrators.Integrators.AbstractTableauRK","text":"Holds the tableau of a Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.readTableauRKHeaderFromFile-Tuple{Any}","page":"Integrators","title":"GeometricIntegrators.Integrators.readTableauRKHeaderFromFile","text":"Reads and parses Tableau metadata from file.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.writeTableauToFile-Union{Tuple{T}, Tuple{AbstractString,AbstractTableauRK{T}}} where T","page":"Integrators","title":"GeometricIntegrators.Integrators.writeTableauToFile","text":"Write Runge-Kutta tableau to file.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheERK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheERK","text":"Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorERK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorERK","text":"Explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersERK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersERK","text":"Parameters for right-hand side function of explicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauERK","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauERK","text":"Holds the tableau of an explicit Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorERK{DT,TT,D,S,ET} where ET where S where D,AtomicSolutionODE{DT,TT}}, Tuple{IntegratorERK{DT,TT,D,S,ET} where ET where S where D,AtomicSolutionODE{DT,TT},GeometricIntegrators.Integrators.IntegratorCacheERK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.readTableauERKFromFile-Tuple{AbstractString,AbstractString}","page":"Integrators","title":"GeometricIntegrators.Integrators.readTableauERKFromFile","text":"Read explicit Runge-Kutta tableau from file.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheDIRK","text":"Diagonally implicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorDIRK","text":"Diagonally implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersDIRK","text":"Parameters for right-hand side function of diagonally implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauDIRK","text":"Holds the tableau of a diagonally implicit Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict,Int64}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initial_guess!-Union{Tuple{DT}, Tuple{IntegratorDIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{DT,TT,VT,IT} where IT<:Interpolator where VT) where ST where PT<:(GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D where TT,AtomicSolutionODE{DT,TT} where TT}, Tuple{IntegratorDIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{DT,TT,VT,IT} where IT<:Interpolator where VT) where ST where PT<:(GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D where TT,AtomicSolutionODE{DT,TT} where TT,GeometricIntegrators.Integrators.IntegratorCacheDIRK{DT,D,S} where S where D}} where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.initial_guess!","text":"Compute initial guess for internal stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.initialize!-Tuple{IntegratorDIRK,GeometricIntegrators.Integrators.IntegratorCacheDIRK}","page":"Integrators","title":"GeometricIntegrators.Integrators.initialize!","text":"Initialise initial guess\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{N}, Tuple{TT}, Tuple{DT}, Tuple{IntegratorDIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{DT,TT,VT,IT} where IT<:Interpolator where VT) where ST where PT<:(GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionODE{DT,TT}}, Tuple{IntegratorDIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{DT,TT,VT,IT} where IT<:Interpolator where VT) where ST where PT<:(GeometricIntegrators.Integrators.ParametersDIRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionODE{DT,TT},GeometricIntegrators.Integrators.IntegratorCacheDIRK{DT,D,S} where S where D}} where N where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with diagonally implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheFIRK","text":"Fully implicit Runge-Kutta integrator cache.\n\nFields\n\nq̃: initial guess of solution\nṽ: initial guess of vector field\ns̃: holds shift due to periodicity of solution\nQ: internal stages of solution\nV: internal stages of vector field\nY: vector field of internal stages\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorFIRK","text":"Fully implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersFIRK","text":"Parameters for right-hand side function of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauFIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauFIRK","text":"Holds the tableau of a fully implicit Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersFIRK{DT,TT,D,S,ET,FT,JT} where JT where FT where ET<:NamedTuple where S,GeometricIntegrators.Integrators.CacheDict}} where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorFIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{DT,TT,VT,IT} where IT<:Interpolator where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersFIRK{DT,TT,D,S,ET,FT,JT} where JT where FT where ET<:NamedTuple where S where D) where S where D,AtomicSolutionODE{DT,TT}}, Tuple{IntegratorFIRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{DT,TT,VT,IT} where IT<:Interpolator where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersFIRK{DT,TT,D,S,ET,FT,JT} where JT where FT where ET<:NamedTuple where S where D) where S where D,AtomicSolutionODE{DT,TT},GeometricIntegrators.Integrators.IntegratorCacheFIRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with fully implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.jacobian!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{Array{DT,1},Array{DT,2},GeometricIntegrators.Integrators.IntegratorCacheFIRK{DT,D,S},GeometricIntegrators.Integrators.ParametersFIRK{DT,TT,D,S,ET,FT,JT} where JT where FT where ET<:NamedTuple}} where S where D where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.jacobian!","text":"Compute stages of fully implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheEPRK","text":"Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorEPRK","text":"Explicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersEPRK","text":"Parameters for right-hand side function of explicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauEPRK","text":"TableauEPRK: Tableau of an Explicit Partitioned Runge-Kutta method\n\nbeginaligned\nV_ni = hphantom- dfracpartial Hpartial p (Q_ni P_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = - dfracpartial Hpartial q (Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nusually satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + b_j a_ji = b_i b_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.computeStageP!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorEPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D,GeometricIntegrators.Integrators.IntegratorCacheEPRK{DT,D,S} where S where D,Int64,Int64,TT}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.computeStageP!","text":"Compute P stages of explicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.computeStageQ!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorEPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D,GeometricIntegrators.Integrators.IntegratorCacheEPRK{DT,D,S} where S where D,Int64,Int64,TT}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.computeStageQ!","text":"Compute Q stages of explicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorEPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D,AtomicSolutionPODE{DT,TT}}, Tuple{IntegratorEPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D,AtomicSolutionPODE{DT,TT},GeometricIntegrators.Integrators.IntegratorCacheEPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate partitioned ODE with explicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheIPRK","text":"Implicit partitioned Runge-Kutta integrator cache.\n\nFields\n\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: vector field of internal stages of q\nZ: vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorIPRK","text":"Implicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersIPRK","text":"Parameters for right-hand side function of implicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.TableauIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.TableauIPRK","text":"TableauIPRK: Tableau of an Implicit Partitioned Runge-Kutta method\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nusually satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + b_j a_ji = b_i b_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersIPRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of implicit partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorIPRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessPODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersIPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT}}, Tuple{IntegratorIPRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessPODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersIPRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT},GeometricIntegrators.Integrators.IntegratorCacheIPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with implicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorFLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorFLRK","text":"Formal Lagrangian Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersFLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersFLRK","text":"Parameters for right-hand side function of formal Lagrangian Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersFLRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of formal Lagrangian Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.CoefficientsPGLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.CoefficientsPGLRK","text":"Holds the coefficients of a projected Gauss-Legendre Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorPGLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorPGLRK","text":"Projected Gauss-Legendre Runge-Kutta integrator.\n\nReference: LUIGI BRUGNANO, FELICE IAVERNARO, AND DONATO TRIGIANTE.\n    ENERGY- AND QUADRATIC INVARIANTS–PRESERVING INTEGRATORS BASED\n    UPON GAUSS COLLOCATION FORMULAE.\n    SIAM J. NUMER. ANAL. Vol. 50, No. 6, pp. 2897–2916, 2012.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersPGLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersPGLRK","text":"Parameters for right-hand side function of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Base.show-Tuple{IO,CoefficientsPGLRK}","page":"Integrators","title":"Base.show","text":"Print Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersPGLRK{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorPGLRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{DT,TT,VT,IT} where IT<:Interpolator where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersPGLRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionODE{DT,TT}}, Tuple{IntegratorPGLRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessODE{DT,TT,VT,IT} where IT<:Interpolator where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersPGLRK{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionODE{DT,TT},GeometricIntegrators.Integrators.IntegratorCachePGLRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with projected Gauss-Legendre Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#SPARK-Methods","page":"Integrators","title":"SPARK Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators.SPARK]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK","text":"Parameters for right-hand side function of Specialised Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.AbstractTableauSPARK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsARK","text":"Holds the coefficients of an additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsIRK","text":"Holds the coefficients of an additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsMRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsMRK","text":"Holds the multiplier Runge-Kutta coefficients.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsPRK","text":"Holds the coefficients of a projective Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.CoefficientsSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.CoefficientsSPARK","text":"Holds the coefficients of a SPARK method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorCacheSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorCacheSPARK","text":"Cache of a Specialised Partitioned Additive Runge-Kutta integrator.\n\nFields\n\nn: time step number\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\np: current solution of p\np̅: previous solution of p\nv: vector field of q\nv̅: vector field of q̅\nf: vector field of p\nf̅: vector field of p̅\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: vector field of internal stages of q\nZ: vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHPARK","text":"Partitioned Additive Runge-Kutta integrator for Hamiltonian systems subject to Dirac constraints.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \ntildePhi_ni = 0   i = 1  r \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKprimary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKprimary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorHSPARKsecondary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems subject to Dirac constraints with projection on secondary constraint.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorSLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorSLRK","text":"Specialised Partitioned Additive Runge-Kutta integrator for degenerate variational systems with projection on secondary constraint.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a^1_ij V_nj + h sum limits_j=1^sigma a^2_ij tildeLambda_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s bara^1_ij F^1_nj + h sum limits_j=1^s bara^2_ij F^2_nj + h sum limits_j=1^sigma bara^3_ij tildeF^3_nj   i = 1  s  \n0 = Phi_ni   i = 1  s \nendaligned\n\nthe projective stages\n\nbeginaligned\ntildeQ_ni = q_n + h sum limits_j=1^s alpha^1_ij tildeV_nj + h sum limits_j=1^sigma alpha^2_ij tildeLambda_nj   i = 1  sigma  \ntildeP_ni = p_n + h sum limits_j=1^s baralpha^1_ij F^1_nj + h sum limits_j=1^s baralpha^2_ij tildeF^2_nj + h sum limits_j=1^sigma baralpha^3_ij tildeF^3_nj   i = 1  sigma  \n0 = tildePhi_ni   i = 1  sigma  \n0 = sum limits_j=1^sigma omega_ij tildePsi_ni   i = 1  sigma-1 \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b^1_i V_ni + h sum limits_i=1^sigma b^2_i tildeLambda_ni  \np_n+1 = p_n + h sum limits_i=1^s b^1_i F^1_ni + h sum limits_i=1^s b^2_i F^2_ni + h sum limits_i=1^sigma b^3_i tildeF^3_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nwith definitions\n\nbeginaligned\nF^1_ni = nabla H (Q_ni)   i = 1  s  \nF^2_ni = nabla vartheta (Q_ni) cdot V_ni   i = 1  s  \ntildeF^3_ni = nabla phi (tildeQ_ni tildeP_ni) cdot tildeLambda_ni   i = 1  sigma  \nPhi_ni = phi (Q_ni P_ni) = P_ni - vartheta (Q_ni)   i = 1  s  \ntildePhi_ni = phi (tildeQ_ni tildeP_ni) = tildeP_ni - vartheta (tildeQ_ni)   i = 1  sigma  \ntildePsi_ni = psi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla vartheta (tildeQ_ni)   i = 1  sigma \nendaligned\n\nso that\n\nbeginaligned\nF^1_ni + F^2_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nphi (Q_ni P_ni) = P_ni - fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \npsi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla fracpartial Lpartial v (tildeQ_ni tildeV_ni)   i = 1  sigma \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVPARK","text":"Variational partitioned additive Runge-Kutta integrator.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \ntildePhi_ni = 0   i = 1  r \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for Variational systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKprimary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKprimary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Variational systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1  \n0 = sum limits_i=1^r tilded_i  Lambda_ni \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.IntegratorVSPARKsecondary","text":"Specialised Partitioned Additive Runge-Kutta integrator for degenerate variational systems with projection on secondary constraint.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a^1_ij V_nj + h sum limits_j=1^sigma a^2_ij tildeLambda_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s bara^1_ij F^1_nj + h sum limits_j=1^s bara^2_ij F^2_nj + h sum limits_j=1^sigma bara^3_ij tildeF^3_nj   i = 1  s  \n0 = Phi_ni   i = 1  s \nendaligned\n\nthe projective stages\n\nbeginaligned\ntildeQ_ni = q_n + h sum limits_j=1^s alpha^1_ij tildeV_nj + h sum limits_j=1^sigma alpha^2_ij tildeLambda_nj   i = 1  sigma  \ntildeP_ni = p_n + h sum limits_j=1^s baralpha^1_ij F^1_nj + h sum limits_j=1^s baralpha^2_ij tildeF^2_nj + h sum limits_j=1^sigma baralpha^3_ij tildeF^3_nj   i = 1  sigma  \n0 = tildePhi_ni   i = 1  sigma  \n0 = sum limits_j=1^sigma omega_ij tildePsi_ni   i = 1  sigma-1 \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b^1_i V_ni + h sum limits_i=1^sigma b^2_i tildeLambda_ni  \np_n+1 = p_n + h sum limits_i=1^s b^1_i F^1_ni + h sum limits_i=1^s b^2_i F^2_ni + h sum limits_i=1^sigma b^3_i tildeF^3_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nwith definitions\n\nbeginaligned\nF^1_ni = nabla H (Q_ni)   i = 1  s  \nF^2_ni = nabla vartheta (Q_ni) cdot V_ni   i = 1  s  \ntildeF^3_ni = nabla phi (tildeQ_ni tildeP_ni) cdot tildeLambda_ni   i = 1  sigma  \nPhi_ni = phi (Q_ni P_ni) = P_ni - vartheta (Q_ni)   i = 1  s  \ntildePhi_ni = phi (tildeQ_ni tildeP_ni) = tildeP_ni - vartheta (tildeQ_ni)   i = 1  sigma  \ntildePsi_ni = psi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla vartheta (tildeQ_ni)   i = 1  sigma \nendaligned\n\nso that\n\nbeginaligned\nF^1_ni + F^2_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nphi (Q_ni P_ni) = P_ni - fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \npsi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla fracpartial Lpartial v (tildeQ_ni tildeV_ni)   i = 1  sigma \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersHPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersHPARK","text":"Parameters for right-hand side function of Hamiltonian Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersSLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersSLRK","text":"Parameters for right-hand side function of Specialised Partitioned Additive Runge-Kutta methods for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersVPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersVPARK","text":"Parameters for right-hand side function of Variational Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.ParametersVSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.ParametersVSPARKsecondary","text":"Parameters for right-hand side function of Specialised Partitioned Additive Runge-Kutta methods for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauHPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauHPARK","text":"Holds the tableau of a Hamiltonian Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauSLRK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauSLRK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauSPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauSPARK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauVPARK","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauVPARK","text":"Holds the tableau of an Variational Partitioned Additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.SPARK.TableauVSPARKsecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.SPARK.TableauVSPARKsecondary","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsARK}","page":"Integrators","title":"Base.show","text":"Print additive Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsIRK}","page":"Integrators","title":"Base.show","text":"Print additive Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsMRK}","page":"Integrators","title":"Base.show","text":"Print multiplier Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsPRK}","page":"Integrators","title":"Base.show","text":"Print projective Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Base.show-Tuple{IO,GeometricIntegrators.Integrators.SPARK.CoefficientsSPARK}","page":"Integrators","title":"Base.show","text":"Print SPARK coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hspark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hspark_primary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vspark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{P}, Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vspark_primary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where P where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hpark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned additive Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:hspark_secondary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vpark,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned additive Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:vspark_secondary,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.SPARK.AbstractParametersSPARK{:slrk,DT,TT,D,S,R,P,equType,tabType} where tabType<:AbstractTableau where equType<:NamedTuple where P where R,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.SPARK.AbstractIntegratorSPARK{DT,TT,D,S,R} where R where S where D,AtomicSolutionPDAE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.SPARK.AbstractIntegratorSPARK{DT,TT,D,S,R} where R where S where D,AtomicSolutionPDAE{DT,TT},GeometricIntegrators.Integrators.SPARK.IntegratorCacheSPARK{DT,D,S,R} where R where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate an implicit DAE with a specialised partitioned additive Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#VPRK-Methods","page":"Integrators","title":"VPRK Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators.VPRK]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK","text":"Parameters for right-hand side function of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK","text":"Variational partitioned Runge-Kutta integrator cache.\n\nFields\n\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: integral of vector field of internal stages of q\nZ: integral of vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRK","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKdegenerate","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKdegenerate","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpInternal","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpInternal","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpLegendre","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpLegendre","text":"Variational special partitioned additive Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpMidpoint","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpMidpoint","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary","text":"Variational partitioned Runge-Kutta integrator with projection on secondary constraint.\n\nThe VPRK integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  big( V_nj + Lambda_nj big)  \nP_ni = p_n + h sum limits_i=1^s bara_ij  big( F_nj + nabla vartheta (Q_nj)^T cdot Lambda_nj big) - d_i lambda  \n0 = sum limits_i=1^s d_i V_i  \n0 = sum limits_j=1^s omega_ij Psi_nj \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nPsi_ni = psi(Q_ni V_ni P_ni F_ni) \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i  big( V_ni + Lambda_ni big)  \np_n+1 = p_n + h sum limits_i=1^s barb_i  big( F_ni + nabla vartheta (Q_nj)^T cdot Lambda_nj big)  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nsatisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\nthe primary constraint,\n\nbeginaligned\nphi(qp) = p - vartheta (q) = 0 \nendaligned\n\nat the final solution (q_n+1 p_n+1), and super positions of the secondary constraints,\n\nbeginaligned\npsi(qdotqpdotp)\n= dotp - dotq cdot nabla vartheta (q)\n= big( nabla vartheta (q) - nabla vartheta^T (q) big) cdot dotq - nabla H (q)\n= 0\nendaligned\n\nwhich, evaluated at the internal stages, read\n\nbeginaligned\nPsi_nj = big( nabla vartheta (Q_nj) - nabla vartheta^T (Q_nj) big) cdot V_nj - nabla H (Q_nj) \nendaligned\n\nHere, omega is a (s-1) times s matrix, chosen such that the resulting method has optimal order. The vector d is zero for Gauss-Legendre methods and needs to be chosen appropriately for Gauss-Lobatto methods (for details see documentation of VPRK methods).\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymmetric","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymmetric","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpTableau","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpTableau","text":"Projected Variational Gauss-Legendre Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariational","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariational","text":"Variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRK","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKdegenerate","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKdegenerate","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpInternal","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpInternal","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpLegendre","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpLegendre","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpMidpoint","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpMidpoint","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSecondary","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSecondary","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpStandard","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpStandard","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSymmetric","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpSymmetric","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau","text":"Parameters for right-hand side function of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.ParametersVPRKpVariational","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.ParametersVPRKpVariational","text":"Parameters for right-hand side function of Variational Partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.VPRK.TableauVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.VPRK.TableauVPRK","text":"TableauVPRK: Tableau of a Variational Partitioned Runge-Kutta method\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nP_ni = p_n + h sum limits_i=1^s bara_ij  F_nj - d_i lambda  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni  \n\n0 = sum limits_i=1^s d_i V_i  \nendaligned\n\nsatisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + b_j a_ji = b_i b_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_degenerate,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute solution of degenerate symplectic partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pinternal,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_plegendre,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational special partitioned additive Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pmidpoint,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psecondary,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pstandard,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psymmetric,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pvariational,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau{DT,TT,D,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of projected Gauss-Legendre Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKdegenerate{DT,TT,D,S,PT,PPT,ST,PST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where PST<:NonlinearSolver{DT} where ST<:NonlinearSolver{DT} where PPT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_degenerate,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKdegenerate{DT,TT,D,S,PT,PPT,ST,PST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where PST<:NonlinearSolver{DT} where ST<:NonlinearSolver{DT} where PPT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_degenerate,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT},GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpInternal{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pinternal,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpInternal{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pinternal,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT},GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpLegendre{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_plegendre,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpLegendre{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_plegendre,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT},GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate DAE with variational special partitioned additive Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpMidpoint{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pmidpoint,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpMidpoint{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pmidpoint,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT},GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psecondary,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSecondary{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psecondary,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT},GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard{DT,TT,D,S,PT,PPT,ST,PST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where PST<:NonlinearSolver{DT} where ST<:NonlinearSolver{DT} where PPT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pstandard,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpStandard{DT,TT,D,S,PT,PPT,ST,PST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where PST<:NonlinearSolver{DT} where ST<:NonlinearSolver{DT} where PPT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pstandard,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT},GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymmetric{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psymmetric,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpSymmetric{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_psymmetric,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT},GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpTableau{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpTableau{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.ParametersVPRKpTableau{DT,TT,D,S,ET} where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT},GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with projected Gauss-Legendre Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariational{DT,TT,D,S,PT,PPT,ST,PST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where PST<:NonlinearSolver{DT} where ST<:NonlinearSolver{DT} where PPT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pvariational,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRKpVariational{DT,TT,D,S,PT,PPT,ST,PST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where PST<:NonlinearSolver{DT} where ST<:NonlinearSolver{DT} where PPT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk_pvariational,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT},GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.VPRK.IntegratorVPRK{DT,TT,D,S,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.VPRK.AbstractParametersVPRK{:vprk,DT,TT,D,S,ET,PT} where PT<:NamedTuple where ET<:NamedTuple where S where D) where S where D,AtomicSolutionPODE{DT,TT},GeometricIntegrators.Integrators.VPRK.IntegratorCacheVPRK{DT,D,S} where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Galerkin-Variational-Integrators","page":"Integrators","title":"Galerkin Variational Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/cgvi/integrators_cgvi.jl\",\n           \"integrators/dgvi/integrators_dgvi.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCGVI","text":"Continuous Galerkin Variational Integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersCGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersCGVI","text":"ParametersCGVI: Parameters for right-hand side function of continuous Galerkin variational Integrator.\n\nParameters\n\nΘ: function of the noncanonical one-form (∂L/∂v)\nf: function of the force (∂L/∂q)\nΔt: time step\nb: weights of the quadrature rule\nc: nodes of the quadrature rule\nx: nodes of the basis\nm: mass matrix\na: derivative matrix\nr₀: reconstruction coefficients at the beginning of the interval\nr₁: reconstruction coefficients at the end of the interval\nt: initial time\nq: solution of q at time t\np: solution of p at time t\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersCGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{IntegratorCGVI{DT,TT,D,S,R,BT,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersCGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple) where BT<:Basis where R where S where D,AtomicSolutionPODE{DT,TT}}, Tuple{IntegratorCGVI{DT,TT,D,S,R,BT,PT,ST,IT} where IT<:(InitialGuessIODE{DT,TT,VT,FT,IT} where IT<:Interpolator where FT where VT) where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.ParametersCGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple) where BT<:Basis where R where S where D,AtomicSolutionPODE{DT,TT},GeometricIntegrators.Integrators.IntegratorCacheCGVI{DT,D,S,R} where R where S where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate ODE with variational partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheDGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheDGVI","text":"Nonlinear function cache for Discontinuous Galerkin Variational Integrator.\n\nParameters\n\nST: data type\nD: number of dimensions\nS: number of degrees of freedom\nR: number of nodes of quadrature formula\n\nFields\n\nX: degrees of freedom\nQ: solution at quadrature nodes\nV: velocity at quadrature nodes\nP: one-form at quadrature nodes\nF: forces at quadrature nodes\nq:  current solution of q_n\nq⁻: current solution of q_n^-\nq⁺: current solution of q_n^+\nq̅:  current solution of q_n+1\nq̅⁻: current solution of q_n+1^-\nq̅⁺: current solution of q_n+1^+\nϕ:  average of the solution at t_n\nϕ̅:  average of the solution at t_n+1\nλ:  jump of the solution at t_n\nλ̅:  jump of the solution at t_n+1\nθ:  one-form evaluated across at t_n\nΘ̅:  one-form evaluated across at t_n+1\ng:  projection evaluated across at t_n\ng̅:  projection evaluated across at t_n+1\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorDGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorDGVI","text":"IntegratorDGVI: Discontinuous Galerkin Variational Integrator.\n\nThe DGVI integrators arise from the discretization of the action integral\n\nmathcalA q = int limits_0^T L(q(t) dotq(t))  dt \n\nwith L a fully degenerate Lagrangian of the form\n\nL(q dotq) = vartheta (q) cdot dotq - H(q) \n\nwhere vartheta (q) denotes the Cartan one-form and H(q) the Hamiltonian, which is usually given by the total energy of the system.\n\nDiscretization\n\nWithin each interval (t_n t_n+1) a piecewise-polynomial approximation q_h of the trajectory q is constructed using S basis functions varphi_i,\n\nq_h(t) vert_(t_n t_n+1) = sum limits_i=1^S x_ni  barvarphi_ni (t) \n\nwhere barvarphi_ni (t) is a rescaled basis function, defined by\n\nbarvarphi_ni (t) = varphi_i bigg( fract - t_nt_n+1 - t_n bigg) \n\nand it is assumed that varphi_i is compactly supported on 01. These approximations q_h(t) are not assumed to be continuous across interval boundaries t_n but usuaslly have jumps.\n\nThe integral over (t_n t_n+1) is approximated by a quadrature rule with R nodes c_i and weights b_i. Denote by m and a mass and derivative matrices, respectively, whose elements  are given by\n\nm_ij = varphi_j (c_i) \nqquad\na_ij = varphi_j (c_i) \nqquad\ni = 1  R \n\nj = 1  S \n\nWith that, the solution and its time derivative at the quadrature points can be written as\n\nQ_ni equiv q_h(t_n + c_i h) = m_ij x_nj \nqquad\nV_ni equiv dotq_h (t_n + c_i h) = a_ij x_nj \n\nwhere\n\nx_n = ( x_n1  x_nS )^T\n\nis the vector containing the degrees of freedom of q_h vert_t_n t_n+1. The limits of q_h(t) at t_n and t_n+1 are given by\n\nq_n^+ = lim limits_t downarrow t_n q_h(t) = sum limits_j=1^S r^+_j delta x_nj \nhspace3em\nq_n+1^- = lim limits_t uparrow t_n+1 q_h(t) = sum limits_j=1^S r^-_j delta x_nj \n\nThe discrete action reads\n\nmathcalA_d x_d = h sum limits_n=0^N-1 bigg\n     sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big \n     + fracvartheta (q_n) + vartheta (q_n^+)2 cdot (q_n^+ - q_n)\n     + fracvartheta (q_n+1^-) + vartheta (q_n+1)2 cdot (q_n+1 - q_n+1^-)\nbigg \n\nso that using the relations\n\ndelta Q_ni = m_ij delta x_nj \nqquad\ndelta V_ni = fraca_ijh delta x_nj \nqquad\ndelta q_n^- = r^-_j delta x_n-1j \nqquad\ndelta q_n^+ = r^+_j delta x_nj \n\nthe discrete action principle leads to the discrete equations of motion,\n\n0 = sum limits_i=1^R b_i big h m_ij nabla vartheta (Q_ni) cdot V_ni + a_ij vartheta (Q_ni) - h m_ij nabla H(Q_ni) big \n+ r^+_j  frac vartheta ( q_n     ) + vartheta( q_n  ^+ ) 2\n- r^-_j  frac vartheta ( q_n+1^- ) + vartheta( q_n+1   ) 2\n   big \n+ h r^+_j  nabla vartheta (q_n  ^+) cdot (q_n  ^+ - q_n    )\n+ h r^-_j  nabla vartheta (q_n+1^-) cdot (q_n+1   - q_n+1^-) \n\nand\n\nvartheta(q_n^+) = vartheta (q_n^-) + nabla vartheta (q_n) cdot (q_n^+ - q_n^-) \n\nfor all n and all j. Let us introduce the variable p_n as\n\np_n = vartheta (q_n^-) + nabla vartheta (q_n) cdot (q_n - q_n^-) \n\nso that\n\nvartheta(q_n^+) = p_n + nabla vartheta (q_n) cdot (q_n^+ - q_n) \n\nThen the above equations provide a map (q_n p_n) mapsto (q_n+1 p_n+1). In order to solve these equations, initial conditions q_0 and p_0 = vartheta(q_0) have to be prescribed.\n\nFields\n\nequation: Implicit Ordinary Differential Equation\nbasis: piecewise polynomial basis\nquadrature: numerical quadrature rule\nΔt: time step\nparams: ParametersDGVI\nsolver: nonlinear solver\niguess: initial guess\nq: current solution vector for trajectory\np: current solution vector for one-form\ncache: temporary variables for nonlinear solver\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.ParametersDGVI","page":"Integrators","title":"GeometricIntegrators.Integrators.ParametersDGVI","text":"ParametersDGVI: Parameters for right-hand side function of Discontinuous Galerkin Variational Integrator.\n\nParameters\n\nDT: data type\nTT: parameter type\nD: dimension of the system\nS: number of basis nodes\nR: number of quadrature nodes\n\nFields\n\nΘ:  function of the noncanonical one-form (∂L/∂v)\nf:  function of the force (∂L/∂q)\ng:  function of the projection ∇ϑ(q)⋅v\nΔt: time step\nb:  quadrature weights\nc:  quadrature nodes\nm:  mass matrix\na:  derivative matrix\nr⁻: reconstruction coefficients, jump lhs value\nr⁺: reconstruction coefficients, jump rhs value\nt:  initial time\nq:  solution of q  at time t\nq⁻: solution of q⁻ at time t\nq⁺: solution of q⁺ at time t\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.compute_stages_p!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{GeometricIntegrators.Integrators.IntegratorCacheDGVI{ST,D,S,R},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.compute_stages_p!","text":"Compute one-form and forces at quadrature nodes.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.compute_stages_q!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{GeometricIntegrators.Integrators.IntegratorCacheDGVI{ST,D,S,R},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.compute_stages_q!","text":"Compute solution at quadrature nodes and across jump.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.compute_stages_v!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{GeometricIntegrators.Integrators.IntegratorCacheDGVI{ST,D,S,R},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.compute_stages_v!","text":"Compute velocities at quadrature nodes.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{R}, Tuple{S}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.ParametersDGVI{DT,TT,D,S,R,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where R where S where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of variational partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#Stochastic-Integrators","page":"Integrators","title":"Stochastic Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators.Stochastic]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSERK","text":"Stochastic Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIPRK","text":"Structure for holding the internal stages Q, the values of the drift vector and the diffusion matrix evaluated at the internal stages V=v(Q), B=B(Q), and the increments Y = Δt*a_drift*v(Q) + a_diff*B(Q)*ΔW.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIRK","text":"Structure for holding the internal stages Q, the values of the drift vector and the diffusion matrix evaluated at the internal stages V=v(Q), B=B(Q), and the increments Y = a_drift*v(Q)*Δt + a_diff*B(Q)*ΔW.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSISPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSISPRK","text":"Structure for holding the internal stages Q, the values of the drift vector and the diffusion matrix evaluated at the internal stages V=v(Q), B=B(Q), and the increments Y = Δt*a_drift*v(Q) + a_diff*B(Q)*ΔW.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWERK","text":"Weak Stochastic Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWIRK","text":"Structure for holding the internal stages Q0, and Q1 the values of the drift vector and the diffusion matrix evaluated at the internal stages V=v(Q0), B=B(Q1), and the increments Y = Δt*a_drift*v(Q) + a_diff*B(Q)*ΔW.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorSERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorSERK","text":"Stochastic Explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorSIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorSIPRK","text":"Stochastic implicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorSIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorSIRK","text":"Stochastic implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorSISPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorSISPRK","text":"Stochastic implicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorWERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorWERK","text":"Weak Stochastic Explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.IntegratorWIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.IntegratorWIRK","text":"Stochastic implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.ParametersSERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.ParametersSERK","text":"Parameters for stochastic explicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK","text":"Parameters for right-hand side function of implicit Runge-Kutta methods.\n\nA - if positive, the upper bound of the Wiener process increments; if A=0.0, no truncation\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.ParametersSIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.ParametersSIRK","text":"Parameters for right-hand side function of implicit Runge-Kutta methods.\n\nA - if positive, the upper bound of the Wiener process increments; if A=0.0, no truncation\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK","text":"Parameters for right-hand side function of implicit Runge-Kutta methods.\n\nA - if positive, the upper bound of the Wiener process increments; if A=0.0, no truncation.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.ParametersWERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.ParametersWERK","text":"Parameters for weak stochastic explicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.ParametersWIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.ParametersWIRK","text":"Parameters for right-hand side function of weak implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.TableauSERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.TableauSERK","text":"Holds the tableau of a stochastic explicit Runge-Kutta method.\n\nOrder of the tableau is not included, because unlike in the deterministic setting, it depends on the properties of the noise (e.g., the dimension of the Wiener process and the commutativity properties of the diffusion matrix).\n\nOrders stored in qdrift, qdiff and qdiff2 are understood as the classical orders of these methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.TableauSIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.TableauSIPRK","text":"Holds the tableau of a stochastic implicit partitioned Runge-Kutta method. qdrift, pdrift hold the RK coefficients for the drift part, and qdiff, pdiff hold the RK coefficients for the diffusion part of the SDE.\n\nOrder of the tableau is not included, because unlike in the deterministic setting, it depends on the properties of the noise (e.g., the dimension of the Wiener process and the commutativity properties of the diffusion matrix).\n\nOrders stored in qdrift and qdiff are understood as the classical orders of these methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.TableauSIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.TableauSIRK","text":"Holds the tableau of a stochastic implicit Runge-Kutta method.\n\nqdrift holds the RK coefficients for the drift part, qdiff holds the RK coefficients for the diffusion part of the SDE.\n\nOrder of the tableau is not included, because unlike in the deterministic setting, it depends on the properties of the noise (e.g., the dimension of the Wiener process and the commutativity properties of the diffusion matrix).\n\nOrders stored in qdrift and qdiff are understood as the classical orders of these methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.TableauSISPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.TableauSISPRK","text":"Holds the tableau of a stochastic implicit split partitioned Runge-Kutta method.\n\nqdrift, pdrift1, pdrift2 hold the RK coefficients for the drift parts, and qdiff, pdiff1, pdiff2 hold the RK coefficients for the diffusion part of the SDE.\n\nOrder of the tableau is not included, because unlike in the deterministic setting, it depends on the properties of the noise (e.g., the dimension of the Wiener process and the commutativity properties of the diffusion matrix)\n\nOrders stored in qdrift and qdiff are understood as the classical orders of these methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.TableauWERK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.TableauWERK","text":"Holds the tableau of a weak explicit Runge-Kutta method.\n\nReference: Andreas Rossler, \"Second order Runge-Kutta methods for Stratonovich stochastic differential equations\",\nBIT Numerical Mathematics (2007) 47, equation (5.1).\n\nOrder of the tableau is not included, because unlike in the deterministic setting, it depends on the properties of the noise (e.g., the dimension of the Wiener process and the commutativity properties of the diffusion matrix)\n\nOrders stored in qdrift, qdiff are irrelevant and set to 0.\n\nqdrift0, qdrift1, qdrift2 correspond to A0, A1, A2 in the paper qdiff0, qdiff1, qdiff2, qdiff3 correspond to B0, B1, B2, B3 qdrift0.b = alpha qdiff0.b  = beta1 qdiff3.b  = beta2 qdrift0.c = c0 qdrift1.c = c1 qdrift2.c = c2\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.TableauWIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.TableauWIRK","text":"Holds the tableau of a weak implicit Runge-Kutta method.\n\nReference: Wang, Hong, Xu, \"Construction of Symplectic Runge-Kutta Methods for Stochastic Hamiltonian Systems\",\nCommun. Comput. Phys. 21(1), 2017.\n\nOrder of the tableau is not included, because unlike in the deterministic setting, it depends on the properties of the noise (e.g., the dimension of the Wiener process and the commutativity properties of the diffusion matrix)\n\nOrders stored in qdrift and qdiff are understood as the classical orders of these methods.\n\nqdrift0, qdrift1 correspond to A0, A1 in the paper qdiff0, qdiff1, qdiff3 correspond to B0, B1, B3 qdrift0.b = alpha qdiff0.b  = beta qdrift0.c = c0 qdrift1.c = c1\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.compute_stages!-Union{Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{Array{ST,1},1},Array{Array{ST,1},1},Array{Array{ST,2},1},Array{Array{ST,1},1},GeometricIntegrators.Integrators.Stochastic.ParametersSIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M}} where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.compute_stages!","text":"Unpacks the data stored in x = (Y[1][1], Y[1][2], ... Y[1][D], Y[2][1], ...) into Y, calculates the internal stages Q, the values of the RHS of the SDE ( v(Q) and B(Q) ), and assigns them to V and B. Unlike for FIRK, here Y = a v(Q) Δt + â B(Q) ΔW\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.compute_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},AbstractArray{Array{ST,1},2},Array{Array{ST,1},1},Array{Array{ST,2},1},AbstractArray{Array{ST,1},2},GeometricIntegrators.Integrators.Stochastic.ParametersWIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.compute_stages!","text":"Unpacks the data stored in x = (Y0[1][1], Y0[1][2]], ... Y0[1][D], ... Y0[S][D], Y1[1][1,1], Y1[1][2,1], ... Y1[1][D,1], Y1[1][1,2], Y1[1][2,2], ... Y1[1][D,2], ... Y1[S][D,M] ) into Y0 and Y1, calculates the internal stages Q0 and Q1, the values of the RHS of the SDE ( v(Q0) and B(Q1) ), and assigns them to V and B. Unlike for FIRK, here Y = Δt a v(Q) + â B(Q) ΔW.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.compute_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{Array{ST,1},1},Array{Array{ST,1},1},Array{Array{ST,1},1},Array{Array{ST,1},1},Array{Array{ST,2},1},Array{Array{ST,2},1},Array{Array{ST,1},1},Array{Array{ST,1},1},GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.compute_stages!","text":"Unpacks the data stored in x = (Y[1][1], Y[1][2], ... Y[1][D], Y[2][1], ..., Z[1][1], Z[1][2], ... Z[1][D], Z[2][1], ...) into Y, Z, calculates the internal stages Q, P, the values of the RHS of the SDE ( v(Q,P), f(Q,P), B(Q,P) and G(Q,P) ), and assigns them to V, F, B and G. Unlike for FIRK, here Y = Δt a_drift v(Q,P) + a_diff B(Q,P) ΔW, Z = Δt â_drift v(Q,P) + â_diff B(Q,P) ΔW.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.compute_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSISPRK{ST,D,M,S} where S where M where D,GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.compute_stages!","text":"Unpacks the data stored in x = (Y[1][1], Y[1][2], ... Y[1][D], Y[2][1], ..., Z[1][1], Z[1][2], ... Z[1][D], Z[2][1], ...) into Y, Z, calculates the internal stages Q, P, the values of the RHS of the SDE ( vi(Q,P), fi(Q,P), Bi(Q,P) and Gi(Q,P) ), and assigns them to V[i], F[i], B[i] and G[i]. Unlike for FIRK, here Y = Δt a_drift v(Q,P) + a_diff B(Q,P) ΔW, Z = Δt â1_drift f1(Q,P) + Δt â2_drift f2(Q,P) + â1_diff G1(Q,P) ΔW + â2_diff G2(Q,P) ΔW.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.initial_guess!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIPRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIPRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT},GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIPRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.initial_guess!","text":"This function computes initial guesses for Y, Z and assigns them to int.solver.x The prediction is calculated using an explicit integrator.\n\nSIMPLE SOLUTION The simplest initial guess for Y, Z is 0: int.solver.x .= zeros(eltype(int), 2*tableau(int).s*ndims(int))\n\nUSING AN EXPLICIT INTEGRATOR TO COMPUTE AN INITIAL GUESS Below we use the R2 method of Burrage & Burrage to calculate the internal stages at the times c[1]...c[s]. This approach seems to give very good approximations if the time step and magnitude of noise are not too large. If the noise intensity is too big, one may have to perform a few iterations of the explicit method with a smaller time step, use a higher-order explicit method (e.g. CL or G5), or use the simple solution above.\n\nWhen calling this function, int.params should contain the data: int.params.q - the q solution at the previous time step int.params.p - the p solution at the previous time step int.params.t - the time of the previous step int.params.ΔW- the increment of the Brownian motion for the current step\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.initial_guess!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT},GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.initial_guess!","text":"This function computes initial guesses for Y and assigns them to int.solver.x. The prediction is calculated using an explicit integrator.\n\nSIMPLE SOLUTION The simplest initial guess for Y is 0: int.solver.x .= zeros(eltype(int), tableau(int).s*ndims(int))\n\nUSING AN EXPLICIT INTEGRATOR TO COMPUTE AN INITIAL GUESS Below we use the R2 method of Burrage & Burrage to calculate the internal stages at the times c[1]...c[s]. This approach seems to give very good approximations if the time step and magnitude of noise are not too large. If the noise intensity is too big, one may have to perform a few iterations of the explicit method with a smaller time step, use a higher-order explicit method (e.g. CL or G5), or use the simple solution above.\n\nWhen calling this function, int.params should contain the data: int.params.q  - the solution at the previous time step int.params.t  - the time of the previous step int.params.ΔW - the increment of the Brownian motion for the current step\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.initial_guess!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSISPRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSISPRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT},GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSISPRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.initial_guess!","text":"This function computes initial guesses for Y, Z and assigns them to int.solver.x.\n\nFor SISPRK we are NOT IMPLEMENTING an InitialGuess.\n\nSIMPLE SOLUTION The simplest initial guess for Y, Z is 0.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.initial_guess!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorWIRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersWIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorWIRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersWIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT},GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWIRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.initial_guess!","text":"This function computes initial guesses for Y and assigns them to int.solver.x For WIRK we are NOT IMPLEMENTING an InitialGuess.\n\nUsing an explicit integrator to predict the next step's value (like in SIRK) does not seem to be a good idea here, because the integrators are convergent in the weak sense only, and there is no guarantee that the explicit integrator will produce anything close to the desired solution...\n\nThe simplest initial guess for Y is 0.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.update_solution!-Union{Tuple{T}, Tuple{AtomicSolutionPSDE{T,TT} where TT,Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1}}, Tuple{AtomicSolutionPSDE{T,TT} where TT,Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1}}, Tuple{AtomicSolutionPSDE{T,TT} where TT,Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1},Array{T,1}}} where T","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.update_solution!","text":"Update solution for stochastic split partitioned Runge-Kutta methods\n\nq, p: the solution vector to be updated\nV, F1, F2: the matrix containing the drift vectors evaluated at the internal stages v(Qi), fi(Qi)\nB, G1, G2: the array containing the diffusion matrices evaluated at the internal stages B(Qi), Gi(Qi)\nbqdrift, bpdrift1, bpdrift2: the Runge-Kutta coefficients for the drift parts of the q and p equations\nbqdiff, bpdiff1, bpdiff2:    the Runge-Kutta coefficients for the diffusion parts of the q and p equations\nΔt: the time step\nΔW: the increments of the Brownian motion\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.update_solution!-Union{Tuple{T}, Tuple{AtomicSolutionPSDE{T,TT} where TT,Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1}}, Tuple{AtomicSolutionPSDE{T,TT} where TT,Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1}}, Tuple{AtomicSolutionPSDE{T,TT} where TT,Array{Array{T,1},1},Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1},Array{T,1}}} where T","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.update_solution!","text":"Update solution for stochastic partitioned Runge-Kutta methods\n\nq, p: the solution vector to be updated\nV, F: the matrix containing the drift vectors evaluated at the internal stages v(Qi), f(Qi)\nB, G: the array containing the diffusion matrices evaluated at the internal stages B(Qi), G(Qi)\nbqdrift, bpdrift: the Runge-Kutta coefficients for the drift parts of the q and p equations\nbqdiff, bpdiff:   the Runge-Kutta coefficients for the diffusion parts of the q and p equations\nΔt: the time step\nΔW: the increments of the Brownian motion\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.update_solution!-Union{Tuple{T}, Tuple{AtomicSolutionSDE{T,TT} where TT,Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1}}, Tuple{AtomicSolutionSDE{T,TT} where TT,Array{Array{T,1},1},Array{Array{T,2},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1}}} where T","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.update_solution!","text":"Update solution for weak Runge-Kutta methods WERK\n\nx:  the solution vector to be updated\nV:  the matrix containing the drift vector evaluated at the internal stages v(Q_i)\nB1: the array containing the diffusion matrix evaluated at the internal stages H^(l)i, such that B1[:,l,i] is evaluated at H^(l)i\nB2: the array containing the diffusion matrix evaluated at the internal stages Ĥ^(l)i, such that B2[:,l,i] is evaluated at Ĥ^(l)i\nα:  the Runge-Kutta coefficients for the drift part\nβ1: the Runge-Kutta coefficients for the diffusion term with the random increments\nβ2: the Runge-Kutta coefficients for the second diffusion term\nΔt: the time step\nΔW: the increments of the Brownian motion represented by the random variables Î^(k)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.update_solution!-Union{Tuple{T}, Tuple{AtomicSolutionSDE{T,TT} where TT,Array{Array{T,1},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1}}, Tuple{AtomicSolutionSDE{T,TT} where TT,Array{Array{T,1},1},Array{Array{T,2},1},Array{T,1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1},Array{T,1}}} where T","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.update_solution!","text":"Update solution for stochastic Runge-Kutta methods (SERK)\n\nx: the solution vector to be updated\nV: the matrix containing the drift vector evaluated at the internal stages v(Q_i)\nB: the array containing the diffusion matrix evaluated at the internal stages B(Q_i)\nbdrift: the Runge-Kutta coefficients for the drift part\nbdiff:  the Runge-Kutta coefficients for the ΔW terms of the diffusion part\nbdiff2: the Runge-Kutta coefficients for the ΔZ terms of the diffusion part\nΔt: the time step\nΔW: the increments of the Brownian motion\nΔZ: the integrals of the increments of the Brownian motion\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.Stochastic.update_solution!-Union{Tuple{T}, Tuple{AtomicSolutionSDE{T,TT} where TT,Array{Array{T,1},1},Array{Array{T,2},1},Array{T,1},Array{T,1},T,Array{T,1}}, Tuple{AtomicSolutionSDE{T,TT} where TT,Array{Array{T,1},1},Array{Array{T,2},1},Array{T,1},Array{T,1},T,Array{T,1},Array{T,1}}} where T","page":"Integrators","title":"GeometricIntegrators.Integrators.Stochastic.update_solution!","text":"Update solution for stochastic Runge-Kutta methods (SIRK and WIRK)\n\nx: the solution vector to be updated\nV: the matrix containing the drift vector evaluated at the internal stages v(Qi) (SIRK) or v(Q0i) (WIRK)\nB: the array containing the diffusion matrix evaluated at the internal stages B(Qi) (SIRK) or B(Q1^(l)i) (WIRK)\nbdrift: the Runge-Kutta coefficients for the drift part\nbdiff:  the Runge-Kutta coefficients for the diffusion part\nΔt: the time step\nΔW: the increments of the Brownian motion (SFIRK) or the increments represented by the random variables Î^(k) (WFIRK)\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.Stochastic.ParametersSIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of stochastic implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of stochastic implicit split partitioned Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.function_stages!-Union{Tuple{S}, Tuple{M}, Tuple{D}, Tuple{TT}, Tuple{DT}, Tuple{ST}, Tuple{Array{ST,1},Array{ST,1},GeometricIntegrators.Integrators.Stochastic.ParametersWIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple,GeometricIntegrators.Integrators.CacheDict}} where S where M where D where TT where DT where ST","page":"Integrators","title":"GeometricIntegrators.Integrators.function_stages!","text":"Compute stages of weak implicit Runge-Kutta methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSERK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D,AtomicSolutionSDE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSERK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D,AtomicSolutionSDE{DT,TT},GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSERK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate SDE with explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIPRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIPRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT},GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIPRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate PSDE with a stochastic implicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSIRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT},GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSIRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate SDE with a stochastic implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSISPRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorSISPRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersSISPRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionPSDE{DT,TT},GeometricIntegrators.Integrators.Stochastic.IntegratorCacheSISPRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate PSDE with a stochastic implicit partitioned Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorWERK{DT,TT,D,M,S,ET} where ET where S where M where D,AtomicSolutionSDE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorWERK{DT,TT,D,M,S,ET} where ET where S where M where D,AtomicSolutionSDE{DT,TT},GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWERK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate SDE with explicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.integrate_step!-Union{Tuple{TT}, Tuple{DT}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorWIRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersWIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT}}, Tuple{GeometricIntegrators.Integrators.Stochastic.IntegratorWIRK{DT,TT,D,M,S,PT,ST} where ST<:NonlinearSolver{DT} where PT<:(GeometricIntegrators.Integrators.Stochastic.ParametersWIRK{DT,TT,D,M,S,ET} where ET<:NamedTuple where S where M where D) where S where M where D,AtomicSolutionSDE{DT,TT},GeometricIntegrators.Integrators.Stochastic.IntegratorCacheWIRK{DT,D,M,S} where S where M where D}} where TT where DT","page":"Integrators","title":"GeometricIntegrators.Integrators.integrate_step!","text":"Integrate SDE with a stochastic implicit Runge-Kutta integrator.\n\n\n\n\n\n","category":"method"},{"location":"integrators/dgvi/#Discontinuous-Galerkin-Variational-Integrators","page":"DGVI","title":"Discontinuous Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"Discontinuous Galerkin Variational Integrators (DGVIs) are a family of integrators for degenerate Lagrangian systems and for Hamiltonian systems subject to Dirac constraints. For integrators for non-degenerate (regular) Lagrangian and unconstrained Hamiltonian systems see Hamilton-Pontryagin-Galerkin (HPG) Integrators.","category":"page"},{"location":"integrators/dgvi/#Degenerate-Lagrangian-Systems","page":"DGVI","title":"Degenerate Lagrangian Systems","text":"","category":"section"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"Consider a fully degenerate Lagrangian system of the form","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"L(q dotq) = vartheta (q) cdot dotq - H(q) ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"where vartheta (q) denotes the Cartan one-form and H(q) the Hamiltonian, that is usually given by the total energy of the system.","category":"page"},{"location":"integrators/dgvi/#Discrete-Trajectories-and-Numerical-Quadrature","page":"DGVI","title":"Discrete Trajectories and Numerical Quadrature","text":"","category":"section"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"The first step in the derivation of variational integrators is the discretization of the action integral","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"mathcalA q = int limits_0^T L(q(t) dotq(t))  dt ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"To this end, the interval 0T is split into N sub-intervals t_n t_n+1 with t_n = nh and h the time step size, so that t_N = T and the action can be written as","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"mathcalA q = sum limits_n=0^N-1 int limits_t_n t_n+1 L(q(t) dotq(t))  dt ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"Within each interval (t_n t_n+1) a piecewise-polynomial approximation q_h of the trajectory q is constructed using S basis functions varphi_i,","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"q_h(t) vert_(t_n t_n+1) = sum limits_i=1^S x_ni  barvarphi_ni (t) ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"where barvarphi_ni (t) is a rescaled basis function, defined by","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"barvarphi_ni (t) = varphi_i bigg( fract - t_nt_n+1 - t_n bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"and it is assumed that varphi_i is compactly supported on 01. These approximations q_h(t) do not need to be continuous across interval boundaries but are indeed allowed to have jumps. Replacing the continuous trajectory q in the action with q_h, we obtain","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"mathcalA q_h = sum limits_n=0^N-1 int limits_(t_n t_n+1) big vartheta (q_h (t)) cdot dotq_h (t) - H(q_h (t)) big  dt\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n  ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"The integral of the Hamiltonian H(q_h) over the interval boundaries does not contribute to the integral, differently from the term vartheta (q_h) cdot dotq_h, which will determine the numerical flux  cdot _n at t_n of the Discontinuous Galerkin method. The approximation of this term will be discussed below. In order to obtain a fully discrete action, a numerical quadrature rule with R nodes c_i and weights b_i is introduced for the approximation of the integral,","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (q_h(t_n + c_i h)) cdot dotq_h (t_n + c_i h) - H(q_h(t_n + c_i h)) big\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"Here, x_d denotes the vector of all the degrees of freedom, i.e.,","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"x_d = ( x_01  x_0S  x_11  x_N-2S  x_N-11  x_N-1S )^T ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"In order to write the discrete action in a more explicit form, mass and derivative matrices m and a are introduced, whose elements are given by","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"m_ij = varphi_j (c_i) \nqquad\na_ij = varphi_j (c_i) \nqquad\ni = 1  R \n\nj = 1  S ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"so that the solution and its time derivative at the quadrature points can be written as","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"Q_ni equiv q_h(t_n + c_i h) = m_ij x_nj \nqquad\nV_ni equiv dotq_h (t_n + c_i h) = a_ij x_nj ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"where","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"x_n = ( x_n1  x_nS )^T","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"is the vector containing the degrees of freedom of q_h vert_t_n t_n+1. Using these definitions, the discrete action can be written as","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n ","category":"page"},{"location":"integrators/dgvi/#Numerical-Fluxes","page":"DGVI","title":"Numerical Fluxes","text":"","category":"section"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"In the following, the solution values \"left\" and \"right\" of the jump will be needed. This will be denoted by q_n^- and q_n^+, respectively. Usually, these just correspond to the polynomials on the left and right, evaluated at t_n, i.e.,","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"q_n^- = lim_t uparrow t_n q_h (t) = q_h vert_t_n-1 t_n (t_n) \nqquad\nq_n^+ = lim_t downarrow t_n q_h (t) = q_h vert_t_n t_n+1 (t_n) ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"In principle, however, more general reconstructions of the solution could be used. In the following, it will be assumed, that q_n^- is given by some linear combinations of the degrees of freedom of the polynomial on the left interval and correspondingly that q_n^+ is given by some linear combinations of the degrees of freedom of the polynomial on the right interval, specifically","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"q_n^- = r^- cdot x_n \nqquad\nq_n^+ = r^+ cdot x_n+1 ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"where r^pm are appropriate coefficient vectors.","category":"page"},{"location":"integrators/dgvi/#Gauge-Terms","page":"DGVI","title":"Gauge Terms","text":"","category":"section"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"The Lagrangian L can be augmented with any total time derivative without changing the (continuous) Euler-Lagrange equations. In particular, one can consider the modified Lagrangian","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"L(q dotq) = vartheta (q) cdot dotq - H(q) - nu dfracddt bigg( vartheta (q) cdot q bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"While this gauge term vanishes in the continuous case, it takes a finite value across jumps of the discontinuous discrete solution, so that the modified discrete action reads","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big\n+ sum limits_n=1^N-1 biggbigg vartheta (q_h (t)) cdot dotq_h (t) - nu dfracddt bigg( vartheta (q) cdot q bigg) biggbigg_t=t_n ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"In the following, only the modified Lagrangian and action will be considered, in order to obtain a sufficiently general framework for constructing numerical fluxes. For brevity of notation, the prime will be dropped.","category":"page"},{"location":"integrators/dgvi/#Total-Time-Derivatives-Across-Jumps","page":"DGVI","title":"Total Time Derivatives Across Jumps","text":"","category":"section"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"The computation of the total time derivative in the gauge term is simple, at least in the distributional sense. Even though both, vartheta (q_h) and q_h have a jump, the jump occurs at the same position in time, so that the derivative can be computed as","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"dfracddt bigg( vartheta (q_h) cdot q_h bigg) biggvert_t=t_n\n= dfracddt bigg( vartheta (q_n^-) cdot q_n^-  Theta (t_n - t) + vartheta (q_n^+) cdot q_n^+  Theta (t - t_n) bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"where Theta denotes the Heaviside function. This can be explicitly computed as","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"dfracddt bigg( vartheta (q_h) cdot q_h bigg) biggvert_t=t_n\n= - vartheta (q_n^-) cdot q_n^-  delta (t_n) + vartheta (q_n^+) cdot q_n^+  delta (t_n)\n=  vartheta (q_h) cdot q_h _t=t_n  delta (t_n) ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"with delta (t_n) the Dirac delta-function at t_n.","category":"page"},{"location":"integrators/dgvi/#Non-conservative-Products","page":"DGVI","title":"Non-conservative Products","text":"","category":"section"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"Simple means for integrating the Lagrangian across jumps are provided by discretisations of the integral","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"int limits_0^1 vartheta (Phi(tau q^- q^+)) cdot dfracd Phi(tau q^- q^+)dtau  dtau ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"where Phi is a path connecting the solution values q^- and q^+ on the left and the right of the jump. Upon picking a quadrature rule with sigma nodes gamma_i and corresponding weights beta_i, the discrete product takes the form","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"sum limits_i=1^sigma beta_i  vartheta big( Phi (gamma_i q_n^-  q_n^+) big) cdot dfracdPhidtau (gamma_i q_n^-  q_n^+) ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"For a compact notation, \"mass\" and \"derivative\" vectors mu^pm and alpha^pm are introduced, so that","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"Phi (gamma_i q_n^-  q_n^+) = mu^-_i q_n^- + mu^+_i q_n^+\nqquad\nPhi (gamma_i q_n^-  q_n^+) = alpha^-_i q_n^- + alpha^+_i q_n^+ ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"and the discrete product can be written as","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"sum limits_i=1^sigma beta_i  vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"Providing the path Phi by two functions phi^pm(tau), so that","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"phi(tau q^- q^+) = q^- phi^-(tau) + q^+ phi^+(tau) ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"the components of the \"mass\" and \"derivative\" vectors are given by","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"mu^-_i = phi^- (gamma_i) \nqquad\nmu^+_i = phi^+ (gamma_i) ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"and","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"alpha^-_i = fracdphi^-dtau (gamma_i) \nqquad\nalpha^+_i = fracdphi^+dtau (gamma_i) ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"respectively.","category":"page"},{"location":"integrators/dgvi/#Discrete-Variational-Principle","page":"DGVI","title":"Discrete Variational Principle","text":"","category":"section"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"Using the construction of the previous sections, the discrete action reads","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma beta_i  vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ )\n- nu big vartheta (q_n^+) cdot q_n^+ - vartheta (q_n^-) cdot q_n^- big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"The discrete Euler-Lagrange equations are obtained by applying Hamilton's principle of stationary action to mathcalA_d x_d, that is requiring that delta mathcalA_d x_d = 0. The variations of the discrete action are computed as follows,","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"delta mathcalA_d x_d\n= h sum limits_n=0^N-1 sum limits_i=1^R b_i big delta Q_ni cdot nabla vartheta (Q_ni) cdot V_ni + vartheta (Q_ni) cdot delta V_ni - delta Q_ni cdot nabla H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma beta_i  big ( mu^-_i delta q_n^- + mu^+_i delta q_n^+ ) cdot nabla vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) + vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i delta q_n^- + alpha^+_i delta q_n^+ ) big \n- nu big delta q_n^+ cdot nabla vartheta (q_n^+) cdot q_n^+  + vartheta (q_n^+) cdot delta q_n^+ - delta q_n^- cdot nabla vartheta (q_n^-) cdot q_n^- - vartheta (q_n^-) cdot delta q_n^- big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"Using the relations","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"delta Q_ni = m_ij delta x_nj \nqquad\ndelta V_ni = fraca_ijh delta x_nj \nqquad\ndelta q_n^- = r^-_j delta x_n-1j \nqquad\ndelta q_n^+ = r^+_j delta x_nj ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"the variations of the discrete action become","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"delta mathcalA_d x_d\n= sum limits_n=0^N-1 sum limits_i=1^R sum limits_j=1^S b_i big h m_ij delta x_nj cdot nabla vartheta (Q_ni) cdot V_ni + vartheta (Q_ni) cdot a_ij delta x_nj - h m_ij delta x_nj cdot nabla H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma sum limits_j=1^S beta_i  big ( mu^-_i r^-_j delta x_n-1j + mu^+_i r^+_j delta x_nj ) cdot nabla vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) + vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i r^-_j delta x_n-1j + alpha^+_i r^+_j delta x_nj ) big \n- nu big r^+_j delta x_nj cdot nabla vartheta (q_n^+) cdot q_n^+  + vartheta (q_n^+) cdot r^+_j delta x_nj - r^-_j delta x_n-1j cdot nabla vartheta (q_n^-) cdot q_n^- - vartheta (q_n^-) cdot r^-_j delta x_n-1j big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"Requiring the variation of the discrete action to vanish yields the discrete equations of motion,","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"0 = sum limits_i=1^R b_i big h m_ij nabla vartheta (Q_ni) cdot V_ni + a_ij vartheta (Q_ni) - h m_ij nabla H(Q_ni) big \n+ bigg sum limits_i=1^sigma beta_i  big\n   mu^-_i r^-_j nabla vartheta ( mu^-_i q_n+1^- + mu^+_i q_n+1^+ ) cdot ( alpha^-_i q_n+1^- + alpha^+_i q_n+1^+ )\n + mu^+_i r^+_j nabla vartheta ( mu^-_i q_n  ^- + mu^+_i q_n  ^+ ) cdot ( alpha^-_i q_n  ^- + alpha^+_i q_n  ^+ ) \n + vartheta ( mu^-_i q_n+1^- + mu^+_i q_n+1^+ ) alpha^-_i r^-_j\n + vartheta ( mu^-_i q_n  ^- + mu^+_i q_n  ^+ ) alpha^+_i r^+_j\n   big \n - nu big\n     r^+_j nabla vartheta (q_n  ^+) cdot q_n  ^+ + r^+_j vartheta (q_n  ^+)\n   - r^-_j nabla vartheta (q_n+1^-) cdot q_n+1^- - r^-_j vartheta (q_n+1^-)\n   big\n bigg ","category":"page"},{"location":"integrators/dgvi/","page":"DGVI","title":"DGVI","text":"for all n and all j.","category":"page"},{"location":"modules/solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"modules/solutions/","page":"Solutions","title":"Solutions","text":"Modules = [GeometricIntegrators.Solutions]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Abstract atomistic or single-step solution.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Tuple{Equation}","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Print error for AtomicSolutions of equations not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{AbstractEquationDAE{DT,TT}}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{AbstractEquationODE{DT,TT}}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{AbstractEquationPDAE{DT,TT}}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{AbstractEquationPODE{DT,TT}}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{AbstractEquationPSDE{DT,TT}}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for PSDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{AbstractEquationSDE{DT,TT}}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for SDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{SolutionDAE{DT,TT,N} where N}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{SolutionODE{DT,TT,N} where N}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{SolutionPDAE{DT,TT,N} where N}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{SolutionPODE{DT,TT,N} where N}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{SolutionPSDE{DT,TT,NQ,NW,CONV} where CONV where NW where NQ}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for PSDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolution-Union{Tuple{SolutionSDE{DT,TT,NQ,NW,CONV} where CONV where NW where NQ}, Tuple{TT}, Tuple{DT}} where TT where DT","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolution","text":"Create AtomicSolution for SDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionDAE","text":"Atomic solution for an DAE.\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\nλ: current solution of λ\nλ̅: previous solution of λ\nv: vector field of q\nv̅: vector field of q̅\nu: projective vector field of q\nu̅: projective vector field of q̅\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionODE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionODE","text":"Atomic solution for an ODE.\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\nv: vector field of q\nv̅: vector field of q̅\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionPDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionPDAE","text":"Atomic solution for an PDAE.\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\np: current solution of p\np̅: previous solution of p\np̃: compensated summation error of p\nλ: current solution of λ\nλ̅: previous solution of λ\nv: vector field of q\nv̅: vector field of q̅\nf: vector field of p\nf̅: vector field of p̅\nu: projective vector field of q\nu̅: projective vector field of q̅\ng: projective vector field of p\ng̅: projective vector field of p̅\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionPODE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionPODE","text":"Atomic solution for an PODE.\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\np: current solution of p\np̅: previous solution of p\np̃: compensated summation error of p\nv: vector field of q\nv̅: vector field of q̅\nf: vector field of p\nf̅: vector field of p̅\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionPSDE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionPSDE","text":"Atomic solution for an SDE.\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\np: current solution of p\np̅: previous solution of p\np̃: compensated summation error of p\nΔW: Wiener process driving the stochastic process q\nΔZ: Wiener process driving the stochastic process q\nK:  integer parameter defining the truncation of the increments of the Wiener process (for strong solutions)\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.AtomicSolutionSDE","page":"Solutions","title":"GeometricIntegrators.Solutions.AtomicSolutionSDE","text":"Atomic solution for an SDE.\n\nFields\n\nt: time of current time step\nt̅: time of previous time step\nq: current solution of q\nq̅: previous solution of q\nq̃: compensated summation error of q\nΔW: Wiener process driving the stochastic process q\nΔZ: Wiener process driving the stochastic process q\nK:  integer parameter defining the truncation of the increments of the Wiener process (for strong solutions)\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{AbstractEquationDAE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{AbstractEquationODE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{AbstractEquationPDAE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{AbstractEquationPODE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{Equation,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Print error for solutions of equations not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{SDE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for SDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.Solution-Tuple{Union{PSDE, SPSDE},Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.Solution","text":"Create solution for PSDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionDAE","text":"SolutionDAE: Solution of a differential algebraic equation\n\nContains all fields necessary to store the solution of an DAE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnm: dimension of the constraint submanifold\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\nλ:  Lagrange multiplier λ[nd, nt+1, ni]\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionODE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionODE","text":"SolutionODE: Solution of an ordinary differential equation\n\nContains all fields necessary to store the solution of an ODE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionPDAE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionPDAE","text":"SolutionPDAE: Solution of a partitioned differential algebraic equation\n\nContains all fields necessary to store the solution of an PDAE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnm: dimension of the constraint submanifold\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\np:  solution p[nd, nt+1, ni] with p[:,0,:] the initial conditions\nλ:  Lagrange multiplier λ[nd, nt+1, ni]\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionPODE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionPODE","text":"SolutionPODE: Solution of a partitioned ordinary differential equation\n\nContains all fields necessary to store the solution of an PODE.\n\nFields\n\nnd: dimension of the dynamical variable q\nnt: number of time steps to store\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ni] with q[:,0,:] the initial conditions\np:  solution p[nd, nt+1, ni] with p[:,0,:] the initial conditions\nntime: number of time steps to compute\nnsave: store every nsave'th time step (default: 1)\nnwrite: save data to disk after every nwrite'th time step (default: ntime)\ncounter: counter for copied solution entries\nwoffset: counter for file offset\nh5: HDF5 file for storage\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionPSDE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionPSDE","text":"SolutionPSDE: Solution of a partitioned stochastic differential equation\n\nContains all fields necessary to store the solution of a PSDE or SPSDE\n\nFields\n\nconv: type of the solution: :strong or :weak\nnd: dimension of the dynamical variable q\nnm: dimension of the Wiener process\nnt: number of time steps to store\nns: number of sample paths\nni: number of initial conditions\nt:  time steps\nq:  solution q[nd, nt+1, ns, ni] with q[:,0,:,:] the initial conditions\np:  solution p[nd, nt+1, ns, ni] with p[:,0,:,:] the initial conditions\nW:  Wiener process driving the stochastic processes q and p\nK:  integer parameter defining the truncation of the increments of the Wiener process (for strong solutions),\n  A = √(2 K Δt |log Δt|) due to Milstein & Tretyakov; if K=0 no truncation\nntime: number of time steps to compute\nnsave: save every nsave'th time step\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.SolutionSDE","page":"Solutions","title":"GeometricIntegrators.Solutions.SolutionSDE","text":"SolutionSDE: Solution of a stochastic differential equation\n\nContains all fields necessary to store the solution of an SDE.\n\nFields\n\nconv: type of the solution: :strong or :weak\nnd: dimension of the dynamical variable q\nnm: dimension of the Wiener process\nnt: number of time steps to store\nns: number of sample paths\nt:  time steps\nq:  solution q[nd, nt+1, ns] with q[:,0,:] the initial conditions\nW:  Wiener process driving the stochastic process q\nK:  integer parameter defining the truncation of the increments of the Wiener process (for strong solutions),\n  A = √(2 K Δt |log Δt|) due to Milstein & Tretyakov; if K=0 no truncation\nntime: number of time steps to compute\nnsave: save every nsave'th time step\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.WienerProcess","page":"Solutions","title":"GeometricIntegrators.Solutions.WienerProcess","text":"Type for holding the increments of a Wiener process\n\nFields:\n\nnd: dimension of the Wiener process\nnt: number of increments in the DataSeries\nns: number of sample paths of the Wiener process\nΔt: time increment of the TimeSeries\nΔW: variable storing the increments of the Wiener process over Δt, or the discrete random variable \\hat{I}\nΔZ: variable holding the time integral of the Wiener process \\int_{tk}^{tk+1} (W(t)-W(tk))dt, or the discrete random variable \\tilde{I}\n\nParameters:\n\ndType: type of the elements of the increments of the Wiener process\ntType: type of the time steps\nN:     the number of dimensions of the arrays holding data in ΔW and ΔZ\nCONV:  mode of convergence: :strong or :weak\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricIntegrators.CommonFunctions.write_to_hdf5","page":"Solutions","title":"GeometricIntegrators.CommonFunctions.write_to_hdf5","text":"Append solution to HDF5 file.\n\n\n\n\n\n","category":"function"},{"location":"modules/solutions/#GeometricIntegrators.CommonFunctions.write_to_hdf5-2","page":"Solutions","title":"GeometricIntegrators.CommonFunctions.write_to_hdf5","text":"Append solution to HDF5 file.   soffset - start writing the solution q at the position soffset+2   woffset - start writing the increments ΔW, ΔZ at the position woffset+1\n\n\n\n\n\n","category":"function"},{"location":"modules/solutions/#GeometricIntegrators.CommonFunctions.write_to_hdf5-3","page":"Solutions","title":"GeometricIntegrators.CommonFunctions.write_to_hdf5","text":"Append solution to HDF5 file.\n\n\n\n\n\n","category":"function"},{"location":"modules/solutions/#GeometricIntegrators.CommonFunctions.write_to_hdf5-Tuple{Solution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.CommonFunctions.write_to_hdf5","text":"Creates HDF5 file, writes solution to file, and closes file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.CommonFunctions.write_to_hdf5-Tuple{Solution}","page":"Solutions","title":"GeometricIntegrators.CommonFunctions.write_to_hdf5","text":"writetohdf5: Wrapper for saving Solution to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{AbstractEquationDAE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{AbstractEquationODE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{AbstractEquationPDAE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for partitioned DAE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{AbstractEquationPODE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for partitioned ODE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{Equation,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Print error for parallel solutions of equations not implemented, yet.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{SDE,Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for SDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.ParallelSolution-Tuple{Union{PSDE, SPSDE},Any,Int64}","page":"Solutions","title":"GeometricIntegrators.Solutions.ParallelSolution","text":"Create parallel solution for PSDE.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.copy_solution!-Tuple{Solution,AtomicSolution,Any,Any}","page":"Solutions","title":"GeometricIntegrators.Solutions.copy_solution!","text":"Copy solution from atomistic solution to solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.createHDF5-Tuple{Solution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.createHDF5","text":"createHDF5: Creates or opens HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.create_hdf5!-Tuple{Solution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.create_hdf5!","text":"Creates HDF5 file and initialises datasets for solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.create_hdf5-Tuple{DeterministicSolution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.create_hdf5","text":"Creates HDF5 file and initialises datasets for deterministic solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.create_hdf5-Tuple{StochasticSolution,AbstractString}","page":"Solutions","title":"GeometricIntegrators.Solutions.create_hdf5","text":"Creates HDF5 file and initialises datasets for stochastic solution object.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.save_attributes-Tuple{DeterministicSolution,HDF5.HDF5File}","page":"Solutions","title":"GeometricIntegrators.Solutions.save_attributes","text":"save_attributes: Saves attributes of Deterministic Solutions to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.save_attributes-Tuple{Solution}","page":"Solutions","title":"GeometricIntegrators.Solutions.save_attributes","text":"save_attributes: Saves common attributes of Solution to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solutions/#GeometricIntegrators.Solutions.save_attributes-Tuple{StochasticSolution,HDF5.HDF5File}","page":"Solutions","title":"GeometricIntegrators.Solutions.save_attributes","text":"save_attributes: Saves attributes of Stochastic Solutions to HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"modules/solvers_linear/#Linear-Solvers","page":"Linear Solvers","title":"Linear Solvers","text":"","category":"section"},{"location":"modules/solvers_linear/","page":"Linear Solvers","title":"Linear Solvers","text":"Modules = [GeometricIntegrators.Solvers]\nPages   = [\"solvers/linear/linear_solvers.jl\",\n           \"solvers/linear/lu_solver.jl\",\n           \"solvers/linear/lu_solver_lapack.jl\"]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/discontinuities/#Discontinuities","page":"Discontinuities","title":"Discontinuities","text":"","category":"section"},{"location":"modules/discontinuities/","page":"Discontinuities","title":"Discontinuities","text":"Modules = [GeometricIntegrators.Discontinuities]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/discontinuities/#GeometricIntegrators.Discontinuities.PathIntegralLinear","page":"Discontinuities","title":"GeometricIntegrators.Discontinuities.PathIntegralLinear","text":"PathIntegralLinear is a path integral along a linear path\n\nphi (tau q^- q^+) = (1-tau) q^- + tau q^+ \n\n\n\n\n\n","category":"type"},{"location":"modules/discontinuities/#GeometricIntegrators.Discontinuities.PathIntegralTrigonometric","page":"Discontinuities","title":"GeometricIntegrators.Discontinuities.PathIntegralTrigonometric","text":"PathIntegralTrigonometric is a path integral along a cos^2/sin^2 path\n\nphi (tau q^- q^+) = cos^2 (pi tau  2) q^- + sin^2 (pi tau  2) q^+ \n\n\n\n\n\n","category":"type"},{"location":"integrators/stochastic/#Stochastic-Integrators","page":"Stochastic","title":"Stochastic Integrators","text":"","category":"section"},{"location":"modules/interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"modules/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [GeometricIntegrators.Interpolation]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/interpolation/#GeometricIntegrators.Interpolation.HermiteInterpolation","page":"Interpolation","title":"GeometricIntegrators.Interpolation.HermiteInterpolation","text":"Hermite's Interpolating Polynomials\n\nHere, we implement a two point Hermite interpolation function which passes through the function and its first derivative for the interval 01. The polynomial is determined by four constraint equations, matching the function and its derivative at the points 0 and 1.\n\nStart by defining the 3rd degree polynomial and its derivative by\n\nbeginalign*\ng(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3  \ng(x) = a_1 + 2 a_2 x + 3 a_3 x^2 \nendalign*\n\nand apply the constraints\n\nbeginalign*\ng(0) = f_0   Rightarrow  a_0 = f_0  \ng(1) = f_1   Rightarrow  a_0 + a_1 + a_2 + a_3 = f_1  \ng(0) = f_0   Rightarrow  a_1 = f_0  \ng(1) = f_1   Rightarrow  a_1 + 2 a_2 + 3 a_3 = f_1  \nendalign*\n\nSolving for a_0 a_1 a_2 a_3 leads to\n\nbeginalign*\na_0 = f_0  \na_1 = f_0  \na_2 = - 3 f_0 + 3 f_1 - 2 f_0 - f_1  \na_3 = 2 f_0 - 2 f_1 + f_0 + f_1 \nendalign*\n\nso that the polynomial g(x) reads\n\ng(x) = f_0 + f_0 x + (- 3 f_0 + 3 f_1 - 2 f_0 - f_1) x^2 + (2 f_0 - 2 f_1 + f_0 + f_1) x^3 \n\nThe function and derivative values can be factored out, so that g(x) can be rewritten as\n\ng(x) = f_0 (1 - 3 x^2 + 2 x^3) + f_1 (3 x^2 - 2 x^3) + f_0 (x - 2 x^2 + x^3) + f_1 (- x^2 + x^3) \n\nor in generic form as\n\ng(x) = f_0 a_0(x) + f_1 a_1(x) + f_0 b_0(x) + f_1 b_1(x) \n\nwith basis functions\n\nbeginalign*\na_0 (x) = 1 - 3 x^2 + 2 x^3  \nb_0 (x) = x - 2 x^2 + x^3  \na_1 (x) = 3 x^2 - 2 x^3  \nb_1 (x) = - x^2 + x^3 \nendalign*\n\nThe derivative g(x) accordingly reads\n\ng(x) = f_0 a_0(x) + f_1 a_1(x) + f_0 b_0(x) + f_1 b_1(x) \n\nwith\n\nbeginalign*\na_0 (x) = - 6 x + 6 x^2  \nb_0 (x) = 1 - 4 x + 3 x^2  \na_1 (x) = 6 x - 6 x^2  \nb_1 (x) = - 2 x + 3 x^2 \nendalign*\n\nThe basis functions a_0and a_1 are associated with the function values at x_0 and x_1, respectively, while the basis functions b_0 and b_1 are associated with the derivative values at x_0 and x_1. The basis functions satisfy the following relations,\n\nbeginalign*\na_i (x_j) = delta_ij  \nb_i (x_j) = 0  \na_i (x_j) = 0  \nb_i (x_j) = delta_ij  \nij = 0 1 \nendalign*\n\nwhere delta_ij denotes the Kronecker-delta, so that\n\nbeginalign*\ng(0) = f_0  \ng(1) = f_1  \ng(0) = f_0  \ng(1) = f_1 \nendalign*\n\n\n\n\n\n","category":"type"},{"location":"integrators/hpg/#Hamilton-Pontryagin-Galerkin-Integrators","page":"HPG","title":"Hamilton-Pontryagin-Galerkin Integrators","text":"","category":"section"},{"location":"releasenotes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"releasenotes/#.4.0","page":"Release Notes","title":"0.4.0","text":"","category":"section"},{"location":"releasenotes/#New-Integrators","page":"Release Notes","title":"New Integrators","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Runge-Kutta integrators for implicit ODEs (FIRKimplicit and SRKimplicit)\nVariational Partitioned Runge-Kutta integrator with projection based on internal stages","category":"page"},{"location":"releasenotes/#Fixes","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Computation of initial guess in all implicit integrators","category":"page"},{"location":"modules/#Modules","page":"Modules","title":"Modules","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Pages = [\"modules/basis_functions.md\",\n         \"modules/quadratures.md\",\n         \"modules/discontinuities.md\",\n         \"modules/equations.md\",\n         \"modules/solutions.md\",\n         \"modules/integrators.md\",\n         \"modules/integrators_stochastic.md\",\n         \"modules/integrators_spark.md\",\n         \"modules/integrators_vprk.md\",\n         \"modules/interpolation.md\",\n         \"modules/solvers_linear.md\",\n         \"modules/solvers_nonlinear.md\",\n         \"modules/simulations.md\",\n         \"modules/tableaus.md\"]\nDepth = 3","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"author: \"Michael Kraus\" title: \"GeometricIntegrators.jl Tutorial\" –-","category":"page"},{"location":"tutorial/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/tutorial/#Introduction","page":"Tutorial","title":"Introduction","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In the simplest cases, the use of GeometricIntegrators.jl requires the construction of two objects, an equation and an integrator. For many standard methods, the integrator is implicitly selected by specifying an equation and a tableau.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Before any use, we need to load GeometricIntegrators,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeometricIntegrators","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Then we can create an ODE object for the equation dotx (t) = x(t) with initial condition x(0) = 1,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\node = ODE((t, x, ẋ) -> ẋ[1] = x[1], [1.0]);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ODE{Float64,Float64,Main.##WeaveSandBox#422.var\"#1#2\",Nothing,Nothing,1}(1,\n 1, Main.##WeaveSandBox#422.var\"#1#2\"(), nothing, 0.0, [1.0], nothing, [0.0\n])","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"create an integrator for this ODE, using the tableau for the explicit Euler method and a time step of Delta t = 01,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\nint = Integrator(ode, getTableauExplicitEuler(), 0.1);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"IntegratorERK{Float64,Float64,1,1,NamedTuple{(:v,),Tuple{Main.##WeaveSandBo\nx#422.var\"#1#2\"}}}(GeometricIntegrators.Integrators.ParametersERK{Float64,F\nloat64,1,1,NamedTuple{(:v,),Tuple{Main.##WeaveSandBox#422.var\"#1#2\"}}}((v =\n Main.##WeaveSandBox#422.var\"#1#2\"(),), TableauERK{Float64}(:explicit_euler\n, 1, 1, Runge-Kutta Coefficients explicit_euler with 1 stages and order 1  \na = [0.0]  b = [1.0]  c = [0.0]), 0.1), GeometricIntegrators.Integrators.Ca\ncheDict{GeometricIntegrators.Integrators.ParametersERK{Float64,Float64,1,1,\nNamedTuple{(:v,),Tuple{Main.##WeaveSandBox#422.var\"#1#2\"}}}}(GeometricInteg\nrators.Integrators.ParametersERK{Float64,Float64,1,1,NamedTuple{(:v,),Tuple\n{Main.##WeaveSandBox#422.var\"#1#2\"}}}((v = Main.##WeaveSandBox#422.var\"#1#2\n\"(),), TableauERK{Float64}(:explicit_euler, 1, 1, Runge-Kutta Coefficients \nexplicit_euler with 1 stages and order 1  a = [0.0]  b = [1.0]  c = [0.0]),\n 0.1), Dict{UInt64,IntegratorCache}()))","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"and compute the solution for n_t = 10 time steps,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\nsol = integrate(ode, int, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"SSolutionODE{Float64,Float64,2}(1, 10, 1, [0.1, 0.2, 0.30000000000000004, 0\n.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1.0, #undef], Da\ntaSeries with data type Float64 and 2 dimensions:\n[1.0 1.1 … 2.357947691 2.5937424601], 10, 1, 10, [11], 0, [0.0], #undef)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Plot and compare with the exact solution","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\nusing Plots\nplot(xlim=[0,1], xlab=\"t\", ylab=\"x(t)\", legend=:bottomright)\nplot!(sol.t.t, sol.q.d[1,:], label=\"numeric\")\nplot!(sol.t.t, exp.(sol.t.t), label=\"exact\")","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/tutorial/#Equations","page":"Tutorial","title":"Equations","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In GeometricIntegrators.jl we distinguish between three basic types of equations:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ordinary differential equations (ODEs),\ndifferential algebraic equations (DAEs),\nstochastic differential equations (SDEs).","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"For each type, there are several subtypes","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\"normal\" equations (ODE, DAE, SDE),\nimplicit equations (IODE, IDAE),\nvariational equations (VODE, VDAE),\nHamiltonian equations (HODE, HDAE),\npartitioned equations (PODE, PDAE, PSDE),\nsplit equations (SODE, SPDAE).","category":"page"},{"location":"tutorial/tutorial/#Ordinary-differential-equations","page":"Tutorial","title":"Ordinary differential equations","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Consider an ODE of the form","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"dotx (t) = f(t x(t)) ","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"where dotx denotes the derivative of x and f the vector field of the equation, which is assumed to depend on both t and x. In the following, we will solve the mathematical pendulum, whose equations are given by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"beginpmatrix\ndotx_1 \ndotx_2 \nendpmatrix\n=\nbeginpmatrix\nx_2 \nsin (x_1) \nendpmatrix ","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Creating an ODE object requires the prescription of a function that computes the vector field f, e.g.,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\nfunction ẋ(t, x, v)\n    v[1] = x[2]\n    v[2] = sin(x[1])\nend","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ẋ (generic function with 1 method)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"which has to take three arguments, the current time t, the current solution vector x and the output vector f. Moreover, we need a set of initial conditions,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\nx₀ = [acos(0.4), 0.0]","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"2-element Array{Float64,1}:\n 1.1592794807274085\n 0.0","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"An ODE object is than instantiated by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ODE(<vector field>, <initial conditions>)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"specifically,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\node = ODE(ẋ, x₀);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ODE{Float64,Float64,typeof(Main.##WeaveSandBox#422.ẋ),Nothing,Nothing,1}(2,\n 1, Main.##WeaveSandBox#422.ẋ, nothing, 0.0, [1.1592794807274085, 0.0], not\nhing, [0.0, 0.0])","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The initial time, ode.t₀ is assumed to be 0 be default. It can also be specified explicitly by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\nt₀  = 1.0\node = ODE(ẋ, t₀, x₀);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"ODE{Float64,Float64,typeof(Main.##WeaveSandBox#422.ẋ),Nothing,Nothing,1}(2,\n 1, Main.##WeaveSandBox#422.ẋ, nothing, 1.0, [1.1592794807274085, 0.0], not\nhing, [0.0, 0.0])","category":"page"},{"location":"tutorial/tutorial/#Partitioned-ordinary-differential-equations","page":"Tutorial","title":"Partitioned ordinary differential equations","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The pendulum problem is a Hamiltonian system that can also be expressed as","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"dotq = fracpartial Hpartial p = p \nhspace3em\ndotp = - fracpartial Hpartial q = sin (q) \nhspace3em\nH (qp) = frac12 p^2 + cos (q) ","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"This structure, namely the partitioning into two sets of variables (qp) instead of x, can be exploited for more efficient integration. Such equations can be defined in terms of a partitioned ODE, where the vector fields are specified separately,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\nfunction q̇(t, q, p, v)\n    v[1] = p[1]\nend\n\nfunction ṗ(t, q, p, f)\n    f[1] = sin(q[1])\nend\n\npode = PODE(q̇, ṗ, [acos(0.4)], [0.0]);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"PODE{Float64,Float64,typeof(Main.##WeaveSandBox#422.q̇),typeof(Main.##Weave\nSandBox#422.ṗ),Nothing,Nothing,1}(1, 1, Main.##WeaveSandBox#422.q̇, Main.##\nWeaveSandBox#422.ṗ, nothing, 0.0, [1.1592794807274085], [0.0], nothing, [0.\n0])","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The first two arguments to the PODE constructor are the functions that determine the vector fields of the equations dotq (t) = v(t q(t) p(t)) and dotp (t) = f(t q(t) p(t)). The third and fourth argument determines the initial conditions of q and p, respectively. The functions defining the vector field have to take four arguments, the current time t, the current solution vectors q and p and the output vector v or f.","category":"page"},{"location":"tutorial/tutorial/#Integrators","page":"Tutorial","title":"Integrators","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"We support a number of standard integrators (geometric and non-geometric) like explicit, implicit and partitioned Runge-Kutta methods, splitting methods and general linear methods (planned).","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to instantiate many of the standard integrators, one needs to specify an ODE, a tableau and a timestep, e.g.,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\nint = Integrator(ode, getTableauExplicitEuler(), 0.1);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"IntegratorERK{Float64,Float64,2,1,NamedTuple{(:v,),Tuple{typeof(Main.##Weav\neSandBox#422.ẋ)}}}(GeometricIntegrators.Integrators.ParametersERK{Float64,F\nloat64,2,1,NamedTuple{(:v,),Tuple{typeof(Main.##WeaveSandBox#422.ẋ)}}}((v =\n Main.##WeaveSandBox#422.ẋ,), TableauERK{Float64}(:explicit_euler, 1, 1, Ru\nnge-Kutta Coefficients explicit_euler with 1 stages and order 1  a = [0.0] \n b = [1.0]  c = [0.0]), 0.1), GeometricIntegrators.Integrators.CacheDict{Ge\nometricIntegrators.Integrators.ParametersERK{Float64,Float64,2,1,NamedTuple\n{(:v,),Tuple{typeof(Main.##WeaveSandBox#422.ẋ)}}}}(GeometricIntegrators.Int\negrators.ParametersERK{Float64,Float64,2,1,NamedTuple{(:v,),Tuple{typeof(Ma\nin.##WeaveSandBox#422.ẋ)}}}((v = Main.##WeaveSandBox#422.ẋ,), TableauERK{Fl\noat64}(:explicit_euler, 1, 1, Runge-Kutta Coefficients explicit_euler with \n1 stages and order 1  a = [0.0]  b = [1.0]  c = [0.0]), 0.1), Dict{UInt64,I\nntegratorCache}()))","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to run the integrator, the integrate() functions is called, passing an integrator object and the number of time steps to integrate:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\nsol = integrate(ode, int, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"SSolutionODE{Float64,Float64,2}(2, 10, 1, [1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.\n7000000000000002, 1.8, 1.9, 2.0, #undef], DataSeries with data type Float64\n and 2 dimensions:\n[1.1592794807274085 1.1592794807274085 … 1.4933089381704785 1.5782527524424\n927; 0.0 0.0916515138991168 … 0.8494381427201427 0.9491380781351366], 10, 1\n, 10, [11], 0, [0.0, 0.0], #undef)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"The integrate function automatically creates an appropriate solution object, that contains the result of the integration.","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"For a Hamiltonian system, defined as a PODE, a different tableau might be more appropriate, for example a symplectic Euler method,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\nint = Integrator(pode, getTableauSymplecticEulerA(), 0.1)\nsol = integrate(pode, int, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"SSolutionPODE{Float64,Float64,2}(1, 10, 1, [0.1, 0.2, 0.30000000000000004, \n0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1.0, #undef], D\nataSeries with data type Float64 and 2 dimensions:\n[1.1592794807274085 1.1592794807274085 … 1.495787179740738 1.58154640667814\n46], DataSeries with data type Float64 and 2 dimensions:\n[0.0 0.0916515138991168 … 0.8575922693740649 0.957586491218836], 10, 1, 10,\n [11], 0, [0.0], #undef)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"This creates a different integrator, which exploits the partitioned structure of the system. The solution return by the integrate step will also be a different solution, adapted to the partitioned system.","category":"page"},{"location":"tutorial/tutorial/#Tableaus","page":"Tutorial","title":"Tableaus","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Many tableaus for Runge-Kutta methods are predefined and can easily be used like outlined above. In particular, this includes the following methods:","category":"page"},{"location":"tutorial/tutorial/#Explicit-Runge-Kutta-Methods","page":"Tutorial","title":"Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\ngetTableauExplicitEuler() 1 Explicit / Forward Euler\ngetTableauExplicitMidpoint() 2 Explicit Midpoint\ngetTableauHeun() 2 Heun's Method\ngetTableauKutta() 3 Kutta's Method\ngetTableauERK4() 4 Explicit 4th order Runge-Kutta (1/6 rule)\ngetTableauERK438() 4 Explicit 4th order Runge-Kutta (3/8 rule)","category":"page"},{"location":"tutorial/tutorial/#Fully-Implicit-Runge-Kutta-Methods","page":"Tutorial","title":"Fully Implicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\ngetTableauImplicitEuler() 1 Implicit / Backward Euler\ngetTableauImplicitMidpoint() 2 Implicit Midpoint\ngetTableauRadIIA2() 3 Radau-IIA s=2\ngetTableauRadIIA3() 5 Radau-IIA s=3\ngetTableauSRK3() 4 Symmetric Runge-Kutta s=3\ngetTableauGLRK(s) 2s Gauss-Legendre Runge-Kutta","category":"page"},{"location":"tutorial/tutorial/#Explicit-Partitioned-Runge-Kutta-Methods","page":"Tutorial","title":"Explicit Partitioned Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\ngetTableauSymplecticEulerA() 1 Symplectic Euler A\ngetTableauSymplecticEulerB() 1 Symplectic Euler B\ngetTableauLobattoIIIAIIIB2() 2 Lobatto-IIIA-IIIB\ngetTableauLobattoIIIBIIIA2() 2 Lobatto-IIIB-IIIA","category":"page"},{"location":"tutorial/tutorial/#Custom-Tableaus","page":"Tutorial","title":"Custom Tableaus","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"If required, it is straight-forward to create a custom tableau. The tableau of Heun's method, for example, is defined as follows:","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\na = [[0.0 0.0]\n     [1.0 0.0]]\nb = [0.5, 0.5]\nc = [0.0, 1.0]\no = 2\n\ntab = TableauERK(:heun, o, a, b, c)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"TableauERK{Float64}(:heun, 2, 2, Runge-Kutta Coefficients heun with 2 stage\ns and order 2  a = [0.0 0.0; 1.0 0.0]  b = [0.5, 0.5]  c = [0.0, 1.0])","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, o is the order of the method, a are the coefficients, b the weights and c the nodes. TableauERK states that the method is explicit. Other choices include TableauFIRK for fully implicit Runge-Kutta methods, TableauDIRK for diagonally implicit and TableauSIRK for singly implicit Runge-Kutta methods. TableauEPRK and TableauIPRK can be used for explicit and implicit partitioned Runge-Kutta methods. The first parameter of the constructor of each tableau assigns a name to the tableau. Such custom tableaus can be used in exactly the same as standard tableaus, e.g., by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\nint = Integrator(ode, tab, 0.1)\nsol = integrate(ode, int, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"SSolutionODE{Float64,Float64,2}(2, 10, 1, [1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.\n7000000000000002, 1.8, 1.9, 2.0, #undef], DataSeries with data type Float64\n and 2 dimensions:\n[1.1592794807274085 1.1638620564223643 … 1.5384377274167502 1.6291711802405\n64; 0.0 0.0916515138991168 … 0.8573607029279458 0.9572633162883342], 10, 1,\n 10, [11], 0, [0.0, 0.0], #undef)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"making it very easy to implement and test new methods.","category":"page"},{"location":"tutorial/tutorial/#Solutions","page":"Tutorial","title":"Solutions","text":"","category":"section"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"In what we have seen so far, the solution was always automatically created by the integrate() function. While this is often convenient, it is sometimes not performant, e.g., when carrying out long-time simulations with intermediate saving of the solution. In such cases, it is better to preallocate a solution object by","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"\nsol = Solution(ode, 0.1, 10);","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"SSolutionODE{Float64,Float64,2}(2, 10, 1, [1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.\n7000000000000002, 1.8, 1.9, 2.0, #undef], DataSeries with data type Float64\n and 2 dimensions:\n[1.1592794807274085 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], 10, 1, 10, [1], 0, [\n0.0, 0.0], #undef)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"where the first argument is an equation, the second argument is the time step and the third argument is the number of time steps that will be computed in one integration step. The call to the integrator is then made via","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"integrate!(int, sol)","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"If several integration cycles shall be performed, the reset!() function can be used to copy the solution of the last time step to the initial conditions of the solution,","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"for i in 1:10\n    # integrate!(int, sol)\n    #\n    # save or process solution\n    #\n    # reset!(sol)\nend","category":"page"},{"location":"tutorial/tutorial/","page":"Tutorial","title":"Tutorial","text":"All solutions have a t field holding the series of time steps that has been computed in addition to several data fields, for example q for an ODE solution, q and p for a PODE solution, qand λ for a DAE solution, and q, p and λ for a PDAE solution.","category":"page"},{"location":"modules/equations/#Equations","page":"Equations","title":"Equations","text":"","category":"section"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"Modules = [GeometricIntegrators.Equations]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/equations/#GeometricIntegrators.Equations.DAE","page":"Equations","title":"GeometricIntegrators.Equations.DAE","text":"DAE: Differential Algebraic Equation\n\nDefines a differential algebraic initial value problem\n\nbeginalign*\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))   q(t_0) = q_0  \n0 = phi (t q(t) lambda(t))   lambda(t_0) = lambda_0 \nendalign*\n\nwith vector field v, projection u, algebraic constraint phi=0, initial conditions q_0 and lambda_0, the dynamical variable q taking values in mathbbR^m and the algebraic variable lambda taking values in mathbbR^n.\n\nFields\n\nd: dimension of dynamical variable q and the vector field v\nm: dimension of algebraic variable lambda and the constraint phi\nn: number of initial conditions\nv: function computing the vector field\nu: function computing the projection\nϕ: algebraic constraint\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition for dynamical variable q\nλ₀: initial condition for algebraic variable lambda\n\nThe function v, providing the vector field, takes three arguments, v(t, q, v), the functions u and ϕ, providing the projection and the algebraic constraint take four arguments, u(t, q, λ, u) and ϕ(t, q, λ, ϕ), where t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nExample\n\n    function v(t, q, v)\n        v[1] = q[1]\n        v[2] = q[2]\n    end\n\n    function u(t, q, λ, u)\n        u[1] = +λ[1]\n        u[2] = -λ[1]\n    end\n\n    function ϕ(t, q, λ, ϕ)\n        ϕ[1] = q[2] - q[1]\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ₀ = [0.]\n\n    dae = DAE(v, u, ϕ, t₀, q₀, λ₀)\n\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.HDAE","page":"Equations","title":"GeometricIntegrators.Equations.HDAE","text":"HDAE: Hamiltonian Differential Algebraic Equation EXPERIMENTAL\n\nDefines a Hamiltonian differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginalign*\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + barg(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barf(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendalign*\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qplambda)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^n times mathbbR^d.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nm: dimension of algebraic variables lambda and gamma and the constraints phi and psi\nn: number of initial conditions\nv: function computing the Hamiltonian vector field v\nf: function computing the Hamiltonian vector field f\nu: function computing the primary projection field u\ng: function computing the primary projection field g\nu̅: function computing the secondary projection field u\ng̅: function computing the secondary projection field g\nϕ: primary constraints\nψ: secondary constraints\nh: function computing the Hamiltonian H\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable λ\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.HODE","page":"Equations","title":"GeometricIntegrators.Equations.HODE","text":"HODE: Hamiltonian Ordinary Differential Equation EXPERIMENTAL\n\nDefines a Hamiltonian ordinary differential initial value problem, that is a canonical Hamiltonian system of equations,\n\nbeginalign*\ndotq (t) = v(t q(t) p(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))   p(t_0) = p_0 \nendalign*\n\nwith vector fields v and f, given by\n\nbeginalign*\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendalign*\n\ninitial conditions (q_0 p_0) and the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nn: number of initial conditions\nv: function computing the vector field v\nf: function computing the vector field f\nh: function computing the Hamiltonian H\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.IDAE","page":"Equations","title":"GeometricIntegrators.Equations.IDAE","text":"IDAE: Implicit Differential Algebraic Equation\n\nDefines a partitioned differential algebraic initial value problem\n\nbeginalign*\ndotq (t) = v(t) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + r(t q(t) p(t) lambda(t))   p(t_0) = p_0  \np(t) = p(t q(t) v(t))   \n0 = phi (t q(t) p(t) lambda(t))   lambda(t_0) = lambda_0 \nendalign*\n\nwith vector field f, the momentum defined by p, projection u and r, algebraic constraint phi=0, conditions (q_0 p_0) and lambda_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variable lambda taking values in mathbbR^n.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nm: dimension of algebraic variable lambda and the constraint phi\nn: number of initial conditions\nϑ: function determining the momentum\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraint\nh: function computing the Hamiltonian (optional)\nv: function computing an initial guess for the velocity field (optional)\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable lambda\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.IODE","page":"Equations","title":"GeometricIntegrators.Equations.IODE","text":"IODE: Implicit Ordinary Differential Equation\n\nDefines an implicit initial value problem\n\nbeginalign*\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendalign*\n\nwith vector field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by ∇ϑ(q)λ\nh: function computing the Hamiltonian (optional)\nv: function computing an initial guess for the velocity field (optional)\nt₀: initial time (optional)\nq₀: initial condition for q\np₀: initial condition for p\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(t, q, v, p)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. In addition, two functions g and v are specified by\n\n    function g(t, q, λ, g)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\nand\n\n    function v(t, q, p, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nThe function v is used for initial guesses in nonlinear implicit solvers. The function g is used in projection methods that enforce p = ϑ(q).\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.ODE","page":"Equations","title":"GeometricIntegrators.Equations.ODE","text":"ODE: Ordinary Differential Equation\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d.\n\nFields\n\nd: dimension of dynamical variable q and the vector field v\nn: number of initial conditions\nv: function computing the vector field\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition\n\nThe function v providing the vector field must have the interface\n\n    function v(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, and v is the vector which holds the result of evaluating the vector field v on t and q.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.PDAE","page":"Equations","title":"GeometricIntegrators.Equations.PDAE","text":"PDAE: Partitioned Differential Algebraic Equation\n\nDefines a partitioned differential algebraic initial value problem\n\nbeginalign*\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + r(t q(t) p(t) lambda(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t) lambda(t))   lambda(t_0) = lambda_0 \nendalign*\n\nwith vector fields v and f, projection u and r, algebraic constraint phi=0, conditions (q_0 p_0) and lambda_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variable lambda taking values in mathbbR^n.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nm: dimension of algebraic variable lambda and the constraint phi\nn: number of initial conditions\nv: function computing the vector field v\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraint\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable lambda\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.PODE","page":"Equations","title":"GeometricIntegrators.Equations.PODE","text":"PODE: Partitioned Ordinary Differential Equation\n\nDefines a partitioned initial value problem\n\nbeginalign*\ndotq (t) = v(t q(t) p(t))  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))  \np(t_0) = p_0 \nendalign*\n\nwith vector fields v and f, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nv: function computing the vector field v\nf: function computing the vector field f\nh: function computing the Hamiltonian (optional)\nt₀: initial time\nq₀: initial condition for q\np₀: initial condition for p\n\nThe functions v and f must have the interface\n\n    function v(t, q, p, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, p, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q and p are the current solution vectors and v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.PSDE","page":"Equations","title":"GeometricIntegrators.Equations.PSDE","text":"PSDE: Stratonovich Partitioned Stochastic Differential Equation\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginalign*\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \ndp (t) = f(t q(t))  dt + G(t q(t)) circ dW   p(t_0) = p_0\nendalign*\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nFields\n\nd:  dimension of dynamical variable q and the vector field v\nm:  dimension of the Wiener process\nni: number of initial conditions\nns: number of sample paths\nv:  function computing the drift vector field for the position variable q\nf:  function computing the drift vector field for the momentum variable p\nB:  function computing the d x m diffusion matrix for the position variable q\nG:  function computing the d x m diffusion matrix for the momentum variable p\nt₀: initial time\nq₀: initial condition for dynamical variable q (may be a random variable itself)\np₀: initial condition for dynamical variable p (may be a random variable itself)\n\nThe functions v, f, 'B' and G, providing the drift vector fields and diffusion matrices, take four arguments, v(t, q, p, v), f(t, q, p, f), B(t, q, p,  B) and G(t, q, p, G), where t is the current time, (q, p) is the current solution vector, and v, f, 'B' and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p).\n\nExample\n\n    function v(λ, t, q, v)\n        v[1] = λ*q[1]\n        v[2] = λ*q[2]\n    end\n\n    function B(μ, t, q, B)\n        B[1] = μ*q[1]\n        B[2] = μ*q[2]\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ  = 2.\n    μ  = 1.\n\n    v_sde = (t, q, v) -> v(λ, t, q, v)\n    B_sde = (t, q, B) -> B(μ, t, q, B)\n\n    sde = SDE(v_sde, B_sde, t₀, q₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SDE","page":"Equations","title":"GeometricIntegrators.Equations.SDE","text":"SDE: Stratonovich Stochastic Differential Equation\n\nDefines a stochastic differential initial value problem\n\nbeginalign*\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendalign*\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nFields\n\nd:  dimension of dynamical variable q and the vector field v\nm:  dimension of the Wiener process\nni: number of initial conditions\nns: number of sample paths\nv:  function computing the deterministic vector field\nB:  function computing the d x m diffusion matrix\nt₀: initial time\nq₀: initial condition for dynamical variable q (may be a random variable itself)\n\nParameters\n\nN: dimension of nitial condition array: N=1 - single, N=2 - multiple\n\nThe functions v and B, providing the drift vector field and diffusion matrix, v(t, q, v) and B(t, q, B, col=0), where t is the current time, q is the current solution vector, and v and B are the variables which hold the result of evaluating the vector field v and the matrix B on t and q (if col==0), or the column col of the matrix B (if col>0).\n\nExample\n\n    function v(t, q, v, p)\n        λ = p[:λ]\n        v[1] = λ*q[1]\n        v[2] = λ*q[2]\n    end\n\n    function B(t, q, B, p, col=0)\n        μ = p[:μ]\n        if col==0 #whole matrix\n            B[1,1] = μ*q[1]\n            B[2,1] = μ*q[2]\n        elseif col==1\n            #just first column\n        end\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ  = 2.\n    μ  = 1.\n    p = (λ=λ, μ=μ)\n\n    sde = SDE(v, B, t₀, q₀; parameters=p)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SODE","page":"Equations","title":"GeometricIntegrators.Equations.SODE","text":"SODE: Split Ordinary Differential Equation\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nFields\n\nd: dimension of dynamical variable q and the vector field v\nv: tuple of functions computing the vector field\nq: tuple of functions computing the solution\nt₀: initial time\nq₀: initial condition\n\nThe functions v_i providing the vector field must have the interface\n\n    function v_i(t, q, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nand the functions q_i providing the solutions must have the interface\n\n    function q_i(t, q₀, q₁, h)\n        q₁[1] = q₀[1] + ...\n        q₁[2] = q₀[2] + ...\n        ...\n    end\n\nwhere t is the current time, q₀ is the current solution vector, q₁ is the new solution vector which holds the result of computing one substep with the vector field v_i on t and q₀, and h is the (sub-)timestep to compute the update for.\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SPDAE","page":"Equations","title":"GeometricIntegrators.Equations.SPDAE","text":"SPDAE: Split Partitioned Differential Algebraic Equation EXPERIMENTAL\n\nDefines a split differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginalign*\ndotq (t) = v_1(t q(t) p(t)) + v_2(t q(t) p(t) lambda(t)) + v_3(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f_1(t q(t) p(t)) + f_2(t q(t) p(t) lambda(t)) + f_3(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendalign*\n\nwith vector fields v_i and f_i for i = 1  3, primary constraint phi(qp)=0 and secondary constraint psi(qplambda)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^n times mathbbR^d.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields v and f\nm: dimension of algebraic variables lambda and gamma and the constraints phi and psi\nn: number of initial conditions\nv: tuple of functions computing the vector fields v_i, i = 1  3\nf: tuple of functions computing the vector fields f_i, i = 1  3\nϕ: primary constraints\nψ: secondary constraints\nt₀: initial time\nq₀: initial condition for dynamical variable q\np₀: initial condition for dynamical variable p\nλ₀: initial condition for algebraic variable λ\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.SPSDE","page":"Equations","title":"GeometricIntegrators.Equations.SPSDE","text":"SPSDE: Stratonovich Split Partitioned Stochastic Differential Equation\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginalign*\ndq (t) =   v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \ndp (t) =  f1(t q(t)) + f2(t q(t))   dt +  G1(t q(t)) + G2(t q(t))  circ dW   p(t_0) = p_0\nendalign*\n\nwith the drift vector fields v and fi, diffusion matrices B and Gi, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nFields\n\nd:  dimension of dynamical variable q and the vector fields vi\nm:  dimension of the Wiener process\nni: number of initial conditions\nns: number of sample paths\nv :  function computing the drift vector field for the position variable q\nf1:  function computing the drift vector field for the momentum variable p\nf2:  function computing the drift vector field for the momentum variable p\nB :  function computing the d x m diffusion matrix for the position variable q\nG1:  function computing the d x m diffusion matrix for the momentum variable p\nG2:  function computing the d x m diffusion matrix for the momentum variable p\nt₀: initial time\nq₀: initial condition for dynamical variable q (may be a random variable itself)\np₀: initial condition for dynamical variable p (may be a random variable itself)\n\nThe functions v, f, 'B' and G, providing the drift vector fields and diffusion matrices, take four arguments, v(t, q, p, v), f(t, q, p, f), B(t, q, p,  B) and G(t, q, p, G), where t is the current time, (q, p) is the current solution vector, and v, f, 'B' and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p).\n\nExample\n\n    function v(λ, t, q, v)\n        v[1] = λ*q[1]\n        v[2] = λ*q[2]\n    end\n\n    function B(μ, t, q, B)\n        B[1] = μ*q[1]\n        B[2] = μ*q[2]\n    end\n\n    t₀ = 0.\n    q₀ = [1., 1.]\n    λ  = 2.\n    μ  = 1.\n\n    v_sde = (t, q, v) -> v(λ, t, q, v)\n    B_sde = (t, q, B) -> B(μ, t, q, B)\n\n    sde = SDE(v_sde, B_sde, t₀, q₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.VDAE","page":"Equations","title":"GeometricIntegrators.Equations.VDAE","text":"VDAE: Variational Differential Algebraic Equation EXPERIMENTAL\n\nDefines an implicit initial value problem\n\nbeginalign*\ndotq (t) = v(t) + λ(t) \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) λ(t)) + obarg(t q(t) μ(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendalign*\n\nwith vector field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (v lambda mu) taking values in mathbbR^d times mathbbR^d times mathbbR^m. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and mu.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the primary projection, usually given by ∇ϑ(q)⋅λ\ng̅: function determining the secondary projection, usually given by λ⋅∇ϑ(q)\nϕ: primary constraints, usually given by p-ϑ(q)\nψ: secondary constraints, usually given by ṗ-q̇⋅∇ϑ(q)\nh: function computing the Hamiltonian (optional)\nv: function computing an initial guess for the velocity field (optional)\nΩ: symplectic matrix (optional)\n∇H: gradient of the Hamiltonian (optional)\nt₀: initial time (optional)\nq₀: initial condition for q\np₀: initial condition for p\nλ₀: initial condition for λ (optional)\nμ₀: initial condition for μ (optional)\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(t, q, v, p)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g and v are specified by\n\n    function g(t, q, λ, g)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\nand\n\n    function v(t, q, p, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricIntegrators.Equations.VODE","page":"Equations","title":"GeometricIntegrators.Equations.VODE","text":"VODE: Variational Ordinary Differential Equation EXPERIMENTAL\n\nDefines an implicit initial value problem\n\nbeginalign*\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendalign*\n\nwith vector field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v.\n\nFields\n\nd: dimension of dynamical variables q and p as well as the vector fields f and p\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by ∇ϑ(q)⋅λ\nh: function computing the Hamiltonian (optional)\nv: function computing an initial guess for the velocity field (optional)\nΩ: symplectic matrix (optional)\n∇H: gradient of the Hamiltonian (optional)\nt₀: initial time (optional)\nq₀: initial condition for q\np₀: initial condition for p\nλ₀: initial condition for λ (optional)\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(t, q, v, p)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(t, q, v, f)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g and v are specified by\n\n    function g(t, q, λ, g)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\nand\n\n    function v(t, q, p, v)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n\n\n\n\n","category":"type"},{"location":"integrators/vprk/#Variational-Partitioned-Runge-Kutta-Integrators","page":"VPRK","title":"Variational Partitioned Runge-Kutta Integrators","text":"","category":"section"},{"location":"modules/tableaus/#Tableaus","page":"Tableaus","title":"Tableaus","text":"","category":"section"},{"location":"modules/tableaus/","page":"Tableaus","title":"Tableaus","text":"Modules = [GeometricIntegrators.Tableaus]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauBurrageCL-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauBurrageCL","text":"Tableau for the explicit 4-stage CL method due to K. Burrage and P. Burrage   Method cited in Eq. (56) in    K. Burrage, P. Burrage (1996) \"High strong order explicit Runge-Kutta methods for stochastic ordinary differential equations\".   According to the paper, the method has strong order 1.5 for one-dimensional Brownian motion. Reduces to the classical R-K method   of order 4 when noise is zero.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauBurrageE1-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauBurrageE1","text":"Tableau for the explicit 4-stage E1 method due to K. Burrage and P. Burrage   Method cited in Eq. (4.2)-(4.3) in    K. Burrage, P. Burrage (2000) \"Order conditions for stochastic Runge-Kutta methods by B-series\".   According to the paper, the method has strong order 1.0 for one-dimensional Brownian motion.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauBurrageG5-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauBurrageG5","text":"Tableau for the explicit 5-stage G5 method due to K. Burrage and P. Burrage   Method cited in Section 4 of    K. Burrage, P. Burrage (2000) \"Order conditions for stochastic Runge-Kutta methods by B-series\".   According to the paper, the method has strong order 1.5 for one-dimensional Brownian motion.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauBurrageR2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauBurrageR2","text":"Tableau for the explicit 2-stage R2 method due to K. Burrage and P. Burrage   Method cited in Eq. (51) in    K. Burrage, P. Burrage (1996) \"High strong order explicit Runge-Kutta methods for stochastic ordinary differential equations\".   According to the paper, the method has strong order 1.0 for one-dimensional Brownian motion\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauERK4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauERK4","text":"Tableau for explicit Runge-Kutta method of order four (1/6 rule)\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauERK438-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauERK438","text":"Tableau for explicit Runge-Kutta method of order four (3/8 rule)\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauExplicitEuler-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauExplicitEuler","text":"Tableau for explicit Euler method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauExplicitMidpoint-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauExplicitMidpoint","text":"Tableau for explicit midpoint method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauGLRK-Tuple{Int64}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauGLRK","text":"Gauss-Legendre Runge-Kutta\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauGLRKpSymplectic-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauGLRKpSymplectic","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauHPARKGLRK-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauHPARKGLRK","text":"Tableau for Gauss-Legendre HPARK method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauHPARKLobIIIAIIIB2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauHPARKLobIIIAIIIB2","text":"Tableau for Gauss-Lobatto IIIA-IIIB HPARK method with two stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauHPARKLobIIIAIIIB3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauHPARKLobIIIAIIIB3","text":"Tableau for Gauss-Lobatto IIIA-IIIB HPARK method with three stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauHPARKLobIIIAIIIB4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauHPARKLobIIIAIIIB4","text":"Tableau for Gauss-Lobatto IIIA-IIIB HPARK method with four stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauHSPARKGLRKpSymmetric-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauHSPARKGLRKpSymmetric","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauHSPARKLobIIIAIIIB2pSymmetric-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauHSPARKLobIIIAIIIB2pSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with two stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauHSPARKLobIIIAIIIB3pSymmetric-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauHSPARKLobIIIAIIIB3pSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with three stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauHSPARKLobIIIAIIIB4pSymmetric-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauHSPARKLobIIIAIIIB4pSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with four stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauHeun-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauHeun","text":"Tableau for Heun's method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauImplicitEuler-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauImplicitEuler","text":"Implicit Euler\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauImplicitMidpoint-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauImplicitMidpoint","text":"Implicit Midpoint\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauKutta-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauKutta","text":"Tableau for Kutta's method of order three\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIA2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIA2","text":"Gauss-Lobatto-IIIA Runge-Kutta, s=2\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIA3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIA3","text":"Gauss-Lobatto-IIIA Runge-Kutta, s=3\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIA4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIA4","text":"Gauss-Lobatto-IIIA Runge-Kutta, s=4\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIAIIIB2pSymplectic-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIAIIIB2pSymplectic","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with two stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIAIIIB3pSymplectic-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIAIIIB3pSymplectic","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with three stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIAIIIB4pSymplectic-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIAIIIB4pSymplectic","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with four stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIB2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIB2","text":"Gauss-Lobatto-IIIB Runge-Kutta, s=2\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIB3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIB3","text":"Gauss-Lobatto-IIIB Runge-Kutta, s=3\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIB4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIB4","text":"Gauss-Lobatto-IIIB Runge-Kutta, s=4\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIC2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIC2","text":"Gauss-Lobatto-IIIC Runge-Kutta, s=2\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIC3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIC3","text":"Gauss-Lobatto-IIIC Runge-Kutta, s=3\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIC4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIC4","text":"Gauss-Lobatto-IIIC Runge-Kutta, s=4\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIID2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIID2","text":"Gauss-Lobatto-IIID Runge-Kutta, s=2\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIID3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIID3","text":"Gauss-Lobatto-IIID Runge-Kutta, s=3\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIID4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIID4","text":"Gauss-Lobatto-IIID Runge-Kutta, s=4\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIE2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIE2","text":"Gauss-Lobatto-IIIE Runge-Kutta, s=2\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIE3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIE3","text":"Gauss-Lobatto-IIIE Runge-Kutta, s=3\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIE4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIE4","text":"Gauss-Lobatto-IIIE Runge-Kutta, s=4\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIF2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIF2","text":"Gauss-Lobatto-IIIF Runge-Kutta, s=2\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIF3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIF3","text":"Gauss-Lobatto-IIIF Runge-Kutta, s=3\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIF4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIF4","text":"Gauss-Lobatto-IIIF Runge-Kutta, s=4\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIG2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIG2","text":"Gauss-Lobatto-IIIG Runge-Kutta, s=2\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIG3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIG3","text":"Gauss-Lobatto-IIIG Runge-Kutta, s=3\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobIIIG4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobIIIG4","text":"Gauss-Lobatto-IIIG Runge-Kutta, s=4\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobattoIIIAIIIB2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobattoIIIAIIIB2","text":"Tableau for Gauss-Lobatto IIIAIIIB method with s=2 stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauLobattoIIIBIIIA2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauLobattoIIIBIIIA2","text":"Tableau for Gauss-Lobatto IIIBIIIA method with s=2 stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauModifiedStochasticStormerVerlet","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauModifiedStochasticStormerVerlet","text":"Tableau for the 2-stage modified stochastic LobattoIIIA-IIIB method   Tableau for the 2-stage modified stochastic LobattoIIIA-IIIB method   Satisfies the conditions for Lagrange-d'Alembert integrators   and the conditions for convergence of order 1.0 for one Wiener process\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauPlaten-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauPlaten","text":"Tableau for the explicit Platen method   Platen's method cited in Eq. (52) in    K. Burrage, P. Burrage (1996) \"High strong order explicit Runge-Kutta methods for stochastic ordinary differential equations\".   According to the paper, the method has strong order 1.0 for one-dimensional Brownian motion.   Appears to have a rather poor long-time performance.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauRadIIA2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauRadIIA2","text":"Gauss-Radau-IIA Runge-Kutta, s=2\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauRadIIA3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauRadIIA3","text":"Gauss-Radau-IIA Runge-Kutta, s=3\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauRosslerRS1-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauRosslerRS1","text":"Tableau for the explicit 4-stage RS1 method due to Andreas Rossler   Method cited in Table 5.2 in   Andreas Rossler, \"Second order Runge-Kutta methods for Stratonovich stochastic differential equations\",   BIT Numerical Mathematics (2007) 47   According to the paper, the method has weak order 2.0.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauRosslerRS2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauRosslerRS2","text":"Tableau for the explicit 4-stage RS2 method due to Andreas Rossler   Method cited in Table 5.3 in   Andreas Rossler, \"Second order Runge-Kutta methods for Stratonovich stochastic differential equations\",   BIT Numerical Mathematics (2007) 47   According to the paper, the method has weak order 2.0.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauRunge-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauRunge","text":"Tableau for Runge's method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauSPARKGLRK-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauSPARKGLRK","text":"SPARK tableau for Gauss-Legendre Runge-Kutta method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauSPARKGLRKLobIIIAIIIB","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauSPARKGLRKLobIIIAIIIB","text":"SPARK tableau for Gauss-Legendre/Gauss-Lobatto methods.\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauSPARKLob-Tuple{Any,Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauSPARKLob","text":"SPARK tableau for Gauss-Lobatto methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauSPARKLobIIIAIIIB-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauSPARKLobIIIAIIIB","text":"SPARK tableau for Gauss-Lobatto IIIA-IIIB method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauSRK3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauSRK3","text":"Gauss-Legendre Runge-Kutta, s=3\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauSRKw1","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauSRKw1","text":"Tableau for the 1-stage SRKw1 method due to Wang, Hong & Xu   Method cited in   Wang, Hong, Xu, \"Construction of Symplectic Runge-Kutta Methods for Stochastic Hamiltonian Systems\",   Commun. Comput. Phys. 21(1), 2017   According to the paper, the method has weak order 1.0.\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauSRKw2","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauSRKw2","text":"Tableau for the 4-stage SRKw2 method due to Wang, Hong & Xu   Method cited in   Wang, Hong, Xu, \"Construction of Symplectic Runge-Kutta Methods for Stochastic Hamiltonian Systems\",   Commun. Comput. Phys. 21(1), 2017   According to the paper, the method has weak order 2.0 when applied to systems   driven by one-dimensional noise.\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauStochasticDIRK","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauStochasticDIRK","text":"Tableau for the 2-stage stochastic symplectic DIRK method   Tableau for the stochastic symplectic DIRK method   Satisfies the conditions for Lagrange-d'Alembert integrators.   Satisfies the conditions for strong convergence of order 1.0 for one Wiener process\n\n\n\n\n\n","category":"function"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauStochasticEuler-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauStochasticEuler","text":"Tableau for the explicit 1-stage stochastic Euler method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauStochasticGLRK-Tuple{Int64}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauStochasticGLRK","text":"Tableau for the s-stage Gauss-Lobatto SFIRK method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauStochasticHeun-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauStochasticHeun","text":"Tableau for the explicit 2-stage stochastic Heun method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauStochasticLobIIIABD2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauStochasticLobIIIABD2","text":"Tableau for the 2-stage stochastic LobattoIIIA-IIIB-IIID method   Tableau for the 2-stage stochastic LobattoIIIA-IIIB-IIID method   (based on the deterministic LobattoIIIA-IIIB-IIID due to L. Jay)   It satisfies the conditions for convergence of order 1.0 for one Wiener process,   but it doesn't satisfy the conditions for Lagrange-d'Alembert integrators\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauStochasticStormerVerlet-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauStochasticStormerVerlet","text":"Tableau for the 2-stage stochastic LobattoIIA-IIB method (Stormer-Verlet)\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauStochasticSymplecticEuler-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauStochasticSymplecticEuler","text":"Tableau for the stochastic symplectic Euler method   Tableau for the stochastic symplectic Euler method   Satisfies the conditions for Lagrange-d'Alembert integrators.   Satisfies the conditions for strong convergence of order 1.0 for one Wiener process   for special choices of the stochastic Hamiltonians and forces, e.g., h=h(q), f=0.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauSymplecticEulerA-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauSymplecticEulerA","text":"Tableau for symplectic Euler-A method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauSymplecticEulerB-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauSymplecticEulerB","text":"Tableau for symplectic Euler-B method\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPGLRK-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPGLRK","text":"Tableau for variational Gauss-Legendre method with s stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIA2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIA2","text":"Tableau for variational Gauss-Lobatto IIIA-IIIB method with two stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIA3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIA3","text":"Tableau for variational Gauss-Lobatto IIIA-IIIB method with three stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIA4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIA4","text":"Tableau for variational Gauss-Lobatto IIIA-IIIB method with four stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIAIIIA2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIAIIIA2","text":"Tableau for Gauss-Lobatto IIIA-IIIA method with two stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIAIIIA3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIAIIIA3","text":"Tableau for Gauss-Lobatto IIIA-IIIA method with three stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIAIIIA4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIAIIIA4","text":"Tableau for Gauss-Lobatto IIIA-IIIA method with four stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIB2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIB2","text":"Tableau for variational Gauss-Lobatto IIIA-IIIB method with two stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIB3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIB3","text":"Tableau for variational Gauss-Lobatto IIIA-IIIB method with three stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIB4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIB4","text":"Tableau for variational Gauss-Lobatto IIIA-IIIB method with four stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIC2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIC2","text":"Tableau for variational Gauss-Lobatto IIIC-III method with two stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIC3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIC3","text":"Tableau for variational Gauss-Lobatto IIIC-III method with three stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIC4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIC4","text":"Tableau for variational Gauss-Lobatto IIIC-III method with four stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIID2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIID2","text":"Tableau for variational Gauss-Lobatto IIID method with two stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIID3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIID3","text":"Tableau for variational Gauss-Lobatto IIID method with three stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIID4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIID4","text":"Tableau for variational Gauss-Lobatto IIID method with four stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIE2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIE2","text":"Tableau for variational Gauss-Lobatto IIIE method with two stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIE3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIE3","text":"Tableau for variational Gauss-Lobatto IIIE method with three stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIE4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIE4","text":"Tableau for variational Gauss-Lobatto IIIE method with four stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIF2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIF2","text":"Tableau for variational Gauss-Lobatto IIIF method with two stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIF3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIF3","text":"Tableau for variational Gauss-Lobatto IIIF method with three stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIF4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIF4","text":"Tableau for variational Gauss-Lobatto IIIF method with four stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIG2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIG2","text":"Tableau for variational Gauss-Lobatto IIIG method with two stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIG3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIG3","text":"Tableau for variational Gauss-Lobatto IIIG method with three stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPLobIIIG4-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPLobIIIG4","text":"Tableau for variational Gauss-Lobatto IIIG method with four stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPRadIIAIIA2-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPRadIIAIIA2","text":"Tableau for Gauss-Radau IIA-IIA method with two stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPRadIIAIIA3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPRadIIAIIA3","text":"Tableau for Gauss-Radau IIA-IIA method with three stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVPSRK3-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVPSRK3","text":"Tableau for variational symmetric Runge-Kutta method with 3 stages\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVSPARKGLRKpMidpoint-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVSPARKGLRKpMidpoint","text":"Tableau for Gauss-Legendre method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVSPARKGLRKpSymmetric-Tuple{Any}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVSPARKGLRKpSymmetric","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVSPARKLobIIIAIIIB2pSymmetric-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVSPARKLobIIIAIIIB2pSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with two stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVSPARKLobIIIAIIIB3pSymmetric-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVSPARKLobIIIAIIIB3pSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with three stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/tableaus/#GeometricIntegrators.Tableaus.getTableauVSPARKLobIIIAIIIB4pSymmetric-Tuple{}","page":"Tableaus","title":"GeometricIntegrators.Tableaus.getTableauVSPARKLobIIIAIIIB4pSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with four stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"integrators/splitting/#Splitting-Methods","page":"Splitting","title":"Splitting Methods","text":"","category":"section"},{"location":"modules/simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"modules/simulations/","page":"Simulations","title":"Simulations","text":"Modules = [GeometricIntegrators.Simulations]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/simulations/#GeometricIntegrators.Simulations.ParallelSimulation","page":"Simulations","title":"GeometricIntegrators.Simulations.ParallelSimulation","text":"ParallelSimulation: collects all data structures that are necessary for a    simulation run in parallel.\n\nWARNING: Many integrators are not thread-safe at this point!\n\n\n\n\n\n","category":"type"},{"location":"#GeometricIntegrators.jl","page":"Home","title":"GeometricIntegrators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia library of geometric integrators for ordinary differential equations and differential algebraic equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage Status) (Image: codecov)","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl is a library of geometric integrators for ordinary differential equations and differential algebraic equations in Julia. Its main aim is the implementation and verification of novel geometric integrators, especially with respect to long-time stability and conservation of geometric structures. In order to be able to perform simulations with millions or billions of time steps, the design of the library tries to minimize overhead and maximize performance. For example, all data structures are preallocated and reused so that all runtime allocations are eliminated. GeometricIntegrators.jl provides solvers for various families of integrators as well as facilities to derive such integrators of arbitrary order, e.g., via discrete variational principles.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"tutorial/tutorial.md\",\n         \"integrators.md\"]","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"modules/basis_functions.md\",\n         \"modules/equations.md\",\n         \"modules/integrators.md\",\n         \"modules/interpolation.md\",\n         \"modules/quadratures.md\",\n         \"modules/discontinuities.md\",\n         \"modules/simulations.md\",\n         \"modules/solvers_linear.md\",\n         \"modules/solvers_nonlinear.md\",\n         \"modules/solutions.md\",\n         \"modules/tableaus.md\"\n]","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following list provides and overview of supported and planned features.","category":"page"},{"location":"#Families-of-Standard-Methods","page":"Home","title":"Families of Standard Methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[x] Explicit Runge-Kutta Methods (ERK),\n[x] Diagonally Implicit Runge-Kutta Methods (DIRK),\n[x] Fully Implicit Runge-Kutta Methods (FIRK),\n[x] Explicit Partitioned Runge-Kutta Methods (EPRK),\n[x] Implicit Partitioned Runge-Kutta Methods (IPRK),\n[ ] Additive Runge-Kutta Methods (ARK),\n[x] Partitioned Additive Runge-Kutta Methods (PARK),\n[ ] Generalised Additive Runge-Kutta Methods (GARK),\n[ ] Specialised Partitioned Additive Runge-Kutta Methods (SPARK),\n[ ] Continuous-stage Runge-Kutta Methods (CSRK),\n[ ] Two-step Runge-Kutta Methods (TSRK),\n[ ] General Linear Methods (GLM).","category":"page"},{"location":"#Families-of-Geometric-Integrators","page":"Home","title":"Families of Geometric Integrators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[x] Gauss-Legendre Runge-Kutta Methods (GLRK),\n[x] Variational Partitioned Runge-Kutta Methods (VPRK),\n[x] Hamiltonian Partitioned Additive Runge-Kutta Methods (HPARK, HSPARK),\n[x] Variational Partitioned Additive Runge-Kutta Methods (VPARK, VSPARK),\n[x] Continuous Galerkin Variational Integrators (CGVI),\n[x] Discontinuous Galerkin Variational Integrators (DGVI),\n[ ] Hamilton-Pontryagin-Galerkin Integrators (HPGI),\n[ ] Spline Variational Integrators (SVI),\n[ ] Taylor Variational Integrators (TVI),\n[x] Splitting Methods (SM),\n[ ] Hamiltonian Boundary Value Methods (HBVM).","category":"page"},{"location":"#Families-of-Stochastic-Integrators","page":"Home","title":"Families of Stochastic Integrators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[x] Stochastic Explicit Runge-Kutta Methods (SERK),\n[x] Stochastic Implicit Runge-Kutta Methods (SIRK),\n[x] Stochastic Implicit Partitioned Runge-Kutta Methods (SIPRK),\n[x] Stochastic Implicit Partitioned Additive Runge-Kutta Methods,\n[x] Stochastic Weak Explicit Runge-Kutta Methods (WERK),\n[x] Stochastic Weak Implicit Runge-Kutta Methods (WIRK).","category":"page"},{"location":"#Families-of-Equations","page":"Home","title":"Families of Equations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[x] Systems of ODEs,\n[x] Systems of DAEs,\n[x] Systems of SDEs,\n[x] Partitioned ODEs,\n[x] Partitioned DAEs,\n[x] Partitioned SDEs,\n[x] Implicit ODEs,\n[x] Implicit DAEs,\n[ ] Implicit SDEs,\n[x] Variational ODEs,\n[x] Hamiltonian DAEs,\n[x] Split ODEs,\n[ ] Split Partitioned ODEs,\n[x] Split Partitioned SDEs.","category":"page"},{"location":"#Linear-Solvers","page":"Home","title":"Linear Solvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[x] LU decomposition (LAPACK),\n[x] LU decomposition (native Julia),\n[ ] Krylov,","category":"page"},{"location":"#Nonlinear-Solvers","page":"Home","title":"Nonlinear Solvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[ ] Fixed-Point Iteration,\n[ ] Fixed-Point Iteration with Aitken Acceleration,\n[ ] Fixed-Point Iteration with Anderson Acceleration,\n[ ] Jacobian-free Newton-Krylov,\n[x] Newton's method,\n[x] Newton's method with line search (Armijo, quadratic),\n[x] Quasi-Newton,","category":"page"},{"location":"","page":"Home","title":"Home","text":"with","category":"page"},{"location":"","page":"Home","title":"Home","text":"[x] Analytic Jacobian,\n[x] Finite Difference Jacobian,\n[x] Jacobian obtained via Automatic Differentiation.","category":"page"},{"location":"#Diagnostics","page":"Home","title":"Diagnostics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[x] Symplecticity Conditions,\n[ ] Runge-Kutta Stability Area,\n[ ] Convergence Analysis,\n[x] First Poincaré Integral Invariant,\n[x] Second Poincaré Integral Invariant.","category":"page"},{"location":"#References-(mostly-in-preparation)","page":"Home","title":"References (mostly in preparation)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Michael Kraus. Hamilton-Pontryagin-Galerkin Integrators.\nMichael Kraus. Projected Variational Integrators for Degenerate Lagrangian Systems.\nMichael Kraus. Discontinuous Galerkin Variational Integrators for Degenerate Lagrangian Systems.\nMichael Kraus. Discontinuous Galerkin Variational Integrators for Hamiltonian Systems subject to Dirac Constraints.\nMichael Kraus. SPARK Methods for Degenerate Lagrangian Systems.\nMichael Kraus. SPARK Methods for Hamiltonian Systems subject to Dirac Constraints.\nMichael Kraus. Symplectic Gauß-Legendre Runge-Kutta Methods for Degenerate Lagrangian Systems.\nMichael Kraus. Symplectic Lobatto Runge-Kutta Methods for Degenerate Lagrangian Systems.\nMichael Kraus. Variational Integrators for Degenerate Lagrangians.\nMichael Kraus. Variational Integrators for Noncanonical Hamiltonian Systems.\nMichael Kraus and Tomasz M. Tyranowski. Variational Integrators for Stochastic Dissipative Hamiltonian Systems.\nMichael Kraus, Joshua Burby. Conservation of Poincaré Integral Invariants in Numerical Simulations.","category":"page"},{"location":"#Background-Material","page":"Home","title":"Background Material","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ernst Hairer and Christian Lubich. Numerical Solution of Ordinary Differential Equations. The Princeton Companion to Applied Mathematics, 293-305, 2015. Princeton University Press. (Author's Web Site)\nErnst Hairer, Christian Lubich and Gerhard Wanner. Geometric Numerical Integration Illustrated by the Störmer–Verlet Method. Acta Numerica 12, 399-450, 2003. (Journal)\nLaurent O. Jay. Lobatto Methods. Encyclopedia of Applied and Computational Mathematics, 817–826. Springer, 2015. (Article)","category":"page"},{"location":"#Books-on-the-Numerical-Integration-of-Ordinary-Differential-Equations","page":"Home","title":"Books on the Numerical Integration of Ordinary Differential Equations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ernst Hairer, Syvert P. Nørsett and Gerhard Wanner. Solving Ordinary Differential Equations I: Nonstiff Problems. Springer, 1993. (eBook)\nErnst Hairer and Gerhard Wanner. Solving Ordinary Differential Equations II: Stiff and Differential-Algebraic Problems. Springer, 1996. (eBook)\nPeter Deuflhard, Folkmar Bornemann. Scientific Computing with Ordinary Differential Equations. Springer, 2002. (eBook)\nJohn C. Butcher. Numerical Methods for Ordinary Differential Equations. Wiley, 2016. (eBook)\nErnst Hairer, Christian Lubich and Gerhard Wanner. Geometric Numerical Integration. Springer, 2006. (eBook)\nBenedict Leimkuhler and Sebastian Reich. Simulating Hamiltonian Dynamics. Cambridge University Press, 2005. (eBook)\nSergio Blanes, Fernando Casas. A Concise Introduction to Geometric Numerical Integration. CRC Press, 2016. (eBook)","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Copyright (c) Michael Kraus <michael.kraus@ipp.mpg.de>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"integrators/cgvi/#Continuous-Galerkin-Variational-Integrators","page":"CGVI","title":"Continuous Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/spark/#Special-Partitioned-Additive-Runge-Kutta-Integrators","page":"SPARK","title":"Special Partitioned Additive Runge-Kutta Integrators","text":"","category":"section"}]
}
