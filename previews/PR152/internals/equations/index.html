<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Equations · GeometricIntegrators.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GeometricIntegrators.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../problems/">Problems</a></li><li><a class="tocitem" href="../../methods/">Methods</a></li><li><span class="tocitem">Integrators</span><ul><li><a class="tocitem" href="../../integrators/rk/">Runge-Kutta</a></li><li><a class="tocitem" href="../../integrators/splitting/">Splitting</a></li><li><a class="tocitem" href="../../integrators/variational/">Variational</a></li><li><a class="tocitem" href="../../integrators/vprk/">VPRK</a></li><li><a class="tocitem" href="../../integrators/spark/">SPARK</a></li><li><a class="tocitem" href="../../integrators/dvi/">DVI</a></li><li><a class="tocitem" href="../../integrators/cgvi/">CGVI</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../../modules/methods/">Methods</a></li><li><a class="tocitem" href="../../modules/integrators/">Integrators</a></li><li><a class="tocitem" href="../../modules/equations/">Problems</a></li><li><a class="tocitem" href="../../modules/solutions/">Solutions</a></li><li><a class="tocitem" href="../../modules/rungekutta/">Runge-Kutta Tableaus</a></li><li><a class="tocitem" href="../../modules/rungekutta_partitioned/">Partitioned Runge-Kutta Tableaus</a></li><li><a class="tocitem" href="../../modules/spark/">SPARK Methods</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../developer/code_integration/">Code Integration</a></li><li><a class="tocitem" href="../../developer/custom_integrators/">Custom Integrators</a></li><li><a class="tocitem" href="../../developer/adaptive_time_stepping/">Adaptive Time Stepping</a></li></ul></li><li><a class="tocitem" href="../../releasenotes/">Release Notes</a></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../authors/">Authors</a></li><li><a class="tocitem" href="../../LICENSE/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Equations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Equations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGNI/GeometricIntegrators.jl/blob/master/docs/src/internals/equations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Equations"><a class="docs-heading-anchor" href="#Equations">Equations</a><a id="Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Equations" title="Permalink"></a></h1><p>The following data structures are all implemented in <a href="https://github.com/JuliaGNI/GeometricEquations.jl">GeometricEquations.jl</a>.</p><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.GeometricEquation" href="#GeometricEquations.GeometricEquation"><code>GeometricEquations.GeometricEquation</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GeometricEquation{invType,parType,perType}</code> is the abstract type all equation types are derived from.</p><p>All equations should have fields for defining invariants, parameters and periodicity of the main state variable. The types of these fields are stored in the following type parameters:</p><ul><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p>The <code>Optional*</code> types are all unions of the respective <code>Null*</code> types and <code>NamedTuple</code> or <code>AbstractArray</code>, i.e.,</p><pre><code class="language-julia hljs">const OptionalInvariants = Union{NamedTuple, NullInvariants}
const OptionalParameters = Union{NamedTuple, NullParameters}
const OptionalPeriodicity = Union{AbstractArray, NullPeriodicity}</code></pre><p>The <code>Null*</code> types are empty structs, merely used for dispatch and the traits <code>hasinvariants</code>, <code>hasparameters</code> and <code>hasperiodicity</code>.</p></div></section></article><h2 id="Ordinary-Differential-Equations"><a class="docs-heading-anchor" href="#Ordinary-Differential-Equations">Ordinary Differential Equations</a><a id="Ordinary-Differential-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Ordinary-Differential-Equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.ODE" href="#GeometricEquations.ODE"><code>GeometricEquations.ODE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ODE</code>: Ordinary Differential Equation</p><p>Ordinary differential equations define an initial value problem of the form</p><p class="math-container">\[\dot{q} (t) = v(t, q(t)) , \qquad q(t_{0}) = q_{0} ,\]</p><p>with vector field <span>$v$</span>, initial condition <span>$q_{0}$</span> and the solution <span>$q$</span> taking values in <span>$\mathbb{R}^{d}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Callable</code>: type of <code>v</code></li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code>: function computing the vector field</li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ODE(v, invariants, parameters, periodicity)
ODE(v; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())</code></pre><p><strong>Function Definitions</strong></p><p>The function <code>v</code> providing the vector field must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, params)
    v[1] = ...
    v[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the vector which holds the result of evaluating the vector field <span>$v$</span> on <code>t</code> and <code>q</code>, and <code>params</code> is a <code>NamedTuple</code> of additional parameters on which the vector field may depend.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.PODE" href="#GeometricEquations.PODE"><code>GeometricEquations.PODE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PODE</code>: Partitioned Ordinary Differential Equation</p><p>A partitioned ordinary differential equation is an initial value problem of the form</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) , &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) , &amp;
p(t_{0}) &amp;= p_{0} ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span> and <span>$f$</span>, initial conditions <span>$(q_{0}, p_{0})$</span> and the solution <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Callable</code>: type of <code>v</code></li><li><code>fType &lt;: Callable</code>: type of <code>f</code></li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code>: function computing the vector field <span>$v$</span></li><li><code>f</code>: function computing the vector field <span>$f$</span></li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">PODE(v, f, invariants, parameters, periodicity)
PODE(v, f; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())</code></pre><p><strong>Function Definitions</strong></p><p>The functions <code>v</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f(f, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> and <code>p</code> are the current solution vectors, <code>v</code> and <code>f</code> are the vectors which hold the result of evaluating the vector fields <span>$v$</span> and <span>$f$</span> on <code>t</code>, <code>q</code> and <code>p</code>, and params is a <code>NamedTuple</code> of additional parameters.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.HODE" href="#GeometricEquations.HODE"><code>GeometricEquations.HODE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>HODE</code>: Hamiltonian Ordinary Differential Equation</p><p>A canonical Hamiltonian system of equations is special case of a partitioned ordinary differential equation,</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) , &amp; p(t_{0}) &amp;= p_{0} ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span> and <span>$f$</span>, given by</p><p class="math-container">\[\begin{aligned}
v &amp;=   \frac{\partial H}{\partial p} , &amp;
f &amp;= - \frac{\partial H}{\partial q} ,
\end{aligned}\]</p><p>initial conditions <span>$(q_{0}, p_{0})$</span> and the dynamical variables <span>$(q,p)$</span> taking values in <span>$T^{*} Q \simeq \mathbb{R}^{d} \times \mathbb{R}^{d}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Callable</code>: type of <code>v</code></li><li><code>fType &lt;: Callable</code>: type of <code>f</code></li><li><code>hamType &lt;: Callable</code>: Hamiltonian type</li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code>: function computing the vector field <span>$v$</span></li><li><code>f</code>: function computing the vector field <span>$f$</span></li><li><code>hamiltonian</code>: function computing the Hamiltonian <span>$H$</span> (usually the total energy of the system)</li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HODE(v, f, hamiltonian, invariants, parameters, periodicity)
HODE(v, f, hamiltonian; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())</code></pre><p><strong>Function Definitions</strong></p><p>The functions <code>v</code>, <code>f</code> and <code>hamiltonian</code> must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f(f, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end

function hamiltonian(t, q, p, params)
    return ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> and <code>p</code> are the current solution vectors, <code>v</code> and <code>f</code> are the vectors which hold the result of evaluating the vector fields on <code>t</code>, <code>q</code> and <code>p</code>, and params is a <code>NamedTuple</code> of additional parameters.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.IODE" href="#GeometricEquations.IODE"><code>GeometricEquations.IODE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>IODE</code>: Implicit Ordinary Differential Equation</p><p>An implicit ordinary differential equations is an initial value problem of the form</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) , &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) , &amp;
p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= ϑ(t, q(t), v(t))
\end{aligned}\]</p><p>with force field <span>$f$</span>, the momentum defined by <span>$p$</span>, initial conditions <span>$(q_{0}, p_{0})$</span> and the solution <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>. This is a special case of a differential algebraic equation with dynamical variables <span>$(q,p)$</span> and algebraic variable <span>$v$</span>, that is determined such that the constraint <span>$p(t) = ϑ(t, q(t), v(t))$</span> is satisfied.</p><p>Most integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + λ(t) , &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), v(t), λ(t)) , &amp;
p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= ϑ(t, q(t), v(t)) , &amp;
λ(t_{0}) &amp;= λ_{0}
\end{aligned}\]</p><p>where the vector field defining the projection step is usually given as</p><p class="math-container">\[\begin{aligned}
g(t, q(t), v(t), λ(t)) &amp;= λ(t) \cdot \nabla ϑ(t, q(t), v(t)) .
\end{aligned}\]</p><p><strong>Parameters</strong></p><ul><li><code>ϑType &lt;: Callable</code>: type of <code>ϑ</code></li><li><code>fType &lt;: Callable</code>: type of <code>f</code></li><li><code>gType &lt;: Callable</code>: type of <code>g</code></li><li><code>v̄Type &lt;: Callable</code>: type of <code>v̄</code></li><li><code>f̄Type &lt;: Callable</code>: type of <code>f̄</code></li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>ϑ</code>: function determining the momentum</li><li><code>f</code>: function computing the vector field</li><li><code>g</code>: function determining the projection, given by <span>$\nabla \vartheta (t,q,v) \cdot \lambda$</span></li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span> (optional)</li><li><code>f̄</code>: function computing an initial guess for the force field <span>$f$</span> (optional)</li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">IODE(ϑ, f, g, v̄, f̄, invariants, parameters, periodicity)
IODE(ϑ, f, g; v̄ = _iode_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())</code></pre><p>where </p><pre><code class="language-julia hljs">_iode_default_v̄(v, t, q, params) = nothing</code></pre><p>The functions <code>ϑ</code>, <code>f</code> and <code>g</code> compute the momentum and the vector fields, respectively.</p><p><strong>Function Definitions</strong></p><p>The functions <code>ϑ</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">function ϑ(p, t, q, v)
    p[1] = ...
    p[2] = ...
    ...
end</code></pre><p>and</p><pre><code class="language-julia hljs">function f(f, t, q, v)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the current velocity and <code>f</code> and <code>p</code> are the vectors which hold the result of evaluating the functions <span>$f$</span> and <span>$ϑ$</span> on <code>t</code>, <code>q</code> and <code>v</code>. In addition, the functions <code>g</code>, <code>v̄</code> and <code>f̄</code> are specified by</p><pre><code class="language-julia hljs">function g(g, t, q, v, λ)
    g[1] = ...
    g[2] = ...
    ...
end

function v̄(v, t, q)
    v[1] = ...
    v[2] = ...
    ...
end

function f̄(f, t, q, v)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>The function <code>g</code> is used in projection methods that enforce <span>$p = ϑ(q)$</span>. The functions <code>v̄</code> and <code>f̄</code> are used for initial guesses in nonlinear implicit solvers.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.LODE" href="#GeometricEquations.LODE"><code>GeometricEquations.LODE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LODE</code>: Lagrangian Ordinary Differential Equation</p><p>A Lagrangian system of equations is a special case of an implicit ordinary differential equations, that is an implicit initial value problem of the form</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) , &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) , &amp;
p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= ϑ(t, q(t), v(t))
\end{aligned}\]</p><p>with momentum <span>$p$</span> and force field <span>$f$</span>, given by</p><p class="math-container">\[\begin{aligned}
p &amp;= \frac{\partial L}{\partial v} , &amp;
f &amp;= \frac{\partial L}{\partial q} ,
\end{aligned}\]</p><p>initial conditions <span>$(q_{0}, p_{0})$</span> and the solution <span>$(q,p)$</span> taking values in <span>$T^{*} Q \simeq \mathbb{R}^{d} \times \mathbb{R}^{d}$</span>. This is a special case of an implicit ordinary differential equation, that is defined by a Lagrangian, as well as a special case of a differential algebraic equation with dynamical variables <span>$(q,p)$</span> and algebraic variable <span>$v$</span>, that is determined such that the constraint <span>$p(t) = ϑ(t, q(t), v(t))$</span> is satisfied.</p><p>Many integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + \lambda(t) , &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), v(t), \lambda(t)) , &amp;
p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= ϑ(t, q(t), v(t)) , &amp;
\lambda(t_{0}) &amp;= \lambda_{0}
\end{aligned}\]</p><p>where the vector field defining the projection step is usually given as</p><p class="math-container">\[\begin{aligned}
g(t, q(t), v(t), λ(t)) &amp;= λ(t) \cdot \nabla ϑ(t, q(t), v(t)) .
\end{aligned}\]</p><p><strong>Parameters</strong></p><ul><li><code>ϑType &lt;: Function</code>: type of <code>ϑ</code></li><li><code>fType &lt;: Function</code>: type of <code>f</code></li><li><code>gType &lt;: Function</code>: type of <code>g</code></li><li><code>ωType &lt;: Function</code>: type of <code>ω</code></li><li><code>v̄Type &lt;: Function</code>: type of <code>v̄</code></li><li><code>f̄Type &lt;: Function</code>: type of <code>f̄</code></li><li><code>lagType &lt;: Function</code>: Lagrangian type</li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>ϑ</code>: function determining the momentum</li><li><code>f</code>: function computing the vector field</li><li><code>g</code>: function determining the projection, given by <span>$\nabla \vartheta (q) \cdot \lambda$</span></li><li><code>ω</code>: function computing the symplectic matrix</li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span> (optional)</li><li><code>f̄</code>: function computing an initial guess for the force field <span>$f$</span> (optional)</li><li><code>lagrangian</code>: function computing the Lagrangian <span>$L$</span></li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">LODE(ϑ, f, g, ω, l, v̄, f̄, invariants, parameters, periodicity)
LODE(ϑ, f, g, ω, l; v̄ = _lode_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())</code></pre><p>where </p><pre><code class="language-julia hljs">_lode_default_v̄(v, t, q, params) = nothing</code></pre><p><strong>Function Definitions</strong></p><p>The functions <code>ϑ</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">function ϑ(p, t, q, v)
    p[1] = ...
    p[2] = ...
    ...
end</code></pre><p>and</p><pre><code class="language-julia hljs">function f(f, t, q, v)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the current velocity and <code>f</code> and <code>p</code> are the vectors which hold the result of evaluating the functions <span>$f$</span> and <span>$ϑ$</span> on <code>t</code>, <code>q</code> and <code>v</code>. The funtions <code>g</code>, <code>v̄</code> and <code>f̄</code> are specified by</p><pre><code class="language-julia hljs">function g(g, t, q, λ)
    g[1] = ...
    g[2] = ...
    ...
end</code></pre><p>and</p><pre><code class="language-julia hljs">function v̄(v, t, q)
    v[1] = ...
    v[2] = ...
    ...
end

function f̄(f, t, q, v)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>The function <code>g</code> is used in projection methods that enforce <span>$p = ϑ(q)$</span>. The functions <code>v̄</code> and <code>f̄</code> are used for initial guesses in nonlinear implicit solvers. Finally, the functions <code>ω</code> and <code>l</code>, computing the symplectic matrix and the Lagrangian, have the following signature</p><pre><code class="language-julia hljs">function ω(f, t, q, v, params)
    ω[1,1] = ...
    ω[1,2] = ...
    ...
end

function l(t, q, v, params)
    return ...
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.SODE" href="#GeometricEquations.SODE"><code>GeometricEquations.SODE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SODE</code>: Split Ordinary Differential Equation</p><p>Defines an initial value problem</p><p class="math-container">\[\dot{q} (t) = v(t, q(t)) , \qquad q(t_{0}) = q_{0} ,\]</p><p>with vector field <span>$v$</span>, initial condition <span>$q_{0}$</span> and the solution <span>$q$</span> taking values in <span>$\mathbb{R}^{d}$</span>. Here, the vector field <span>$v$</span> is given as a sum of vector fields</p><p class="math-container">\[v (t) = v_1 (t) + ... + v_r (t) .\]</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Union{Tuple,Nothing}</code>: type of <code>v</code></li><li><code>qType &lt;: Union{Tuple,Nothing}</code>: type of <code>q</code></li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code>: tuple of functions computing the vector fields for each substep</li><li><code>q</code>: tuple of functions computing the solutions for each substep</li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SODE(v, invariants, parameters, periodicity)
SODE(v; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())
SODE(v, q, invariants, parameters, periodicity)
SODE(v, q; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())</code></pre><p><strong>Function Definitions</strong></p><p>The functions <code>v_i</code> providing the vector field must have the interface</p><pre><code class="language-julia hljs">function v_i(v, t, q, params)
    v[1] = ...
    v[2] = ...
    ...
end</code></pre><p>and the functions <code>q_i</code> providing the solutions must have the interface</p><pre><code class="language-julia hljs">function q_i(q₁, t₁, q₀, t₀, params)
    q₁[1] = q₀[1] + ...
    q₁[2] = q₀[2] + ...
    ...
end</code></pre><p>where <code>t₀</code> is the current time, <code>q₀</code> is the current solution vector, <code>q₁</code> is the new solution vector at time <code>t₁</code>, holding the result of computing one substep</p><p>The fact that the function <code>v</code> returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps. with the vector field <span>$v_i$</span>.</p></div></section></article><h2 id="Differential-Algebraic-Equations"><a class="docs-heading-anchor" href="#Differential-Algebraic-Equations">Differential Algebraic Equations</a><a id="Differential-Algebraic-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Differential-Algebraic-Equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.DAE" href="#GeometricEquations.DAE"><code>GeometricEquations.DAE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>DAE</code>: Differential Algebraic Equation</p><p>Defines a differential algebraic initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t)) + u(t, q(t), \lambda(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
0 &amp;= \phi (t, q(t)) , &amp; \lambda(t_{0}) &amp;= \lambda_{0} ,
\end{aligned}\]</p><p>with vector field <span>$v$</span>, projection <span>$u$</span>, algebraic constraint <span>$\phi=0$</span>, initial conditions <span>$q_{0}$</span> and <span>$\lambda_{0}$</span>, the dynamical variable <span>$q$</span> taking values in <span>$\mathbb{R}^{d}$</span> and the algebraic variable <span>$\lambda$</span> taking values in <span>$\mathbb{R}^{m}$</span>.</p><p>Some integrators also enforce the secondary constraint <span>$\psi$</span>, that is the time derivative of the algebraic constraint <span>$\phi$</span>. In this case, the system of equations is modified as follows</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t)) + u(t, q(t), \lambda(t)) + \bar{u} (t, q(t), \dot{q} (t), \dot{p} (t), \gamma(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
0 &amp;= \phi (t, q(t)) , &amp; \lambda(t_{0}) &amp;= \lambda_{0} , \\
0 &amp;= \psi (t, q(t), \dot{q} (t)) , &amp; \gamma(t_{0}) &amp;= \gamma_{0} ,
\end{aligned}\]</p><p>with the second algebraic variable <span>$\gamma$</span> also taking values in <span>$\mathbb{R}^{m}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Callable</code>: type of <code>v</code></li><li><code>uType &lt;: Callable</code>: type of <code>u</code></li><li><code>ϕType &lt;: Callable</code>: type of <code>ϕ</code></li><li><code>ūType &lt;: OptionalCallable</code>: type of <code>ū</code></li><li><code>ψType &lt;: OptionalCallable</code>: type of <code>ψ</code></li><li><code>v̄Type &lt;: Callable</code>: type of <code>v̄</code></li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code>: function computing the vector field <code>v(v, t, q, params)</code></li><li><code>u</code>: function computing the projection <code>u(u, t, q, λ, params)</code></li><li><code>ϕ</code>: algebraic constraint <code>ϕ(ϕ, t, q, params)</code></li><li><code>ū</code>: function computing the secondary projection field <code>ū(ū, t, q, λ, params)</code> (<em>optional</em>)</li><li><code>ψ</code>: secondary constraint <code>ψ(ψ, t, q, v, params)</code> (<em>optional</em>)</li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span> (defaults to <code>v</code>)</li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">DAE(v, u, ϕ, ū, ψ, v̄, invariants, parameters, periodicity)
DAE(v, u, ϕ, ū, ψ; kwargs...)
DAE(v, u, ϕ; kwargs...)</code></pre><p>The functions <code>v</code> and <code>u</code> compute the vector field and the projection, respectively, <code>ϕ</code> provides the algebraic constraint. The functions <code>ψ</code> and <code>ū</code> are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.</p><p><strong>Function Definitions</strong></p><p>The functions are defined by</p><p>The functions <code>v</code>, <code>u</code> and <code>ϕ</code> must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, params)
    v[1] = ...
    v[2] = ...
    ...
end

function u(u, t, q, λ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function ϕ(ϕ, t, q, params)
    ϕ[1] = ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> and <code>λ</code> are the current solution vectors, and <code>v</code>, <code>u</code> and <code>ϕ</code> are the vectors which hold the result of evaluating the vector field <span>$v$</span>, the projection <span>$u$</span> and the algebraic constraint <span>$\phi$</span> on <code>t</code>, <code>q</code> and <code>λ</code>.</p><p>Some integrators also enforce the secondary constraint <span>$\psi$</span> and require the following additional functions</p><pre><code class="nohighlight hljs">function ū(u, t, q, γ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function ψ(ψ, t, q, v, params)
    ψ[1] = ...
end</code></pre><p>The <code>DAE</code> is created by</p><pre><code class="language-julia hljs">equ = DAE(v, u, ϕ)</code></pre><p>or</p><pre><code class="language-julia hljs">equ = DAE(v, u, ϕ, ū, ψ)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.PDAE" href="#GeometricEquations.PDAE"><code>GeometricEquations.PDAE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PDAE</code>: Partitioned Differential Algebraic Equation</p><p>A partitioned differential algebraic equation has the form</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) + u(t, q(t), p(t), \lambda(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) + g(t, q(t), p(t), \lambda(t)) , &amp; p(t_{0}) &amp;= p_{0} , \\
0 &amp;= \phi (t, q(t), p(t)) , &amp; \lambda(t_{0}) &amp;= \lambda_{0} ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span> and <span>$f$</span>, projection <span>$u$</span> and <span>$g$</span>, algebraic constraint <span>$\phi=0$</span>, initial conditions <span>$(q_{0}, p_{0})$</span> and <span>$\lambda_{0}$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span> and the algebraic variable <span>$\lambda$</span> taking values in <span>$\mathbb{R}^{m}$</span>.</p><p>Some integrators also enforce the secondary constraint <span>$\psi$</span>, that is the time derivative of the algebraic constraint <span>$\phi$</span>. In this case, the system of equations is modified as follows</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) + u(t, q(t), p(t), \lambda(t)) + \bar{u} (t, q(t), p(t), \gamma(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) + g(t, q(t), p(t), \lambda(t)) + \bar{g} (t, q(t), p(t), \gamma(t)) , &amp; p(t_{0}) &amp;= p_{0} , \\
0 &amp;= \phi (t, q(t), p(t)) , &amp; \lambda(t_{0}) &amp;= \lambda_{0} , \\
0 &amp;= \psi (t, q(t), p(t), \dot{q} (t), \dot{p} (t)) , &amp; \gamma(t_{0}) &amp;= \gamma_{0} ,
\end{aligned}\]</p><p>with the second algebraic variable <span>$\gamma$</span> also taking values in <span>$\mathbb{R}^{m}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Callable</code>: type of <code>v</code></li><li><code>fType &lt;: Callable</code>: type of <code>f</code></li><li><code>uType &lt;: Callable</code>: type of <code>u</code></li><li><code>gType &lt;: Callable</code>: type of <code>g</code></li><li><code>ϕType &lt;: Callable</code>: type of <code>ϕ</code></li><li><code>ūType &lt;: Callable</code>: type of <code>ū</code></li><li><code>ḡType &lt;: Callable</code>: type of <code>ḡ</code></li><li><code>ψType &lt;: Callable</code>: type of <code>ψ</code></li><li><code>v̄Type &lt;: Callable</code>: type of <code>v̄</code></li><li><code>f̄Type &lt;: Callable</code>: type of <code>f̄</code></li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code>: function computing the vector field <span>$v$</span></li><li><code>f</code>: function computing the vector field <span>$f$</span></li><li><code>u</code>: function computing the projection for <span>$q$</span></li><li><code>g</code>: function computing the projection for <span>$p$</span></li><li><code>ϕ</code>: algebraic constraints</li><li><code>ū</code>: function computing the secondary projection field <span>$\bar{u}$</span> (<em>optional</em>)</li><li><code>ḡ</code>: function computing the secondary projection field <span>$\bar{g}$</span> (<em>optional</em>)</li><li><code>ψ</code>: secondary constraints (<em>optional</em>)</li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span> (<em>optional</em>, defaults to <code>v</code>)</li><li><code>f̄</code>: function computing an initial guess for the force field <span>$f$</span> (<em>optional</em>, defaults to <code>f</code>)</li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">PDAE(v, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, invariants, parameters, periodicity)
PDAE(v, f, u, g, ϕ, ū, ḡ, ψ; kwargs...)
PDAE(v, f, u, g, ϕ; kwargs...)</code></pre><p>The functions <code>v</code> and <code>f</code> compute the vector field, <code>u</code> and <code>g</code> compute the projections, and <code>ϕ</code> provides the algebraic constraint. The functions <code>ψ</code>, <code>ū</code> and <code>ḡ</code> are optional and provide the secondary constraint and the corresponding projection.</p><p><strong>Function Definitions</strong></p><p>The functions are defined by</p><p>The functions <code>v</code>, <code>f</code>, <code>u</code>, <code>g</code> and <code>ϕ</code> must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f(g, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end

function u(u, t, q, p, λ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function g(g, t, q, p, λ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function ϕ(ϕ, t, q, p, params)
    ϕ[1] = ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code>, <code>p</code> and <code>λ</code> are the current solution vectors, <code>v</code>, <code>f</code>, <code>u</code> and <code>g</code> are the vectors which hold the result of evaluating the vector fields <span>$v$</span> and <span>$f$</span>, the projections <span>$u$</span> and <span>$g$</span>, and <code>ϕ</code> holds the algebraic constraint <span>$\phi$</span>, evaluated on <code>t</code>, <code>q</code>, <code>p</code> and <code>λ</code>.</p><p>Some integrators also enforce the secondary constraint <span>$\psi$</span> and require the following additional functions</p><pre><code class="nohighlight hljs">function ū(u, t, q, p, γ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function ḡ(g, t, q, p, γ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function ψ(ψ, t, q, p, v, f, params)
    ψ[1] = ...
end</code></pre><p>The <code>PDAE</code> is created by</p><pre><code class="language-julia hljs">equ = PDAE(v, f, u, g, ϕ)</code></pre><p>or</p><pre><code class="language-julia hljs">equ = PDAE(v, f, u, g, ϕ, ū, ḡ, ψ)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.HDAE" href="#GeometricEquations.HDAE"><code>GeometricEquations.HDAE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>HDAE</code>: Hamiltonian Differential Algebraic Equation</p><p>A Hamiltonian differential algebraic is an initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) + u(t, q(t), p(t), \lambda(t)) + \bar{u} (t, q(t), p(t), \gamma(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) + g(t, q(t), p(t), \lambda(t)) + \bar{g} (t, q(t), p(t), \gamma(t)) , &amp; p(t_{0}) &amp;= p_{0} , \\
0 &amp;= \phi (t, q(t), p(t)) , \\
0 &amp;= \psi (t, q(t), p(t), \dot{q}(t), \dot{p}(t)) ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span>, <span>$u$</span>, <span>$\bar{u}$</span> and <span>$f$</span>, <span>$g$</span>, <span>$\bar{g}$</span>, primary constraint <span>$\phi(q,p)=0$</span> and secondary constraint <span>$\psi(q,p,\dot{q},\dot{p})=0$</span>, initial conditions <span>$(q_{0}, p_{0})$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span> and the algebraic variables <span>$(\lambda, \gamma)$</span> taking values in <span>$\mathbb{R}^{m} \times \mathbb{R}^{m}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Callable</code>: type of <code>v</code></li><li><code>fType &lt;: Callable</code>: type of <code>f</code></li><li><code>uType &lt;: Callable</code>: type of <code>u</code></li><li><code>gType &lt;: Callable</code>: type of <code>g</code></li><li><code>ϕType &lt;: Callable</code>: type of <code>ϕ</code></li><li><code>ūType &lt;: Callable</code>: type of <code>ū</code></li><li><code>ḡType &lt;: Callable</code>: type of <code>ḡ</code></li><li><code>ψType &lt;: Callable</code>: type of <code>ψ</code></li><li><code>v̄Type &lt;: Callable</code>: type of <code>v̄</code></li><li><code>f̄Type &lt;: Callable</code>: type of <code>f̄</code></li><li><code>hamType &lt;: Callable</code>: Hamiltonian type</li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code>: function computing the Hamiltonian vector field <span>$v$</span></li><li><code>f</code>: function computing the Hamiltonian vector field <span>$f$</span></li><li><code>u</code>: function computing the projection for <span>$q$</span></li><li><code>g</code>: function computing the primary projection field <span>$g$</span></li><li><code>ϕ</code>: primary constraints</li><li><code>ū</code>: function computing the secondary projection field <span>$\bar{u}$</span> (<em>optional</em>)</li><li><code>ḡ</code>: function computing the secondary projection field <span>$\bar{g}$</span> (<em>optional</em>)</li><li><code>ψ</code>: secondary constraints (<em>optional</em>)</li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span> (<em>optional</em>, defaults to <code>v</code>)</li><li><code>f̄</code>: function computing an initial guess for the force field <span>$f$</span> (<em>optional</em>, defaults to <code>f</code>)</li><li><code>hamiltonian</code>: function computing the Hamiltonian <span>$H$</span> (usually the total energy of the system)</li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, v̄, f̄, invariants, parameters, periodicity)
HDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h; kwargs...)
HDAE(v, f, u, g, ϕ, h; kwargs...)</code></pre><p>The functions <code>v</code> and <code>f</code> compute the vector field, <code>u</code> and <code>g</code> compute the projections, <code>ϕ</code> provides the algebraic constraint and <code>h</code> the Hamiltonian. The functions <code>ψ</code>, <code>ū</code> and <code>ḡ</code> are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.</p><p><strong>Function Definitions</strong></p><p>The functions are defined by</p><p>The functions <code>v</code>, <code>f</code>, <code>u</code>, <code>g</code>, <code>ϕ</code> and <code>h</code> must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f(g, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end

function u(u, t, q, p, λ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function g(g, t, q, p, λ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function ϕ(ϕ, t, q, p, params)
    ϕ[1] = ...
end

function h(t, q, p, params)
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code>, <code>p</code>, <code>λ</code> and <code>γ</code> are the current solution vectors, <code>v</code>, <code>f</code>, <code>u</code> and <code>g</code> are the vectors which hold the result of evaluating the vector fields <span>$v$</span> and <span>$f$</span>, the projections on the primary constraint <span>$u$</span> and <span>$g$</span>,  <code>ϕ</code> holds the algebraic constraint <span>$\phi$</span>, and <code>h</code> returns the Hamiltonian of the system, all evaluated on <code>t</code>, <code>q</code>, <code>p</code> and <code>λ</code>.</p><p>Some integrators also enforce the secondary constraint <span>$\psi$</span> and require the following additional functions</p><pre><code class="nohighlight hljs">function ū(u, t, q, p, γ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function ḡ(g, t, q, p, γ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function ψ(ψ, t, q, p, v, f, params)
    ψ[1] = ...
end</code></pre><p>The <code>HDAE</code> is created by</p><pre><code class="language-julia hljs">equ = HDAE(v, f, u, g, ϕ, h)</code></pre><p>or</p><pre><code class="language-julia hljs">equ = HDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.IDAE" href="#GeometricEquations.IDAE"><code>GeometricEquations.IDAE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>IDAE</code>: Implicit Differential Algebraic Equation</p><p>An implicit differential algebraic initial value problem takes the form</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + u(t, q(t), v(t), p(t), \lambda(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), v(t), p(t), \lambda(t)) , &amp; p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= ϑ(t, q(t), v(t)) , &amp;&amp; \\
0 &amp;= \phi (t, q(t), v(t), p(t)) , &amp; \lambda(t_{0}) &amp;= \lambda_{0} ,
\end{aligned}\]</p><p>with force field <span>$f$</span>, the momentum defined by <span>$ϑ$</span>, projections <span>$u$</span> and <span>$g$</span>, algebraic constraint <span>$\phi(t,q,v,p)=0$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>, the algebraic variable <span>$\lambda$</span> taking values in <span>$\mathbb{R}^{m}$</span>, and initial conditions <span>$(q_{0}, p_{0})$</span> and <span>$\lambda_{0}$</span>.</p><p>Some integrators also enforce the secondary constraint <span>$\psi$</span>, that is the time derivative of the algebraic constraint <span>$\phi$</span>. In this case, the system of equations is modified as follows</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + u(t, q(t), v(t), p(t), \lambda(t)) + \bar{u} (t, q(t), v(t), p(t), \gamma(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), v(t), p(t), \lambda(t)) + \bar{g} (t, q(t), v(t), p(t), \gamma(t)) , &amp; p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= ϑ(t, q(t), v(t)) , &amp;&amp; \\
0 &amp;= \phi (t, q(t), v(t), p(t)) , &amp; \lambda(t_{0}) &amp;= \lambda_{0} , \\
0 &amp;= \psi (t, q(t), v(t), p(t), \dot{q} (t), \dot{p} (t)) , &amp; \gamma(t_{0}) &amp;= \gamma_{0} ,
\end{aligned}\]</p><p>with the second algebraic variable <span>$\gamma$</span> also taking values in <span>$\mathbb{R}^{m}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>ϑType &lt;: Callable</code>: type of <code>ϑ</code></li><li><code>fType &lt;: Callable</code>: type of <code>f</code></li><li><code>uType &lt;: Callable</code>: type of <code>u</code></li><li><code>gType &lt;: Callable</code>: type of <code>g</code></li><li><code>ϕType &lt;: Callable</code>: type of <code>ϕ</code></li><li><code>ūType &lt;: Callable</code>: type of <code>ū</code></li><li><code>ḡType &lt;: Callable</code>: type of <code>ḡ</code></li><li><code>ψType &lt;: Callable</code>: type of <code>ψ</code></li><li><code>v̄Type &lt;: Callable</code>: type of <code>v̄</code></li><li><code>f̄Type &lt;: Callable</code>: type of <code>f̄</code></li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>ϑ</code>: function determining the momentum</li><li><code>f</code>: function computing the vector field <span>$f$</span></li><li><code>u</code>: function computing the projection for <span>$q$</span></li><li><code>g</code>: function computing the projection for <span>$p$</span></li><li><code>ϕ</code>: algebraic constraints</li><li><code>ū</code>: function computing the secondary projection field <span>$\bar{u}$</span> (<em>optional</em>)</li><li><code>ḡ</code>: function computing the secondary projection field <span>$\bar{g}$</span> (<em>optional</em>)</li><li><code>ψ</code>: secondary constraints (<em>optional</em>)</li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span> (<em>optional</em>)</li><li><code>f̄</code>: function computing an initial guess for the force field <span>$f$</span> (<em>optional</em>)</li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">IDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, invariants, parameters, periodicity)
IDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ; v̄ = _idae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())
IDAE(ϑ, f, u, g, ϕ; v̄ = _idae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())</code></pre><p>where </p><pre><code class="language-julia hljs">_idae_default_v̄(v, t, q, params) = nothing</code></pre><p>The function <code>ϑ</code> computes the momentum, <code>f</code> computes the force field, <code>u</code> and <code>g</code> compute the projections, and <code>ϕ</code> provides the algebraic constraint. The functions <code>ψ</code>, <code>ū</code> and <code>ḡ</code> are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.</p><p><strong>Function Definitions</strong></p><p>The functions <code>ϑ</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">function ϑ(p, t, q, v)
    p[1] = ...
    p[2] = ...
    ...
end

function f(f, t, q, v)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the current velocity and <code>f</code> and <code>p</code> are the vectors which hold the result of evaluating the functions <span>$f$</span> and <span>$ϑ$</span> on <code>t</code>, <code>q</code> and <code>v</code>. The funtions <code>g</code>, <code>v̄</code> and <code>f̄</code> are specified by</p><pre><code class="language-julia hljs">function u(u, t, q, v, p, λ)
    u[1] = ...
    u[2] = ...
    ...
end

function g(g, t, q, v, p, λ)
    g[1] = ...
    g[2] = ...
    ...
end

function v̄(v, t, q)
    v[1] = ...
    v[2] = ...
    ...
end

function f̄(f, t, q, v)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>Some integrators also enforce the secondary constraint <span>$\psi$</span> and require the following additional functions</p><pre><code class="nohighlight hljs">function ū(u, t, q, v, p, γ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function ḡ(g, t, q, v, p, γ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function ψ(ψ, t, q, v, p, q̇, ṗ, params)
    ψ[1] = ...
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.LDAE" href="#GeometricEquations.LDAE"><code>GeometricEquations.LDAE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LDAE</code>: Lagrangian Differential Algebraic Equation</p><p>A special case of an implicit initial value problem is a Lagrangian differential algebraic equation of the form</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + u(t, q(t), v(t), p(t), \lambda(t)) + \bar{u} (t, q(t), v(t), p(t), \gamma(t)) , &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), v(t), p(t), \lambda(t)) + \bar{g} (t, q(t), v(t), p(t), \gamma(t)) , &amp;
p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= ϑ(t, q(t), v(t)) , \\
0 &amp;= \phi (t, q(t), v(t), p(t)) , \\
0 &amp;= \psi (t, q(t), v(t), p(t), \dot{q}(t), \dot{p}(t)) ,
\end{aligned}\]</p><p>with momentum <span>$p$</span> and force field <span>$f$</span>, given by</p><p class="math-container">\[\begin{aligned}
p &amp;= \frac{\partial L}{\partial v} (q,v) , &amp;
f &amp;= \frac{\partial L}{\partial q} (q,v) ,
\end{aligned}\]</p><p>projection fields <span>$u$</span>, <span>$\bar{u}$</span> and <span>$g$</span>, <span>$\bar{g}$</span>, initial conditions <span>$(q_{0}, p_{0})$</span> and the solution <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span> and the algebraic variables <span>$(v, \lambda, \gamma)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{m} \times \mathbb{R}^{m}$</span>. This is a special case of a differential algebraic equation with dynamical variables <span>$(q,p)$</span> and algebraic variables <span>$v$</span>, <span>$\lambda$</span> and <span>$\gamma$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>ϑType &lt;: Callable</code>: type of <code>ϑ</code></li><li><code>fType &lt;: Callable</code>: type of <code>f</code></li><li><code>uType &lt;: Callable</code>: type of <code>u</code></li><li><code>gType &lt;: Callable</code>: type of <code>g</code></li><li><code>ϕType &lt;: Callable</code>: type of <code>ϕ</code></li><li><code>ūType &lt;: Callable</code>: type of <code>ū</code></li><li><code>ḡType &lt;: Callable</code>: type of <code>ḡ</code></li><li><code>ψType &lt;: Callable</code>: type of <code>ψ</code></li><li><code>ωType &lt;: Callable</code>: type of <code>ω</code></li><li><code>v̄Type &lt;: Callable</code>: type of <code>v̄</code></li><li><code>f̄Type &lt;: Callable</code>: type of <code>f̄</code></li><li><code>lagType &lt;: Callable</code>: Lagrangian type</li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>f</code>: function computing the vector field</li><li><code>u</code>: function computing the projection for <span>$q$</span>, for a degenerate system given by <span>$\lambda$</span></li><li><code>g</code>: function computing the projection for <span>$p$</span>, for a degenerate system given by <span>$\nabla \vartheta (q) \cdot \lambda$</span></li><li><code>ϕ</code>: primary constraints, for a degenerate system given by <span>$p - \vartheta (t,q)$</span></li><li><code>ū</code>: function computing the secondary projection field <span>$\bar{u}$</span>, for a degenerate system given by <span>$\lambda$</span> (<em>optional</em>)</li><li><code>ḡ</code>: function computing the secondary projection field <span>$\bar{g}$</span>, for a degenerate system given by <span>$\lambda \cdot \nabla \vartheta (t,q)$</span> (<em>optional</em>)</li><li><code>ψ</code>: secondary constraints, for a degenerate system given by <span>$\dot{p} - \dot{q} \cdot \nabla \vartheta (t,q)$</span> (<em>optional</em>)</li><li><code>ω</code>: function computing the symplectic matrix</li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span> (<em>optional</em>)</li><li><code>f̄</code>: function computing an initial guess for the force field <span>$f$</span> (<em>optional</em>)</li><li><code>lagrangian</code>: function computing the Lagrangian <span>$L$</span></li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">LDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, v̄, f̄, lagrangian, invariants, parameters, periodicity)
LDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, lagrangian; v̄ = _ldae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())
LDAE(ϑ, f, u, g, ϕ, ω, lagrangian; v̄ = _ldae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())</code></pre><p>where </p><pre><code class="language-julia hljs">_ldae_default_v̄(v, t, q, params) = nothing</code></pre><p>The function <code>ϑ</code> computes the momentum, <code>f</code> computes the force field, <code>u</code> and <code>g</code> compute the projections, and <code>ϕ</code> provides the algebraic constraint. The functions <code>ψ</code>, <code>ū</code> and <code>ḡ</code> are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.</p><p><strong>Function Definitions</strong></p><p>The functions <code>ϑ</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">function ϑ(p, t, q, v)
    p[1] = ...
    p[2] = ...
    ...
end

function f(f, t, q, v)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the current velocity and <code>f</code> and <code>p</code> are the vectors which hold the result of evaluating the functions <span>$f$</span> and <span>$ϑ$</span> on <code>t</code>, <code>q</code> and <code>v</code>. The funtions <code>g</code>, <code>v̄</code> and <code>f̄</code> are specified by</p><pre><code class="language-julia hljs">function u(u, t, q, v, p, λ)
    u[1] = ...
    u[2] = ...
    ...
end

function g(g, t, q, v, p, λ)
    g[1] = ...
    g[2] = ...
    ...
end

function v̄(v, t, q)
    v[1] = ...
    v[2] = ...
    ...
end

function f̄(f, t, q, v)
    f[1] = ...
    f[2] = ...
    ...
end</code></pre><p>and the functions <code>ω</code> and <code>l</code>, computing the symplectic matrix and the Lagrangian, have the following signature</p><pre><code class="language-julia hljs">function ω(f, t, q, v, params)
    ω[1,1] = ...
    ω[1,2] = ...
    ...
end

function l(t, q, v, params)
    return ...
end</code></pre><p>Some integrators also enforce the secondary constraint <span>$\psi$</span> and require the following additional functions</p><pre><code class="nohighlight hljs">function ū(u, t, q, v, p, γ, params)
    u[1] = ...
    u[2] = ...
    ...
end

function ḡ(g, t, q, v, p, γ, params)
    g[1] = ...
    g[2] = ...
    ...
end

function ψ(ψ, t, q, v, p, q̇, ṗ, params)
    ψ[1] = ...
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.SPDAE" href="#GeometricEquations.SPDAE"><code>GeometricEquations.SPDAE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SPDAE</code>: Split Partitioned Differential Algebraic Equation <em>EXPERIMENTAL</em></p><p>Defines a split differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v_1(t, q(t), p(t)) + v_2(t, q(t), p(t), \lambda(t)) + v_3(t, q(t), p(t), \lambda(t), \gamma(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f_1(t, q(t), p(t)) + f_2(t, q(t), p(t), \lambda(t)) + f_3(t, q(t), p(t), \lambda(t), \gamma(t)) , &amp; p(t_{0}) &amp;= p_{0} , \\
0 &amp;= \phi (t, q(t), p(t)) , \\
0 &amp;= \psi (t, q(t), p(t), \dot{q}(t), \dot{p}(t)) ,
\end{aligned}\]</p><p>with vector fields <span>$v_i$</span> and <span>$f_i$</span> for <span>$i = 1 ... 3$</span>, primary constraint <span>$\phi(q,p)=0$</span> and secondary constraint <span>$\psi(q,p,\lambda)=0$</span>, initial conditions <span>$(q_{0}, p_{0})$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span> and the algebraic variables <span>$(\lambda, \gamma)$</span> taking values in <span>$\mathbb{R}^{n} \times \mathbb{R}^{d}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Callable</code>: type of <code>v</code></li><li><code>fType &lt;: Callable</code>: type of <code>f</code></li><li><code>ϕType &lt;: Callable</code>: type of <code>ϕ</code></li><li><code>ψType &lt;: Callable</code>: type of <code>ψ</code></li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code>: tuple of functions computing the vector fields <span>$v_i$</span>, <span>$i = 1 ... 3$</span></li><li><code>f</code>: tuple of functions computing the vector fields <span>$f_i$</span>, <span>$i = 1 ... 3$</span></li><li><code>ϕ</code>: primary constraints</li><li><code>ψ</code>: secondary constraints</li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SPDAE(v, f, ϕ, ψ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)
SPDAE(v, f, ϕ, ψ, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)
SPDAE(v, f, ϕ, ψ, t₀, q₀::State, p₀::State, λ₀::State=zero(q₀); kwargs...)
SPDAE(v, f, ϕ, ψ, q₀::State, p₀::State, λ₀::State=zero(q₀); kwargs...)</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>invariants = nothing</code></li><li><code>parameters = nothing</code></li><li><code>periodicity = nothing</code></li></ul></div></section></article><h2 id="Stochastic-Differential-Equations"><a class="docs-heading-anchor" href="#Stochastic-Differential-Equations">Stochastic Differential Equations</a><a id="Stochastic-Differential-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-Differential-Equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.SDE" href="#GeometricEquations.SDE"><code>GeometricEquations.SDE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SDE</code>: Stratonovich Stochastic Differential Equation</p><p>Defines a stochastic differential initial value problem</p><p class="math-container">\[\begin{aligned}
dq (t) &amp;= v(t, q(t)) \, dt + B(t, q(t)) \circ dW , &amp; q(t_{0}) &amp;= q_{0} ,
\end{aligned}\]</p><p>with drift vector field <span>$v$</span>, diffusion matrix <span>$B$</span>, initial conditions <span>$q_{0}$</span>, the dynamical variable <span>$q$</span> taking values in <span>$\mathbb{R}^{d}$</span>, and the m-dimensional Wiener process W</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Callable</code>: type of <code>v</code></li><li><code>BType &lt;: Callable</code>: type of <code>B</code></li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code>:  function computing the deterministic vector field</li><li><code>B</code>:  function computing the d x m diffusion matrix</li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SDE(v, B, invariants, parameters, periodicity)
SDE(v, B; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())</code></pre><p>The functions <code>v</code> and <code>B</code>, providing the drift vector field and diffusion matrix. The function <code>v</code> must have the interface</p><pre><code class="language-julia hljs">function v(v, t, q, params)
    v[1] = ...
    v[2] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the vector which holds the result of evaluating the vector field <span>$v$</span> on <code>t</code> and <code>q</code>, and params are additional parameters. The function <code>B</code> should have a method with interface</p><pre><code class="language-julia hljs">function B(B, t, q, params)
    B[1,1] = ...
    ...
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.PSDE" href="#GeometricEquations.PSDE"><code>GeometricEquations.PSDE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PSDE</code>: Stratonovich Partitioned Stochastic Differential Equation</p><p>A partitioned stochastic differential equations is an initial value problem of the form</p><p class="math-container">\[\begin{aligned}
dq (t) &amp;= v(t, q(t), p(t)) \, dt + B(t, q(t), p(t)) \circ dW , &amp; q(t_{0}) &amp;= q_{0} , \\
dp (t) &amp;= f(t, q(t), p(t)) \, dt + G(t, q(t), p(t)) \circ dW , &amp; p(t_{0}) &amp;= p_{0}
\end{aligned}\]</p><p>with the drift vector fields <span>$v$</span> and <span>$f$</span>, diffusion matrices <span>$B$</span> and <span>$G$</span>, initial conditions <span>$q_{0}$</span> and <span>$p_{0}$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>, and the m-dimensional Wiener process W</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Callable</code>: type of <code>v</code></li><li><code>fType &lt;: Callable</code>: type of <code>f</code></li><li><code>BType &lt;: Callable</code>: type of <code>B</code></li><li><code>GType &lt;: Callable</code>: type of <code>G</code></li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code>:  function computing the drift vector field for the position variable <span>$q$</span></li><li><code>f</code>:  function computing the drift vector field for the momentum variable <span>$p$</span></li><li><code>B</code>:  function computing the d x m diffusion matrix for the position variable <span>$q$</span></li><li><code>G</code>:  function computing the d x m diffusion matrix for the momentum variable <span>$p$</span></li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">PSDE(v, f, B, G, invariants, parameters, periodicity)
PSDE(v, f, B, G; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())</code></pre><p>The functions <code>v</code>, <code>f</code>, <code>B</code> and <code>G</code>, providing the drift vector fields and diffusion matrices, each take five arguments, <code>v(v, t, q, p, params)</code>, <code>f(f, t, q, p, params)</code>, <code>B(B, t, q, p, params)</code> and <code>G(G, t, q, p, params)</code>, where <code>t</code> is the current time, <code>(q, p)</code> is the current solution, and <code>v</code>, <code>f</code>, <code>B</code> and <code>G</code> are the variables which hold the result of evaluating the vector fields <span>$v$</span>, <span>$f$</span> and the matrices <span>$B$</span>, <span>$G$</span> on <code>t</code> and <code>(q,p)</code>, and <code>params</code> are optional parameters.</p><p>The corresponding methods should have the following signatures:</p><pre><code class="language-julia hljs">function v(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f(f, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end

function B(B, t, q, p, params)
    B[1,1] = ...
    ...
end

function G(G, t, q, p, params)
    G[1,1] = ...
    ...
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.SPSDE" href="#GeometricEquations.SPSDE"><code>GeometricEquations.SPSDE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SPSDE</code>: Stratonovich Split Partitioned Stochastic Differential Equation</p><p>Defines a partitioned stochastic differential initial value problem</p><p class="math-container">\[\begin{aligned}
dq (t) &amp;=   v(t, q(t), p(t)) \, dt + B(t, q(t), p(t)) \circ dW , &amp; q(t_{0}) &amp;= q_{0} , \\
dp (t) &amp;= [ f_1(t, q(t), p(t)) + f_2(t, q(t), p(t)) ] \, dt + [ G_1(t, q(t), p(t)) + G_2(t, q(t), p(t)) ] \circ dW , &amp; p(t_{0}) &amp;= p_{0} ,
\end{aligned}\]</p><p>with the drift vector fields <span>$v$</span> and <span>$f_i$</span>, diffusion matrices <span>$B$</span> and <span>$G_i$</span>, initial conditions <span>$q_{0}$</span> and <span>$p_{0}$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>, and the m-dimensional Wiener process W</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Function</code>: type of <code>v</code></li><li><code>f1Type &lt;: Function</code>: type of <code>f1</code></li><li><code>f2Type &lt;: Function</code>: type of <code>f2</code></li><li><code>BType &lt;: Function</code>: type of <code>B</code></li><li><code>G1Type &lt;: Function</code>: type of <code>G1</code></li><li><code>G2Type &lt;: Function</code>: type of <code>G2</code></li><li><code>invType &lt;: OptionalInvariants</code>: invariants type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li><li><code>perType &lt;: OptionalPeriodicity</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code> :  function computing the drift vector field for the position variable <span>$q$</span></li><li><code>f1</code>:  function computing the drift vector field for the momentum variable <span>$p$</span></li><li><code>f2</code>:  function computing the drift vector field for the momentum variable <span>$p$</span></li><li><code>B</code> :  function computing the d x m diffusion matrix for the position variable <span>$q$</span></li><li><code>G1</code>:  function computing the d x m diffusion matrix for the momentum variable <span>$p$</span></li><li><code>G2</code>:  function computing the d x m diffusion matrix for the momentum variable <span>$p$</span></li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SPSDE(v, f1, f2, B, G1, G2, invariants, parameters, periodicity)
SPSDE(v, f1, f2, B, G1, G2; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())</code></pre><p>The functions <code>v</code>, <code>f1</code>, <code>f2</code>, <code>B</code>, <code>G1</code> and <code>G2</code>, providing the drift vector fields and diffusion matrices, all take five arguments, <code>(out, t, q, p, params)</code>.</p><pre><code class="language-julia hljs">function v(v, t, q, p, params)
    v[1] = ...
    v[2] = ...
    ...
end

function f1(f, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end

function f2(f, t, q, p, params)
    f[1] = ...
    f[2] = ...
    ...
end

function B(B, t, q, p, params)
    B[1,1] = ...
    ...
end

function G1(G, t, q, p, params)
    G[1,1] = ...
    ...
end

function G2(G, t, q, p, params)
    G[1,1] = ...
    ...
end</code></pre><p>where <code>t</code> is the current time, <code>(q,p)</code> is the current solution vector, and <code>v</code>, <code>f</code>, <code>B</code> and <code>G</code> are the variables which hold the result of evaluating the vector fields <span>$v$</span>, <span>$f$</span> and the matrices <span>$B_i$</span>, <span>$G_i$</span> on <code>(t,q,p)</code>.</p></div></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 17 February 2023 13:05">Friday 17 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
