var documenterSearchIndex = {"docs":
[{"location":"developer/integrators/#Integrators","page":"Integrators","title":"Integrators","text":"","category":"section"},{"location":"integrators/cgvi/#cgvi","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In the following, we first present the Galerkin framework for variational integrators [[41], [13], [42], [43], [44], [15]] where the space of curves mfQ that connect two points in mfM is approximated by a finite-dimensional subspace (Galerkin integrators of 0th kind). We use Lagrange polynomials to approximate the trajectories albeit other choices are possible. Alternatively, we can approximate the generalised velocities  (Galerkin integrators of 1st kind), which leads us to variational-partitioned Runge-Kutta methods. Even though, in some cases correspondences between integrators of 0th kind and integrators of 1st kind might be found, in general they are different.","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In our treatment we distinguish between integer timesteps, which are the coordinates q_n at time t_n, and internal stages (nodes), which are the coordinates Q_ni located between two integer timesteps q_n and q_n+1 at consecutive points in time t_n and t_n+1. In all of the following we assume that the timestep h is constant.","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In the discrete variational principle, we have to consider variations at both, the integer timesteps and the internal stages. For Galerkin integrators of 0th kind, the coordinates Q_ni are varied, whereas for the Galerkin integrators of 1st kind, the velocities dotQ_ni are varied. So the independent variables are (q_n Q_ni) and (q_n dotQ_ni), respectively.","category":"page"},{"location":"integrators/cgvi/#Space-of-Discrete-Trajectories","page":"Continuous Galerkin Variational Integrators","title":"Space of Discrete Trajectories","text":"","category":"section"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In order to construct the discrete space of curves from q_0 to q_N,","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"mfQ_d ( q_0 q_N  t_n _n=0^N ) = big q_d   t_n _n=0^N rightarrow mfM  bigvert  q_d (t_0) = q_0  q_d (t_N) = q_N big subset mfQ_d ( mfM ) ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"we will construct a finite-dimensional subspace of","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"mfQ ( q_0 q_N 0 T ) = big q  0 T rightarrow mfM  bigvert  q(0) = q_0  q(T) = q_N big subset mfQ ( mfM ) ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"The subspace mfQ_h ( q_0 q_N 0 T ) is defined by","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginequationlabeleqgalerkin-vi-space-of-piecewise-polynomials\nmfQ_h ( q_0 q_N 0 T ) = bigq_h  0 T rightarrow mfM  bigvert  q_h vert_  t_n  t_n+1   in mathbbP_s (t_n t_n+1)    q_h in C^0 (0 T) big \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"where mathbbP_s (t_n t_n+1) is the space of polynomials of degree s in the interval t_n t_n+1 subset 0 T. We see that mfQ_h ( q_0 q_N 0 T ) subset mfQ ( q_0 q_N 0 T ). In order for mfQ_h ( q_0 q_N 0 T ) to be an instance of mfQ_d ( q_0 q_N  t_n _n=0^N ) we have to require in addition to the definition \\eqref{eq:galerkin-vi-space-of-piecewise-polynomials} that  on the sequence  t_n _n=0^N, the curves q_h in mfQ_h ( q_0 q_N 0 T ) satisfy","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"q_h vert_  t_n  t_n+1   (t_n)   = q_n\nqquad textand qquad\nq_h vert_  t_n  t_n+1   (t_n+1) = q_n+1 ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"where q_n are the points of the discrete trajectories q_d =  q_n _n=0^N. However, it is often more convenient to enforce these continuity constraints weakly in the action rather than building them into the spaces, which implies dropping the condition q_h in C^0 (0 T) in \\eqref{eq:galerkin-vi-space-of-piecewise-polynomials}. This in turn means that the whole of mfQ_h ( q_0 q_N 0 T ) is not a subspace of mfQ ( q_0 q_N 0 T ) anymore.","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"TODO: The role of continuity is not clearly explained and probably not correctly worked out. In practice, we are using broken spaces mfQ_h and enforce continuity only weakly in the action principle.  It should be made clear, that mfQ_d is an approximation of mfQ, but not a subspace of mfQ. mfQ_h, however, is a subspace of mfQ (although it can be broken). The connection between mfQ_h and mfQ_d is made by the continuity constraints (which for Lagrange polynomials and sequences of nodes which include the boundaries, i.e., c_1=0 and c_s=1, is automatically satisfied). In this context we also need to discuss that curves in mfQ(mfM) are assumed to be C^2, which is not required by the curves in mfQ_h.","category":"page"},{"location":"integrators/cgvi/#Piecewise-Polynomials","page":"Continuous Galerkin Variational Integrators","title":"Piecewise Polynomials","text":"","category":"section"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"A basis of mfQ_h ( q_0 q_N 0 T ) can easily be constructed by combining bases of mathbbP_s (t_n t_n+1), e.g., using Lagrange polynomials. We start by specifying the collocation times of the internal stages. Select a set of s points c_i with 0 leq c_i leq 1, which are the nodes of the basis functions. Therefore the basis is built by s functions. The internal stages are then located at t_ni = t_n + h c_i, such that","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"t_n leq t_n1    t_ns leq t_n+1 ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"and we have","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"Q_ni approx q ( t_ni ) ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"We will only be concerned with Lagrange polynomials. The j-th Lagrange polynomial of order s is defined by","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"l^si (tau) = prod limits_substack1 leq j leq s j neq i dfractau - c_jc_i - c_j ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"The c_i are often chosen to be the collocation points of some quadrature rule (e.g., Gauß-Legendre or Gauß-Chebyshew points). Within each subinterval between two consecutive timesteps, t_n and t_n+1, the same Lagrange basis is used, namely","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"spn big varphi_n^sm (t)  bigvert  1 leq m leq s big ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"with","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"varphi_n^sm (t) = begincases\nl^sm big( (t-t_n)  (t_n+1 - t_n) big)  hspace5em  t_n leq t leq t_n+1  \nhspace8em 0   textelse \nendcases","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"It suffices to specify the basis for one subinterval t_n t_n+1 and then replicate this basis for all subintervals, so that the finite-dimensional subspace of mfQ ( q_0 q_N 0 T ) is given by","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginmultline\nmfQ_h ( q_0 q_N 0 T ) \n= Big q_h  0 T rightarrow mfM  Bigvert  q_h bigvert_t_n t_n+1 in spn big varphi_n^sm  bigvert  1 leq m leq s big    textfor  0 leq n leq N-1  \n  q_h (0) = q_0   q_h (T) = q_N Big \nendmultline","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In order to obtain the discrete space of curves mfQ_d ( q_0 q_N  t_n _n=0^N ) we have to add continuity constraints, connecting the polynomials in each interval with the nodal values q_n, that is","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginmultline\nmfQ_d ( q_0 q_N  t_n _n=0^N ) \n= Big q_h in mfQ_h ( q_0 q_N 0 T )  Bigvert  q_h bigvert_t_n t_n+1 (t_n) = q_n   q_h bigvert_t_n t_n+1 (t_n+1) = q_n+1 Big \nendmultline","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"We project the trajectories of the particles onto a Lagrange basis in order to obtain the polynomial approximation of the trajectory in the interval t_n t_n+1, i.e.,","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginequationlabeleqparticle-trajectory-position\nq_h (t) bigvert_t_n t_n+1 = sum limits_m=1^s Q_nm  varphi_n^sm (t) \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"The particle velocities are then obtained by differentiating with respect to time,","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginequationlabeleqparticle_trajectory_velocity\ndotq_h (t) bigvert_t_n t_n+1 = sum limits_m=1^s Q_nm  dotvarphi_n^sm (t) \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"For s=2, we obtain","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginaligned\nq_h (t) bigvert_  t_n  t_n+1   = Q_n1  dfract - t_n+1t_n - t_n+1 + Q_n2  dfract - t_nt_n+1 - t_n  \ndotq_h (t) bigvert_  t_n  t_n+1   = dfracQ_n2 - Q_n1t_n+1 - t_n \nendaligned","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"which is just linear interpolation for q and piecewise constant for dotq.","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"TODO: Discuss other basis functions (e.g. Chebychev polynomials, B-splines) and other quadrature rules (e.g., Chebyshev points, optimised IGA points) and visualise basis functions for different quadrature points.","category":"page"},{"location":"integrators/cgvi/#Numerical-Quadrature","page":"Continuous Galerkin Variational Integrators","title":"Numerical Quadrature","text":"","category":"section"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In order to numerically compute the definite integral","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginequationlabeleqgalerkin-vi-quadrature-integral\nF q = int limits_t_n^t_n+1 f big( t q(t) big)  dt \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"we apply two levels of approximation. As q(t) is unknown, we replace it with the piecewise polynomial approximation q_h (t). Further, we introduce a quadrature formula in which f itself is approximated by a Lagrange polynomial, i.e.,","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"f_h (t q (t)) = sum limits_i=1^s varphi_n^si (t)  f big( t_n + h c_i  q (t_n + h c_i) big) ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"Together, this gives an approximation of the integral \\eqref{eq:galerkin-vi-quadrature-integral} as follows","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginequationlabeleqgalerkin_vi_quadrature_rule\nF_h q\n= int limits_t_n^t_n+1 f_h (t q_h (t))  dt\n= h sum limits_i=1^s b_i  f big( t_n + h c_i  q_h (t_n + h c_i) big) \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"where b_i are the weights or coefficients of the quadrature formula, given by","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginequationlabeleqgalerkin_vi_quadrature_weights\nb_i\n= dfrac1h int limits_t_n^t_n+1 varphi_n^si (t)  dt\n= int limits_0^1 l^si (tau)  dtau \nendequation","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"h = t_n+1 - t_n","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"is the time step, and q_h (t) bigvert_  t_n  t_n+1   is some polynomial approximation to q(t) in the interval t_n t_n+1. %The c_i will also be the collocation points of the quadrature rule that is used to approximate the action integral. We will focus on collocation methods where the nodes c_i of the quadrature rule are also the nodes of the basis functions, so that for \\eqref{eq:particle-trajectory-position}, we have q_h (t_n + h c_i) = Q_ni. It follows that the discrete Lagrangian can be written as","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"L_d (q_n q_n+1) = h sum limits_i=1^s b_i  L big( Q_ni  dotQ_ni big) ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"Most often, we use Gauss-Legendre quadrature, where the nodes c_i are given by the roots of the Legendre polynomials. The Gauss quadrature rules with s nodes yield exact results when applied to polynomials of order up to 2s.","category":"page"},{"location":"integrators/cgvi/#Galerkin-Variational-Integrators","page":"Continuous Galerkin Variational Integrators","title":"Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In order to write the discrete Lagrangian in the discrete action in a compact form, we define the nodal coefficients a_ij,","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"a_ij\n= h dfracd varphi_n^sjdt biggvert_t=t_n + h c_i\n= dfracd l^sjdtau biggvert_tau=c_i ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"so that the velocities can be written as","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"dotQ_ni\n= dotq_h (t_ni)\n= sum limits_j=1^s Q_nj  dotvarphi_n^sj (t_n + h c_i)\n= dfrac1h sum limits_j=1^s a_ij  Q_nj ","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"In order to complete the discrete action, we explicitly add the continuity constraint,","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"beginmultline\nmathcalA_d q_d\n= sum limits_n=0^N-1 bigg\n\tsum limits_i=1^s b_i  L big( Q_ni  dotQ_ni big)\n  + lambda_n cdot big( q_hvert_  t_n  t_n+1   (t_n  ) - q_n   big) \n  + mu_n+1   cdot big( q_hvert_  t_n  t_n+1   (t_n+1) - q_n+1 big)\nbigg \nendmultline","category":"page"},{"location":"integrators/cgvi/","page":"Continuous Galerkin Variational Integrators","title":"Continuous Galerkin Variational Integrators","text":"which ensures that the polynomials in neighbouring intervals, e.g., t_n t_n+1 and t_n+1 t_n+2, have the same value at integer timesteps, e.g., t_n+1.","category":"page"},{"location":"integrators/dvi/#Degenerate-Variational-Integrators","page":"DVI","title":"Degenerate Variational Integrators","text":"","category":"section"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"CurrentModule = GeometricIntegrators.SPARK","category":"page"},{"location":"integrators/spark/#Special-Partitioned-Additive-Runge-Kutta-Integrators","page":"SPARK","title":"Special Partitioned Additive Runge-Kutta Integrators","text":"","category":"section"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"SPARK or Special Partitioned Additive Runge-Kutta Integrators are a family of integrators that have been introduced by Laurent O. Jay for the integration of differential algebraic equations and in particular systems subject to holonomic and nonholonomic constraints [[37], [33], [34], [38], [39]]. Recently, the idea of SPARK methods has been generalized and adapted to facilitate the integration of degenerate Lagrangian systems as well as Hamiltonian systems subject to Dirac constraints [[40]].","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"GeometricIntegrators.jl provides several flavours of such SPARK methods (some are still experimental):","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"Integrator Description\nIntegratorHPARK Partitioned additive methods for Hamiltonian system subject to a general constraint phi(qp) = 0\nIntegratorVPARK Partitioned additive methods for Lagrangian system subject to a general constraint phi(qp) = 0\nIntegratorSPARK SPARK methods for general index-two differential algebraic equations\nIntegratorHSPARK Hamiltonian system subject to a general constraint phi(qp) = 0\nIntegratorHSPARKprimary Hamiltonian system subject primary constraint in the sense of Dirac\nIntegratorHSPARKsecondary Hamiltonian system enforcing primary & secondary Dirac constraint\nIntegratorVSPARK Lagrangian system in implicit form subject to a general constraint phi(qp) = 0\nIntegratorVSPARKprimary Degenerate Lagrangian system subject primary constraint in the sense of Dirac\nIntegratorVSPARKsecondary Degenerate Lagrangian system enforcing primary & secondary Dirac constraint","category":"page"},{"location":"integrators/spark/","page":"SPARK","title":"SPARK","text":"These integrators are applied to either an IDAE, HDAE or LDAE.","category":"page"},{"location":"integrators/various/#Various-Integrators","page":"Various Integrators","title":"Various Integrators","text":"","category":"section"},{"location":"integrators/various/","page":"Various Integrators","title":"Various Integrators","text":"GeometricIntegrators.Integrators.IntegratorExplicitEuler\nGeometricIntegrators.Integrators.IntegratorImplicitEuler","category":"page"},{"location":"modules/methods/#Methods","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"modules/methods/","page":"Methods","title":"Methods","text":"Modules = [GeometricIntegrators.Methods]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"developer/adaptive_time_stepping/#Adaptive-Time-Stepping","page":"Adaptive Time Stepping","title":"Adaptive Time Stepping","text":"","category":"section"},{"location":"developer/adaptive_time_stepping/","page":"Adaptive Time Stepping","title":"Adaptive Time Stepping","text":"GeometricIntegrators.jl does not provide any general infrastructure for adaptive time stepping. The main reason is that adaptive time stepping is not easy to combine with structure-preservation. Most typical applicatons of the GeometricIntegrators developers require the output of solutions at a sequence of time steps with constant step size.","category":"page"},{"location":"developer/adaptive_time_stepping/","page":"Adaptive Time Stepping","title":"Adaptive Time Stepping","text":"Nonetheless, geometric methods with time step adaptation do exist and it is not hard to implement such methods in the GeometricIntegrators framework. Here, the standard infrastructure is used to specify \"target time steps\", at which a solution has to be computed. That means an adaptive integrator is required to compute a solution for every point in the equidistant time series, but in between in adapts as it wishes. Whenever an adaptive time step would step over a \"target time step\", it is reduced to hit that target. For geometric, structure-preserving integrators that often is the only sensible thing to do (and for most practical applications as well).","category":"page"},{"location":"developer/adaptive_time_stepping/","page":"Adaptive Time Stepping","title":"Adaptive Time Stepping","text":"In all of this, the integrator has to take care of the sub-cycling and the rest of GeometricIntegrators doesn't really care about it. If for some reason you want to output the solution at the intermediate irregular time steps, this is relatively easily possible via the (still mostly undocumented) mid-level interface that is used to call the integrators.","category":"page"},{"location":"modules/simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"modules/simulations/","page":"Simulations","title":"Simulations","text":"Modules = [GeometricIntegrators.Simulations]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/rungekutta_partitioned/#PartitionedRungeKuttaTableaus","page":"Partitioned Runge-Kutta Tableaus","title":"Partitioned Runge-Kutta Tableaus","text":"","category":"section"},{"location":"modules/rungekutta_partitioned/","page":"Partitioned Runge-Kutta Tableaus","title":"Partitioned Runge-Kutta Tableaus","text":"The following tableaus are all implemented in RungeKutta.jl.","category":"page"},{"location":"modules/rungekutta_partitioned/","page":"Partitioned Runge-Kutta Tableaus","title":"Partitioned Runge-Kutta Tableaus","text":"RungeKutta.PartitionedTableau","category":"page"},{"location":"modules/rungekutta_partitioned/#RungeKutta.PartitionedTableau","page":"Partitioned Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableau","text":"Tableau of a Partitioned Runge-Kutta method\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  v(t_n + c_j Delta t Q_nj P_nj)  \nq_n+1 = q_n + h sum limits_i=1^s b_i   v(t_n + c_j Delta t Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  f(t_n + c_j Delta t Q_nj P_nj)  \np_n+1 = p_n + h sum limits_i=1^s barb_i    f(t_n + c_j Delta t Q_ni P_ni) \nendaligned\n\nParameters:\n\nT: datatype of coefficient arrays\n\nFields:\n\nname: symbolic name of the tableau\no: order of the method\ns: number of stages\nq: Tableau for q\np: Tableau for p\nR∞: stability function at infinity\n\nThe actual tableaus are stored in q and p:\n\na: coefficients a_ij with $ 1 \\le i,j \\le s$\nb: weights b_i  with $ 1 \\le i \\le s$\nc: nodes c_i  with $ 1 \\le i \\le s$\n\nConstructors:\n\nPartitionedTableau{T}(name, o, q, p)\nPartitionedTableau{T}(name, q, p)\nPartitionedTableau(name::Symbol, q::Tableau, p::Tableau)\nPartitionedTableau(name::Symbol, q::Tableau)\n\n\n\n\n\n","category":"type"},{"location":"modules/rungekutta_partitioned/","page":"Partitioned Runge-Kutta Tableaus","title":"Partitioned Runge-Kutta Tableaus","text":"Modules = [RungeKutta.PartitionedTableaus]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.PartitionedTableauGauss-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Partitioned Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.PartitionedTableauGauss","text":"Partitioned Gauss-Legendre Runge-Kutta tableau with s stages\n\nPartitionedTableauGauss(::Type{T}, s)\nPartitionedTableauGauss(s) = PartitionedTableauGauss(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauGauss for both coefficients a and ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIB-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Partitioned Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIB","text":"Partitioned Gauss-Lobatto IIIA-IIIB tableau with s stages\n\nTableauLobattoIIIAIIIB(::Type{T}, s)\nTableauLobattoIIIAIIIB(s) = TableauLobattoIIIAIIIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIA for a and TableauLobattoIIIB for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Partitioned Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIAIIIĀ","text":"Tableau for Gauss-Lobatto IIIA-IIIĀ method with s stages\n\nTableauLobattoIIIAIIIĀ(::Type{T}, s)\nTableauLobattoIIIAIIIĀ(s) = TableauLobattoIIIAIIIĀ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIA for a and TableauLobattoIIIĀ for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIA-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Partitioned Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages\n\nTableauLobattoIIIBIIIA(::Type{T}, s)\nTableauLobattoIIIBIIIA(s) = TableauLobattoIIIBIIIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIB for a and TableauLobattoIIIA for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Partitioned Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIBIIIB̄","text":"Tableau for Gauss-Lobatto IIIB-IIIB̄ method with s stages\n\nTableauLobattoIIIBIIIB̄(::Type{T}, s)\nTableauLobattoIIIBIIIB̄(s) = TableauLobattoIIIBIIIB̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIB for a and TableauLobattoIIIB̄ for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIICIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Partitioned Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIICIIIC̄","text":"Tableau for Gauss-Lobatto IIIC-IIIC̄ method with s stages\n\nTableauLobattoIIICIIIC̄(::Type{T}, s)\nTableauLobattoIIICIIIC̄(s) = TableauLobattoIIICIIIC̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIC for a and TableauLobattoIIIC̄ for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIC̄IIIC-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Partitioned Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIC̄IIIC","text":"Tableau for Gauss-Lobatto IIIC̄-IIIC method with s stages\n\nTableauLobattoIIIC̄IIIC(::Type{T}, s)\nTableauLobattoIIIC̄IIIC(s) = TableauLobattoIIIC̄IIIC(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIC̄ for a and TableauLobattoIIIC for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIDIIID̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Partitioned Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIDIIID̄","text":"Tableau for Gauss-Lobatto IIID-IIID̄ method with s stages\n\nTableauLobattoIIIDIIID̄(::Type{T}, s)\nTableauLobattoIIIDIIID̄(s) = TableauLobattoIIIDIIID̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIID for a and TableauLobattoIIID̄ for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIEIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Partitioned Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIEIIIĒ","text":"Tableau for Gauss-Lobatto IIIE-IIIĒ method with s stages\n\nTableauLobattoIIIEIIIĒ(::Type{T}, s)\nTableauLobattoIIIEIIIĒ(s) = TableauLobattoIIIEIIIĒ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIE for a and TableauLobattoIIIĒ for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIFIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Partitioned Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIFIIIF̄","text":"Tableau for Gauss-Lobatto IIIF-IIIF̄ method with s stages\n\nTableauLobattoIIIFIIIF̄(::Type{T}, s)\nTableauLobattoIIIFIIIF̄(s) = TableauLobattoIIIFIIIF̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIF for a and TableauLobattoIIIF̄ for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIF̄IIIF-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Partitioned Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIF̄IIIF","text":"Tableau for Gauss-Lobatto IIIF̄-IIIF method with s stages\n\nTableauLobattoIIIF̄IIIF(::Type{T}, s)\nTableauLobattoIIIF̄IIIF(s) = TableauLobattoIIIF̄IIIF(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIF̄ for a and TableauLobattoIIIF for ā.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta_partitioned/#RungeKutta.PartitionedTableaus.TableauLobattoIIIGIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Partitioned Runge-Kutta Tableaus","title":"RungeKutta.PartitionedTableaus.TableauLobattoIIIGIIIḠ","text":"Tableau for Gauss-Lobatto IIIG-IIIḠ method with s stages\n\nTableauLobattoIIIGIIIḠ(::Type{T}, s)\nTableauLobattoIIIGIIIḠ(s) = TableauLobattoIIIGIIIḠ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThis PartitionedTableau uses TableauLobattoIIIG for a and TableauLobattoIIIḠ for ā.\n\n\n\n\n\n","category":"method"},{"location":"solutions/#Solutions","page":"-","title":"Solutions","text":"","category":"section"},{"location":"solutions/","page":"-","title":"-","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator\nprob = harmonic_oscillator_ode()","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"In what we have seen so far, the solution was always automatically created by the integrate() function. While this is often convenient, it is sometimes not performant, e.g., when carrying out long-time simulations with intermediate saving of the solution. In such cases, it is better to preallocate a solution object by","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"sol = Solution(prob)","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"where the first argument is an equation, the second argument is the time step and the third argument is the number of time steps that will be computed in one integration step. The call to the integrator is then made via","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"int = Integrator(prob, Gauss(1))\nintegrate!(sol, int)","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"If several integration cycles shall be performed, the reset!() function can be used to copy the solution of the last time step to the initial conditions of the solution,","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"for i in 1:10\n    # integrate!(sol, int)\n    #\n    # save or process solution\n    #\n    # reset!(sol)\nend","category":"page"},{"location":"solutions/","page":"-","title":"-","text":"All solutions have a t field holding the series of time steps that has been computed in addition to several data fields, for example q for an ODE solution, q and p for a PODE solution, qand λ for a DAE solution, and q, p and λ for a PDAE solution.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"CurrentModule = GeometricIntegrators","category":"page"},{"location":"integrators/rk/#Runge-Kutta-Methods","page":"Runge-Kutta","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Runge-Kutta methods exploit the Fundamental Theorem of Calculus, which states that the solution of an initial-value problem","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\ndotx (t) = f(t x(t))  \nx(t_n) = x_n \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"at time t_n+1 is given by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"x (t_n+1) = x (t_n) + int limits_t_n^t_n+1 dotx (t)  dt ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Runge-Kutta methods are constructed by approximating the integral by some quadrature formula with s nodes c_i and corresponding weights b_i to obtain x_n+1 approx x (t_n+1) by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nx_n+1 = x_n + h sum limits_i=1^s b_i dotX_ni  \ndotX_ni = f(t_n + c_i h X_ni) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"where the internal stage values X_ni approx x(t_n + c_i h) for i = 1  s are determined by another quadrature formula, approximating the integral","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"x(t_n + c_i h) = x (t_n) + int limits_t_n^t_n + c_i h dotx (t)  dt ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"namely","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"X_ni = x_n + h sum limits_j=1^s a_ij dotX_nj ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"with the same vector field values dotX_nj used for the computation of x_n+1.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Definition: Runge-Kutta methods are numerical one-step methods","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nX_ni = x_n + h sum limits_j=1^s a_ij  f(t_n + c_j h X_nj)  \nx_n+1 = x_n + h sum limits_j=1^s b_j   f(t_n + c_j h X_nj) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"defined by a set of nodes c_i, weights b_i and coefficients a_ij with ij = 1  s, summarized in the Butcher tableau","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginarraycc\nc  a     \nhline\n   b^T \nendarray\n=\nbeginarrayccccc\nc_1   a_11  a_12  dots  a_1s \nc_2   a_21  a_22  dots  a_2s \nvdots  vdots  vdots  ddots  vdots \nc_s   a_s1  a_s2  dots  a_ss \nhline\n        b_1   b_2   dots  b_s  \nendarray","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Most properties of the methods, such as order or stability, can be analysed just by posing conditions on the Butcher tableau.","category":"page"},{"location":"integrators/rk/#Common-Runge-Kutta-Methods","page":"Runge-Kutta","title":"Common Runge-Kutta Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"GeometricIntegrators.jl provides various explicit and implicit (both diagonally and fully implicit) Runge-Kutta methods. For many methods, tabulated coefficients are included, namely","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Function and Aliases Stages Order\nExplicit Methods  \nTableauExplicitEuler, TableauForwardEuler 1 1\nTableauExplicitMidpoint 2 2\nTableauHeun2 2 2\nTableauHeun3 3 3\nTableauKutta, TableauKutta3 3 3\nTableauRalston2 2 2\nTableauRalston3 3 3\nTableauRunge, TableauRunge2 2 2\nTableauRK416, TableauRK4 4 4\nTableauRK438 4 4\nTableauSSPRK3 3 3\nDiagonally Implicit Methods  \nTableauCrankNicolson 2 2\nTableauCrouzeix 2 3\nTableauKraaijevangerSpijker 2 2\nTableauQinZhang 2 2\nFully Implicit Methods  \nTableauImplicitEuler, TableauBackwardEuler 1 1\nTableauImplicitMidpoint 2 2\nTableauSRK3 3 4","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The coefficients of other methods are computed on-the-fly as described in the following.","category":"page"},{"location":"integrators/rk/#Simplifying-Assumptions","page":"Runge-Kutta","title":"Simplifying Assumptions","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The construction of many Runge-Kutte methods, in particular the Gauß, Lobatto and Radau methods, relies on the so-called simplifying assumptions:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nB(sigma)  sum limits_i=1^s b_i c_i^k-1 = frac1k  \nk = 1      sigma  \n\nC(eta)  sum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  \ni = 1     s   k = 1      eta  \n\nD(zeta)  sum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k )  \nj = 1     s   k = 1      zeta \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"These assumptions provide order conditions for a Runge-Kutta method given by (a_ij b_i c_i). The condition B(p) implies that the quadrature rule (b_i c_i) is of order p. Furthermore, the following theorem holds:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Theorem (Butcher 1964): If the coefficients (a_ij b_i c_i) of a Runge-Kutta method satisfy B(sigma), C(eta), D(zeta) with sigma le eta + zeta + 1 and sigma le 2 eta + 2, then the method is of order sigma.","category":"page"},{"location":"integrators/rk/#Gauß,-Lobatto-and-Radau-Methods","page":"Runge-Kutta","title":"Gauß, Lobatto and Radau Methods","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Gauß methods are collocation methods using the nodes and weights of Gaußian quadrature formulas. The nodes are the zeros of the shifted Legendre polynomials of degree s,","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"fracd^sdx^s big( x^s (x-1)^s big) ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"In a similar fashion, the nodes of the Radau I and II and the Lobatto III methods are defined as the roots of the polynomials","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\n fracd^s-1dx^s-1 big( x^s (x-1)^s-1 big)      text(Radau I)  \n fracd^s-1dx^s-1 big( x^s-1 (x-1)^s big)      text(Radau II)  \n fracd^s-2dx^s-2 big( x^s-1 (x-1)^s-1 big)  text(Lobatto III) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The weights b_1  b_s are chosen such that the methods satisfy B(sigma), that is B(s), for the Gauß methods, B(s-1) for the Radau methods, and B(s-2) for the Lobatto methods.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The coefficients a_ij for ij = 1  s are obtained by the simplifying assumption C(s) for the Gauß, Radau IIA and Lobatto IIIA methods, and by the simplifying assumption D(s) for the Radau IA and Lobatto IIIB methods. The coefficients of the Lobatto IIIC methods are determined by setting a_i1 = b_1 for i = 1  s and solving the simplifying assumption C(s-1), while the coefficients of the Lobatto IIIC̄ methods are determined by setting a_is = 0 and solving C(s-1). Note that the Lobatto IIIC̄ methods are sometimes also called Lobatto III or Lobatto III*. For reasons of code symmetry we chose to stick with the less common name Lobatto IIIC̄. The Lobatto IIID and IIIE methods are obtained by combining the tableaus of the Lobatto IIIC and IIIC̄ and the Lobatto IIIA and IIIB methods, respectively, i.e., ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\na_ij^D = tfrac12 ( a_ij^C + a_ij^C ) \n textand \na_ij^E = tfrac12 ( a_ij^A + a_ij^B ) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"While the Lobatto IIIA, IIIB, IIIC and IIIC̄ methods are not symplectic on their own (although the Lobatto IIIA-IIIB and IIIC-IIIC̄ pairs constitute symplectic partitioned Runge-Kutta methods), the Lobatto IIID and IIIE methods are each symplectic by themselves.","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The Gauß methods are of order 2s, the Radau methods or order 2s-1 and the Lobatto methods are of order 2s-2, with the exception of the Lobatto IIIF method. This method has been specifically constructed to be of order 2s as described in [[3]]. The Lobatto IIIG method is constructed in a similar fashion as the Lobatto IIID and IIIE methods by averaging the coefficients of the Lobatto IIIF method with its symplectic complement, i.e.,","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"a_ij^G = tfrac12 ( a_ij^F + bara_ij^F ) ","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"where the coffiecients bara_ij^F are determined by","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nb_i bara^F_ij + barb_j a^F_ji = b_i barb_j  \n textand \nbarb_i = b_i \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The tableaus of all of the above methods can be computed for an arbitrary number of stages s and thus to arbitrary order.","category":"page"},{"location":"integrators/rk/#Constructors","page":"Runge-Kutta","title":"Constructors","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The following methods are provided for selecting the previously described Runge-Kutta schemes:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Function Method Order\nTableauGauss(s) Gauß-Legendre with s stages 2s\nTableauLobattoIIIA(s) Lobatto IIIA with s stages 2s-2\nTableauLobattoIIIB(s) Lobatto IIIB with s stages 2s-2\nTableauLobattoIIIC(s) Lobatto IIIC with s stages 2s-2\nTableauLobattoIIIC̄(s) Lobatto IIIC̄ with s stages 2s-2\nTableauLobattoIIID(s) Lobatto IIID with s stages 2s-2\nTableauLobattoIIIE(s) Lobatto IIIE with s stages 2s-2\nTableauLobattoIIIF(s) Lobatto IIIF with s stages 2s-2\nTableauLobattoIIIG(s) Lobatto IIIG with s stages 2s-2\nTableauRadauIA(s) Radau IA with s stages 2s-1\nTableauRadauIB(s) Radau IB with s stages 2s-1\nTableauRadauIIA(s) Radau IIA with s stages 2s-1\nTableauRadauIIB(s) Radau IIB with s stages 2s-1","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The first argument s refers to the number of stages (s ge 1 for Gauß and s ge 2 for all other methods). The second argument specifies the number type of the coefficients. Internally, all coefficients are computed using BigFloat and then converted to the requested number type, defaulting to Float64.","category":"page"},{"location":"integrators/rk/#Partitioned-Equations","page":"Runge-Kutta","title":"Partitioned Equations","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Partitioned Runge-Kutta methods consist of two tableaus that solve a partitioned ordinary differential equation,","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\ndotq (t) = v(t q(t) p(t))  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))  \np(t_0) = p_0 \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"in the following way:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  v(t_n + c_j Delta t Q_nj P_nj)  \nq_n+1 = q_n + h sum limits_i=1^s b_i   v(t_n + c_j Delta t Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  f(t_n + c_j Delta t Q_nj P_nj)  \np_n+1 = p_n + h sum limits_i=1^s barb_i    f(t_n + c_j Delta t Q_ni P_ni) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"The PartitionedTableau data structure can be used to compose any two Runge-Kutta tableaus into a partitioned Runge-Kutta tableau. A particular interesting family of partitioned Runge-Kutta methods are symplectic Lobatto methods, specifically","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Function Method Order\nTableauLobattoIIIAIIIB(s) Lobatto-IIIA-IIIB 2s-2\nTableauLobattoIIIBIIIA(s) Lobatto-IIIB-IIIA 2s-2\nTableauLobattoIIIAIIIĀ(s) Lobatto-IIIA-IIIĀ 2s-2\nTableauLobattoIIIBIIIB̄(s) Lobatto-IIIB-IIIB̄ 2s-2\nTableauLobattoIIICIIIC̄(s) Lobatto-IIIC-IIIC̄ 2s-2\nTableauLobattoIIIC̄IIIC(s) Lobatto-IIIC̄-IIIC 2s-2\nTableauLobattoIIIDIIID̄(s) Lobatto-IIID-IIID̄ 2s-2\nTableauLobattoIIIEIIIĒ(s) Lobatto-IIIE-IIIĒ 2s-2\nTableauLobattoIIIFIIIF̄(s) Lobatto-IIIF-IIIF̄ 2s\nTableauLobattoIIIF̄IIIF(s) Lobatto-IIIF̄-IIIF 2s\nTableauLobattoIIIGIIIḠ(s) Lobatto-IIIG-IIIḠ 2s","category":"page"},{"location":"integrators/rk/#Implicit-Equations","page":"Runge-Kutta","title":"Implicit Equations","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"An implicit ordinary differential equations is an initial value problem of the form","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t)) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Such problems can be integrated with adapted Runge-Kutta methods, namely","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"beginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  v(t_n + c_j Delta t Q_nj P_nj)  \nq_n+1 = q_n + h sum limits_i=1^s b_i   v(t_n + c_j Delta t Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  f(t_n + c_j Delta t Q_nj P_nj)  \np_n+1 = p_n + h sum limits_i=1^s barb_i    f(t_n + c_j Delta t Q_ni P_ni)  \nP_ni = ϑ(t_n + c_j Delta t Q_nj P_nj) \nendaligned","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Implicit ODEs can be integrated with any implicit Runge-Kutta or partitioned Runge-Kutta method.","category":"page"},{"location":"integrators/rk/#Custom-Tableaus","page":"Runge-Kutta","title":"Custom Tableaus","text":"","category":"section"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"If required, it is straight-forward to create a custom tableau. The tableau of Heun's method, for example, is defined as follows:","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"using GeometricIntegrators # hide\na = [[0.0 0.0]\n     [1.0 0.0]]\nb = [0.5, 0.5]\nc = [0.0, 1.0]\no = 2\n\ntab = Tableau(:heun, o, a, b, c)","category":"page"},{"location":"integrators/rk/","page":"Runge-Kutta","title":"Runge-Kutta","text":"Here, o is the order of the method, a are the coefficients, b the weights and c the nodes. For partitioned Runge-Kutta tableaus, PartitionedTableau can be used. The first parameter of the constructor of each tableau assigns a name to the tableau. Such custom tableaus can be used in exactly the same as standard tableaus, making it very easy to implement and test new Runge-Kutta methods.","category":"page"},{"location":"modules/problems/#Problem-Types","page":"Problems","title":"Problem Types","text":"","category":"section"},{"location":"modules/problems/","page":"Problems","title":"Problems","text":"The following data structures are all implemented in GeometricEquations.jl. Each problem type is derived from GeometricProblem.","category":"page"},{"location":"modules/problems/#Geometric-Problems","page":"Problems","title":"Geometric Problems","text":"","category":"section"},{"location":"modules/problems/","page":"Problems","title":"Problems","text":"GeometricEquations.GeometricProblem","category":"page"},{"location":"modules/problems/#Ordinary-Differential-Equations","page":"Problems","title":"Ordinary Differential Equations","text":"","category":"section"},{"location":"modules/problems/","page":"Problems","title":"Problems","text":"GeometricEquations.ODEProblem\nGeometricEquations.PODEProblem\nGeometricEquations.HODEProblem\nGeometricEquations.IODEProblem\nGeometricEquations.LODEProblem\nGeometricEquations.SODEProblem","category":"page"},{"location":"modules/problems/#GeometricEquations.ODEProblem","page":"Problems","title":"GeometricEquations.ODEProblem","text":"ODEProblem: Ordinary Differential Equation Problem\n\nOrdinary differential equations define an initial value problem of the form\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d.\n\nConstructors\n\nODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)\nODEProblem(v, tspan, tstep, q₀::State; kwargs...)\n\nwhere v is the function computing the vector field,  tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe function v providing the vector field must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params is a NamedTuple of additional parameters on which the vector field may depend.\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.PODEProblem","page":"Problems","title":"GeometricEquations.PODEProblem","text":"PODEProblem: Partitioned Ordinary Differential Equation Problem\n\nA partitioned ordinary differential equation is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))  \np(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d.\n\nConstructors\n\nPODEProblem(v, f, tspan, tstep, ics; kwargs...)\nPODEProblem(v, f, tspan, tstep, q₀::State, p₀::State; kwargs...)\n\nwhere v and f are the function computing the vector fields,  tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v and f must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.HODEProblem","page":"Problems","title":"GeometricEquations.HODEProblem","text":"HODEProblem: Hamiltonian Ordinary Differential Equation Problem\n\nA canonical Hamiltonian system of equations is special case of a partitioned ordinary differential equation,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))   p(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, given by\n\nbeginaligned\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendaligned\n\ninitial conditions (q_0 p_0) and the dynamical variables (qp) taking values in T^* Q simeq mathbbR^d times mathbbR^d.\n\nConstructors\n\nHODEProblem(v, f, hamiltonian, tspan, tstep, ics; kwargs...)\nHODEProblem(v, f, hamiltonian, tspan, tstep, q₀::State, p₀::State; kwargs...)\n\nwhere v and f are the function computing the vector fields,  hamiltonian returns the value of the Hamiltonian (i.e. the total energy), tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nKeyword arguments:\n\ninvariants = NullInvariants()\nparameters = NullParameters()\nperiodicity = NullPeriodicity()\n\nFunction Definitions\n\nThe functions v, f and hamiltonian must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction hamiltonian(t, q, p, params)\n    return ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.IODEProblem","page":"Problems","title":"GeometricEquations.IODEProblem","text":"IODEProblem: Implicit Ordinary Differential Equation Problem\n\nAn implicit ordinary differential equations is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith force field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMost integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + λ(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) λ(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \nλ(t_0) = λ_0\nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nConstructors\n\nIODEProblem(ϑ, f, tspan, tstep, ics; kwargs...)\nIODEProblem(ϑ, f, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\nIODEProblem(ϑ, f, g, tspan, tstep, ics; kwargs...)\nIODEProblem(ϑ, f, g, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\n\nThe functions ϑ, f and g compute the momentum and the vector fields, respectively.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, an IODEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _iode_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. In addition, the functions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, v, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers.\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.LODEProblem","page":"Problems","title":"GeometricEquations.LODEProblem","text":"LODEProblem: Lagrangian Ordinary Differential Equation Problem\n\nA Lagrangian system of equations is a special case of an implicit ordinary differential equations, that is an implicit initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v  \nf = fracpartial Lpartial q \nendaligned\n\ninitial conditions (q_0 p_0) and the solution (qp) taking values in T^* Q simeq mathbbR^d times mathbbR^d. This is a special case of an implicit ordinary differential equation, that is defined by a Lagrangian, as well as a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMany integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + lambda(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) lambda(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \nlambda(t_0) = lambda_0\nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nConstructors\n\nLODEProblem(ϑ, f, ω, l, tspan, tstep, ics; kwargs...)\nLODEProblem(ϑ, f, ω, l, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\nLODEProblem(ϑ, f, g, ω, l, tspan, tstep, ics; kwargs...)\nLODEProblem(ϑ, f, g, ω, l, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\n\nwhere ϑ, f and g are the functions computing the momentum and the vector fields, respectively, ω determines the symplectic matrix, and l returns the Lagrangian, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p and λ. The initial conditions q₀, p₀ and λ₀ can also be prescribed directly, with State an AbstractArray{<:Number}, where λ₀ can also be omitted.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a LODEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _lode_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nand\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers. Finally, the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.SODEProblem","page":"Problems","title":"GeometricEquations.SODEProblem","text":"SODEProblem: Split Ordinary Differential Equation Problem\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nConstructors\n\nSODEProblem(v, q, tspan, tstep, ics::NamedTuple; kwargs...)\nSODEProblem(v, q, tspan, tstep, q₀::State; kwargs...)\nSODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)\nSODEProblem(v, tspan, tstep, q₀::State; kwargs...)\n\nwhere v is a tuple of functions computing the vector fields for each substep,  q is an optional tuple of functions computing the solution for each substep, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v_i providing the vector field must have the interface\n\nfunction v_i(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nand the functions q_i providing the solutions must have the interface\n\nfunction q_i(q₁, t₁, q₀, t₀, params)\n    q₁[1] = q₀[1] + ...\n    q₁[2] = q₀[2] + ...\n    ...\nend\n\nwhere t₀ is the current time, q₀ is the current solution vector, q₁ is the new solution vector at time t₁, holding the result of computing one substep\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps. with the vector field v_i.\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#Differential-Algebraic-Equations","page":"Problems","title":"Differential Algebraic Equations","text":"","category":"section"},{"location":"modules/problems/","page":"Problems","title":"Problems","text":"GeometricEquations.DAEProblem\nGeometricEquations.PDAEProblem\nGeometricEquations.HDAEProblem\nGeometricEquations.IDAEProblem\nGeometricEquations.LDAEProblem\nGeometricEquations.SPDAEProblem","category":"page"},{"location":"modules/problems/#GeometricEquations.DAEProblem","page":"Problems","title":"GeometricEquations.DAEProblem","text":"DAEProblem: Differential Algebraic Equation Problem\n\nDefines a differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))   q(t_0) = q_0  \n0 = phi (t q(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector field v, projection u, algebraic constraint phi=0, initial conditions q_0 and lambda_0, the dynamical variable q taking values in mathbbR^d and the algebraic variable lambda taking values in mathbbR^m.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t)) + baru (t q(t) dotq (t) dotp (t) gamma(t))   q(t_0) = q_0  \n0 = phi (t q(t))   lambda(t_0) = lambda_0  \n0 = psi (t q(t) dotq (t))   gamma(t_0) = gamma_0 \nendaligned\n\nwith the second algebraic variable gamma also taking values in mathbbR^m.\n\nConstructors\n\nDAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, ics::NamedTuple; kwargs...)\nDAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, q₀::State, λ₀::State; kwargs...)\nDAEProblem(v, u, ϕ, tspan, tstep, ics::NamedTuple; kwargs...)\nDAEProblem(v, u, ϕ, tspan, tstep, q₀::State, λ₀::State; kwargs...)\n\nThe functions v and u compute the vector field and the projection, respectively, ϕ provides the algebraic constraint. The functions ψ and ū are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and λ. The initial conditions q₀ and λ₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a DAEProblem accepts a function v̄ for the computation of an initial guess for the vector field with default value v̄ = v.\n\nFunction Definitions\n\nThe functions v, u and ϕ must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction u(u, t, q, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, γ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the DAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\nλ₀ = [0.]\nγ₀ = [0.]\n\nprob = DAEProblem(v, u, ϕ, tspan, tstep, q₀, λ₀)\n\nor\n\nprob = DAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, q₀, λ₀, γ₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.PDAEProblem","page":"Problems","title":"GeometricEquations.PDAEProblem","text":"PDAEProblem: Partitioned Differential Algebraic Equation Problem\n\nA partitioned differential algebraic equation has the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector fields v and f, projection u and g, algebraic constraint phi=0, initial conditions (q_0 p_0) and lambda_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variable lambda taking values in mathbbR^m.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))   lambda(t_0) = lambda_0  \n0 = psi (t q(t) p(t) dotq (t) dotp (t))   gamma(t_0) = gamma_0 \nendaligned\n\nwith the second algebraic variable gamma also taking values in mathbbR^m.\n\nConstructors\n\nPDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, ics::NamedTuple; kwargs...)\nPDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀::State, p₀::State, λ₀::State; kwargs...)\nPDAEProblem(v, f, u, g, ϕ, tspan, tstep, ics::NamedTuple; kwargs...)\nPDAEProblem(v, f, u, g, ϕ, tspan, tstep, q₀::State, p₀::State, λ₀::State; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p and λ. The initial conditions q₀, p₀ and λ₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a PDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = v and f̄ = f.\n\nFunction Definitions\n\nThe functions v, f, u, g and ϕ must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q, p and λ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections u and g, and ϕ holds the algebraic constraint phi, evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, γ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, γ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the PDAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\nγ₀ = [0.]\n\nprob = PDAEProblem(v, f, u, g, ϕ, tspan, tstep, q₀, p₀, λ₀)\n\nor\n\nprob = PDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀, p₀, λ₀, γ₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.HDAEProblem","page":"Problems","title":"GeometricEquations.HDAEProblem","text":"HDAEProblem: Hamiltonian Differential Algebraic Equation\n\nA Hamiltonian differential algebraic is an initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qpdotqdotp)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nHDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, ics::NamedTuple; kwargs...)\nHDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, q₀::State, p₀::State, λ₀::State; kwargs...)\nHDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, ics::NamedTuple; kwargs...)\nHDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, q₀::State, p₀::State, λ₀::State; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, ϕ provides the algebraic constraint and h the Hamiltonian. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p, λ and γ. The initial conditions q₀, p₀, λ₀ and γ₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a HDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = v and f̄ = f.\n\nFunction Definitions\n\nThe functions v, f, u, g, ϕ and h must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nfunction h(t, q, p, params)\n    ...\nend\n\nwhere t is the current time, q, p, λ and γ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections on the primary constraint u and g,  ϕ holds the algebraic constraint phi, and h returns the Hamiltonian of the system, all evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, γ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, γ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the HDAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\nγ₀ = [0.]\n\nprob = HDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, q₀, p₀, λ₀)\n\nor\n\nprob = HDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, q₀, p₀, λ₀, γ₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.IDAEProblem","page":"Problems","title":"GeometricEquations.IDAEProblem","text":"IDAEProblem: Implicit Differential Algebraic Equation Problem\n\nAn implicit differential algebraic initial value problem takes the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t))   p(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))   \n0 = phi (t q(t) v(t) p(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith force field f, the momentum defined by ϑ, projections u and g, algebraic constraint phi(tqvp)=0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, the algebraic variable lambda taking values in mathbbR^m, and initial conditions (q_0 p_0) and lambda_0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) gamma(t))   p(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))   \n0 = phi (t q(t) v(t) p(t))   lambda(t_0) = lambda_0  \n0 = psi (t q(t) v(t) p(t) dotq (t) dotp (t))   gamma(t_0) = gamma_0 \nendaligned\n\nwith the second algebraic variable gamma also taking values in mathbbR^m.\n\nConstructors\n\nIDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, ics; kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, tspan, tstep, ics; kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, an IDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _idae_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, λ)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, γ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, γ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.LDAEProblem","page":"Problems","title":"GeometricEquations.LDAEProblem","text":"LDAEProblem: Lagrangian Differential Algebraic Equation Problem\n\nA special case of an implicit initial value problem is a Lagrangian differential algebraic equation of the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) gamma(t))  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) gamma(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v (qv)  \nf = fracpartial Lpartial q (qv) \nendaligned\n\nprojection fields u, baru and g, barg, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (v lambda gamma) taking values in mathbbR^d times mathbbR^m times mathbbR^m. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and gamma.\n\nConstructors\n\nLDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, ics; kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, ics; kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a LDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _ldae_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, λ)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nand the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, γ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, γ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the LDAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\nγ₀ = [0.]\n\nprob = LDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, q₀, p₀, λ₀)\n\nor\n\nprob = LDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, q₀, p₀, λ₀, γ₀)\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.SPDAEProblem","page":"Problems","title":"GeometricEquations.SPDAEProblem","text":"\n\n\n\n","category":"type"},{"location":"modules/problems/#Stochastic-Differential-Equations","page":"Problems","title":"Stochastic Differential Equations","text":"","category":"section"},{"location":"modules/problems/","page":"Problems","title":"Problems","text":"GeometricEquations.SDEProblem\nGeometricEquations.PSDEProblem\nGeometricEquations.SPSDEProblem","category":"page"},{"location":"modules/problems/#GeometricEquations.SDEProblem","page":"Problems","title":"GeometricEquations.SDEProblem","text":"SDEProblem: Stratonovich Stochastic Differential Equation Problem\n\nDefines a stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendaligned\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nSDEProblem(v, B, tspan, tstep, ics::NamedTuple; kwargs...)\nSDEProblem(v, B, tspan, tstep, q₀::State; kwargs...)\n\nwhere v is the function computing the vector field and B computes the diffusion matrix tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v and B, providing the drift vector field and diffusion matrix. The function v must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params are additional parameters. The function B should have a method with interface\n\nfunction B(B, t, q, params)\n    B[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.PSDEProblem","page":"Problems","title":"GeometricEquations.PSDEProblem","text":"PSDEProblem: Stratonovich Partitioned Stochastic Differential Equation Problem\n\nA partitioned stochastic differential equations is an initial value problem of the form\n\nbeginaligned\ndq (t) = v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) = f(t q(t) p(t))  dt + G(t q(t) p(t)) circ dW   p(t_0) = p_0\nendaligned\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nPSDEProblem(v, f, B, G, tspan, tstep, ics::NamedTuple; kwargs...)\nPSDEProblem(v, f, B, G, tspan, tstep, q₀::State; p₀::State; kwargs...)\n\nwhere v and f are the functions computing the vector field and B and G compute the diffusion matrices, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, each take five arguments, v(v, t, q, p, params), f(f, t, q, p, params), B(B, t, q, p, params) and G(G, t, q, p, params), where t is the current time, (q, p) is the current solution, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p), and params are optional parameters.\n\nThe corresponding methods should have the following signatures:\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/problems/#GeometricEquations.SPSDEProblem","page":"Problems","title":"GeometricEquations.SPSDEProblem","text":"SPSDEProblem: Stratonovich Split Partitioned Stochastic Differential Equation Problem\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) =   v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) =  f_1(t q(t) p(t)) + f_2(t q(t) p(t))   dt +  G_1(t q(t) p(t)) + G_2(t q(t) p(t))  circ dW   p(t_0) = p_0 \nendaligned\n\nwith the drift vector fields v and f_i, diffusion matrices B and G_i, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nSPSDEProblem(v, f1, f2, B, G1, G2, tspan, tstep, ics::NamedTuple; kwargs...)\nSPSDEProblem(v, f1, f2, B, G1, G2, tspan, tstep, q₀::State; p₀::State; kwargs...)\n\nwhere v and f are the functions computing the vector field and Bᵢ and Gᵢ compute the diffusion matrices, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v, f1, f2, B, G1 and G2, providing the drift vector fields and diffusion matrices, all take five arguments, (out, t, q, p, params).\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f1(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction f2(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G1(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nfunction G2(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nwhere t is the current time, (q,p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B_i, G_i on (t,q,p).\n\n\n\n\n\n","category":"type"},{"location":"developer/custom_integrators/#Custom-Integrators","page":"Custom Integrators","title":"Custom Integrators","text":"","category":"section"},{"location":"modules/integrators/#Integrators","page":"Integrators","title":"Integrators","text":"","category":"section"},{"location":"modules/integrators/#Common","page":"Integrators","title":"Common","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/abstract_coefficients.jl\",\n           \"integrators/abstract_integrator.jl\",\n           \"integrators/abstract_tableau.jl\",\n           \"integrators/integrator_cache.jl\",\n           \"integrators/integrators_common.jl\",\n           \"integrators/integrators.jl\"]","category":"page"},{"location":"modules/integrators/#Initial-Guesses","page":"Integrators","title":"Initial Guesses","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/initial_guess/initial_guess_ode.jl\",\n           \"integrators/initial_guess/initial_guess_iode.jl\",\n           \"integrators/initial_guess/initial_guess_pode.jl\"]","category":"page"},{"location":"modules/integrators/#Extrapolation-Methods","page":"Integrators","title":"Extrapolation Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"The extrapolation routines are exclusively used for computing initial guesses and are usually not called directly by the user.","category":"page"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nOrder   = [:constant, :type, :macro, :function]\nPages   = [\"integrators/extrapolation/extrapolation.jl\",\n           \"integrators/extrapolation/aitken_neville.jl\",\n           \"integrators/extrapolation/euler.jl\",\n           \"integrators/extrapolation/hermite.jl\",\n           \"integrators/extrapolation/midpoint.jl\"]","category":"page"},{"location":"modules/integrators/#Splitting-Methods","page":"Integrators","title":"Splitting Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/splitting/integrators_composition.jl\",\n           \"integrators/splitting/integrators_splitting.jl\",\n           \"integrators/splitting/integrators_exact_ode.jl\",\n           \"integrators/splitting/splitting_tableau.jl\"]","category":"page"},{"location":"modules/integrators/#Runge-Kutta-Methods","page":"Integrators","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/rk/bstract_integrator_rk.jl\",\n           \"integrators/rk/coefficients.jl\",\n           \"integrators/rk/tableaus.jl\",\n           \"integrators/rk/integrators_erk.jl\",\n           \"integrators/rk/integrators_dirk.jl\",\n           \"integrators/rk/integrators_firk.jl\",\n           \"integrators/rk/integrators_eprk.jl\",\n           \"integrators/rk/integrators_iprk.jl\",\n           \"integrators/rk/integrators_flrk.jl\",\n           \"integrators/rk/integrators_pglrk.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheERK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheERK","text":"Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorERK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorERK","text":"Explicit Runge-Kutta integrator solving the system\n\nbeginaligned\nV_ni = v (t_i Q_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheDIRK","text":"Diagonally implicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorDIRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorDIRK","text":"Diagonally implicit Runge-Kutta integrator solving the system\n\nbeginaligned\nV_ni = v (t_i Q_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheEPRK","text":"Explicit Runge-Kutta integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorEPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorEPRK","text":"Explicit partitioned Runge-Kutta integrator solving the system\n\nbeginaligned\nV_ni = v (t_i Q_ni P_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = f (t_i Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nUsually we are interested in Hamiltonian systems, where\n\nbeginaligned\nV_ni = dfracpartial Hpartial p (Q_ni P_ni)  \nF_ni = - dfracpartial Hpartial q (Q_ni P_ni)  \nendaligned\n\nand tableaus satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheIPRK","text":"Implicit partitioned Runge-Kutta integrator cache.\n\nFields\n\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: vector field of internal stages of q\nZ: vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorIPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorIPRK","text":"Implicit partitioned Runge-Kutta integrator solving the system\n\nbeginaligned\nV_ni = v (t_i Q_ni P_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = f (t_i Q_ni P_ni)  \nP_ni = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni \nendaligned\n\nUsually we are interested in Hamiltonian systems, where\n\nbeginaligned\nV_ni = dfracpartial Hpartial p (Q_ni P_ni)  \nF_ni = - dfracpartial Hpartial q (Q_ni P_ni)  \nendaligned\n\nand tableaus satisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Variational-Integrators","page":"Integrators","title":"Variational Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/vi/integrators_vprk.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorVPRK","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorVPRK","text":"Variational Partitioned Runge-Kutta Integrator.\n\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nP_ni = p_n + h sum limits_i=1^s bara_ij  F_nj - d_i lambda  \np_n+1 = p_n + h sum limits_i=1^s barb_i  F_ni  \n\n0 = sum limits_i=1^s d_i V_i  \nendaligned\n\nsatisfying the symplecticity conditions\n\nbeginaligned\nb_i bara_ij + b_j a_ji = b_i b_j  \nbarb_i = b_i \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Degenerate-Variational-Integrators","page":"Integrators","title":"Degenerate Variational Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/dvi/integrators_dvi_a.jl\",\n           \"integrators/dvi/integrators_dvi_b.jl\",\n           \"integrators/dvi/integrators_cmdvi.jl\",\n           \"integrators/dvi/integrators_ctdvi.jl\"]","category":"page"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheDVIA","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheDVIA","text":"Degenerate variational integrator cache.\n\nFields\n\nq: internal stages of solution\nv: internal stages of vector field\nΘ: implicit function evaluated on solution\nf: vector field of implicit function\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorDVIA","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorDVIA","text":"Symplectic Euler-A Degenerate Variational Integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheDVIB","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheDVIB","text":"Degenerate variational integrator cache.\n\nFields\n\nq: internal stages of solution\nv: internal stages of vector field\nΘ: implicit function evaluated on solution\nf: vector field of implicit function\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorDVIB","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorDVIB","text":"Symplectic Euler-B Degenerate Variational Integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCMDVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCMDVI","text":"Midpoint Degenerate Variational Integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheCMDVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheCMDVI","text":"Degenerate variational integrator cache.\n\nFields\n\nq: internal stages of solution\nv: internal stages of vector field\nΘ: implicit function evaluated on solution\nf: vector field of implicit function\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCTDVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCTDVI","text":"Trapezoidal Degenerate Variational Integrator.\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#GeometricIntegrators.Integrators.IntegratorCacheCTDVI","page":"Integrators","title":"GeometricIntegrators.Integrators.IntegratorCacheCTDVI","text":"Degenerate variational integrator cache.\n\nFields\n\nq: internal stages of solution\nv: internal stages of vector field\nΘ: implicit function evaluated on solution\nf: vector field of implicit function\n\n\n\n\n\n","category":"type"},{"location":"modules/integrators/#Galerkin-Variational-Integrators","page":"Integrators","title":"Galerkin Variational Integrators","text":"","category":"section"},{"location":"modules/integrators/","page":"Integrators","title":"Integrators","text":"Modules = [GeometricIntegrators.Integrators]\nPages   = [\"integrators/cgvi/integrators_cgvi.jl\",\n           \"integrators/dgvi/integrators_dgvi.jl\"]","category":"page"},{"location":"integrators/dgvi/#dgvi","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Discontinuous Galerkin Variational Integrators (DGVIs) are a family of integrators for degenerate Lagrangian systems and for Hamiltonian systems subject to Dirac constraints. For integrators for non-degenerate (regular) Lagrangian and unconstrained Hamiltonian systems see Hamilton-Pontryagin-Galerkin (HPG) Integrators.","category":"page"},{"location":"integrators/dgvi/#Degenerate-Lagrangian-Systems","page":"Discontinuous Galerkin Variational Integrators","title":"Degenerate Lagrangian Systems","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Consider a fully degenerate Lagrangian system of the form","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"L(q dotq) = vartheta (q) cdot dotq - H(q) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where vartheta (q) denotes the Cartan one-form and H(q) the Hamiltonian, that is usually given by the total energy of the system.","category":"page"},{"location":"integrators/dgvi/#Discrete-Trajectories-and-Numerical-Quadrature","page":"Discontinuous Galerkin Variational Integrators","title":"Discrete Trajectories and Numerical Quadrature","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The first step in the derivation of variational integrators is the discretization of the action integral","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q = int limits_0^T L(q(t) dotq(t))  dt ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"To this end, the interval 0T is split into N sub-intervals t_n t_n+1 with t_n = nh and h the time step size, so that t_N = T and the action can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q = sum limits_n=0^N-1 int limits_t_n t_n+1 L(q(t) dotq(t))  dt ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Within each interval (t_n t_n+1) a piecewise-polynomial approximation q_h of the trajectory q is constructed using S basis functions varphi_i,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_h(t) vert_(t_n t_n+1) = sum limits_i=1^S x_ni  barvarphi_ni (t) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where barvarphi_ni (t) is a rescaled basis function, defined by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"barvarphi_ni (t) = varphi_i bigg( fract - t_nt_n+1 - t_n bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and it is assumed that varphi_i is compactly supported on 01. These approximations q_h(t) do not need to be continuous across interval boundaries but are indeed allowed to have jumps. Replacing the continuous trajectory q in the action with q_h, we obtain","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA q_h = sum limits_n=0^N-1 int limits_(t_n t_n+1) big vartheta (q_h (t)) cdot dotq_h (t) - H(q_h (t)) big  dt\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n  ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The integral of the Hamiltonian H(q_h) over the interval boundaries does not contribute to the integral, differently from the term vartheta (q_h) cdot dotq_h, which will determine the numerical flux  cdot _n at t_n of the Discontinuous Galerkin method. The approximation of this term will be discussed below. In order to obtain a fully discrete action, a numerical quadrature rule with R nodes c_i and weights b_i is introduced for the approximation of the integral,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (q_h(t_n + c_i h)) cdot dotq_h (t_n + c_i h) - H(q_h(t_n + c_i h)) big\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Here, x_d denotes the vector of all the degrees of freedom, i.e.,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"x_d = ( x_01  x_0S  x_11  x_N-2S  x_N-11  x_N-1S )^T ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In order to write the discrete action in a more explicit form, mass and derivative matrices m and a are introduced, whose elements are given by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"m_ij = varphi_j (c_i) \nqquad\na_ij = varphi_j (c_i) \nqquad\ni = 1  R \n\nj = 1  S ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"so that the solution and its time derivative at the quadrature points can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Q_ni equiv q_h(t_n + c_i h) = m_ij x_nj \nqquad\nV_ni equiv dotq_h (t_n + c_i h) = a_ij x_nj ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"x_n = ( x_n1  x_nS )^T","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"is the vector containing the degrees of freedom of q_h vert_t_n t_n+1. Using these definitions, the discrete action can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big\n+ sum limits_n=1^N-1  vartheta (q_h (t)) cdot dotq_h (t) _t=t_n ","category":"page"},{"location":"integrators/dgvi/#Numerical-Fluxes","page":"Discontinuous Galerkin Variational Integrators","title":"Numerical Fluxes","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In the following, the solution values \"left\" and \"right\" of the jump will be needed. This will be denoted by q_n^- and q_n^+, respectively. Usually, these just correspond to the polynomials on the left and right, evaluated at t_n, i.e.,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_n^- = lim_t uparrow t_n q_h (t) = q_h vert_t_n-1 t_n (t_n) \nqquad\nq_n^+ = lim_t downarrow t_n q_h (t) = q_h vert_t_n t_n+1 (t_n) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In principle, however, more general reconstructions of the solution could be used. In the following, it will be assumed, that q_n^- is given by some linear combinations of the degrees of freedom of the polynomial on the left interval and correspondingly that q_n^+ is given by some linear combinations of the degrees of freedom of the polynomial on the right interval, specifically","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"q_n^- = r^- cdot x_n \nqquad\nq_n^+ = r^+ cdot x_n+1 ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where r^pm are appropriate coefficient vectors.","category":"page"},{"location":"integrators/dgvi/#Gauge-Terms","page":"Discontinuous Galerkin Variational Integrators","title":"Gauge Terms","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The Lagrangian L can be augmented with any total time derivative without changing the (continuous) Euler-Lagrange equations. In particular, one can consider the modified Lagrangian","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"L(q dotq) = vartheta (q) cdot dotq - H(q) - nu dfracddt bigg( vartheta (q) cdot q bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"While this gauge term vanishes in the continuous case, it takes a finite value across jumps of the discontinuous discrete solution, so that the modified discrete action reads","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big\n+ sum limits_n=1^N-1 biggbigg vartheta (q_h (t)) cdot dotq_h (t) - nu dfracddt bigg( vartheta (q) cdot q bigg) biggbigg_t=t_n ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"In the following, only the modified Lagrangian and action will be considered, in order to obtain a sufficiently general framework for constructing numerical fluxes. For brevity of notation, the prime will be dropped.","category":"page"},{"location":"integrators/dgvi/#Total-Time-Derivatives-Across-Jumps","page":"Discontinuous Galerkin Variational Integrators","title":"Total Time Derivatives Across Jumps","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The computation of the total time derivative in the gauge term is simple, at least in the distributional sense. Even though both, vartheta (q_h) and q_h have a jump, the jump occurs at the same position in time, so that the derivative can be computed as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"dfracddt bigg( vartheta (q_h) cdot q_h bigg) biggvert_t=t_n\n= dfracddt bigg( vartheta (q_n^-) cdot q_n^-  Theta (t_n - t) + vartheta (q_n^+) cdot q_n^+  Theta (t - t_n) bigg) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where Theta denotes the Heaviside function. This can be explicitly computed as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"dfracddt bigg( vartheta (q_h) cdot q_h bigg) biggvert_t=t_n\n= - vartheta (q_n^-) cdot q_n^-  delta (t_n) + vartheta (q_n^+) cdot q_n^+  delta (t_n)\n=  vartheta (q_h) cdot q_h _t=t_n  delta (t_n) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"with delta (t_n) the Dirac delta-function at t_n.","category":"page"},{"location":"integrators/dgvi/#Non-conservative-Products","page":"Discontinuous Galerkin Variational Integrators","title":"Non-conservative Products","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Simple means for integrating the Lagrangian across jumps are provided by discretisations of the integral","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"int limits_0^1 vartheta (Phi(tau q^- q^+)) cdot dfracd Phi(tau q^- q^+)dtau  dtau ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"where Phi is a path connecting the solution values q^- and q^+ on the left and the right of the jump. Upon picking a quadrature rule with sigma nodes gamma_i and corresponding weights beta_i, the discrete product takes the form","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"sum limits_i=1^sigma beta_i  vartheta big( Phi (gamma_i q_n^-  q_n^+) big) cdot dfracdPhidtau (gamma_i q_n^-  q_n^+) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"For a compact notation, \"mass\" and \"derivative\" vectors mu^pm and alpha^pm are introduced, so that","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Phi (gamma_i q_n^-  q_n^+) = mu^-_i q_n^- + mu^+_i q_n^+\nqquad\nPhi (gamma_i q_n^-  q_n^+) = alpha^-_i q_n^- + alpha^+_i q_n^+ ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and the discrete product can be written as","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"sum limits_i=1^sigma beta_i  vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Providing the path Phi by two functions phi^pm(tau), so that","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"phi(tau q^- q^+) = q^- phi^-(tau) + q^+ phi^+(tau) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"the components of the \"mass\" and \"derivative\" vectors are given by","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mu^-_i = phi^- (gamma_i) \nqquad\nmu^+_i = phi^+ (gamma_i) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"and","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"alpha^-_i = fracdphi^-dtau (gamma_i) \nqquad\nalpha^+_i = fracdphi^+dtau (gamma_i) ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"respectively.","category":"page"},{"location":"integrators/dgvi/#Discrete-Variational-Principle","page":"Discontinuous Galerkin Variational Integrators","title":"Discrete Variational Principle","text":"","category":"section"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Using the construction of the previous sections, the discrete action reads","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"mathcalA_d x_d = h sum limits_n=0^N-1 sum limits_i=1^R b_i big vartheta (Q_ni) cdot V_ni - H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma beta_i  vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ )\n- nu big vartheta (q_n^+) cdot q_n^+ - vartheta (q_n^-) cdot q_n^- big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"The discrete Euler-Lagrange equations are obtained by applying Hamilton's principle of stationary action to mathcalA_d x_d, that is requiring that delta mathcalA_d x_d = 0. The variations of the discrete action are computed as follows,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta mathcalA_d x_d\n= h sum limits_n=0^N-1 sum limits_i=1^R b_i big delta Q_ni cdot nabla vartheta (Q_ni) cdot V_ni + vartheta (Q_ni) cdot delta V_ni - delta Q_ni cdot nabla H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma beta_i  big ( mu^-_i delta q_n^- + mu^+_i delta q_n^+ ) cdot nabla vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) + vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i delta q_n^- + alpha^+_i delta q_n^+ ) big \n- nu big delta q_n^+ cdot nabla vartheta (q_n^+) cdot q_n^+  + vartheta (q_n^+) cdot delta q_n^+ - delta q_n^- cdot nabla vartheta (q_n^-) cdot q_n^- - vartheta (q_n^-) cdot delta q_n^- big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Using the relations","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta Q_ni = m_ij delta x_nj \nqquad\ndelta V_ni = fraca_ijh delta x_nj \nqquad\ndelta q_n^- = r^-_j delta x_n-1j \nqquad\ndelta q_n^+ = r^+_j delta x_nj ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"the variations of the discrete action become","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"delta mathcalA_d x_d\n= sum limits_n=0^N-1 sum limits_i=1^R sum limits_j=1^S b_i big h m_ij delta x_nj cdot nabla vartheta (Q_ni) cdot V_ni + vartheta (Q_ni) cdot a_ij delta x_nj - h m_ij delta x_nj cdot nabla H(Q_ni) big \n+ sum limits_n=1^N-1 bigg sum limits_i=1^sigma sum limits_j=1^S beta_i  big ( mu^-_i r^-_j delta x_n-1j + mu^+_i r^+_j delta x_nj ) cdot nabla vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i q_n^- + alpha^+_i q_n^+ ) + vartheta ( mu^-_i q_n^- + mu^+_i q_n^+ ) cdot ( alpha^-_i r^-_j delta x_n-1j + alpha^+_i r^+_j delta x_nj ) big \n- nu big r^+_j delta x_nj cdot nabla vartheta (q_n^+) cdot q_n^+  + vartheta (q_n^+) cdot r^+_j delta x_nj - r^-_j delta x_n-1j cdot nabla vartheta (q_n^-) cdot q_n^- - vartheta (q_n^-) cdot r^-_j delta x_n-1j big bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"Requiring the variation of the discrete action to vanish yields the discrete equations of motion,","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"0 = sum limits_i=1^R b_i big h m_ij nabla vartheta (Q_ni) cdot V_ni + a_ij vartheta (Q_ni) - h m_ij nabla H(Q_ni) big \n+ bigg sum limits_i=1^sigma beta_i  big\n   mu^-_i r^-_j nabla vartheta ( mu^-_i q_n+1^- + mu^+_i q_n+1^+ ) cdot ( alpha^-_i q_n+1^- + alpha^+_i q_n+1^+ )\n + mu^+_i r^+_j nabla vartheta ( mu^-_i q_n  ^- + mu^+_i q_n  ^+ ) cdot ( alpha^-_i q_n  ^- + alpha^+_i q_n  ^+ ) \n + vartheta ( mu^-_i q_n+1^- + mu^+_i q_n+1^+ ) alpha^-_i r^-_j\n + vartheta ( mu^-_i q_n  ^- + mu^+_i q_n  ^+ ) alpha^+_i r^+_j\n   big \n - nu big\n     r^+_j nabla vartheta (q_n  ^+) cdot q_n  ^+ + r^+_j vartheta (q_n  ^+)\n   - r^-_j nabla vartheta (q_n+1^-) cdot q_n+1^- - r^-_j vartheta (q_n+1^-)\n   big\n bigg ","category":"page"},{"location":"integrators/dgvi/","page":"Discontinuous Galerkin Variational Integrators","title":"Discontinuous Galerkin Variational Integrators","text":"for all n and all j.","category":"page"},{"location":"modules/solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"modules/solutions/","page":"Solutions","title":"Solutions","text":"Modules = [GeometricSolutions]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/solutions/#GeometricSolutions.EnsembleSolution","page":"Solutions","title":"GeometricSolutions.EnsembleSolution","text":"EnsembleSolution: Collection of all solutions of an EnsembleProblem.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#GeometricSolutions.GeometricSolution","page":"Solutions","title":"GeometricSolutions.GeometricSolution","text":"GeometricSolution: Solution of a geometric differential equation\n\nContains all fields necessary to store the solution of a GeometricProblem.\n\nFields\n\nt:  time steps\ns:  NamedTuple of DataSeries for each solution component\nstep: store every step'th time step (default: 1)\nnstore: number of time steps to store\noffset: offset of current time step\n\nConstructors\n\nGeometricSolution(problem; step=1)\n\nThe usual way to initialise a Solution is by passing a GeometricProblem, which  can for example be an ODEProblem or PODEProblem. The optional parameter step determines the intervals for storing the solution, i.e., if store > 1 only every store'th solution is actually stored.\n\n\n\n\n\n","category":"type"},{"location":"modules/solutions/#Solution-Steps","page":"Solutions","title":"Solution Steps","text":"","category":"section"},{"location":"modules/solutions/","page":"Solutions","title":"Solutions","text":"Modules = [GeometricIntegrators.Solutions]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"developer/code_integration/#Code-Integration","page":"Code Integration","title":"Code Integration","text":"","category":"section"},{"location":"modules/discontinuities/#Discontinuities","page":"Discontinuities","title":"Discontinuities","text":"","category":"section"},{"location":"modules/discontinuities/","page":"Discontinuities","title":"Discontinuities","text":"Modules = [GeometricIntegrators.Discontinuities]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/discontinuities/#GeometricIntegrators.Discontinuities.PathIntegralLinear","page":"Discontinuities","title":"GeometricIntegrators.Discontinuities.PathIntegralLinear","text":"PathIntegralLinear is a path integral along a linear path\n\nphi (tau q^- q^+) = (1-tau) q^- + tau q^+ \n\n\n\n\n\n","category":"type"},{"location":"modules/discontinuities/#GeometricIntegrators.Discontinuities.PathIntegralTrigonometric","page":"Discontinuities","title":"GeometricIntegrators.Discontinuities.PathIntegralTrigonometric","text":"PathIntegralTrigonometric is a path integral along a cos^2/sin^2 path\n\nphi (tau q^- q^+) = cos^2 (pi tau  2) q^- + sin^2 (pi tau  2) q^+ \n\n\n\n\n\n","category":"type"},{"location":"modules/rungekutta/#RungeKuttaTableaus","page":"Runge-Kutta Tableaus","title":"Runge-Kutta Tableaus","text":"","category":"section"},{"location":"modules/rungekutta/","page":"Runge-Kutta Tableaus","title":"Runge-Kutta Tableaus","text":"The following tableaus are all implemented in RungeKutta.jl.","category":"page"},{"location":"modules/rungekutta/","page":"Runge-Kutta Tableaus","title":"Runge-Kutta Tableaus","text":"RungeKutta.Tableau","category":"page"},{"location":"modules/rungekutta/#RungeKutta.Tableau","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableau","text":"Holds the tableau of a Runge-Kutta method\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij  v(t_n + c_j Delta t Q_nj)  \nq_n+1 = q_n + h sum limits_i=1^s b_i   v(t_n + c_j Delta t Q_ni)  \nendaligned\n\nParameters:\n\nT: datatype of coefficient arrays\n\nFields:\n\nname: symbolic name of the tableau\no: order of the method\ns: number of stages\na: coefficients a_ij with $ 1 \\le i,j \\le s$\nb: weights b_i  with $ 1 \\le i \\le s$\nc: nodes c_i  with $ 1 \\le i \\le s$\nR∞: stability function at infinity\n\nConstructors:\n\nTableau{T}(name, o, s, a, b, c)\nTableau{T}(name, o, a, b, c)\nTableau(name::Symbol, o::Int, s::Int, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)\nTableau(name::Symbol, o::Int, a::AbstractMatrix, b::AbstractVector, c::AbstractVector)\nTableau(name::Symbol, o::Int, t::AbstractMatrix)\n\nThe last constructor accepts an (s+1) times (s+1) array that holds the whole tableau in the form of a Butcher tableau, i.e.,\n\nc a\n b\n\n\n\n\n\n","category":"type"},{"location":"modules/rungekutta/","page":"Runge-Kutta Tableaus","title":"Runge-Kutta Tableaus","text":"Modules = [RungeKutta.Tableaus]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauBackwardEuler","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauBackwardEuler","text":"Alias for TableauImplicitEuler\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauCrankNicolson-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauCrankNicolson","text":"Tableau of Crank-Nicolson two-stage, 2nd order method\n\nTableauCrankNicolson(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJ. Crank and P. Nicolson.\nA practical method for numerical evaluation of solutions of partial differential equations of the heat-conduction type.\nMathematical Proceedings of the Cambridge Philosophical Society, Volume 43, Issue 1, Pages 50-67, 1947.\ndoi: 10.1017/S0305004100023197\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauCrouzeix-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauCrouzeix","text":"Tableau of Crouzeix's two-stage, 3rd order method\n\nTableauCrouzeix(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nM.Crouzeix.\nSur L'approximation des équations différentielles opérationelles linéaires par des méthodes de Runge-Kutta.\nThesis. Université de Paris, 1975.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauExplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauExplicitEuler","text":"Tableau of one-stage, 1st order explicit (forward) Euler method\n\nTableauExplicitEuler(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nLeonhard Euler.\nInstitutiones calculi differentialis cum eius vsu in analysi finitorum ac doctrina serierum.\nImp. Acad. Imper. Scient. Petropolitanae, Opera Omnia, Vol.X, [I.6], 1755.\nIn: Opera Omnia, 1st Series, Volume 11, Institutiones Calculi Integralis. Teubner, Leipzig, Pages 424-434, 1913.\nSectio secunda. Caput VII. De integratione aequationum differentialium per approximationem. Problema 85.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauExplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauExplicitMidpoint","text":"Tableau of explicit two-stage, 2nd order midpoint method\n\nTableauExplicitMidpoint(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nCarl Runge.\nÜber die numerische Auflösung von Differentialgleichungen.\nMathematische Annalen, Volume 46, Pages 167-178, 1895.\ndoi: 10.1007/BF01446807.\nEquation (2)\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauForwardEuler","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauForwardEuler","text":"Alias for TableauExplicitEuler\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauGauss-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauGauss","text":"Gauss tableau with s stages\n\nTableauGauss(::Type{T}, s)\nTableauGauss(s) = TableauGauss(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nJohn C. Butcher.\nImplicit Runge-Kutta processes.\nMathematics of Computation, Volume 18, Pages 50-64, 1964.\ndoi: 10.1090/S0025-5718-1964-0159424-9.\n\nJohn C. Butcher.\nGauss Methods. \nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_115.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauHeun2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauHeun2","text":"Tableau of Heun's two-stage, 2nd order method\n\nTableauHeun2(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nKarl Heun.\nNeue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.\nZeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.\nAlgorithm II.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauHeun3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauHeun3","text":"Tableau of Heun's three-stage, 3rd order method\n\nTableauHeun3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nKarl Heun.\nNeue Methoden zur approximativen Integration der Differentialgleichungen einer unabhängigen Veränderlichen.\nZeitschrift für Mathematik und Physik, Volume 45, Pages 23-38, 1900.\nAlgorithm VI.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauImplicitEuler-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauImplicitEuler","text":"Tableau of one-stage, 1st order implicit (backward) Euler method\n\nTableauImplicitEuler(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAugustin-Louis Cauchy.\nÉquations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.\nEd. Christian Gilain, Etudes Vivantes, 1981.\nPage 102, Equation (5), Θ=1.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauImplicitMidpoint-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauImplicitMidpoint","text":"Tableau of two-stage, 2nd order implicit midpoint method\n\nTableauImplicitMidpoint(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAugustin-Louis Cauchy.\nÉquations différentielles ordinaires. Cours inédit (fragment). Douzième leçon.\nEd. Christian Gilain, Etudes Vivantes, 1981.\nPage 102, Equation (5), Θ=1/2.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauKraaijevangerSpijker-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauKraaijevangerSpijker","text":"Tableau of Kraaijevanger and Spijker's two-stage, 2nd order method\n\nTableauKraaijevangerSpijker(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJ. F. B. M. Kraaijevanger and M. N. Spijker.\nAlgebraic stability and error propagation in Runge-Kutta methods.\nApplied Numerical Mathematics, Volume 5, Issues 1-2, Pages 71-87, 1989.\ndoi: 10.1016/0168-9274(89)90025-1\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauKutta-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauKutta","text":"Tableau of Kutta's three-stage, 3rd order method\n\nTableauKutta(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.\nPage 440\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauKutta3","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauKutta3","text":"Alias for TableauKutta\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIII-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIII","text":"Lobatto III tableau with s stages\n\nTableauLobattoIII(::Type{T}, s)\nTableauLobattoIII(s) = TableauLobattoIII(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nSometimes this tableau is also referred to as Lobatto IIIC*.\n\nReferences:\n\nJohn C. Butcher.\nIntegration processes based on Radau quadrature formulas\nMathematics of Computation, Volume 18, Pages 233-244, 1964.\ndoi: 10.1090/S0025-5718-1964-0165693-1.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIA","text":"Lobatto IIIA tableau with s stages\n\nTableauLobattoIIIA(::Type{T}, s)\nTableauLobattoIIIA(s) = TableauLobattoIIIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIB","text":"Lobatto IIIB tableau with s stages\n\nTableauLobattoIIIB(::Type{T}, s)\nTableauLobattoIIIB(s) = TableauLobattoIIIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle.\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIB̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIB̄","text":"Lobatto IIIB̄ tableau with s stages\n\nTableauLobattoIIIB̄(::Type{T}, s)\nTableauLobattoIIIB̄(s) = TableauLobattoIIIB̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIB̄ tableau is the conjugate symplectic to TableauLobattoIIIB. On paper, its coefficients are identical to TableauLobattoIIIA, however, they are computed by the symplecticity condition and not by the formula for Lobatto IIIA and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIC-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIC","text":"Lobatto IIIC tableau with s stages\n\nTableauLobattoIIIC(::Type{T}, s)\nTableauLobattoIIIC(s) = TableauLobattoIIIC(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nF. H. Chipman.\nA-stable Runge-Kutta processes.\nBIT, Volume 11, Pages 384-388, 1971.\ndoi: 10.1007/BF01939406.\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIC̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIC̄","text":"Lobatto IIIC̄ tableau with s stages\n\nTableauLobattoIIIC̄(::Type{T}, s)\nTableauLobattoIIIC̄(s) = TableauLobattoIIIC̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIC̄ tableau is the conjugate symplectic to TableauLobattoIIIC. On paper, its coefficients are identical to TableauLobattoIII, however, they are computed by the symplecticity condition and not by the formula for Lobatto III and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIID-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIID","text":"Lobatto IIID tableau with s stages\n\nTableauLobattoIIID(::Type{T}, s)\nTableauLobattoIIID(s) = TableauLobattoIIID(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nR.P.K. Chan.\nOn symmetric Runge-Kutta methods of high order.\nComputing, Volume 45, Pages 301-309, 1990.\ndoi: 10.1007/BF02238798\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIID̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIID̄","text":"Lobatto IIID̄ tableau with s stages\n\nTableauLobattoIIID̄(::Type{T}, s)\nTableauLobattoIIID̄(s) = TableauLobattoIIID̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIID̄ tableau is the conjugate symplectic to TableauLobattoIIID. On paper, the coefficients of the Lobatto IIID tableau are symplectic, however, the Lobatto IIID̄ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIID and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIE-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIE","text":"Lobatto IIIE tableau with s stages\n\nTableauLobattoIIIE(::Type{T}, s)\nTableauLobattoIIIE(s) = TableauLobattoIIIE(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nR.P.K. Chan.\nOn symmetric Runge-Kutta methods of high order.\nComputing, Volume 45, Pages 301-309, 1990.\ndoi: 10.1007/BF02238798\n\nLaurent O. Jay.\nLobatto Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_123.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIF-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIF","text":"Lobatto IIIF tableau with s stages\n\nTableauLobattoIIIF(::Type{T}, s)\nTableauLobattoIIIF(s) = TableauLobattoIIIF(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nWang Fangzong and Liao Xiaobing.\nA Class of Lobatto Methods of Order 2s.\nJournal of Applied Mathematics, Volume 46, Pages 6-10, 2016.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIF̄-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIF̄","text":"Lobatto IIIF̄ tableau with s stages\n\nTableauLobattoIIIF̄(::Type{T}, s)\nTableauLobattoIIIF̄(s) = TableauLobattoIIIF̄(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nThe Lobatto IIIF̄ tableau is the conjugate symplectic to TableauLobattoIIIF.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIG-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIG","text":"Lobatto IIIG tableau with s stages\n\nTableauLobattoIIIG(::Type{T}, s)\nTableauLobattoIIIG(s) = TableauLobattoIIIG(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nSymplectizied algorithm for TableauLobattoIIIF\n\nCoefficients are taken as a^G = frac12 ( a^F + bara^F ) where the coefficients bara^F are computed such that the symplecticity conditions b_i bara_ij + barb_j a_ji = b_i barb_j and b_i = barb_i hold for all 1 le ij le s.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIĀ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIĀ","text":"Lobatto IIIĀ tableau with s stages\n\nTableauLobattoIIIĀ(::Type{T}, s)\nTableauLobattoIIIĀ(s) = TableauLobattoIIIĀ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIĀ tableau is the conjugate symplectic to TableauLobattoIIIA. On paper, its coefficients are identical to TableauLobattoIIIB, however, they are computed by the symplecticity condition and not by the formula for Lobatto IIIB and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIĒ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIĒ","text":"Lobatto IIIĒ tableau with s stages\n\nTableauLobattoIIIĒ(::Type{T}, s)\nTableauLobattoIIIĒ(s) = TableauLobattoIIIĒ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIĒ tableau is the conjugate symplectic to TableauLobattoIIIE. On paper, the coefficients of the Lobatto IIIE tableau are symplectic, however, the Lobatto IIIĒ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIIE and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauLobattoIIIḠ-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauLobattoIIIḠ","text":"Lobatto IIIḠ tableau with s stages\n\nTableauLobattoIIIḠ(::Type{T}, s)\nTableauLobattoIIIḠ(s) = TableauLobattoIIIḠ(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nLobatto IIIḠ tableau is the conjugate symplectic to TableauLobattoIIIG. On paper, the coefficients of the Lobatto IIIG tableau are symplectic, however, the Lobatto IIIḠ coefficients are computed by the symplecticity condition and not by the formula for Lobatto IIIG and thus the numerical values are slightly different.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauQinZhang-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauQinZhang","text":"Tableau of Qin and Zhang's symplectic two-stage, 2nd order method\n\nTableauQinZhang(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nM.-Z. Qin and M.-Q. Zhang.\nSymplectic Runge-Kutta algorithms for Hamilton systems.\nJournal of Computational Mathematics, Supplementary Issue, Pages 205-215, 1992.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK21","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK21","text":"Alias for TableauHeun2     according to\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 99\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK22","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK22","text":"Alias for TableauRunge     according to\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 99\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK31-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK31","text":"Tableau of a three-stage, 3rd order method\n\nTableauKutta(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 99\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK32","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK32","text":"Alias for TableauKutta according to\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 99\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK4","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK4","text":"Alias for TableauRK416\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK41","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK41","text":"Alias for TableauRK416 according to\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 102\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK416-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK416","text":"Tableau of explicit Runge-Kutta method of order four (1/6 rule)\n\nTableauRK416(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.\nPage 443\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK42-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK42","text":"Tableau of explicit Runge-Kutta method of order four with four stages\n\nTableauRK42(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 102\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK438-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK438","text":"Tableau of explicit Runge-Kutta method of order four (3/8 rule)\n\nTableauRK438(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nWilhelm Kutta\nBeitrag zur Näherungsweisen Integration totaler Differentialgleichungen\nZeitschrift für Mathematik und Physik, Volume 46, Pages 435-453, 1901.\nPage 441\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRK5-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRK5","text":"Tableau of explicit Runge-Kutta method of order five with six stages\n\nTableauRK5(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nJohn C. Butcher\nNumerical Methods for Ordinary Differential Equations. Wiley, 2016.\nPage 103\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRadauIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRadauIA","text":"Radau IA tableau with s stages\n\nTableauRadauIA(::Type{T}, s)\nTableauRadauIA(s) = TableauRadauIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRadauIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRadauIB","text":"Radau IB tableau with s stages\n\nTableauRadauIB(::Type{T}, s)\nTableauRadauIB(s) = TableauRadauIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nCoefficients are taken as a^B = frac12 ( a^A + bara^A ) where a^A are the coefficients of the Radau IA method and bara^A are computed such that the symplecticity conditions b_i bara_ij + barb_j a_ji = b_i barb_j and b_i = barb_i hold for all 1 le ij le s.\n\nreference(Val(:RadauIB))\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRadauIIA-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRadauIIA","text":"Radau IIA tableau with s stages\n\nTableauRadauIIA(::Type{T}, s)\nTableauRadauIIA(s) = TableauRadauIIA(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nReferences:\n\nByron Leonard Ehle\nOn Padé approximations to the exponential function and a-stable methods for the numerical solution of initial value problems.\nResearch Report CSRR 2010, Dept. AACS, University of Waterloo, 1969.\n\nOwe Axelsson.\nA class of A-stable methods.\nBIT, Volume 9, Pages 185-199, 1969.\ndoi: 10.1007/BF01946812.\n\nErnst Hairer and Gerhard Wanner.\nRadau Methods.\nIn: Engquist B. (eds). Encyclopedia of Applied and Computational Mathematics. Springer, Berlin, Heidelberg. 2015.\ndoi: 10.1007/978-3-540-70529-1_139.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRadauIIB-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRadauIIB","text":"Radau IIB tableau with s stages\n\nTableauRadauIIB(::Type{T}, s)\nTableauRadauIIB(s) = TableauRadauIIB(Float64, s)\n\nThe constructor takes the number of stages s and optionally the element type T of the tableau.\n\nCoefficients are taken as a^B = frac12 ( a^A + bara^A ) where a^A are the coefficients of the Radau IIA method and bara^A are computed such that the symplecticity conditions b_i bara_ij + barb_j a_ji = b_i barb_j and b_i = barb_i hold for all 1 le ij le s.\n\nreference(Val(:RadauIIB))\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRalston2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRalston2","text":"Tableau of Ralston's two-stage, 2nd order method\n\nTableauRalston2(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAnthony Ralston.\nRunge-Kutta Methods with Minimum Error Bounds.\nMathematics of Computation, Volume 16, Pages 431-437, 1962.\ndoi: 10.1090/S0025-5718-1962-0150954-0.\nEquation (3.5)\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRalston3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRalston3","text":"Tableau of Ralston's three-stage, 3rd order method\n\nTableauRalston3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nAnthony Ralston.\nRunge-Kutta Methods with Minimum Error Bounds.\nMathematics of Computation, Volume 16, Pages 431-437, 1962.\ndoi: 10.1090/S0025-5718-1962-0150954-0.\nEquation (4.10)\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRunge-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRunge","text":"Tableau of Runge's two-stage, 2nd order method\n\nTableauRunge(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nCarl Runge\nÜber die numerische Auflösung von Differentialgleichungen.\nMathematische Annalen, Volume 46, Pages 167-178, 1895.\ndoi: 10.1007/BF01446807.\nEquation (3)\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauRunge2","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauRunge2","text":"Alias for TableauRunge\n\n\n\n\n\n","category":"function"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauSRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauSRK3","text":"Tableau of symmetric and symplectic three-stage, 4th order Runge-Kutta method\n\nTableauSRK3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nShan Zhao and Guo-Wei Wei.\nA unified discontinuous Galerkin framework for time integration.\nMathematical Methods in the Applied Sciences, Volume 37, Issue 7, Pages 1042-1071, 2014.\ndoi: 10.1002/mma.2863.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauSSPRK2-Tuple","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauSSPRK2","text":"Tableau of 2rd order Strong Stability Preserving method with two stages and CFL ≤ 1\n\nTableauSSPRK2(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nThis is the same tableau as TableauHeun2.\n\nReference:\n\nChi-Wang Shu, Stanley Osher.\nEfficient implementation of essentially non-oscillatory shock-capturing schemes.\nJournal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.\ndoi: 10.1016/0021-9991(88)90177-5.\nEquation (2.16)\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.TableauSSPRK3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.TableauSSPRK3","text":"Tableau of 3rd order Strong Stability Preserving method with three stages and CFL ≤ 1\n\nTableauSSPRK3(::Type{T}=Float64) where {T}\n\nThe constructor takes one optional argument, that is the element type of the tableau.\n\nReference:\n\nChi-Wang Shu, Stanley Osher.\nEfficient implementation of essentially non-oscillatory shock-capturing schemes.\nJournal of Computational Physics, Volume 77, Issue 2, Pages 439-471, 1988.\ndoi: 10.1016/0021-9991(88)90177-5.\nEquation (2.18)\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_gauss_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_gauss_coefficients","text":"The Gauss coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_gauss_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_gauss_nodes","text":"The Gauss nodes are given by the roots of the shifted Legendre polynomial P_s (2x-1) with s the number of stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_gauss_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_gauss_weights","text":"The Gauss weights are given by the following integrals\n\nb_i = bigg( fracdPdx (c_i) bigg)^-2 int limits_0^1 bigg( fracP(x)x - c_i bigg)^2 dx \n\nwhere P(x) denotes the shifted Legendre polynomial P(x) = P_s (2x-1) with s the number of stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_a_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_a_coefficients","text":"The Lobatto IIIA coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_b_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_b_coefficients","text":"The Lobatto IIIB coefficients are implicitly given by the so-called simplifying assumption D(s):\n\nsum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k)  qquad j = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_c_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_c_coefficients","text":"The Lobatto IIIC coefficients are determined by setting a_i1 = b_1 and solving the so-called simplifying assumption C(s-1), given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s-1 \n\nfor a_ij with i = 1  s and j = 2  s.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_c̄_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_c̄_coefficients","text":"The Lobatto IIIC̄ coefficients are determined by setting a_is = 0 and solving the so-called simplifying assumption C(s-1), given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s-1 \n\nfor a_ij with i = 1  s and j = 1  s-1.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_nodes","text":"The s-stage Lobatto nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-2dx^s-2 big( (x - x^2)^s-1 big) \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_nullvector-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_nullvector","text":"get_lobatto_nullvector(::Type, s; normalize=false)\nget_lobatto_nullvector(s; kwargs...)\n\nComputes the nullvector of the matrix containing the derivatives of the Lagrange basis on the s Lobatto nodes evaluated on these nodes.\n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_lobatto_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_lobatto_weights","text":"The Lobatto weights can be explicitly computed by the formula\n\nb_j = frac1s (s-1) P_s-1(2 c_j - 1)^2 qquad j = 1      s \n\nwhere P_k is the kth Legendre polynomial, given by\n\nP_k (x) = frac1k 2^k big( fracd^kdx^k (x^2 - 1)^k big) \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_radau_1_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_radau_1_coefficients","text":"The Radau IA coefficients are implicitly given by the so-called simplifying assumption D(s):\n\nsum limits_i=1^s b_i c_i^k-1 a_ij = fracb_jk ( 1 - c_j^k)  qquad j = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_radau_1_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_radau_1_nodes","text":"The s-stage Radau IA nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-1dx^s-1 big( x^s (x - 1)^s-1 big) \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_radau_1_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_radau_1_weights","text":"The Radau IA weights are implicitly given by the so-called simplifying assumption B(s):\n\nsum limits_j=1^s b_j c_j^k-1 = frac1k  qquad k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_radau_2_coefficients-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_radau_2_coefficients","text":"The Radau IIA coefficients are implicitly given by the so-called simplifying assumption C(s):\n\nsum limits_j=1^s a_ij c_j^k-1 = fracc_i^kk  qquad i = 1      s   k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_radau_2_nodes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_radau_2_nodes","text":"The s-stage Radau IIA nodes are defined as the roots of the following polynomial of degree s:\n\nfracd^s-1dx^s-1 big( x^s-1 (x - 1)^s big) \n\n\n\n\n\n","category":"method"},{"location":"modules/rungekutta/#RungeKutta.Tableaus.get_radau_2_weights-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Runge-Kutta Tableaus","title":"RungeKutta.Tableaus.get_radau_2_weights","text":"The Radau IIA weights are implicitly given by the so-called simplifying assumption B(s):\n\nsum limits_j=1^s b_j c_j^k-1 = frac1k  qquad k = 1      s \n\n\n\n\n\n","category":"method"},{"location":"methods/#List-of-all-Methods","page":"Methods","title":"List of all Methods","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Error: UndefVarError: Methods not defined ::warning file=../../../.julia/packages/Weave/f7Ly3/src/run.jl,line=224::ERROR: UndefVarError occurred, including output in Weaved document","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"Error: UndefVarError: Methods not defined ::warning file=../../../.julia/packages/Weave/f7Ly3/src/run.jl,line=224::ERROR: UndefVarError occurred, including output in Weaved document","category":"page"},{"location":"modules/#Modules","page":"Modules","title":"Modules","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Pages = [#\"modules/discontinuities.md\",\n         \"modules/equations.md\",\n         \"modules/solutions.md\",\n         \"modules/integrators.md\",\n         \"modules/interpolation.md\",\n         #\"modules/simulations.md\",\n         \"modules/tableaus.md\",\n         \"modules/rungekutta.md\"]\nDepth = 3","category":"page"},{"location":"releasenotes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"releasenotes/#.11.0","page":"Release Notes","title":"0.11.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Rename AtomicSolution to SolutionStep\nDisable Simulation functionality until EnsembleSolution is added to GeometricEquations.jl","category":"page"},{"location":"releasenotes/#New-Features","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/#Documentation","page":"Release Notes","title":"Documentation","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Include documentation of GeometricEquations.jl and GeometricSolutions.jl","category":"page"},{"location":"releasenotes/#.10.0","page":"Release Notes","title":"0.10.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes-2","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Refactor TimeSeries, DataSeries and Solution and move to GeometricSolutions.jl\nAdapt Solution HDF5 interface to default Julia argument order and naming conventions\nExtract HDF5 functionality from Solutions into separate data structure\nRemove parallel Solution types","category":"page"},{"location":"releasenotes/#.9.0","page":"Release Notes","title":"0.9.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes-3","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Move HermiteInterpolation to Integrators and remove Interpolation sub-package\nMove Equations submodule to GeometricEquations.jl\nMove Common, Config and Utils submodules to GeometricBase.jl\nMove TimeSeries, DataSeries and Solution from Solutions types to GeometricBase.jl\nRemove parallel DataSeries and Solution types","category":"page"},{"location":"releasenotes/#New-Features-2","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Implement first and second order Degenerate Variational Integrators (DVIs)\nAdd tests for extrapolation methods","category":"page"},{"location":"releasenotes/#Fixes","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bugfixes in implicit equations\nBugfixes in extrapolation methods\nBugfixes in initial guesses\nBugfixes in VPRK and VSPARK initialisation\nBugfixes in TimeSeries getindex methods","category":"page"},{"location":"releasenotes/#Documentation-2","page":"Release Notes","title":"Documentation","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Add missing docstrings in various places and remove superficial docstrings","category":"page"},{"location":"releasenotes/#.8.0","page":"Release Notes","title":"0.8.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes-4","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Use RungeKutta.jl for most tableaus and coefficients\nMove stochastic integrators to separate package\nRewrite of most equation types\nRename VODE and VDAE to LODE and LDAE for consistency with HODE and HDAE\nAdd optional fields for the secondary constraint to all *DAE equations","category":"page"},{"location":"releasenotes/#New-Features-3","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Allow for arbitrary data structures as states (still experimental and not fully supported)\nAdd convert methods for PODE and HODE to ODE and SODE","category":"page"},{"location":"releasenotes/#Fixes-2","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Countless minor bugfixes","category":"page"},{"location":"releasenotes/#Documentation-3","page":"Release Notes","title":"Documentation","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Add theoretical background for variational integrators, Runge-Kutta and splitting methods\nAdd references for most methods","category":"page"},{"location":"releasenotes/#.7.0","page":"Release Notes","title":"0.7.0","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Use CompactBasisFunctions.jl instead of BasisFunctions submodule\nUse QuadratureRules.jl instead of Quadratures submodule\nUse SimpleSolvers.jl instead of Solvers submodule\nUse GeometricProblems.jl instead of TestProblems submodule","category":"page"},{"location":"releasenotes/#.6.2","page":"Release Notes","title":"0.6.2","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bugfix release","category":"page"},{"location":"releasenotes/#.6.1","page":"Release Notes","title":"0.6.1","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bugfix release","category":"page"},{"location":"releasenotes/#.6.0","page":"Release Notes","title":"0.6.0","text":"","category":"section"},{"location":"releasenotes/#Breaking-Changes-5","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Revise tableaus: align constructor names with RungeKutta.jl","category":"page"},{"location":"releasenotes/#New-Features-4","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Add new Runge-Kutta tableaus\nGeneralise Lobatto and Radau tableaus to arbitrary number of stages\nExtend documentation on integrators and tableaus","category":"page"},{"location":"releasenotes/#.5.1","page":"Release Notes","title":"0.5.1","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Update documentation\nFix HDF5 v0.14 deprecations","category":"page"},{"location":"releasenotes/#.5.0","page":"Release Notes","title":"0.5.0","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Moved repository to JuliaGNI\nMoved CI from Travis to GitHub","category":"page"},{"location":"releasenotes/#Breaking-Changes-6","page":"Release Notes","title":"Breaking Changes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Functions for initial guesses are now called v̄ and f̄ and can be prescribed separately from v and f in PDAE, HDAE, etc.\nRename SPARK tableau constructors and unify distinct constructors for Lobatto tableaus with different number of stages","category":"page"},{"location":"releasenotes/#New-Features-5","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Implement SPARK integrator for index-two DAEs\nImplement infrastructure for storing internal variables and solver output to atomic solutions\nStore internal variables of SPARK and VPRK integrators in atomic solution\nAdd various five-stage Lobatto tableaus\nAdd and clean up SPARK tableaus and add docstrings\nAdd functions for checking symplecticity conditions of SPARK tableaus\nAdd Aqua.jl tests","category":"page"},{"location":"releasenotes/#Fixes-3","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Fix initial guess warnings in tests by prescribing proper functions for v̄ and f̄ in example problems\nFix update_multiplier() method for SPARK integrators","category":"page"},{"location":"releasenotes/#.4.1","page":"Release Notes","title":"0.4.1","text":"","category":"section"},{"location":"releasenotes/#New-Features-6","page":"Release Notes","title":"New Features","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Atomic solutions can now store a NamedTuple of internal variables of the integrator, including nonlinear solver output\nOutput of internal variables has been added to VPRK integrators\nAdd Gauss-Legendre tableaus for implicit partitioned Runge-Kutta methods","category":"page"},{"location":"releasenotes/#Fixes-4","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Revision of integrator type hierarchy","category":"page"},{"location":"releasenotes/#.4.0","page":"Release Notes","title":"0.4.0","text":"","category":"section"},{"location":"releasenotes/#New-Integrators","page":"Release Notes","title":"New Integrators","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Runge-Kutta integrators for implicit ODEs (FIRKimplicit and SRKimplicit)\nVariational Partitioned Runge-Kutta integrator with projection based on internal stages","category":"page"},{"location":"releasenotes/#Fixes-5","page":"Release Notes","title":"Fixes","text":"","category":"section"},{"location":"releasenotes/","page":"Release Notes","title":"Release Notes","text":"Computation of initial guess in all implicit integrators","category":"page"},{"location":"integrators/hpg/#hpg","page":"Hamilton-Pontryagin-Galerkin Integrators","title":"Hamilton-Pontryagin-Galerkin Integrators","text":"","category":"section"},{"location":"modules/equations/#Equations","page":"Equations","title":"Equations","text":"","category":"section"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"The following data structures are all implemented in GeometricEquations.jl.","category":"page"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"GeometricEquations.GeometricEquation","category":"page"},{"location":"modules/equations/#GeometricEquations.GeometricEquation","page":"Equations","title":"GeometricEquations.GeometricEquation","text":"GeometricEquation{invType,parType,perType} is the abstract type all equation types are derived from.\n\nAll equations should have fields for defining invariants, parameters and periodicity of the main state variable. The types of these fields are stored in the following type parameters:\n\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nThe Optional* types are all unions of the respective Null* types and NamedTuple or AbstractArray, i.e.,\n\nconst OptionalInvariants = Union{NamedTuple, NullInvariants}\nconst OptionalParameters = Union{NamedTuple, NullParameters}\nconst OptionalPeriodicity = Union{AbstractArray, NullPeriodicity}\n\nThe Null* types are empty structs, merely used for dispatch and the traits hasinvariants, hasparameters and hasperiodicity.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#Ordinary-Differential-Equations","page":"Equations","title":"Ordinary Differential Equations","text":"","category":"section"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"GeometricEquations.ODE\nGeometricEquations.PODE\nGeometricEquations.HODE\nGeometricEquations.IODE\nGeometricEquations.LODE\nGeometricEquations.SODE","category":"page"},{"location":"modules/equations/#GeometricEquations.ODE","page":"Equations","title":"GeometricEquations.ODE","text":"ODE: Ordinary Differential Equation\n\nOrdinary differential equations define an initial value problem of the form\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d.\n\nParameters\n\nvType <: Callable: type of v\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nODE(v, invariants, parameters, periodicity)\nODE(v; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe function v providing the vector field must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params is a NamedTuple of additional parameters on which the vector field may depend.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.PODE","page":"Equations","title":"GeometricEquations.PODE","text":"PODE: Partitioned Ordinary Differential Equation\n\nA partitioned ordinary differential equation is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))  \np(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPODE(v, f, invariants, parameters, periodicity)\nPODE(v, f; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe functions v and f must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.HODE","page":"Equations","title":"GeometricEquations.HODE","text":"HODE: Hamiltonian Ordinary Differential Equation\n\nA canonical Hamiltonian system of equations is special case of a partitioned ordinary differential equation,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))   p(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, given by\n\nbeginaligned\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendaligned\n\ninitial conditions (q_0 p_0) and the dynamical variables (qp) taking values in T^* Q simeq mathbbR^d times mathbbR^d.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nhamType <: Callable: Hamiltonian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\nhamiltonian: function computing the Hamiltonian H (usually the total energy of the system)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nHODE(v, f, hamiltonian, invariants, parameters, periodicity)\nHODE(v, f, hamiltonian; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe functions v, f and hamiltonian must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction hamiltonian(t, q, p, params)\n    return ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.IODE","page":"Equations","title":"GeometricEquations.IODE","text":"IODE: Implicit Ordinary Differential Equation\n\nAn implicit ordinary differential equations is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith force field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMost integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + λ(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) λ(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \nλ(t_0) = λ_0\nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\ngType <: Callable: type of g\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (tqv) cdot lambda\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nIODE(ϑ, f, g, v̄, f̄, invariants, parameters, periodicity)\nIODE(ϑ, f, g; v̄ = _iode_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_iode_default_v̄(v, t, q, params) = nothing\n\nThe functions ϑ, f and g compute the momentum and the vector fields, respectively.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. In addition, the functions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, v, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.LODE","page":"Equations","title":"GeometricEquations.LODE","text":"LODE: Lagrangian Ordinary Differential Equation\n\nA Lagrangian system of equations is a special case of an implicit ordinary differential equations, that is an implicit initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v  \nf = fracpartial Lpartial q \nendaligned\n\ninitial conditions (q_0 p_0) and the solution (qp) taking values in T^* Q simeq mathbbR^d times mathbbR^d. This is a special case of an implicit ordinary differential equation, that is defined by a Lagrangian, as well as a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMany integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + lambda(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) lambda(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \nlambda(t_0) = lambda_0\nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nParameters\n\nϑType <: Function: type of ϑ\nfType <: Function: type of f\ngType <: Function: type of g\nωType <: Function: type of ω\nv̄Type <: Function: type of v̄\nf̄Type <: Function: type of f̄\nlagType <: Function: Lagrangian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (q) cdot lambda\nω: function computing the symplectic matrix\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nlagrangian: function computing the Lagrangian L\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nLODE(ϑ, f, g, ω, l, v̄, f̄, invariants, parameters, periodicity)\nLODE(ϑ, f, g, ω, l; v̄ = _lode_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_lode_default_v̄(v, t, q, params) = nothing\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nand\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers. Finally, the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.SODE","page":"Equations","title":"GeometricEquations.SODE","text":"SODE: Split Ordinary Differential Equation\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nParameters\n\nvType <: Union{Tuple,Nothing}: type of v\nqType <: Union{Tuple,Nothing}: type of q\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: tuple of functions computing the vector fields for each substep\nq: tuple of functions computing the solutions for each substep\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSODE(v, invariants, parameters, periodicity)\nSODE(v; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())\nSODE(v, q, invariants, parameters, periodicity)\nSODE(v, q; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())\n\nFunction Definitions\n\nThe functions v_i providing the vector field must have the interface\n\nfunction v_i(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nand the functions q_i providing the solutions must have the interface\n\nfunction q_i(q₁, t₁, q₀, t₀, params)\n    q₁[1] = q₀[1] + ...\n    q₁[2] = q₀[2] + ...\n    ...\nend\n\nwhere t₀ is the current time, q₀ is the current solution vector, q₁ is the new solution vector at time t₁, holding the result of computing one substep\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps. with the vector field v_i.\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#Differential-Algebraic-Equations","page":"Equations","title":"Differential Algebraic Equations","text":"","category":"section"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"GeometricEquations.DAE\nGeometricEquations.PDAE\nGeometricEquations.HDAE\nGeometricEquations.IDAE\nGeometricEquations.LDAE\nGeometricEquations.SPDAE","category":"page"},{"location":"modules/equations/#GeometricEquations.DAE","page":"Equations","title":"GeometricEquations.DAE","text":"DAE: Differential Algebraic Equation\n\nDefines a differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))   q(t_0) = q_0  \n0 = phi (t q(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector field v, projection u, algebraic constraint phi=0, initial conditions q_0 and lambda_0, the dynamical variable q taking values in mathbbR^d and the algebraic variable lambda taking values in mathbbR^m.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t)) + baru (t q(t) dotq (t) dotp (t) gamma(t))   q(t_0) = q_0  \n0 = phi (t q(t))   lambda(t_0) = lambda_0  \n0 = psi (t q(t) dotq (t))   gamma(t_0) = gamma_0 \nendaligned\n\nwith the second algebraic variable gamma also taking values in mathbbR^m.\n\nParameters\n\nvType <: Callable: type of v\nuType <: Callable: type of u\nϕType <: Callable: type of ϕ\nūType <: OptionalCallable: type of ū\nψType <: OptionalCallable: type of ψ\nv̄Type <: Callable: type of v̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v(v, t, q, params)\nu: function computing the projection u(u, t, q, λ, params)\nϕ: algebraic constraint ϕ(ϕ, t, q, params)\nū: function computing the secondary projection field ū(ū, t, q, λ, params) (optional)\nψ: secondary constraint ψ(ψ, t, q, v, params) (optional)\nv̄: function computing an initial guess for the velocity field v (defaults to v)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nDAE(v, u, ϕ, ū, ψ, v̄, invariants, parameters, periodicity)\nDAE(v, u, ϕ, ū, ψ; kwargs...)\nDAE(v, u, ϕ; kwargs...)\n\nThe functions v and u compute the vector field and the projection, respectively, ϕ provides the algebraic constraint. The functions ψ and ū are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, u and ϕ must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction u(u, t, q, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, γ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, params)\n    ψ[1] = ...\nend\n\nThe DAE is created by\n\nequ = DAE(v, u, ϕ)\n\nor\n\nequ = DAE(v, u, ϕ, ū, ψ)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.PDAE","page":"Equations","title":"GeometricEquations.PDAE","text":"PDAE: Partitioned Differential Algebraic Equation\n\nA partitioned differential algebraic equation has the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector fields v and f, projection u and g, algebraic constraint phi=0, initial conditions (q_0 p_0) and lambda_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variable lambda taking values in mathbbR^m.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))   lambda(t_0) = lambda_0  \n0 = psi (t q(t) p(t) dotq (t) dotp (t))   gamma(t_0) = gamma_0 \nendaligned\n\nwith the second algebraic variable gamma also taking values in mathbbR^m.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional, defaults to v)\nf̄: function computing an initial guess for the force field f (optional, defaults to f)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, invariants, parameters, periodicity)\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ; kwargs...)\nPDAE(v, f, u, g, ϕ; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, f, u, g and ϕ must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q, p and λ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections u and g, and ϕ holds the algebraic constraint phi, evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, γ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, γ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nThe PDAE is created by\n\nequ = PDAE(v, f, u, g, ϕ)\n\nor\n\nequ = PDAE(v, f, u, g, ϕ, ū, ḡ, ψ)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.HDAE","page":"Equations","title":"GeometricEquations.HDAE","text":"HDAE: Hamiltonian Differential Algebraic Equation\n\nA Hamiltonian differential algebraic is an initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qpdotqdotp)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^m times mathbbR^m.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\nhamType <: Callable: Hamiltonian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the Hamiltonian vector field v\nf: function computing the Hamiltonian vector field f\nu: function computing the projection for q\ng: function computing the primary projection field g\nϕ: primary constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional, defaults to v)\nf̄: function computing an initial guess for the force field f (optional, defaults to f)\nhamiltonian: function computing the Hamiltonian H (usually the total energy of the system)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, v̄, f̄, invariants, parameters, periodicity)\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h; kwargs...)\nHDAE(v, f, u, g, ϕ, h; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, ϕ provides the algebraic constraint and h the Hamiltonian. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, f, u, g, ϕ and h must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nfunction h(t, q, p, params)\n    ...\nend\n\nwhere t is the current time, q, p, λ and γ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections on the primary constraint u and g,  ϕ holds the algebraic constraint phi, and h returns the Hamiltonian of the system, all evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, γ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, γ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nThe HDAE is created by\n\nequ = HDAE(v, f, u, g, ϕ, h)\n\nor\n\nequ = HDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h)\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.IDAE","page":"Equations","title":"GeometricEquations.IDAE","text":"IDAE: Implicit Differential Algebraic Equation\n\nAn implicit differential algebraic initial value problem takes the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t))   p(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))   \n0 = phi (t q(t) v(t) p(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith force field f, the momentum defined by ϑ, projections u and g, algebraic constraint phi(tqvp)=0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, the algebraic variable lambda taking values in mathbbR^m, and initial conditions (q_0 p_0) and lambda_0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) gamma(t))   p(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))   \n0 = phi (t q(t) v(t) p(t))   lambda(t_0) = lambda_0  \n0 = psi (t q(t) v(t) p(t) dotq (t) dotp (t))   gamma(t_0) = gamma_0 \nendaligned\n\nwith the second algebraic variable gamma also taking values in mathbbR^m.\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, invariants, parameters, periodicity)\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ; v̄ = _idae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\nIDAE(ϑ, f, u, g, ϕ; v̄ = _idae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_idae_default_v̄(v, t, q, params) = nothing\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, λ)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, γ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, γ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.LDAE","page":"Equations","title":"GeometricEquations.LDAE","text":"LDAE: Lagrangian Differential Algebraic Equation\n\nA special case of an implicit initial value problem is a Lagrangian differential algebraic equation of the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) gamma(t))  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) gamma(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v (qv)  \nf = fracpartial Lpartial q (qv) \nendaligned\n\nprojection fields u, baru and g, barg, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (v lambda gamma) taking values in mathbbR^d times mathbbR^m times mathbbR^m. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and gamma.\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nωType <: Callable: type of ω\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\nlagType <: Callable: Lagrangian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nf: function computing the vector field\nu: function computing the projection for q, for a degenerate system given by lambda\ng: function computing the projection for p, for a degenerate system given by nabla vartheta (q) cdot lambda\nϕ: primary constraints, for a degenerate system given by p - vartheta (tq)\nū: function computing the secondary projection field baru, for a degenerate system given by lambda (optional)\nḡ: function computing the secondary projection field barg, for a degenerate system given by lambda cdot nabla vartheta (tq) (optional)\nψ: secondary constraints, for a degenerate system given by dotp - dotq cdot nabla vartheta (tq) (optional)\nω: function computing the symplectic matrix\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nlagrangian: function computing the Lagrangian L\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, v̄, f̄, lagrangian, invariants, parameters, periodicity)\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, lagrangian; v̄ = _ldae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\nLDAE(ϑ, f, u, g, ϕ, ω, lagrangian; v̄ = _ldae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_ldae_default_v̄(v, t, q, params) = nothing\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, λ)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nand the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, γ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, γ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.SPDAE","page":"Equations","title":"GeometricEquations.SPDAE","text":"SPDAE: Split Partitioned Differential Algebraic Equation EXPERIMENTAL\n\nDefines a split differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v_1(t q(t) p(t)) + v_2(t q(t) p(t) lambda(t)) + v_3(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f_1(t q(t) p(t)) + f_2(t q(t) p(t) lambda(t)) + f_3(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v_i and f_i for i = 1  3, primary constraint phi(qp)=0 and secondary constraint psi(qplambda)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^n times mathbbR^d.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nϕType <: Callable: type of ϕ\nψType <: Callable: type of ψ\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: tuple of functions computing the vector fields v_i, i = 1  3\nf: tuple of functions computing the vector fields f_i, i = 1  3\nϕ: primary constraints\nψ: secondary constraints\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSPDAE(v, f, ϕ, ψ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nSPDAE(v, f, ϕ, ψ, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nSPDAE(v, f, ϕ, ψ, t₀, q₀::State, p₀::State, λ₀::State=zero(q₀); kwargs...)\nSPDAE(v, f, ϕ, ψ, q₀::State, p₀::State, λ₀::State=zero(q₀); kwargs...)\n\nKeyword arguments:\n\ninvariants = nothing\nparameters = nothing\nperiodicity = nothing\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#Stochastic-Differential-Equations","page":"Equations","title":"Stochastic Differential Equations","text":"","category":"section"},{"location":"modules/equations/","page":"Equations","title":"Equations","text":"GeometricEquations.SDE\nGeometricEquations.PSDE\nGeometricEquations.SPSDE","category":"page"},{"location":"modules/equations/#GeometricEquations.SDE","page":"Equations","title":"GeometricEquations.SDE","text":"SDE: Stratonovich Stochastic Differential Equation\n\nDefines a stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendaligned\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Callable: type of v\nBType <: Callable: type of B\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv:  function computing the deterministic vector field\nB:  function computing the d x m diffusion matrix\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSDE(v, B, invariants, parameters, periodicity)\nSDE(v, B; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v and B, providing the drift vector field and diffusion matrix. The function v must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params are additional parameters. The function B should have a method with interface\n\nfunction B(B, t, q, params)\n    B[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.PSDE","page":"Equations","title":"GeometricEquations.PSDE","text":"PSDE: Stratonovich Partitioned Stochastic Differential Equation\n\nA partitioned stochastic differential equations is an initial value problem of the form\n\nbeginaligned\ndq (t) = v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) = f(t q(t) p(t))  dt + G(t q(t) p(t)) circ dW   p(t_0) = p_0\nendaligned\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nBType <: Callable: type of B\nGType <: Callable: type of G\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv:  function computing the drift vector field for the position variable q\nf:  function computing the drift vector field for the momentum variable p\nB:  function computing the d x m diffusion matrix for the position variable q\nG:  function computing the d x m diffusion matrix for the momentum variable p\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPSDE(v, f, B, G, invariants, parameters, periodicity)\nPSDE(v, f, B, G; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, each take five arguments, v(v, t, q, p, params), f(f, t, q, p, params), B(B, t, q, p, params) and G(G, t, q, p, params), where t is the current time, (q, p) is the current solution, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p), and params are optional parameters.\n\nThe corresponding methods should have the following signatures:\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"modules/equations/#GeometricEquations.SPSDE","page":"Equations","title":"GeometricEquations.SPSDE","text":"SPSDE: Stratonovich Split Partitioned Stochastic Differential Equation\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) =   v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) =  f_1(t q(t) p(t)) + f_2(t q(t) p(t))   dt +  G_1(t q(t) p(t)) + G_2(t q(t) p(t))  circ dW   p(t_0) = p_0 \nendaligned\n\nwith the drift vector fields v and f_i, diffusion matrices B and G_i, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Function: type of v\nf1Type <: Function: type of f1\nf2Type <: Function: type of f2\nBType <: Function: type of B\nG1Type <: Function: type of G1\nG2Type <: Function: type of G2\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv :  function computing the drift vector field for the position variable q\nf1:  function computing the drift vector field for the momentum variable p\nf2:  function computing the drift vector field for the momentum variable p\nB :  function computing the d x m diffusion matrix for the position variable q\nG1:  function computing the d x m diffusion matrix for the momentum variable p\nG2:  function computing the d x m diffusion matrix for the momentum variable p\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSPSDE(v, f1, f2, B, G1, G2, invariants, parameters, periodicity)\nSPSDE(v, f1, f2, B, G1, G2; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v, f1, f2, B, G1 and G2, providing the drift vector fields and diffusion matrices, all take five arguments, (out, t, q, p, params).\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f1(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction f2(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G1(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nfunction G2(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nwhere t is the current time, (q,p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B_i, G_i on (t,q,p).\n\n\n\n\n\n","category":"type"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"CurrentModule = GeometricIntegrators.Integrators","category":"page"},{"location":"integrators/vprk/#Variational-Partitioned-Runge-Kutta-Integrators","page":"VPRK","title":"Variational Partitioned Runge-Kutta Integrators","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Variational partitioned Runge-Kutta methods solve Lagranian systems in implicit form, i.e.,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\np       = dfracpartial Lpartial dotq (q dotq)  \ndotp = dfracpartial Lpartial q       (q dotq)  \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"by the following scheme,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nq_n+1 = q_n + h sum limits_i=1^s b_i  V_ni  \nF_ki = dfracpartial Lpartial q (Q_ni V_ni)  \nP_nj = p_n + h  sum limits_i=1^s bara_ij  F_nj  \np_n+1 = p_n + h sum limits_i=1^s b_i  F_ni \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Here, s denotes the number of internal stages, a_ij and bara_ij are the coefficients of the Runge-Kutta method and b_i and barb_i the corresponding weights. If the coefficients satisfy the symplecticity conditions,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nb_i bara_ij + barb_j a_ji = b_i barb_j \n textand \nbarb_i = b_i \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"these methods correspond to the position-momentum form of the discrete Lagrangian [[9]]","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk-discrete-lagrangian\nL_d (q_n q_n+1) = h sum limits_i=1^s b_i  L big( Q_ni V_ni big) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"While these integrators show favourable properties for systems with regular Lagrangian, they are usually not applicable for degenerate Lagrangian systems, in particular those with Lagrangians of the form L (q dotq) = vartheta(q) cdot dotq - H(q). While variational integrators are still applicable in the case of vartheta being a linear function of q, they are often found to be unstable when vartheta is a nonlinear function of q as is the case with Lotka-Volterra systems, various nonlinear oscillators, guiding centre dynamics and other reduced charged particle models. To mitigate this problem, projection methods have been developed, which can be used in conjunction with variational integrators. These projected variational integrators provide long-time stable methods for general degenerate Lagrangian systems that maintain conservation of energy and momenta over long integration periods [[14]].","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"GeometricIntegrators.jl provides the following VPRK methods:","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Integrator Description\nIntegratorVPRK Variational Partitioned Runge-Kutta (VPRK) integrator without projection\nIntegratorVPRKpStandard VPRK integrator with standard projection\nIntegratorVPRKpSymmetric VPRK integrator with symmetric projection\nIntegratorVPRKpMidpoint VPRK integrator with midpoint projection\nIntegratorVPRKpVariational VPRK integrator with variational projection (unstable)\nIntegratorVPRKpSecondary VPRK integrator with projection on secondary constraint\nIntegratorVPRKpInternal Gauss-Legendre VPRK integrator with projection on internal stages of Runge-Kutta method\nIntegratorVPRKpTableau Gauss-Legendre VPRK integrator with projection in tableau of Runge-Kutta method","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For testing purposes IntegratorVPRKpStandard provides some additional constructors (note that these methods are generally unstable):","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Integrator Description\nIntegratorVPRKpVariationalQ VPRK integrator with variational projection on (q_n p_n+1)\nIntegratorVPRKpVariationalP VPRK integrator with variational projection on (p_n q_n+1)\nIntegratorVPRKpSymplectic VPRK integrator with symplectic projection","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"All of the above integrators are applied to either an IODEProblem or LODEProblem and instantiated as follows:","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"int = IntegratorVPRK(iode, tab, Δt)","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The only exception is IntegratorVPRKpSecondary which can only be applied to an LODEProblem as it needs some additional functions which are only defined for variational problems.","category":"page"},{"location":"integrators/vprk/#Discrete-Action-Princtiple","page":"VPRK","title":"Discrete Action Princtiple","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Symplectic partitioned Runge-Kutta integrators have been shown to be variational integrators [[9], [5]]. Here, the discrete Lagrangian \\eqref{eq:vprk-discrete-lagrangian} has s internal points (or stages) located at t_n + h c_i with weights b_i which are all non-zero and sum up to one. The internal stages Q_ni approx q(t_n + h c_i) are given by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Q_ni = q_n + h sum limits_j=1^s a_ij  V_nj ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In contrast to the composition methods, we do not require c_1 = 0 and c_s = 1. Instead the discrete action is extremised under the constraints","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"q_n+1 = q_n + h sum limits_i=1^s b_i  V_ni ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"which we add to the action with the Lagrange multiplier lambda_n+1, so that we can write","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk-action-gauss\nmathcalA_d = sum limits_n=1^N-1 bigg h sum limits_i=1^s b_i  L big( Q_ni V_n1 big) + lambda_n+1 cdot bigg( q_n+1 - q_n - h sum limits_i=1^s b_i  V_ni bigg) bigg \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Computing variations of the action leads to","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\ndelta mathcalA_d\n= sum limits_n=1^N-1left h sum limits_i=1^s h b_i a_ij  dfracpartial Lpartial q (Q_ni V_ni) \n + h b_j  dfracpartial Lpartial v (Q_nj V_nj)\n - h b_j  lambda_n+1 right cdot delta V_nj \n+ sum limits_n=1^N-1left h sum limits_i=1^s b_i  dfracpartial Lpartial q (Q_ni V_ni) \n - lambda_n+1 + lambda_n right cdot delta q_n \n+ sum limits_n=1^N-1 bigg q_n+1 - q_n - h sum limits_i=1^s b_i  V_ni bigg cdot delta lambda_n+1\n = 0 \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"We define discrete forces and momenta as","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"F_ni = dfracpartial Lpartial q (Q_ni V_ni)\nhspace3em\ntextand\nhspace3em\nP_ni = dfracpartial Lpartial v (Q_ni V_ni) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that the terms of the variation which are multiplying delta V_nj become","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"P_nj = lambda_n+1 - h sum limits_i=1^s dfracb_i a_ijb_j  F_ni ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The terms of the variations which are multiplying delta q_n become","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"lambda_n+1 = lambda_n + h sum limits_i=1^s b_i  F_ni ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Similar to classical variational integrators, we can use the discrete fibre derivative","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdiscrete-fibre-derivative\nbeginaligned\nmathbbF^- L_d  (q_n q_n+1) mapsto (q_n   p_n)   = big( q_n   - D_1 L_d (q_n q_n+1) big)  \nmathbbF^+ L_d  (q_n q_n+1) mapsto (q_n+1 p_n+1) = big( q_n+1   D_2 L_d (q_n q_n+1) big) \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"to define the position-momentum form of the integrator,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvi-position-momentum-form\nbeginaligned\np_n  \n=           -  D_1 L_d (q_n q_n+1)\n = lambda_n+1 - h sum limits_i=1^s b_i  F_ni  \np_n+1\n= hphantom- D_2 L_d (q_n q_n+1)\n = lambda_n+1 \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Replacing lambda_n+1 in the second equation with its expression obtained from the first equation, we get","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"p_n+1 = p_n + h sum limits_i=1^s v_i  F_ni ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"which states that the second symplecticity condition (b_i = barb_i) is automatically satisfied. In the same fashion, we obtain","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"P_nj = p_n + h sum limits_i=1^s bara_ij  F_nj ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"with","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"bara_ij = b_j - b_j a_ji  b_i ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"such that the first symplecticity condition is also satisfied. In summary, we obtain the variational-partitioned Runge-Kutta integrator \\eqref{eq:vprk}. If the fibre derivative is invertible, an equivalent set of equations can be obtained by applying","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nV_ni =   dfracpartial Hpartial p (Q_ni P_ni)  \nF_ni = - dfracpartial Hpartial q (Q_ni P_ni) \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"to the Hamiltonian H(qp) obtained via the Legendre transform. The interested reader can find more details on this in [[5]] and references therein.","category":"page"},{"location":"integrators/vprk/#Lobatto-Methods","page":"VPRK","title":"Lobatto Methods","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Some words of caution are in order. The above derivation works well, if all discrete velocities V_ni are linearly independent. This is the case e.g. for Gauss-Legendre Runge-Kutta discretizations but not for Lobatto discretizations (see [15] for details). For discretizations of Lobatto-IIIA type, where the first internal stage coincides with the solution at the previous time step, the velocities V_ni are not linearly independent and the discrete action \\eqref{eq:vprk-action-gauss} needs to be augmented by an additional constraint to take this dependence into account,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk-action-lobatto\nbeginaligned\nmathcalA_d =\nsum limits_n=0^N-1 Bigglgroup\nh sum limits_i=1^s b_i  bigg L big( Q_ni V_ni big)\n+ F_ni cdot bigg( Q_ni - q_n - h sum limits_j=1^s a_ij  V_nj bigg) bigg \n- p_n+1 cdot bigg( q_n+1 - q_n - h sum limits_i=1^s b_i  V_ni bigg)\n+ mu_n cdot bigg( sum limits_i=1^s d_i V_ni bigg)\nBiggrgroup \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Requiring stationarity of \\eqref{eq:vprk-action-lobatto}, we obtain a modified system of equations,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqvprk-lobatto\nbeginaligned\nP_ni = dfracpartial Lpartial v (Q_ni V_ni)  \nF_ni = dfracpartial Lpartial q (Q_ni V_ni)  \nQ_ni = q_n + h sum limits_j=1^s a_ij  V_nj  \nP_ni = p_n + h sum limits_j=1^s bara_ij  F_nj - mu_n dfracd_ib_i  \nq_n+1 = q_n + h sum limits_i=1^s b_i   V_ni  \np_n+1 = p_n + h sum limits_i=1^s barb_i   F_ni  \n0 = sum limits_i=1^s d_i V_ni \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"accounting for the linear dependence of the dotQ_ni and consequently also of the P_ni. The particular values of d_i depend on the number of stages s and the definition of the q_ni [[15]]. For two stages, we have d_1 = - d_2, so that we can choose, for example, d = (+1 -1), and \\eqref{eq:vprk-lobatto} becomes equivalent to the variational integrator of the trapezoidal Lagrangian. For three stages, we can choose d = (tfrac12 -1 tfrac12), and for four stages we can use d = (+1 -sqrt5 +sqrt5 -1). In GeometricIntegrators, these vectors can be obtained via the function get_lobatto_nullvector from RungeKutta.jl.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Another approach that always works is to use directly compute the position-momentum form \\eqref{eq:vi-position-momentum-form} of the variational integrator for the discrete Lagrangian \\eqref{eq:vprk-discrete-lagrangian} instead of applying the discrete action principle. Such subtleties, which are easily overlooked, can be avoided by starting the discretisation of the action from a more fundamental point of view, namely by approximating the function spaces of the trajectories, which leads us to Galerkin Variational Integrators.","category":"page"},{"location":"integrators/vprk/#sec:degenerate-lagrangian-systems","page":"VPRK","title":"Degenerate Lagrangians","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Degenerate Lagrangian systems are relevant for the study of population models, point vortex dynamics or reduced charged particle models like the guiding centre system. Here, we consider degenerate Lagrangian systems characterized by a Lagrangian that is linear or singular in the velocities. In particular, we consider the class of systems whose Lagrangian is of the form","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdegenerate-lagrangian\nL (q v) = vartheta(q) cdot v - H(q) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The Lagrangian L is a function on the tangent bundle tbmfM,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqlagrangian-tangent-bundle\nL  tbmfM rightarrow mathbbR \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where mfM denotes the configuration manifold of the system which is assumed to be of dimension d. The cotangent bundle of the configuration manifold mfM is denoted by cbmfM. Further, we denote the coordinates of a point m in mfM by q(m) = (q^1 (m) dotsc q^d (m)) and similarly coordinates of points in tbmfM by (q^i v^i) and coordinates of points in cbmfM by (q^i p^i). In the following, we will always assume the existence of a global coordinate chart, so that mfM can be identified with the Euclidean space mathbbR^d. For simplicity, we often use short-hand notation where we write q to refer to both a point in mfM as well as its coordinates. Similarly, we often denote points in the tangent bundle tbmfM by (q v). In local coordinates, the Lagrangian \\eqref{eq:lagrangian-tangent-bundle} is thus written as a map (q v) mapsto L(q v).","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In Equation \\eqref{eq:degenerate-lagrangian}, vartheta = vartheta_i (q)  ext q^i is a differential one-form vartheta  mfM rightarrow cbmfM, whose components vartheta_i  mfM rightarrow mathbbR are general, possibly nonlinear functions of q, some of which (but not all) could be identically zero. For details on differential forms, tangent and cotangent bundles the interested reader may consult any modern book in mathematical physics or differential geometry. We recommend [16], [17], [18], [19] for more physics oriented accounts and [20], [21], [22], [23] for more mathematics oriented accounts. In the following we assume a basic understanding of these concepts. To see their usefulness for classical mechanics we refer to [24], [25], [26].","category":"page"},{"location":"integrators/vprk/#sec:dirac-constraints","page":"VPRK","title":"Dirac Constraints","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Degenerate systems of the form \\eqref{eq:degenerate-lagrangian} can also be formulated in terms of the phasespace trajectory (q p) in the cotangent bundle cbmfM, subject to a primary constraint in the sense of Dirac, determined by the function phi  cbmfM rightarrow mathbbR^d, given by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdirac_constraint\nphi (q p) = p - vartheta(q) = 0 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and originating from the fibre derivative mathbbF L  tbmfM rightarrow cbmfM,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqfibre-derivative-general\nmathbbF L (v_q) cdot w_q = dfracddepsilon biggvert_epsilon=0 L(v_q + epsilon w_q) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where v_q = (q v) and w_q = (q w) denote two points in tbmfM which share the same base point q and are thus elements of the same fibre of tbmfM. By acting point-wise for each t, the fibre derivative maps the curve (q dotq) in the tangent bundle tbmfM into the curve (q p) in the cotangent bundle cbmfM,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqfibre_derivative\n(q (t) p (t)) = left( q (t) dfracpartial Lpartial v (q (t) dotq (t)) right) = (q (t) vartheta (q (t))) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where the last equality follows for Lagrangians of the form \\eqref{eq:degenerate-lagrangian}. The Dirac constraint arising from the degenerate Lagrangian restricts the dynamics to the submanifold","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqconstraint-submanifold\nDelta = big (q p) in cbmfM  bigvert  phi (q p) = 0  big subset cbmfM \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the preceding and the following, we assume that the Lagrangian is degenerate in all velocity components, that is, the Lagrangian is either linear or singular in each component of v, so that","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"dfracpartial^2 Lpartial v^i  partial v^j = 0\nhspace3em\ntextfor all 1 leq ij leq d","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For instructive reasons, however, assume for a moment that the Lagrangian is degenerate in only m  d components of v and, e.g., quadratic in the other d-m components. That is to say we can write","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"p (t)\n= big( beta_1 (q (t) dotq (t)) dotsc beta_d-m (q (t) dotq (t))  vartheta_d-m+1 (q (t)) dotsc vartheta_d (q (t)) big)^T ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"dfracpartial Lpartial v^i (q (t) dotq (t)) = begincases\nbeta_i (q (t) dotq (t))  1 leq i leq d - m  \nvartheta_i (q (t))  d-m+1 leq i leq d  \nendcases","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"We can then denote coordinates in Delta by (q^i pi^j) with 1 leq i leq d and 1 leq j leq d-m, where the pi^i denote those momenta which are ``free'', i.e., not determined by the Dirac constraint. The inclusion map i  Delta rightarrow cbmfM can then be written as","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdirac-inclusion_genereal\ni  (q pi) mapsto (q pi vartheta (q)) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the fully degenerate case, however, we have m=d, so that the configuration manifold mfM and the constraint submanifold Delta are isomorphic and we can label points in Delta by the same q we use to label points in mfM. The inclusion map i  Delta rightarrow cbmfM simplifies accordingly and reads","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqdirac-inclusion\ni  q mapsto (q vartheta (q)) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where it is important to keep in mind that q denotes a point in Delta. The inverse operation is given by the projection pi_Delta  cbmfM rightarrow Delta, defined such that pi_Delta circ i = id.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"As we are lacking a general framework for constructing structure-preserving numerical algorithms for noncanonical Hamiltonian systems on mfM, we will construct such algorithms on i(Delta). This can be achieved by using canonically symplectic integrators on cbmfM and assuring that their solution stays on i(Delta). To this end we will employ various projection methods.","category":"page"},{"location":"integrators/vprk/#Projection-Methods","page":"VPRK","title":"Projection Methods","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Projection methods are a standard technique for the integration of ordinary differential equations on manifolds [[27], [5]]. The problem of constructing numerical integrators on manifolds with complicated structure is often difficult and thus avoided by embedding the manifold into a larger space with simple, usually Euclidean structure, where standard integrators can be applied. Projection methods are then used to ensure that the solution stays on the correct subspace of the extended solution space, as that is usually not guaranteed by the numerical integrator itself.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the standard projection method, a projection is applied after each step of the numerical algorithm. Assuming that the initial condition lies in the manifold, the solution of the projected integrator will stay in the manifold. The problem with this approach is that even though assuming that the numerical integrator is symmetric, the whole algorithm comprised of the integrator and the projection will not be symmetric. This often leads to growing errors in the solution and consequently a drift in the total energy of the system. This can be remedied by symmetrizing the projection [[28], [27], [29], [5]], where the initial data is first perturbed out of the constraint submanifold, before the numerical integrator is applied, and then projected back to the manifold. This leads to very good long-time stability and improved energy behaviour.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"While such projection methods, both standard and symmetric ones, are standard procedures for conserving energy, as well as holonomic and non-holonomic constraints, not much is known about their application to Dirac constraints.  Some authors consider general differential algebraic systems of index two [[30], [31], [32], [29], [33], [34]], the class to which the systems considered here belong, but a discussion of symplecticity seems to be mostly lacking from the literature, aside from some remarks on the conservation of quadratic invariants by the post-projection method of [[32]].","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the following, we apply several projection methods (standard, symmetric, symplectic, midpoint) to variational integrators in position-momentum form. As it turns out, both the standard projection and the symmetric projection are not symplectic. The symmetric projection nevertheless shows very good long-time stability, as it can be shown to be pseudo-symplectic. The symplectic projection method, as the name suggests, is indeed symplectic, although in a generalized sense. The midpoint projection method is symplectic in the usual sense but only for particular integrators.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The general procedure is as follows. We start with initial conditions q_n on Delta (recall that for the particular Lagrangian \\eqref{eq:degenerate-lagrangian} considered here, the configuration manifold mfM and the constraint submanifold Delta are isomorphic, so that we can use the same coordinates on Delta as we use on mfM). We compute the corresponding momentum p_n by the continuous fibre derivative \\eqref{eq:fibre-derivative-general}, which yields initial conditions (q_n p_n = vartheta(q_n)) on cbmfM satisfying the constraint phi(q_n p_n) = 0. This corresponds to the inclusion map \\eqref{eq:dirac-inclusion}. Then, we may or may not perturb these initial conditions off the constraint submanifold by applying a map (q_n p_n) mapsto (barq_n barp_n) which is either the inverse mathbbP^-1 of a projection mathbbP  cbmfM rightarrow i(Delta) or, in the case of the standard projection, just the identity. The perturbation is followed by the application of some canonically symplectic algorithm Psi_h on cbmfM, namely a variational integrator in position-momentum form \\eqref{eq:vi-position-momentum-form} or a variational Runge-Kutta method \\eqref{eq:vprk} or \\eqref{eq:vprk-lobatto}, in which cases we have that Psi_h = big( mathbbF^+ L_d big) circ big( mathbbF^- L_d big)^-1. In general, the result of this algorithm, (barq_n+1 barp_n+1) = Psi_h (barq_n barp_n), will not lie on the constraint submanifold \\eqref{eq:constraint-submanifold}. Therefore we apply a projection (barq_n+1 barp_n+1) mapsto (q_n+1 p_n+1) which enforces phi (q_n+1 p_n+1) = p_n+1 - vartheta(q_n+1) = 0. As this final result is a point in i(Delta) it is completely characterized by the value q_n+1.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: )","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Gradient of the constraint function phi orthogonal and Omega-orthogonal to constant surfaces of phi(q p) = p - sqrtp_0^2 - q^2 for p_0 in  1 2 3 .","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Let us emphasize that in contrast to standard projection methods, where the solution is projected orthogonal to the constrained submanifold, along the gradient of phi, here the projection has to be Omega-orthogonal, where Omega is the canonical symplectic matrix","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqcanonical-symplectic-matrix\nOmega = beginpmatrix\nmathbb0            -  mathbb1 \nmathbb1  hphantom- mathbb0 \nendpmatrix \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"That is, denoting by lambda the Lagrange multiplier, the projection step is given by Omega^-1 nabla phi^T lambda instead of an orthogonal projection nabla phi^T lambda.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Let us also note that, practically speaking, the momenta p_n and p_n+1 are merely treated as intermediate variables much like the internal stages of a Runge-Kutta method. The Lagrange multiplier lambda, on the other hand, is determined in different ways for the different methods and can be the same or different in the perturbation and the projection. It thus takes the role of an internal variable only for the standard, symmetric projection and midpoint projection, but not for the symplectic projection.","category":"page"},{"location":"integrators/vprk/#Geometric-Aside:-Projected-Fibre-Derivatives","page":"VPRK","title":"Geometric Aside: Projected Fibre Derivatives","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the following, we will try to underpin the construction of the various projection methods with some geometric ideas. We already mentioned several times that the position-momentum form of the variational integrator \\eqref{eq:vi-position-momentum-form} suffers from the problem that it does not preserve the constraint submanifold Delta defined in \\eqref{eq:constraint-submanifold}. That is, even though it is applied to a point in i(Delta), it usually returns a point in cbmfM, but outside of i(Delta). In order to understand the reason for this, let us define Delta_mfM^- and Delta_mfM^+ as the subsets of mfM times mfM which are mapped into the constraint submanifold i(Delta) by the discrete fibre derivatives mathbbF^- L_d and mathbbF^+ L_d, respectively, i.e.,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqconstraint-submanifold_QxQ\nbeginaligned\nDelta_mfM^- =  (q_n q_n+1) in mfM times mfM  bigvert  mathbbF^- L_d (q_n q_n+1) = (q_n p_n) in i(Delta) big  \nDelta_mfM^+ =  (q_n q_n+1) in mfM times mfM  bigvert  mathbbF^+ L_d (q_n q_n+1) = (q_n+1 p_n+1) in i(Delta) big \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"or more explicitly,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqconstraint-submanifold_QxQ_coordinates\nbeginaligned\nDelta_mfM^- =  (q_n q_n+1) in mfM times mfM  bigvert  - D_1 L_d (q_n q_n+1) = vartheta(q_n) big  \nDelta_mfM^+ =  (q_n q_n+1) in mfM times mfM  bigvert  D_2 L_d (q_n q_n+1) = vartheta(q_n+1) big \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"A sufficient condition for the position-momentum form of the variational integrator \\eqref{eq:vi-position-momentum-form} to preserve the constraint submanifold \\eqref{eq:constraint-submanifold} would be that Delta_mfM^- and Delta_mfM^+ are identical.  In principle, slightly weaker necessary conditions can be formulated, however in practice it is unclear how to prove any of these conditions and in general they are not satisfied.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In order to construct a modified algorithm which does preserve the constraint submanifold, we compose the discrete fibre derivatives mathbbF^pm with appropriate projections mathbbP^pm,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqposition_momentum_projection\nbeginaligned\n(q_n p_n  )\n= big( mathbbP^- circ mathbbF^- L_d big) (q_n q_n+1)\n = mathbbP_lambda_n^-^- big( q_n -  D_1 L_d (q_n q_n+1) big)  \n(q_n+1 p_n+1)\n= big( mathbbP^+ circ mathbbF^+ L_d big) (q_n q_n+1)\n = mathbbP_lambda_n+1^+^+ big( q_n+1 D_2 L_d (q_n q_n+1) big)  \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that they take any point in mfM times mfM to the constraint submanifold Delta. The Lagrange multiplier lambda is indicated as subscript and implicitly determined by requiring that the constraint phi is satisfied by the projected values of q and p. These projected fibre derivatives will not be a fibre-preserving map anymore, but they will change both q and p. Noting that the nullspace of mathbbP_lambda is the span of Omega^-1 nabla phi, a natural candidate for the projection mathbbP_lambda is given by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqprojector\nbeginaligned\nmathbbP_lambda^pm (q p)  (q p) = (q p) pm h  Omega^-1 nabla phi^T (q p) lambda  \n0 = phi(q p) \nendaligned\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that ( mathbbP^- circ mathbbF^- L_d ) (q_n q_n+1) explicitly reads","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nq_n = q_n - h  phi_p^T (q_n p_n) lambda_n^-  \np_n = - D_1 L_d (q_n q_n+1) + h  phi_q^T (q_n p_n) lambda_n^-  \n0 = phi(q_n p_n) \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and ( mathbbP^+ circ mathbbF^+ L_d ) (q_n q_n+1) explicitly reads","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nq_n+1 = q_n+1 + h  phi_p^T (q_n+1 p_n+1) lambda_n+1^+  \np_n+1 = D_2 L_d (q_n q_n+1) - h  phi_q^T (q_n+1 p_n+1) lambda_n+1^+  \n0 = phi(q_n+1 p_n+1) \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The signs in front of the projections have been chosen in correspondence with the signs of the discrete forces in [9], Chapter 3. With these projections we obtain all of the algorithms introduced in the following sections, except for the midpoint projection, in a similar fashion to the definition of the position-momentum form of the variational integrator \\eqref{eq:vi-position-momentum-form}, as a map Delta rightarrow Delta which can formally be written as","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqprojection-composition-map\nPhi_h = big( pi_Delta circ mathbbP^+ circ mathbbF^+ L_d big) circ big( pi_Delta circ mathbbP^- circ mathbbF^- L_d big)^-1 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In total, we obtain algorithms which map q_n into q_n+1 via the steps","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Delta\nxrightarrowpi_Delta^-1\ni(Delta)\nxrightarrow(mathbbP^-)^-1\ncbmfM\nxrightarrow(mathbbF^- L_d)^-1\nmfM times mfM\nxrightarrowmathbbF^+ L_d\ncbmfM\nxrightarrowmathbbP^+\ni(Delta)\nxrightarrowpi_Delta\nDelta ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where pi_Delta^-1 is identical to the inclusion \\eqref{eq:dirac-inclusion}. The difference of the various algorithms lies in the choice of lambda_n^- and lambda_n+1^+ as follows","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Projection lambda_n^- lambda_n+1^+\nStandard 0 lambda_n+1\nSymplectic lambda_n R (infty)  lambda_n+1hphantom2\nSymmetric lambda_n+12 R (infty)  lambda_n+12\nMidpoint lambda_n+12 R (infty)  lambda_n+12","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For the symmetric, symplectic and midpoint projections, it is important to adapt the sign in the projection according to the stability function R(infty) of the basic integrator (for details see e.g. [29]). For the methods we are interested in, namely Runge-Kutta methods, the stability function is given by R(z) = 1 + z b^T (identity - zA)^-1 e with e = (1 1  1)^T in mathbbR^s, and we have absR(infty)=1 or, more specifically, for Gauss-Legendre methods R(infty) = (-1)^s and for partitioned Gauss-Lobatto IIIA-IIIB and IIIB-IIIA methods we have R(infty) = (-1)^s-1.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Let us remark that for the standard projection, the basic integrator and the projection step can be applied independently. Similarly, for the symplectic projection, the three steps, namely perturbation, numerical integrator, and projection, decouple and can be solved consecutively, as we use different Lagrange multipliers lambda_n in the perturbation and lambda_n+1 in the projection. For the symmetric projection and the midpoint projection, however, this is not the case.  There, we used the same Lagrange multiplier lambda_n+12 in both the perturbation and the projection, so that the whole system has to be solved at once, which is more costly. This also implies that for the projection methods where lambda_n^- and lambda_n+1^+ are the same (possibly up to a sign due to R(infty)), strictly speaking we cannot write the projected algorithm in terms of a composition of two steps as we did in \\eqref{eq:projection-composition-map}. Instead the whole algorithm has to be treated as one nonlinear map. The idea of the construction of the methods is still the same, though. Only the midpoint projection needs special treatment. There, the operator mathbbP_lambda is defined in a slightly more complicated way than in \\eqref{eq:projector}, using different arguments in the projection step, which does not quite fit the general framework outlined here.","category":"page"},{"location":"integrators/vprk/#sec:standard-projection","page":"VPRK","title":"Standard Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: Illustration of the standard projection method)","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Illustration of the standard projection method: The solution is projected to the constraint submanifold Delta after each step of the numerical integrator Psi_h.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The standard projection method [[5], Section IV.4] is the simplest projection method. Starting from q_n, we use the continuous fibre derivative \\eqref{eq:fibre-derivative-general} to compute p_n = vartheta (q_n). Then we apply some symplectic one-step method Psi_h to z_n = (q_n p_n) to obtain an intermediate solution z_n+1,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"barz_n+1 = Psi_h (z_n) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"which is projected onto the constraint submanifold \\eqref{eq:constraint-submanifold} by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqorthogonal_projection\nz_n+1 = barz_n+1 + h  Omega^-1 nabla phi^T (z_n+1) lambda_n+1 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"enforcing the constraint","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"0 = phi (z_n+1) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"This projection method, combined with the variational integrator in position-momentum form \\eqref{eq:vi-position-momentum-form}, is not symmetric, and therefore not reversible. Moreover, it exhibits a drift of the energy, as has been observed before, e.g., for holonomic constraints [[28], [27], [5]].","category":"page"},{"location":"integrators/vprk/#sec:symmetric-projection","page":"VPRK","title":"Symmetric Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: Symmetric Projection +) (Image: Symmetric Projection -)","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Illustration of the symmetric projection method: The solution is first perturbed off the constraint submanifold Delta, then one step of the numerical integrator Psi_h is performed, and the result is projected back onto Delta.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"To overcome the shortcomings of the standard projection, we consider a symmetric projection of the variational Runge-Kutta integrators following [28], [27] and [29], see also [5], Section V.4.1. Here, one starts again by computing the momentum p_n as a function of the coordinates q_n according to the continuous fibre derivative, which can be expressed with the constraint function as","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymmetric-symplectic-projection\n0 = phi (z_n) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Then the initial value z_n is first perturbed,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymmetric-projection-pre\nbarz_n = z_n + h  Omega^-1 nabla phi^T (z_n)  lambda_n+12  \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"followed by the application of some one-step method Psi_h,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"barz_n+1 = Psi_h (barz_n) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and a projection of the result onto the constraint submanifold,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymmetric_projection_post\nz_n+1 = barz_n+1 + h  R(infty)  Omega^-1 nabla phi^T (z_n+1) lambda_n+12 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"which enforces the constraint","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"0 = phi (z_n+1) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Here, it is important to note that Lagrange multiplier lambda_n+12 is the same in both the perturbation and the projection step, and to account for the stability function R(infty) of the basic integrator, as mentioned before. The algorithm composed of the symmetric projection and some symmetric variational integrator in position-momentum form, constitutes a symmetric map","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Phi_h  q_n mapsto q_n+1 ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"where, from a practical point of view, p_n, p_n+1 and lambda_n+12 are treated as intermediate variables. Unfortunately, the method is not symplectic but instead satisfies the relation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginmultlinelabeleqsymmetric-projection-symplecticity-condition\n   dfrac12 barOmega_ij (q_n)  big( ext q_n^i wedge ext q_n^j\n - h^2  ext lambda_n+12^i wedge ext lambda_n+12^j big)\n - h^2 lambda_n+12^k vartheta_kij (q_n)  ext q_n^i wedge ext lambda_n+12^j = \n = dfrac12 barOmega_ij (q_n+1)  big( ext q_n+1^i wedge ext q_n+1^j\n - h^2  ext lambda_n+12^i wedge ext lambda_n+12^j big)\n - h^2 lambda_n+12^k vartheta_kij (q_n+1)  ext q_n+1^i wedge ext lambda_n+12^j \nendmultline","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For certain systems, this method can even be shown to be symplectic. In general, though, it is not symplectic. Nevertheless, it tends to perform very well in long-time simulations.","category":"page"},{"location":"integrators/vprk/#sec:symplectic-projection","page":"VPRK","title":"Symplectic Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: )","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Illustration of the post projection method. Starting on the constraint submanifold Delta, the numerical integrator Psi_h moves the solution away from Delta in the first step. After each step, the solution is projected back onto Delta, but the perturbation at the beginning of each consecutive step is exactly the inverse of the previous projection, so that, practically speaking, the solution is projected back onto Delta only for output purposes.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"In the symplectic projection, we modify the perturbation \\eqref{eq:symmetric-projection-pre} to use the Lagrange multiplier at the previous time step, lambda_n, instead of lambda_n+1. As before, we assum the initial condition z_n satisfies the constraint,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic-projection-pre-constraint\n0 = phi (z_n) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The initial condition is perturbed, using the Lagrange multiplier lambda_n,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic-projection-pre\nbarz_n = z_n + h  Omega^-1 nabla phi^T (z_n)  lambda_n \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Then the usual one-step method Psi_h is applied,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"barz_n+1 = Psi_h (barz_n) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and the result is projected onto the constraint submanifold using the Lagrange multiplier lambda_n+1,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic-projection-post\nz_n+1 = barz_n+1 + h  R(infty)  Omega^-1 nabla phi^T (z_n+1) lambda_n+1 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"in order to enforce the constraint","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic-projection-post-constraint\n0 = phi (z_n+1) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"The symplecticity condition \\eqref{eq:symmetric-projection-symplecticity-condition} is modified as follows,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginmultlinelabeleqsymplectic_projection_symplecticity_condition\n   dfrac12 barOmega_ij (q_n)  big( ext q_n^i wedge ext q_n^j\n - h^2  ext lambda_n^i wedge ext lambda_n^j big)\n - h^2 lambda_n^k vartheta_kij (q_n)  ext q_n^i wedge ext lambda_n^j = \n = dfrac12 barOmega_ij (q_n+1)  big( ext q_n+1^i wedge ext q_n+1^j\n - h^2  ext lambda_n+1^i wedge ext lambda_n+1^j big) \n - h^2 lambda_n+12^k vartheta_kij (q_n+1)  ext q_n+1^i wedge ext lambda_n+1^j \nendmultline","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"implying the conservation of a modified symplectic form omega_lambda defined on an extended phasespace mfM times mathbbR^d with coordinates (q lambda) by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic_projection_two_form\nomega_lambda\n = dfrac12 barOmega_ij (q)  ext q^i wedge ext q^j\n - dfrach^22 barOmega_ij (q)  ext lambda^i wedge ext lambda^j\n - h^2 lambda^k vartheta_kij (q)  ext q^i wedge ext lambda^j \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"with matrix representation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Omega_lambda =\nbeginpmatrix\nbarOmega  - h^2 lambda cdot vartheta_qq \nh^2 lambda cdot vartheta_qq  - h^2 barOmega \nendpmatrix ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"This corresponds to a modified one-form vartheta_lambda, such that omega_lambda = ext vartheta_lambda, given by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic_projection_one_form\nvartheta_lambda = ( vartheta_i (q) - h  lambda^k vartheta_ki (q) )  ( ext q^i - h  ext lambda^i )\nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"As noted by [29], the modified perturbation \\eqref{eq:symplectic-projection-pre-constraint}-\\eqref{eq:symplectic-projection-pre} can be viewed as a change of variables from (q lambda) on mfM times mathbbR^d to (q p) on cbmfM, and the projection \\eqref{eq:symplectic-projection-post}-\\eqref{eq:symplectic-projection-post-constraint} as a change of variables back from (q p) to (q lambda). The symplectic form omega_lambda on mfM times mathbbR^d thus corresponds to the pullback of the canonical symplectic form omega on cbmfM by this variable transformation.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Let us note that the sign in in front of the projection in \\eqref{eq:symplectic-projection-post}, given by the stability function of the basic integrator, has very important implications on the nature of the algorithm. If it is the same as in \\eqref{eq:symplectic-projection-pre}, the character of the method is very similar to the symmetric projection method described before. If the sign is the opposite of the one in \\eqref{eq:symplectic-projection-pre}, like for Gauss-Legendre Runge-Kutta methods with an odd number of stages, the perturbation reverses the projection of the previous step, so that we effectively apply the post-projection method of [32]. That is, the projected integrator Phi_h is conjugate to the unprojected integrator Psi_h by","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Phi_h = mathbbP^-1 circ Psi_h circ mathbbP ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that the following diagram commutes","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"(Image: Commuting Diagram)","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and the projection is effectively only applied for the output of the solution, but the actual advancement of the solution in time happens outside of the constraint submanifold. In other words, applying n times the algorithm Phi_h to a point (q_0 0) is equivalent to applying the perturbation mathbbP^-1, then applying n times the algorithm Psi_h and projecting the result with mathbbP.","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"Potentially, this might degrade the performance of the algorithm. If the accumulated global error drives the solution too far away from the constraint submanifold, the projection step might not have a solution anymore. Interestingly, however, post-projected Gauss-Legendre Runge-Kutta methods retain their optimal order of 2s [[32]]. Moreover, for methods with an odd number of stages, the global error of the unprojected solution is mathcalO(h^s+1), compared to mathcalO(h^s) for methods with an even number of stages. In practice this seems to be at least part of the reason of the good long-time stability of these methods.","category":"page"},{"location":"integrators/vprk/#sec:midpoint-projection","page":"VPRK","title":"Midpoint Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For certain variational Runge-Kutta methods, we can also modify the symmetric projection in a different way in order to obtain a symplectic projection, namely by evaluating the projection at the midpoint","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginaligned\nbarz_n+12 = (barq_n+12 barp_n+12)  \nbarq_n+12 = tfrac12 big( barq_n + barq_n+1 big)  \nbarp_n+12 = tfrac12 big( barp_n + barp_n+1 big) \nendaligned","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"so that the projection algorithm is modified as follows. As always, the initial condition is expected to satisfy the constraint,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqmidpoint_projection_pre_constraint\n0 = phi (z_n) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For the perturbation of the initial condition,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqmidpoint_projection_pre\nbarz_n = z_n + h  Omega^-1 nabla phi^T (barz_n+12)  lambda_n+12 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"the gradient of the constraint is evaluated at the midpoint barz_n+12. A one step method is applied,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"barz_n+1 = Psi_h (z_barz) ","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"and the result is projected, again evaluating the gradient of phi at the midpoint barz_n+12,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqmidpoint_projection_post\nz_n+1 = barz_n+1 + h  R(infty)  Omega^-1 nabla phi^T (z_n+12) lambda_n+12 \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"in order to force the solution to satisfy the constraint,","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"beginequationlabeleqsymplectic_projection_midpoint_post_constraint\n0 = phi (z_n+1) \nendequation","category":"page"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"For certain systems, this method can be shown to be symplectic with respect to the original noncanonical symplectic form on mfM if the integrator Psi_h is a symmetric, symplectic Runge-Kutta method with an odd number of stages s, for which the central stage with index (s+1)2 corresponds to z_n+12. This is obviously the case for the implicit midpoint rule, that is the Gauss-Legendre Runge-Kutta method with s=1, but unfortunately not for higher-order Gauss-Legendre or for Gauss-Lobatto methods. However, following [35] and [36], higher-order methods similar to Gauss-Legendre methods but satisfying the requested property can be obtained. See for example the method with three stages, implemented as TableauSRK3.","category":"page"},{"location":"integrators/vprk/#sec:internal-stage-projection","page":"VPRK","title":"Internal Stage Projection","text":"","category":"section"},{"location":"integrators/vprk/","page":"VPRK","title":"VPRK","text":"TODO","category":"page"},{"location":"authors/#Authors","page":"Authors","title":"Authors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"GeometricIntegrators' development is coordinated by a group of principal developers, who are also its main contributors and who can be contacted in case of questions about GeometricIntegrators. In addition, there are contributors who have provided substantial additions or modifications. Together, these two groups form \"The GeometricIntegrators Authors\" as mentioned in the LICENSE file.","category":"page"},{"location":"authors/#Principal-Developers","page":"Authors","title":"Principal Developers","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"Michael Kraus, Max Planck Institute for Plasma Physics, Garching, Germany","category":"page"},{"location":"authors/#Contributors","page":"Authors","title":"Contributors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"The following people contributed to GeometricIntegrators and are listed in alphabetical order:","category":"page"},{"location":"authors/","page":"Authors","title":"Authors","text":"Christopher Albert\nMichael Kraus\nChristopher Rackauckas\nTomasz M. Tyranoski","category":"page"},{"location":"integrators/variational/#variational-integrators","page":"Variational","title":"Variational Integrators","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The basic idea of variational integrators is to construct a discrete counterpart to a particular mechanical system instead of directly discretising its equations of motion. This means that the fundamental building blocks of classical mechanics, namely the action functional, the Lagrangian, the variational principle, and the Noether theorem, all have discrete equivalents. The application of the discrete variational principle to the discrete action then leads to discrete Euler-Lagrange equations. The evolution map that corresponds to the discrete Euler-Lagrange equations is what is called a variational integrator. The discrete Noether theorem can be used to relate symmetries of the discretised system to discrete momenta that are in principle exactly preserved by this integrator.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"With standard numerical methods, one approximately solves the exact equations of some system. In a sense, the idea of variational integrators is to exactly solve the equations of an approximate system.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The seminal work in the development of a discrete equivalent of classical mechanics was presented by [[10], [10]]. His method, based on a discrete variational principle, leads to symplectic integration schemes that automatically preserve constants of motion [[11], [12]]. A comprehensive review of discrete mechanics can be found in [[9]], including a thorough account on the historical development. The discrete version of Hamilton's phasespace action principle is presented in [[13]].","category":"page"},{"location":"integrators/variational/#Discretisation-of-the-Action","page":"Variational","title":"Discretisation of the Action","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The derivation of the discrete theory follows along the lines of the derivation of the continuous theory. The starting point is the discretisation of the space of paths mathcalQ ( mfM ) that connect two points in mfM,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ ( mfM ) = big q  mathcalI rightarrow mfM  bigvert  mathcalI subset mathbbR  textsmooth and bounded big ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Therefore we divide each time interval mathcalI into an equidistant, monotonic sequence  t_n _n=0^N and defined the discrete path space as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ_d ( mfM ) = big q_d   t_n _n=0^N rightarrow mfM big ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The space mathcalQ_d ( mfM ) contains all possible discrete trajectories q_d in mfM and is isomorphic to mfM times  times mfM (N+1 copies),","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ_d ( mfM ) cong bigtimes_N+1 mfM ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Therefore mathcalQ_d ( mfM ) constitutes a finite-dimensional approximation of the infinite-dimensional space mathcalQ ( mfM ). Note that mathcalQ_d is not a subspace of mathcalQ. Fixing an interval 0 T, so that","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":" t_n _n=0^N =  t_n = nh  vert  n = 0  N   Nh = T  subset mathbbR ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"is an increasing sequence of time points and h is the discrete time step, the discrete equivalent of the space of curves from q_0 to q_N,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ ( q_0 q_N 0 T ) = big q  0 T rightarrow mfM  bigvert  q(0) = q_0  q(T) = q_N big subset mathcalQ ( mfM ) ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"is the space that contains all discrete trajectories with fixed endpoints q_0 and q_N, defined as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalQ_d ( q_0 q_N  t_n _n=0^N ) = big q_d   t_n _n=0^N rightarrow mfM  bigvert  q(t_0) = q_0 q(t_N) = q_N big subset mathcalQ_d ( mfM ) ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete trajectory can be written as q_d =  q_n _n=0^N, where q_n denotes the generalised coordinates at time t_n. The space mathcalQ_d ( q_0 q_N  t_n _n=0^N ) is a finite-dimensional approximation of mathcalQ ( q_0 q_N 0 T ). In the following, we will use piecewise linear Lagrange polynomials to approximate the trajectory q(t), that is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-linear-interpolation\nq_h (t) bigvert_t_n t_n+1 = q_n dfract_n+1 - tt_n+1 - t_n + q_n+1 dfract - t_nt_n+1 - t_n \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The next step is to choose a quadrature rule which determines the discrete action. While the continuous action is a map","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalA  mathcalQ ( q_0 q_N 0 T ) rightarrow mathbbR ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"assigning real values to each path q(t), the discrete action is a map","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalA_d  mathcalQ_d ( q_0 q_N  t_n _n=0^N ) rightarrow mathbbR ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"assigning real values to each discrete path q_d. Once we obtained the discrete action, everything else follows in a straight forward and systematic way from Hamilton's principle of stationary action, so that these choices are determining the form of the discrete equations of motion.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"After we fix the sequence  t_n _n=0^N, the continuous action can be written as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathcalA q(t) = sum_n=0^N-1 int_t_n^t_n+1 L (q dotq)  dt ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The terms of the sum are called the \\emph{exact discrete Lagrangian},","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"L_d^mathrme (q_n q_n+1) = int_t_n^t_n+1 L big( q_nn+1 (t)  dotq_nn+1 (t) big)  dt ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which is defined as a function of two consecutive points on the discrete trajectory q_d =  q_n _n=0^N. Here, q_nn+1 (t) denotes the solution of the continuous Euler-Lagrange equations in the interval t_n t_n+1  satisfying the boundary conditions q_nn+1 (t_n) = q_n and q_nn+1 (t_n+1) = q_n+1, with q_n denoting the generalised coordinates at time t_n and dotq_n the generalised velocities at time point t_n. In practice, the exact discrete Lagrangian cannot be computed exactly, which means we have to approximate it,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"L_d (q_n q_n+1) approx int_t_n^t_n+1 L big( q_nn+1 (t)  dotq_nn+1 (t) big)  dt ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"That is, we have to approximate the trajectory q(t), the velocity dotq(t) and the integral. This approximation leads to the discrete Lagrangian, given as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-quadrature\nL_d (q_n q_n+1) = h sum limits_i=1^s b_i  L big( q_h (t_n + c_i h)  dotq_h (t_n + c_i h) big) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"where q_n = q_h (t_n) and q_n+1 = q_h (t_n+1). The discrete action thus becomes merely a sum over the time index of discrete Lagrangians","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-action\nmathcalA_d q_d = sum limits_n=0^N-1 L_d (q_n q_n+1) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which defines a map mathcalA_d  mathcalQ_d ( q_0 q_N  t_n _n=0^N ) rightarrow mathbbR. In order to obtain the discrete Lagrangian, the generalised velocities are often discretised by simple finite-difference expressions\\footnote{ In the first term of the trapezoidal rule \\eqref{eq:vi-trapezoidal}, this corresponds to a forward finite-difference, in the second term to a backward finite-difference, and in the midpoint rule \\eqref{eq:vi-midpoint} to a centred finite-difference. }, i.e.,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"dotq (t) approx dfracq_n+1 - q_nh\nhspace3em textfor hspace3em\nt in  t_n  t_n+1   ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"This corresponds to approximating the trajectory q(t) between t_n and t_n+1 by linear interpolation between q_n and q_n+1 like in \\eqref{eq:vi-linear-interpolation} and taking the derivative of q_h (t) with respect to t. The quadrature is most often realised by either the trapezoidal rule (c_1 = 0, c_2 = 1),","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-trapezoidal\nL_d^texttr (q_n q_n+1) = dfrach2  L bigg( q_n dfracq_n+1 - q_nh bigg) + dfrach2  L bigg( q_n+1 dfracq_n+1 - q_nh bigg) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"or the midpoint rule (c_1 = 12),","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-midpoint\nL_d^textmp (q_n q_n+1) = h  L bigg( dfracq_n + q_n+12 dfracq_n+1 - q_nh bigg) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The configuration manifold of the discrete theory is still mfM, but the discrete state space is mfM times mfM instead of tbmfM, such that the discrete Lagrangian L_d is a function","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-discrete_lagrangian\nL_d  mfM times mfM rightarrow mathbbR \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mapping two points on the discrete trajectory into the real numbers.","category":"page"},{"location":"integrators/variational/#Discrete-Euler-Lagrange-Equations","page":"Variational","title":"Discrete Euler-Lagrange Equations","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"(Image: Variations of the discrete trajectory)","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete trajectories q_d =  q_n _n=0^N are required to satisfy a discrete version of Hamilton's principle of stationary action","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"delta mathcalA_d q_d = delta sum limits_n=0^N-1 L_d (q_n q_n+1) = 0 ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"As each point q_n of the discrete trajectory takes continuous values, we consider variations as as one-parameter families of transformations, that is families of paths q_d^epsilon =  q_n^epsilon _n=0^N in mathcalQ_d ( q_0 q_N  t_n _n=0^N ) which contain the solution path q_d for epsilon=0. The variations of q_d are contained in the tangent space tbq_dmathcalQ_d ( q_0 q_N  t_n _n=0^N ) to mathcalQ_d ( q_0 q_N  t_n _n=0^N ) at q_d. It is defined as the set of maps","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\nv_q_d   t_n _n=0^N rightarrow tbmfM \n textsuch that \npi_mfM circ v_q_d = q_d \n textand \nv (t_0) = v (t_N) = 0 \nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"where pi_mfM is the canonical projection pi_mfM  tbmfM rightarrow mfM and local coordinates are given by","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"v_q_d =  (q_n v_n) _n=0^N ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"In particular, a discrete variation v_q_d of the discrete path q_d is defined as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"v_q_d = dfracddepsilon q_d^epsilon biggvert_epsilon=0 ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"By identifying delta equiv d  depsilon bigvert_epsilon=0, we can also denote the variation by v_q_d = delta q_d. In analogy to the continuous setting, the variation of the discrete action can be written as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"delta mathcalA_d q_d = \ndfracddepsilon mathcalA_d q_d^epsilon biggvert_epsilon=0\n= ext mathcalA_d q_d cdot v_q_d ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which explicitly computed becomes","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-variation_01\next mathcalA_d q_d cdot v_q_d = sum limits_n=0^N-1 big D_1  L_d (q_n q_n+1) cdot v_n + D_2  L_d (q_n q_n+1) cdot v_n+1 big \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"where D_i denotes the derivative with respect to to the ith argument (slot derivative). What follows corresponds to a discrete integration by parts, i.e., a reordering of the summation. The n=0 term is separated from the first part of the sum and the n=N-1 term is separated from the second part","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-variation_02\nbeginaligned\next mathcalA_d q_d cdot v_q_d\nnonumber\n = D_1  L_d (q_0 q_1) cdot v_0\n+ sum limits_n=1^N-1 D_1  L_d (q_n q_n+1) cdot v_n \n+ sum limits_n=0^N-2 D_2  L_d (q_n q_n+1) cdot v_n+1\n + D_2  L_d (q_N-1 q_N) cdot v_N\n\nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"As the variations at the endpoints are kept fixed, v_0 = v (t_0) = 0 as well as v_N = v (t_N) = 0, the corresponding terms vanish. At last, the summation range of the second sum is shifted upwards by one with the arguments of the discrete Lagrangian adapted correspondingly","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-variation_03\next mathcalA_d q_d cdot v_q_d\n=  sum limits_n=1^N-1 big D_1  L_d (q_n q_n+1) + D_2  L_d (q_n-1 q_n) big cdot v_n\n\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Hamilton's principle of least action requires the variation of the discrete action delta mathcalA_d to vanish for any choice of v_n. Consequently, the expression in the square brackets has to vanish. This defines the discrete Euler-Lagrange equations","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-deleqs\nD_1  L_d (q_n q_n+1) + D_2  L_d (q_n-1 q_n) = 0\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete Euler-Lagrange equations define an evolution map","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-evolution_map\nvarphi_h\n   mfM times mfM rightarrow mfM times mfM\n   ( q_n-1 q_n ) mapsto ( q_n q_n+1 ) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Starting from two configurations, q_0 approx q (t_0) and q_1 approx q (t_1 = t_0 + h), the successive solution of the discrete Euler-Lagrange equations for q_2, q_3, etc., up to q_N, determines the discrete trajectory  q_n _n=0^N.","category":"page"},{"location":"integrators/variational/#Discrete-Fibre-Derivative","page":"Variational","title":"Discrete Fibre Derivative","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Quite often it is more practical to prescribe an initial position and momentum instead of the configuration of the first two time steps. We therefore want to define the discrete momentum p_n at time step n. In the continuous setting this was done with the help of the fibre derivative. However, in the discrete setting, we have two ways to define discrete fibre derivatives,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathbbF^- L_d   mathbbF^+ L_d  mfM times mfM rightarrow cbmfM ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which map the discrete state space mfM times mfM to the tangent bundle cbmfM. They are given by","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\nmathbbF^- L_d  (q_n q_n+1) mapsto (q_n   p_n)   = big( q_n   - D_1 L_d (q_n q_n+1) big)  \nmathbbF^+ L_d  (q_n q_n+1) mapsto (q_n+1 p_n+1) = big( q_n+1   D_2 L_d (q_n q_n+1) big) \nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete Euler-Lagrange equations can now be rewritten as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"mathbbF^+ L_d (q_n-1 q_n) = mathbbF^- L_d (q_n q_n+1) ","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"that is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-momentum\np_n = D_2 L_d (q_n-1 q_n) = - D_1 L_d (q_n q_n+1) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"TODO: Add composition maps of fibre derivatives and Lagrangian evolution map corresponding to the Hamiltonian evolution map.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Thus the discrete fibre derivatives permit a new interpretation of the discrete Euler–Lagrange equations. The variational integrator can be rewritten in position-momentum form,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-position-momentum\nbeginaligned\np_n   =           -  D_1 L_d (q_n q_n+1)  \np_n+1 = hphantom- D_2 L_d (q_n q_n+1) \nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Given (q_n p_n), the first equation can be solved for q_n+1. This is generally a nonlinearly implicit equation that has to be solved by some iterative technique like Newton's method. The second equation is an explicit function, so to obtain p_n+1 we merely have to plug in q_n and q_n+1. The corresponding Hamiltonian evolution map is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-evolution_map_position_momentum\ntildevarphi_h\n   cbmfM rightarrow cbmfM\n   ( q_n p_n ) mapsto ( q_n+1 p_n+1 ) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Thus, starting with an initial position q_0 and an initial momentum p_0, the repeated solution of tildevarphi_h gives the same discrete trajectory  q_n _n=0^N as the repeated solution of varphi_h. The position-momentum form, as a one-step method, is usually easier to implement than the discrete Euler-Lagrange equations. And for most problems, initial conditions are more naturally prescribed via the position and momentum of the particle at a given point in time, (q_0 p_0). If, however, only the position of the particle at two points in time, (q_0 q_1), is known, the Euler-Lagrange equations are the more natural way of describing the dynamics.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"This of course is just reflecting the difference in the Lagrangian and Hamiltonian point of view. For d degrees of freedom, the variational principle leads to d differential equations of second order. Hamilton's equations, on the other hand, are 2d differential equations of first order. Which form is more convenient to use largely depends on the problem at hand.","category":"page"},{"location":"integrators/variational/#Example:-Point-Particle","page":"Variational","title":"Example: Point Particle","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Consider a particle with mass m, moving in some potential V. Its continuous Lagrangian is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1_lagrangian\nL (q dotq) = dfrac12  m dotq^2 - V(q)\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Approximated by the trapezoidal rule, the discrete Lagrangian reads","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1-lagrangian-trapezoidal\nL_d^texttr (q_n q_n+1) = h  bigg dfracm2 bigg( dfracq_n+1 - q_nh bigg)^2 - dfracV (q_n) + V (q_n+1)2 bigg \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Applying the discrete Euler-Lagrange equations \\eqref{eq:vi-deleqs} to this expression results in discrete equations of motion","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1_deleqs_trapezoidal\nm  dfracq_n+1 - 2  q_n + q_n-1h^2 = - nabla V (q_n)\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which clearly are a discrete version of Newton's second law","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1-newton\nm ddotq = - nabla V = F \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"For comparison, consider also the midpoint approximation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1-lagrangian-midpoint\nL_d^textmp (q_n q_n+1) = h  bigg dfracm2  bigg( dfracq_n+1 - q_nh bigg)^2 - V bigg( dfracq_n + q_n+12 bigg) bigg\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"which leads to","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-example1_deleqs_midpoint\nm  dfracq_n+1 - 2  q_n + q_n-1h^2 = - dfrac12  bigg nabla V bigg( dfracq_n-1 + q_n2 bigg) + nabla V bigg( dfracq_n + q_n+12 bigg) bigg\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"and thus a different discretisation of \\eqref{eq:vi-example1-newton}. The position-momentum form \\eqref{eq:vi-position-momentum} of the trapezoidal Lagrangian \\eqref{eq:vi-example1-lagrangian-trapezoidal} can be written as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\ndfracq_n+1 - q_nh =  dfrac1m  bigg p_n - dfrach2  nabla V (q_n) bigg \ndfracp_n+1 - p_nh = -  dfrac12  bigg nabla V (q_n) + nabla V (q_n+1) bigg\nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"and the one of the midpoint Lagrangian \\eqref{eq:vi-example1-lagrangian-midpoint} reads","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\ndfracq_n+1 - q_nh = dfrac1m  bigg p_n - dfrach2  nabla V bigg( dfracq_n + q_n+12 bigg) bigg \ndfracp_n+1 - p_nh = - nabla V bigg( dfracq_n + q_n+12 bigg) \nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"This bears a close resemblance of Hamilton's equations of motion, where the additional term in the first equations can be interpreted as extrapolating the momentum p_n to t_n+12. As already noted, it is not always so easy to solve the first equation in \\eqref{eq:vi-position-momentum} for q_n+1. In general this is an implicit equation.","category":"page"},{"location":"integrators/variational/#Discrete-Symplectic-Form","page":"Variational","title":"Discrete Symplectic Form","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"As in the continuous case, the discrete one-form is obtained by computing the variation of the action for varying endpoints","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\next mathcalA_d q_d cdot v_d\nnonumber\n= sum limits_n=0^N-1 big D_1  L_d (q_n q_n+1) cdot v_n + D_2  L_d (q_n q_n+1) cdot v_n+1 big \nnonumber\n= sum limits_n=1^N-1 big D_1  L_d (q_n q_n+1) + D_2  L_d (q_n-1 q_n) big cdot v_n \nhspace3em\n+ D_1  L_d (q_0 q_1) cdot v_0 + D_2  L_d (q_N-1 q_N) cdot v_N \nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The two latter terms originate from the variation at the boundaries. They form the discrete counterpart of the Lagrangian one-form. However, there are two boundary terms that define two distinct one-forms on mfM times mfM,","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginaligned\nbeginarrayll\nTheta_L_d^- ( q_0   q_1 ) cdot ( v_0    v_1 ) equiv           -  D_1 L_d (q_0   q_1) cdot v_0  \nTheta_L_d^+ ( q_N-1 q_N ) cdot ( v_N-1  v_N ) equiv hphantom- D_2 L_d (q_N-1 q_N) cdot v_N \nendarray\nendaligned","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"In general, these one-forms are defined as","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-discrete-one-form\nbeginaligned\nTheta_L_d^- ( q_n  q_n+1 ) equiv           -  D_1 L_d (q_n q_n+1)  ext q_n  \nTheta_L_d^+ ( q_n  q_n+1 ) equiv hphantom- D_2 L_d (q_n q_n+1)  ext q_n+1 \nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"As ext L_d = Theta_L_d^+ - Theta_L_d^- and ext^2 L_d = 0 one observes that","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"ext Theta_L_d^+ = ext Theta_L_d^-","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"such that the exterior derivative of both discrete one-forms defines the same \\emph{discrete Lagrangian two-form} or \\emph{discrete symplectic form}","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-discrete_two_form\nbeginaligned\nomega_L_d\n= ext Theta_L_d^+\n = ext Theta_L_d^-\n = dfracpartial^2 L_d (q_n q_n+1)partial q_n   partial q_n+1  ext q_n wedge ext q_n+1 \n text(no summation over n) \nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Consider the exterior derivative of the discrete action \\eqref{eq:vi-action}. Upon insertion of the discrete Euler-Lagrange equations \\eqref{eq:vi-deleqs} it becomes","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-symplectic-ext-action\next mathcalA_d\n= D_1 L_d (q_0 q_1) cdot ext q_0 + D_2 L_d (q_N-1 q_N) cdot ext q_N\n= Theta_L_d^+ (q_N-1 q_N) - Theta_L_d^- (q_0 q_1) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"On the right hand side we find the just defined Lagrangian one-forms \\eqref{eq:vi-discrete-one-form}. Taking the exterior derivative of \\eqref{eq:vi-symplectic-ext-action} gives","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-symplectic-preservation\nomega_L_d (q_0 q_1) = omega_L_d (q_N-1 q_N) \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"where q_N-1 and q_N are connected with q_0 and q_1 through the discrete Euler-Lagrange equations \\eqref{eq:vi-deleqs}. Therefore, \\eqref{eq:vi-symplectic-preservation} implies that the discrete symplectic structure omega_L_d is preserved while the system advances from t=0 to t=Nh according to the discrete equations of motion \\eqref{eq:vi-deleqs}. As the number of time steps N is arbitrary, the discrete symplectic form omega_L_d is preserved at all times of the simulation. Note that this does not automatically imply that the continuous symplectic structure omega_L is preserved under the discrete map varphi_h.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"TODO: show preservation of the canonical symplectic form by the position-momentum-form","category":"page"},{"location":"integrators/variational/#Discrete-Noether-Theorem","page":"Variational","title":"Discrete Noether Theorem","text":"","category":"section"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The discrete Noether theorem, just as the continuous Noether theorem, draws the connection between symmetries of a discrete Lagrangian and quantities that are conserved by the discrete Euler-Lagrange equations or, equivalently, the discrete Lagrangian flow. The continuous theory translates straight forwardly to the discrete case. Therefore, we repeat just the important steps, translated to the discrete setting.","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"Consider a one parameter group of discrete curves q_d^epsilon =  q_n^epsilon _n=0^N with q_n^epsilon = sigma^epsilon (t_n q_n epsilon) such that q_n^0 (q_n) = q_n, i.e., sigma^0 = id (note that sigma^epsilon is the same function as in the continuous case). The discrete Lagrangian L_d has a symmetry if it is invariant under this transformation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_1\nbeginaligned\nL_d big( q_n^epsilon q_n+1^epsilon big) = L_d big( q_n q_n+1 big) \n textfor all epsilon and n \nendaligned\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"The generating vector field of such a symmetry transformation is","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_2\nX_n = dfracpartial sigma^epsilonpartial epsilon biggvert_epsilon = 0\nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"such that","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi-noether-finite-3\ndfracdd epsilon L_d big( q_n^epsilon q_n+1^epsilon big) biggvert_epsilon = 0\n = D_1 L_d big( q_n q_n+1 big) cdot X_n  \n + D_2 L_d big( q_n q_n+1 big) cdot X_n+1 \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"If  q_n _n=0^N solves the discrete Euler-Lagrange equations \\eqref{eq:vi-deleqs},","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_4\nD_1  L_d (q_n q_n+1) + D_2  L_d (q_n-1 q_n) = 0 \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"we can replace the first term on the right hand side of \\eqref{eq:vi-noether-finite-3} to get","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_5\n0 = - D_2 L_d big( q_n-1 q_n big) cdot X_n\n    + D_2 L_d big( q_n q_n+1 big) cdot X_n+1 \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"This amounts to a discrete conservation law of the form","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"beginequationlabeleqvi_noether_finite_6\nD_2 L_d big( q_n-1 q_n big) cdot X_n = D_2 L_d big( q_n q_n+1 big) cdot X_n+1 \nendequation","category":"page"},{"location":"integrators/variational/","page":"Variational","title":"Variational","text":"It states that solutions  q_n _n=0^N of the discrete Euler-Lagrange equations preserve the components of the momentum p_n = D_2 L_d big( q_n-1 q_n big) in direction X_n.","category":"page"},{"location":"modules/spark/#SPARK","page":"SPARK Methods","title":"SPARK","text":"","category":"section"},{"location":"modules/spark/","page":"SPARK Methods","title":"SPARK Methods","text":"Modules = [GeometricIntegrators.SPARK]\nOrder   = [:constant, :type, :macro, :function]","category":"page"},{"location":"modules/spark/#GeometricIntegrators.SPARK.AbstractTableauSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.AbstractTableauSPARK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.CoefficientsARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.CoefficientsARK","text":"Holds the coefficients of an additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.CoefficientsIRK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.CoefficientsIRK","text":"Holds the coefficients of an additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.CoefficientsMRK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.CoefficientsMRK","text":"Holds the multiplier Runge-Kutta coefficients.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.CoefficientsPRK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.CoefficientsPRK","text":"Holds the coefficients of a projective Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.CoefficientsSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.CoefficientsSPARK","text":"Holds the coefficients of a SPARK method.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorCacheSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorCacheSPARK","text":"Cache of a Specialised Partitioned Additive Runge-Kutta integrator.\n\nFields\n\nn: time step number\nt: time of current time step\nt̄: time of previous time step\nq: current solution of q\nq̄: previous solution of q\np: current solution of p\np̄: previous solution of p\nv: vector field of q\nv̄: vector field of q̄\nf: vector field of p\nf̄: vector field of p̄\nq̃: initial guess of q\np̃: initial guess of p\nṽ: initial guess of v\nf̃: initial guess of f\ns̃: holds shift due to periodicity of solution\nQ: internal stages of q\nP: internal stages of p\nV: internal stages of v\nF: internal stages of f\nY: vector field of internal stages of q\nZ: vector field of internal stages of p\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorHPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorHPARK","text":"Partitioned Additive Runge-Kutta integrator for Hamiltonian systems subject to Dirac constraints EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \ntildePhi_ni = 0   i = 1  r \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorHSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorHSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorHSPARKprimary","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorHSPARKprimary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorHSPARKsecondary","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorHSPARKsecondary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Hamiltonian systems subject to Dirac constraints with projection on secondary constraint EXPERIMENTAL.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nV_ni = hphantom- fracpartial Hpartial p (Q_ni P_ni)   i = 1  s  \nF_ni =           -  fracpartial Hpartial q (Q_ni P_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorSLRK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorSLRK","text":"Specialised Partitioned Additive Runge-Kutta integrator for degenerate variational systems with projection on secondary constraint.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a^1_ij V_nj + h sum limits_j=1^sigma a^2_ij tildeLambda_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s bara^1_ij F^1_nj + h sum limits_j=1^s bara^2_ij F^2_nj + h sum limits_j=1^sigma bara^3_ij tildeF^3_nj   i = 1  s  \n0 = Phi_ni   i = 1  s \nendaligned\n\nthe projective stages\n\nbeginaligned\ntildeQ_ni = q_n + h sum limits_j=1^s alpha^1_ij tildeV_nj + h sum limits_j=1^sigma alpha^2_ij tildeLambda_nj   i = 1  sigma  \ntildeP_ni = p_n + h sum limits_j=1^s baralpha^1_ij F^1_nj + h sum limits_j=1^s baralpha^2_ij tildeF^2_nj + h sum limits_j=1^sigma baralpha^3_ij tildeF^3_nj   i = 1  sigma  \n0 = tildePhi_ni   i = 1  sigma  \n0 = sum limits_j=1^sigma omega_ij tildePsi_ni   i = 1  sigma-1 \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b^1_i V_ni + h sum limits_i=1^sigma b^2_i tildeLambda_ni  \np_n+1 = p_n + h sum limits_i=1^s b^1_i F^1_ni + h sum limits_i=1^s b^2_i F^2_ni + h sum limits_i=1^sigma b^3_i tildeF^3_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nwith definitions\n\nbeginaligned\nF^1_ni = nabla H (Q_ni)   i = 1  s  \nF^2_ni = nabla vartheta (Q_ni) cdot V_ni   i = 1  s  \ntildeF^3_ni = nabla phi (tildeQ_ni tildeP_ni) cdot tildeLambda_ni   i = 1  sigma  \nPhi_ni = phi (Q_ni P_ni) = P_ni - vartheta (Q_ni)   i = 1  s  \ntildePhi_ni = phi (tildeQ_ni tildeP_ni) = tildeP_ni - vartheta (tildeQ_ni)   i = 1  sigma  \ntildePsi_ni = psi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla vartheta (tildeQ_ni)   i = 1  sigma \nendaligned\n\nso that\n\nbeginaligned\nF^1_ni + F^2_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nphi (Q_ni P_ni) = P_ni - fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \npsi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla fracpartial Lpartial v (tildeQ_ni tildeV_ni)   i = 1  sigma \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for index-two DAE systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorVPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorVPARK","text":"Variational partitioned additive Runge-Kutta integrator.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \ntildePhi_ni = 0   i = 1  r \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorVSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorVSPARK","text":"Specialised Partitioned Additive Runge-Kutta integrator for Variational systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1 \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorVSPARKprimary","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorVSPARKprimary","text":"Specialised Partitioned Additive Runge-Kutta integrator for Variational systems.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a_ij V_nj + h sum limits_j=1^r alpha_ij U_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s a_ij F_nj + h sum limits_j=1^r alpha_ij G_nj   i = 1  s  \ntildeQ_ni = q_n + h sum limits_j=1^s tildea_ij V_nj + h sum limits_j=1^r tildealpha_ij U_nj   i = 1  r  \ntildeP_ni = p_n + h sum limits_j=1^s tildea_ij F_nj + h sum limits_j=1^r tildealpha_ij G_nj   i = 1  r  \n0 = sum limits_j=1^r omega_ij tildePhi_nj   i = 1  r-1  \n0 = sum limits_i=1^r tilded_i  Lambda_ni \nendaligned\n\nwith definitions\n\nbeginaligned\nP_ni = fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \nF_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nU_ni = hphantom- fracpartial phipartial p (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \nG_ni =           -  fracpartial phipartial q (tildeQ_ni tildeP_ni)^T Lambda_ni   i = 1  r  \ntildePhi_ni = phi(tildeQ_ni tildeP_ni)   i = 1  r \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b_i V_ni + h sum limits_i=1^r beta_i U_ni  \np_n+1 = p_n + h sum limits_i=1^s b_i F_ni + h sum limits_i=1^r beta_i G_ni \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.IntegratorVSPARKsecondary","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.IntegratorVSPARKsecondary","text":"Specialised Partitioned Additive Runge-Kutta integrator for degenerate variational systems with projection on secondary constraint.\n\nThis integrator solves the following system of equations for the internal stages,\n\nbeginaligned\nQ_ni = q_n + h sum limits_j=1^s a^1_ij V_nj + h sum limits_j=1^sigma a^2_ij tildeLambda_nj   i = 1  s  \nP_ni = p_n + h sum limits_j=1^s bara^1_ij F^1_nj + h sum limits_j=1^s bara^2_ij F^2_nj + h sum limits_j=1^sigma bara^3_ij tildeF^3_nj   i = 1  s  \n0 = Phi_ni   i = 1  s \nendaligned\n\nthe projective stages\n\nbeginaligned\ntildeQ_ni = q_n + h sum limits_j=1^s alpha^1_ij tildeV_nj + h sum limits_j=1^sigma alpha^2_ij tildeLambda_nj   i = 1  sigma  \ntildeP_ni = p_n + h sum limits_j=1^s baralpha^1_ij F^1_nj + h sum limits_j=1^s baralpha^2_ij tildeF^2_nj + h sum limits_j=1^sigma baralpha^3_ij tildeF^3_nj   i = 1  sigma  \n0 = tildePhi_ni   i = 1  sigma  \n0 = sum limits_j=1^sigma omega_ij tildePsi_ni   i = 1  sigma-1 \nendaligned\n\nand update rule\n\nbeginaligned\nq_n+1 = q_n + h sum limits_i=1^s b^1_i V_ni + h sum limits_i=1^sigma b^2_i tildeLambda_ni  \np_n+1 = p_n + h sum limits_i=1^s b^1_i F^1_ni + h sum limits_i=1^s b^2_i F^2_ni + h sum limits_i=1^sigma b^3_i tildeF^3_ni  \n0 = phi (q_n+1 p_n+1) \nendaligned\n\nwith definitions\n\nbeginaligned\nF^1_ni = nabla H (Q_ni)   i = 1  s  \nF^2_ni = nabla vartheta (Q_ni) cdot V_ni   i = 1  s  \ntildeF^3_ni = nabla phi (tildeQ_ni tildeP_ni) cdot tildeLambda_ni   i = 1  sigma  \nPhi_ni = phi (Q_ni P_ni) = P_ni - vartheta (Q_ni)   i = 1  s  \ntildePhi_ni = phi (tildeQ_ni tildeP_ni) = tildeP_ni - vartheta (tildeQ_ni)   i = 1  sigma  \ntildePsi_ni = psi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla vartheta (tildeQ_ni)   i = 1  sigma \nendaligned\n\nso that\n\nbeginaligned\nF^1_ni + F^2_ni = fracpartial Lpartial q (Q_ni V_ni)   i = 1  s  \nphi (Q_ni P_ni) = P_ni - fracpartial Lpartial v (Q_ni V_ni)   i = 1  s  \npsi (tildeQ_ni tildeV_ni tildeP_ni tildeF_ni) = tildeF_ni - tildeV_ni cdot nabla fracpartial Lpartial v (tildeQ_ni tildeV_ni)   i = 1  sigma \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SLRK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SLRK","text":"Holds all parameters of an Specialised Partitioned Additive Runge-Kutta method for variational systems subject to constraints.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHPARK","text":"Holds the tableau of a Hamiltonian Partitioned Additive Runge-Kutta methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauSPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauSPARK","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVPARK","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVPARK","text":"Holds the tableau of an Variational Partitioned Additive Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#GeometricIntegrators.SPARK.VSPARKsecondary","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.VSPARKsecondary","text":"Holds the tableau of an Specialised Partitioned Additive Runge-Kutta method for Variational systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/spark/#Base.show-Tuple{IO, GeometricIntegrators.SPARK.CoefficientsARK}","page":"SPARK Methods","title":"Base.show","text":"Print additive Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#Base.show-Tuple{IO, GeometricIntegrators.SPARK.CoefficientsIRK}","page":"SPARK Methods","title":"Base.show","text":"Print additive Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#Base.show-Tuple{IO, GeometricIntegrators.SPARK.CoefficientsMRK}","page":"SPARK Methods","title":"Base.show","text":"Print multiplier Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#Base.show-Tuple{IO, GeometricIntegrators.SPARK.CoefficientsPRK}","page":"SPARK Methods","title":"Base.show","text":"Print projective Runge-Kutta coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#Base.show-Tuple{IO, GeometricIntegrators.SPARK.CoefficientsSPARK}","page":"SPARK Methods","title":"Base.show","text":"Print SPARK coefficients.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.Integrators.residual!-Union{Tuple{ST}, Tuple{Vector{ST}, Vector{ST}, SolutionStepPDAE, Union{IDAEProblem{dType} where dType<:Number, LDAEProblem{dType} where dType<:Number}, GeometricIntegrators.SPARK.SPARKMethod, GeometricIntegrators.Integrators.CacheDict}} where ST","page":"SPARK Methods","title":"GeometricIntegrators.Integrators.residual!","text":"Compute stages of specialised partitioned additive Runge-Kutta methods for variational systems.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKGLRK-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKGLRK","text":"SPARK tableau for Gauss-Legendre Runge-Kutta method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKGLRKLobattoIIIAIIIB","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKGLRKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Legendre/Gauss-Lobatto-IIIA-IIIB methods.\n\n\n\n\n\n","category":"function"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKGLRKLobattoIIIBIIIA","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKGLRKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Legendre/Gauss-Lobatto-IIIB-IIIA methods.\n\n\n\n\n\n","category":"function"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKGLVPRK-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKGLVPRK","text":"Tableau for Variational Gauss-Legendre method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKLobABC-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKLobABC","text":"Tableau for Gauss-Lobatto IIIA-IIIB-IIIC method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKLobABD-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKLobABD","text":"Tableau for Gauss-Lobatto IIIA-IIIB-IIID method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKLobatto-Tuple{Any, Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKLobatto","text":"SPARK tableau for Gauss-Lobatto methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Lobatto IIIA-IIIB method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Lobatto IIIB-IIIA method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.SPARKVPRK-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.SPARKVPRK","text":"SPARK Tableau for Variational Partitioned Runge-Kutta Methods.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauGausspSymplectic-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauGausspSymplectic","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHPARKGLRK-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHPARKGLRK","text":"Tableau for Gauss-Legendre HPARK method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHPARKLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHPARKLobattoIIIAIIIB","text":"SPARK tableau for Gauss-Lobatto IIIA-IIIB HPARK method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHPARKLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHPARKLobattoIIIBIIIA","text":"SPARK tableau for Gauss-Lobatto IIIB-IIIA  method with s stages.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHSPARKGLRKpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHSPARKGLRKpSymmetric","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHSPARKLobattoIIIAIIIBpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHSPARKLobattoIIIAIIIBpSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauHSPARKLobattoIIIBIIIApSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauHSPARKLobattoIIIBIIIApSymmetric","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauLobattoIIIAIIIBpSymplectic-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauLobattoIIIAIIIBpSymplectic","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauLobattoIIIBIIIApSymplectic-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauLobattoIIIBIIIApSymplectic","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpInternal-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpInternal","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpLobattoIIIAIIIB","text":"Tableau for Gauss-Legendre method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpLobattoIIIBIIIA","text":"Tableau for Gauss-Legendre method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpMidpoint","text":"Tableau for Gauss-Legendre method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedInternal-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedInternal","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpModifiedMidpoint","text":"Tableau for Gauss-Legendre method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKGLRKpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKGLRKpSymmetric","text":"Tableau for Gauss-Legendre method with s stages and symplectic projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKInternalProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKInternalProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. Use the same tableaus for tildea^1 and tildea^3, so that tildes = s, as well as\n\nbeginaligned\nbeginarrayccc\n tfrac12 b^1 \n vdots \n tfrac12 b^1 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \n vdots \n tfrac12 b^3 \nhline\na^4  \nendarray\n\nbeginarrayccc\n tfrac12 b^1 \nc^1  vdots \n tfrac12 b^1 \nhline\ntildea^2  tfrac12 (1 + R(infty))  b^1 \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \nc^3  vdots \n tfrac12 b^3 \nhline\ntildea^4  tfrac12 (1 + R(infty))  b^3 \nendarray\nendaligned\n\nSet omega = 0  0 1 and\n\ndelta_ij = begincases\n+1  j = i  \n-1  j = tildes  \n 0  textelse \nendcases\n\nso that Lambda_1 = Lambda_2 =  = Lambda_tildes.\n\nThis methods is constructed to satisfy the constraint on the projective stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes. Note, however, that it violates the symplecticity conditions b^1_i b^4_j = b^1_i a^4_ij + b^4_j tildea^1_ji and b^2_i b^3_j = b^2_i tildea^3_ij + b^3_j a^2_ji.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^4 b^4) and (tildea^2 b^2), respectively, and choose tildea^1 and tildea^3 such that the projective stages correspond to the initial condition and the solution, i.e.,\n\nbeginaligned\nbeginarrayccc\n0  0 \n1  b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\n0  tfrac12  0 \n1  tfrac12  0 \nhline\ntildea^2  \nendarray\n\nbeginarrayccc\n0  0 \n1  b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\n0  0  0 \n1  tfrac12  tfrac12 \nhline\ntildea^4  \nendarray\nendaligned\n\nand compute a^2 and a^4 by the symplecticity conditions, that is a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i and a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i. Finally choose omega = 0 0 1 and delta = -1 R_infty, implying that rho = 1. By construction, this method satisfies all symplecticity conditions, but the constraint on the projection stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, is not satisfied exactly, but only approximately, although with bounded error.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpMidpoint","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpModifiedMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpModifiedMidpoint","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIAIIIBpSymmetric","text":"Tableau for Gauss-Lobatto IIIA-IIIB method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIAProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIAProjection","text":"This methods is the same as TableauVSPARKLobattoIIIAIIIBProjection, except for using Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^2 b^2), and (tildea^4 b^4) respectively, instead of the other way around.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApMidpoint","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIAIIIB-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIAIIIB","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIA-IIIB projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIBIIIA-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApModifiedLobattoIIIBIIIA","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and Lobatto-IIIB-IIIA projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApModifiedMidpoint-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApModifiedMidpoint","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and midpoint projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApSymmetric-Tuple{Any}","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKLobattoIIIBIIIApSymmetric","text":"Tableau for Gauss-Lobatto IIIB-IIIA method with s stages and symmetric projection.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKMidpointProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKMidpointProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 1 and rho = 0, such that tildeQ_n1 = tfrac12 ( q_n + q_n+1), tildeP_n1 = tfrac12 ( p_n + p_n+1), i.e.,\n\nbeginaligned\nbeginarrayccc\n tfrac12 \n vdots \n tfrac12 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 \n vdots \n tfrac12 \nhline\na^4  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^2  tfrac12 (1 + R(infty))\nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^4  tfrac12 (1 + R(infty))\nendarray\nendaligned\n\nThe coefficients tildea^1 and tildea^3 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i, and omega = 0 1.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKModifiedInternalProjection","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKModifiedInternalProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s, and set\n\nbeginaligned\nbeginarrayccc\n tfrac12 b^1 \n vdots \n tfrac12 b^1 \nhline\na^2  \nendarray\n\nbeginarrayccc\n tfrac12 b^4 \n vdots \n tfrac12 b^4 \nhline\na^4  \nendarray\n\nbeginarrayccc\n tfrac12 b^1 \nc^1  vdots \n tfrac12 b^1 \nhline\ntildea^2  tfrac12 (1 + R(infty))  b^1 \nendarray\n\nbeginarrayccc\n tfrac12 b^3 \nc^3  vdots \n tfrac12 b^3 \nhline\ntildea^4  tfrac12 (1 + R(infty))  b^3 \nendarray\nendaligned\n\nNote that by this definition tildes = s. The coefficients tildea^1 and tildea^3 are determined by the (modified) symplecticity conditions, specifically a^4_ij = b^3_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^1_j ( b^3_i - tildea^3_ji )  b^3_i, where b^2 has been replaced with b^1 and b^4 with b^3, respectively. Set omega = 0  0 1 and\n\ndelta_ij = begincases\n+1  j = i  \n-1  j = tildes  \n 0  textelse \nendcases\n\nso that Lambda_1 = Lambda_2 =  = Lambda_tildes.\n\nNote that this method satisfies the symplecticity conditions b^1_i b^4_j = b^1_i a^4_ij + b^4_j tildea^1_ji and b^2_i b^3_j = b^2_i tildea^3_ij + b^3_j a^2_ji only if R(infty) = 1 due to the definitions of b^2 and b^4. Moreover, it does usually not satisfy the constraint on the projective stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, exactly, but only approximately with bounded error, thus implying a residual in the symplecticity equation even if R(infty) = 1.\n\n\n\n\n\n","category":"function"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKModifiedLobattoIIIAIIIBProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKModifiedLobattoIIIAIIIBProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^4 b^4) and (tildea^2 b^2), respectively.\n\nThe coefficients tildea^1 and tildea^3 are determined by the relations\n\nbeginaligned\nsum limits_j=1^s tildea^1_ij (c_j^1)^k-1 = frac(c_i^2)^kk  qquad \nsum limits_j=1^s tildea^3_ij (c_j^3)^k-1 = frac(c_i^4)^kk  qquad \ni = 1      tildes  qquad \nk = 1      s \nendaligned\n\nThe coefficients a^2 and a^4 by the symplecticity conditions, that is a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i and a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i. Finally choose omega = 0 0 1 and delta = -1 R_infty, implying that rho = 1. By construction, this method satisfies all symplecticity conditions, but the constraint on the projection stages, phi(tildeQ_ni tildeP_ni) = 0 for i = 1    tildes, is not satisfied exactly, but only approximately, although with bounded error.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKModifiedLobattoIIIBIIIAProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKModifiedLobattoIIIBIIIAProjection","text":"This methods is the same as TableauVSPARKModifiedLobattoIIIAIIIBProjection, except for using Lobatto-IIIA and IIIB tableaus with tildes = 2 stages for (tildea^2 b^2), and (tildea^4 b^4) respectively, instead of the other way around.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKModifiedMidpointProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKModifiedMidpointProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 1 and rho = 0, such that tildeQ_n1 = tfrac12 ( q_n + q_n+1), tildeP_n1 = tfrac12 ( p_n + p_n+1), i.e.,\n\nbeginaligned\nbeginarrayccc\ntfrac12  tfrac12 b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^2  tfrac12 ( 1 + R (infty) ) \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\ntfrac12  tfrac12 \nhline\ntildea^4  tfrac12 ( 1 + R (infty) ) \nendarray\nendaligned\n\nThe coefficients a^2 and a^4 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i, and omega = 0 1.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.TableauVSPARKSymmetricProjection-Union{Tuple{T}, Tuple{Any, Tableau{T}, Tableau{T}}, Tuple{Any, Tableau{T}, Tableau{T}, Any}} where T","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.TableauVSPARKSymmetricProjection","text":"Consider a symplectic pair of tableaus (a^1 b^1 c^1) and (a^3 b^3 c^3), i.e., satsifying b^1_i b^3_j = b^1_i a^3_ij + b^3_j a^1_ji, with an arbitrary number of stages s. For the projection, choose the tableau with tildes = 2 and rho = 1, such that tildeQ_n1 = q_n, tildeQ_n2 = q_n+1, tildeP_n1 = p_n, tildeP_n2 = p_n+1, i.e.,\n\nbeginaligned\nbeginarrayccc\n0  0 \n1  b^1 \nhline\ntildea^1  \nendarray\n\nbeginarrayccc\n 0  0 \n tfrac12  tfrac12 \nhline\ntildea^2  tfrac12  tfrac12 \nendarray\n\nbeginarrayccc\n0  0 \n1  b^3 \nhline\ntildea^3  \nendarray\n\nbeginarrayccc\n 0  0 \n tfrac12  tfrac12 \nhline\ntildea^4  tfrac12  tfrac12 \nendarray\nendaligned\n\nThe coefficients a^2 and a^4 are determined by the symplecticity conditions, specifically a^4_ij = b^4_j ( b^1_i - tildea^1_ji)  b^1_i and a^2_ij = b^2_j ( b^3_i - tildea^3_ji )  b^3_i. Further choose omega = 1 1 0 and delta = -1 R_infty, so that tildeLambda_n1 = R_infty tildeLambda_n2 and\n\ntildeP_n1 - vartheta (tildeQ_n1) + R_infty ( tildeP_n2 - vartheta (tildeQ_n2) ) = 0 \n\nDue to the particular choice of projective stages, this is equivalent to\n\np_n - vartheta (q_n) + R_infty ( p_n+1 - vartheta (q_n+1) ) = 0 \n\nso that the constraint phi(q_n+1 p_n+1) = 0 is satisfied if phi(q_n p_n) = 0. Note that the choice of tildea^2 and tildea^4 violates the symplecticity condition b^2_i b^4_j = b^2_i tildea^4_ij + b^4_j tildea^2_ji.\n\n\n\n\n\n","category":"method"},{"location":"modules/spark/#GeometricIntegrators.SPARK.lobatto_gauss_coefficients","page":"SPARK Methods","title":"GeometricIntegrators.SPARK.lobatto_gauss_coefficients","text":"The projective Lobatto-GLRK coefficients are implicitly given by\n\nsum limits_j=1^s a_ij c_j^k-1 = fracbarc_i^kk  qquad i = 1      sigma   k = 1      s \n\nwhere c are Gauß-Legendre nodes with s stages and barc are Gauß-Lobatto nodes with sigma stages.\n\n\n\n\n\n","category":"function"},{"location":"problems/#Equation-and-Problem-Types","page":"Problems","title":"Equation and Problem Types","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"In GeometricIntegrators.jl we support three basic types of equations:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"ordinary differential equations (ODEs),\ndifferential algebraic equations (DAEs),\nstochastic differential equations (SDEs).","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"For each type, there are several subtypes:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"standard equations (ODEProblem, DAEProblem, SDEProblem),\nimplicit equations (IODEProblem, IDAEProblem),\npartitioned equations (PODEProblem, PDAEProblem, PSDEProblem),\nHamiltonian equations (HODEProblem, HDAEProblem),\nLagrangian equations (LODEProblem, LDAEProblem),\nsplit equations (SODEProblem, SPDAEProblem, SPSDEProblem).","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"Each equation holds a number of functions determining the vector field, constraints, and possibly additional information like parameters, periodicity, invariants and the Hamiltonian or Lagrangian.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"To each equation type there exists a corresponding problem type, which holds the equation, initial conditions, parameters, a time span to integrate over, as well as a time step (which is typically fixed in GeometricIntegrators). In addition, these problem types provide some convenience constructors to generate the equation and the problem at once.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"All of the equation and problem types are defined in the GeometricEquations.jl package. The GeometricProblems.jl package implements a number of example problems for testing and benchmarking.","category":"page"},{"location":"problems/#Keyword-Arguments","page":"Problems","title":"Keyword Arguments","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"All equation and problem types take the following keyword arguments:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"invariants = NullInvariants()\nparameters = NullParameters()\nperiodicity = NullPeriodicity()","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"If not set to their corresponding Null types, the user needs to pass a NamedTuple whose values are","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"functions for invariants,\narbitrary data structures for parameters, \nthe same data structure as the solution for periodicity.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The latter should be zero everywhere, except for those components, that are periodic, i.e., whose value are supposed to stay within a range (0, max). Support for ranges starting with other values than zero is currently missing but can be added if demand arises.","category":"page"},{"location":"problems/#Ordinary-Differential-Equations-(ODEs)","page":"Problems","title":"Ordinary Differential Equations (ODEs)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.ode_equations)","category":"page"},{"location":"problems/#Example:-Harmonic-Oscillator","page":"Problems","title":"Example: Harmonic Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example, let us consider the harmonic oscillator. The dynamical equations are given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"dotq (t) = beginpmatrix\n0  1 \n-k  0 \nendpmatrix q(t) \nqquad\nq in mathbbR^2 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an ODEProblem for the harmonic oscillator, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction v(v, t, x, params)\n    v[1] = x[2]\n    v[2] = - params.k * x[1]\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [0.5, 0.0]\n\nprob = ODEProblem(v, tspan, tstep, q₀; parameters = (k = 0.5,))","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The energy of the harmonic oscillator is preserved, so we can add it as an invariant, ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"energy(t, q, params) = q[2]^2 / 2 + params.k * q[1]^2 / 2\n\nprob = ODEProblem(v, tspan, tstep, q₀; parameters = (k = 0.5,), invariants = (h=energy,))","category":"page"},{"location":"problems/#Partitioned-Ordinary-Differential-Equations-(PODEs)","page":"Problems","title":"Partitioned Ordinary Differential Equations (PODEs)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.pode_equations)","category":"page"},{"location":"problems/#Example:-Harmonic-Oscillator-2","page":"Problems","title":"Example: Harmonic Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example, let us consider the harmonic oscillator. The dynamical equations are given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = p (t) \ndotp (t) = - k  q(t) \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create a PODEProblem for the harmonic oscillator, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction v(v, t, q, p, params)\n    v[1] = p[1]\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = - params.k * q[1]\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [0.5]\np₀ = [0.0]\n\nprob = PODEProblem(v, f, tspan, tstep, q₀, p₀; parameters = (k = 0.5,))","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The energy of the harmonic oscillator is preserved, so we can add it as an invariant, ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"energy(t, q, p, params) = p[1]^2 / 2 + params.k * q[1]^2 / 2\n\nprob = PODEProblem(v, f, tspan, tstep, q₀, p₀; parameters = (k = 0.5,), invariants = (h=energy,))","category":"page"},{"location":"problems/#Hamiltonian-Ordinary-Differential-Equations-(HODEs)","page":"Problems","title":"Hamiltonian Ordinary Differential Equations (HODEs)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.hode_equations)","category":"page"},{"location":"problems/#Example:-Harmonic-Oscillator-3","page":"Problems","title":"Example: Harmonic Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example, let us consider the harmonic oscillator. The dynamical equations are given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = p (t) \ndotp (t) = - k  q(t) \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"which can also be written as ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginpmatrix\ndotq (t) \ndotp (t) \nendpmatrix = beginpmatrix\n0  1 \n-1  0 \nendpmatrix\nnabla H( q(t)  p(t) ) \nqquad\nH(qp) = fracp^22 + k  fracq^22 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"where H is the Hamiltonian, i.e., the total energy of the system.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create a HODEProblem for the harmonic oscillator, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction v(v, t, q, p, params)\n    v[1] = p[1]\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = - params.k * q[1]\nend\n\nh(t, q, p, params) = p[1]^2 / 2 + params.k * q[1]^2 / 2\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [0.5]\np₀ = [0.0]\n\nprob = HODEProblem(v, f, h, tspan, tstep, q₀, p₀; parameters = (k = 0.5,))","category":"page"},{"location":"problems/#Implicit-Ordinary-Differential-Equations-(IODEs)","page":"Problems","title":"Implicit Ordinary Differential Equations (IODEs)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.iode_equations)","category":"page"},{"location":"problems/#Example:-Harmonic-Oscillator-4","page":"Problems","title":"Example: Harmonic Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example, let us consider the harmonic oscillator. In implicit form, its equations are given as follows,","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = v(t)  \np(t) = v(t)  \ndotp (t) = - k q(t) \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"Here, v acts as a Lagrange multiplier that enforces the \"constraint\" p(t) = v(t).","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an IODEProblem for the harmonic oscillator, we thus need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction p(p, t, q, v, params)\n    p[1] = v[1]\nend\n\nfunction f(f, t, q, v, params)\n    p[1] = - params.k * q[1]\nend\n\nfunction g(f, t, q, v, params)\n    p[1] = - params.k * q[1]\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [0.5]\np₀ = [0.0]\n\nprob = IODEProblem(p, f, tspan, tstep, q₀, p₀; parameters = (k = 0.5,))","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The energy of the harmonic oscillator is preserved, so we can add it as an invariant, ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"energy(t, q, v, params) = v[1]^2 / 2 + params.k * q[1]^2 / 2\n\nprob = IODEProblem(p, f, tspan, tstep, q₀, p₀; parameters = (k = 0.5,), invariants = (h=energy,))","category":"page"},{"location":"problems/#Lagrangian-Ordinary-Differential-Equations-(LODEs)","page":"Problems","title":"Lagrangian Ordinary Differential Equations (LODEs)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.lode_equations)","category":"page"},{"location":"problems/#Example:-Harmonic-Oscillator-5","page":"Problems","title":"Example: Harmonic Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example, let us consider the harmonic oscillator. Its Lagrangian is given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"L(q dotq) = fracdotq^22 - k  fracq^22 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"so that the Euler-Lagrange equations","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"fracddt fracpartial Lpartial dotq = fracpartial Lpartial q ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"become","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"ddotq (t) = - k q(t) ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"Most integrators for Lagrangian systems do not solve this second order system (semi-spray form), but instead use a reformulation as an implicit ordinary differential equation. This formulation can most easily be obtained from a Hamilton-Pontryagin principle","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"delta int limits_t_0^t_1 big L(q v) + left p  dotq - v right big = 0 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"as follows,","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = v(t)  \np(t) = fracpartial Lpartial v (q(t)v(t)) = v(t)  \ndotp (t) = fracpartial Lpartial q (q(t)v(t)) = - k q(t) \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"Here, v acts as a Lagrange multiplier that enforces the \"constraint\" p(t) = partial L  partial v.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an LODEProblem for the harmonic oscillator, we thus need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction p(p, t, q, v, params)\n    p[1] = v[1]\nend\n\nfunction f(f, t, q, v, params)\n    p[1] = - params.k * q[1]\nend\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] =  0\n    ω[1,2] = -1\n    ω[2,1] = +1\n    ω[2,2] =  0\nend\n\nfunction l(t, q, v, params)\n    v[1]^2 / 2 - params.k * q[1]^2 / 2\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [0.5]\np₀ = [0.0]\n\nprob = LODEProblem(p, f, ω, l, tspan, tstep, q₀, p₀; parameters = (k = 0.5,))","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The energy of the harmonic oscillator is preserved, so we can add it as an invariant, ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"energy(t, q, v, params) = v[1]^2 / 2 + params.k * q[1]^2 / 2\n\nprob = LODEProblem(p, f, ω, l, tspan, tstep, q₀, p₀; parameters = (k = 0.5,), invariants = (h=energy,))","category":"page"},{"location":"problems/#Differential-Algebraic-Equation-(DAE)","page":"Problems","title":"Differential Algebraic Equation (DAE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.dae_equations)","category":"page"},{"location":"problems/#Example:-Harmonic-Oscillator-6","page":"Problems","title":"Example: Harmonic Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example we consider the harmonic oscillator, with an additional constraint that enforces energy conservation. While the system itself is energy conserving, most integrators do not respect this property. A possible way of remedying this flaw is to explicitly add energy conservation as an algebraic constraint. ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The dynamical equations are given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"dotq (t) = beginpmatrix\n0  1 \n-k  0 \nendpmatrix q(t) \n+ nabla phi (q(t)) lambda \nqquad\nphi (q) = fracq_2^22 + k  fracq_1^22\nqquad\nq in mathbbR^2 \nqquad\nlambda in mathbbR^1 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an DAEProblem for the harmonic oscillator including the projection on the constant energy manifold, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nhamiltonian(t, q, params) = q[2]^2 / 2 + params.k * q[1]^2 / 2\n\nfunction v(v, t, q, params)\n    v[1] = q[2]\n    v[2] = - params.k * q[1]\nend\n\nfunction u(u, t, q, λ, params)\n    u[1] = λ[1] * params.k * q[1]\n    u[2] = λ[1] * q[2]\nend\n\nfunction ϕ(ϕ, t, q, params)\n    ϕ[1] = hamiltonian(t, q, params)\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\nλ₀ = [0.]\nparams = (k=0.5,)\n\nprob = DAEProblem(v, u, ϕ, tspan, tstep, q₀, λ₀; parameters = params)","category":"page"},{"location":"problems/#Partitioned-Differential-Algebraic-Equation-(PDAE)","page":"Problems","title":"Partitioned Differential Algebraic Equation (PDAE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.pdae_equations)","category":"page"},{"location":"problems/#Example:-Pendulum","page":"Problems","title":"Example: Pendulum","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example we consider the pendulum in cartesian coordinates, with a constraint that enforces the solution to respect the length of the pendulum.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The dynamical equations are given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = p (t)  \nq in mathbbR^2\n\ndotp (t) = \nbeginpmatrix\n  - lambda q_1 (t) \n1 - lambda q_2 (t) \nendpmatrix  \np in mathbbR^2 \n\nphi (q) = q^2 - l^2  \nlambda in mathbbR^1 \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an PDAEProblem for the pendulum including the projection on the constant length constraint, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\n\nfunction v(v, t, q, p, params)\n    v .= p\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = 0\n    f[2] = 1\nend\n\nfunction u(u, t, q, p, λ, params)\n    u .= 0\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = - λ[1] * q[1]\n    g[2] = - λ[1] * q[2]\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = q[1]^2 + q[2]^2 - params.l^2\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nparams = (l=0.5,)\n\nq₀ = [params.l, 0.0]\np₀ = [0.0, 0.1]\nλ₀ = [0.0]\n\nprob = PDAEProblem(v, f, u, g, ϕ, tspan, tstep, q₀, p₀, λ₀; parameters = params)","category":"page"},{"location":"problems/#Hamiltonian-Differential-Algebraic-Equation-(HDAE)","page":"Problems","title":"Hamiltonian Differential Algebraic Equation (HDAE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.hdae_equations)","category":"page"},{"location":"problems/#Example:-Pendulum-2","page":"Problems","title":"Example: Pendulum","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example we consider the pendulum in cartesian coordinates, with a constraint that enforces the solution to respect the length of the pendulum.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The Hamiltonian is given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"H(qp) = frac12 p^2 + l - q_2 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"and dynamical equations read","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = p (t)  \nq in mathbbR^2\n\ndotp (t) = \nbeginpmatrix\n  - lambda q_1 (t) \n1 - lambda q_2 (t) \nendpmatrix  \np in mathbbR^2 \n\nphi (q) = q^2 - l^2  \nlambda in mathbbR^1 \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an HDAEProblem for the pendulum including the projection on the constant length constraint, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\n\nfunction v(v, t, q, p, params)\n    v .= p\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = 0\n    f[2] = 1\nend\n\nfunction u(u, t, q, p, λ, params)\n    u .= 0\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = - λ[1] * q[1]\n    g[2] = - λ[1] * q[2]\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = q[1]^2 + q[2]^2 - params.l^2\nend\n\nfunction h(t, q, p, params)\n    return (p[1]^2 + p[2]^2)/2 + params.l - q[2]\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nparams = (l=0.5,)\n\nq₀ = [params.l, 0.0]\np₀ = [0.0, 0.1]\nλ₀ = [0.0]\n\nprob = HDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, q₀, p₀, λ₀; parameters = params)","category":"page"},{"location":"problems/#Implicit-Differential-Algebraic-Equation-(IDAE)","page":"Problems","title":"Implicit Differential Algebraic Equation (IDAE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.idae_equations)","category":"page"},{"location":"problems/#Example:-Pendulum-3","page":"Problems","title":"Example: Pendulum","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example we consider the pendulum in cartesian coordinates, with a constraint that enforces the solution to respect the length of the pendulum.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The implicit equations are given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = v(t)  \nq in mathbbR^2\n\ndotp (t) = \nbeginpmatrix\n0 \n1 \nendpmatrix\n- lambda(t) q(t)  \nv in mathbbR^2 \n\np(t) = v(t)  \np in mathbbR^2 \n\nphi (q) = q^2 - l^2  \nlambda in mathbbR^1 \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an IDAEProblem for the pendulum including the projection on the constant length constraint, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\n\nfunction p(p, t, q, v, params)\n    p .= v\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = 0\n    f[2] = 1\nend\n\nfunction u(u, t, q, v, p, λ, params)\n    u .= 0\nend\n\nfunction g(g, t, q, v, p, λ, params)\n    g[1] = - λ[1] * q[1]\n    g[2] = - λ[1] * q[2]\nend\n\nfunction ϕ(ϕ, t, q, v, p, params)\n    ϕ[1] = q[1]^2 + q[2]^2 - params.l^2\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nparams = (l=0.5,)\n\nq₀ = [params.l, 0.0]\np₀ = [0.0, 0.1]\nλ₀ = [0.0]\n\nprob = IDAEProblem(p, f, u, g, ϕ, tspan, tstep, q₀, p₀, λ₀; parameters = params)","category":"page"},{"location":"problems/#Lagrangian-Differential-Algebraic-Equation-(LDAE)","page":"Problems","title":"Lagrangian Differential Algebraic Equation (LDAE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.ldae_equations)","category":"page"},{"location":"problems/#Example:-Pendulum-4","page":"Problems","title":"Example: Pendulum","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As an example we consider the pendulum in cartesian coordinates, with a constraint that enforces the solution to respect the length of the pendulum.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The Hamilton-Pontryagin principle for this system is given by","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"delta int limits_t_0^t_1 big L(q v) + left p  dotq - v right + lambda  phi (q) big = 0 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"with Lagrangian","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"L(qv) = frac12 v^2 - (l - q_2) ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"and constraint","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"phi(q) = q^2 - l^2 ","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"The resulting implicit equations read","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"beginaligned\ndotq (t) = v(t)  \nq in mathbbR^2\n\ndotp (t) = \nbeginpmatrix\n0 \n1 \nendpmatrix\n- lambda(t) q(t)  \nv in mathbbR^2 \n\np(t) = v(t)  \np in mathbbR^2 \n\nphi (q) = q^2 - l^2  \nlambda in mathbbR^1 \nendaligned","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"In order to create an LDAEProblem for the pendulum including the projection on the constant length constraint, we need to write the following code:","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\n\nfunction p(p, t, q, v, params)\n    p .= v\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = 0\n    f[2] = 1\nend\n\nfunction u(u, t, q, v, p, λ, params)\n    u .= 0\nend\n\nfunction g(g, t, q, v, p, λ, params)\n    g[1] = - λ[1] * q[1]\n    g[2] = - λ[1] * q[2]\nend\n\nfunction ϕ(ϕ, t, q, v, p, params)\n    ϕ[1] = q[1]^2 + q[2]^2 - params.l^2\nend\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] =  0\n    ω[1,2] = -1\n    ω[2,1] = +1\n    ω[2,2] =  0\nend\n\nfunction l(t, q, v, params)\n    return (v[1]^2 + v[2]^2)/2 - (params.l - q[2])\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nparams = (l=0.5,)\n\nq₀ = [params.l, 0.0]\np₀ = [0.0, 0.1]\nλ₀ = [0.0]\n\nprob = LDAEProblem(p, f, u, g, ϕ, ω, l, tspan, tstep, q₀, p₀, λ₀; parameters = params)","category":"page"},{"location":"problems/#Stochastic-Differential-Equations-(SDEs)","page":"Problems","title":"Stochastic Differential Equations (SDEs)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.sde_equations)","category":"page"},{"location":"problems/#Example:-Kubo-Oscillator","page":"Problems","title":"Example: Kubo Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction v(t, q, v, params)\n    v[1] = + params.λ * q[2]\n    v[2] = - params.λ * q[1]\nend\n\nfunction B(t, q, B, params)\n    for j in axes(B, 2)\n        B[1,j] = + params.ν * q[2]\n        B[2,j] = - params.ν * q[1]\n    end\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.01\nq₀ = [0.5, 0.0]\n\nprob = SDEProblem(v, B, tspan, tstep, q₀; parameters = (λ=2.0, μ=1.0))","category":"page"},{"location":"problems/#Partitioned-Stochastic-Differential-Equation-(PSDE)","page":"Problems","title":"Partitioned Stochastic Differential Equation (PSDE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.psde_equations)","category":"page"},{"location":"problems/#Example:-Kubo-Oscillator-2","page":"Problems","title":"Example: Kubo Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction v(v, t, q, p, params)\n    v[1] = + params.λ * p[1]\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = - params.λ * q[1]\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = params.ν * p[1]\nend\n\nfunction G(G, t, q, p, params)\n    G[1,1] = - params.ν * q[1]\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.01\nq₀ = [0.5]\np₀ = [0.0]\n\nprob = PSDEProblem(v, f, B, G, tspan, tstep, q₀, p₀; parameters = (λ=2.0, μ=1.0))","category":"page"},{"location":"problems/#Split-Partitioned-Stochastic-Differential-Equation-(SPSDE)","page":"Problems","title":"Split Partitioned Stochastic Differential Equation (SPSDE)","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricEquations, Markdown\nMarkdown.parse(GeometricEquations.spsde_equations)","category":"page"},{"location":"problems/#Example:-Kubo-Oscillator-3","page":"Problems","title":"Example: Kubo Oscillator","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using GeometricIntegrators # hide\nfunction v(v, t, q, p, params)\n    v[1] = + params.λ * p[1]\nend\n\nfunction f1(f, t, q, p, params)\n    f[1] = - params.λ * q[1]\nend\n\nfunction f2(f, t, q, p, params)\n    f[1] = 0\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = params.ν * p[1]\nend\n\nfunction G1(G, t, q, p, params)\n    G[1,1] = - params.ν * q[1]\nend\n\nfunction G2(G, t, q, p, params)\n    G[1,1] = 0\nend\n\ntspan = (0.0, 1.0)\ntstep = 0.01\nq₀ = [0.5]\np₀ = [0.0]\n\nprob = SPSDEProblem(v, f1, f2, B, G1, G2, tspan, tstep, q₀, p₀; parameters = (λ=2.0, μ=1.0))","category":"page"},{"location":"LICENSE/#MIT-License","page":"License","title":"MIT License","text":"","category":"section"},{"location":"LICENSE/","page":"License","title":"License","text":"Copyright (c) The GeometricIntegrators AuthorsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"integrators/splitting/#Splitting-and-Composition-Methods","page":"Splitting","title":"Splitting and Composition Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"GeometricIntegrators supports splitting and composition methods, where the solution to an ODE of the form","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"dotx = v_1 (tx) +  + v_r (tx)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"is obtained by consecutively integrating each vector field v_i independently and combining the resulting solutions in an appropriate way. Consider a simple ODE dotx = V where the vector field v can be written as V = sum_i v_i. The flow (exact solution) of this ODE is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"x(t) = phi_t (x(0)) = exp(t V) (x(0)) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and the composition method ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = exp(tau v_1) exp(tau v_2) dotsc exp(tau v_r) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where tau denotes the time step, provides a first-order accurate approximation to the exact flow as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"phi_tau = exp bigg( tau sum_i v_i bigg) + mathcalO (tau^2) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the following, we use \"splitting methods\" to denote integrators that utilize the exact solution of each vector field v_i and \"composition methods\" to denote integrators that utilize some consistent but possibly approximate solution for each of the vector fields v_i, i.e., that solution can be exact or obtained by some other integrator. For reference see the excellent review paper by [4] or the canonical book on Geometric Numerical Integration by [5].","category":"page"},{"location":"integrators/splitting/#Splitting-Integrators","page":"Splitting","title":"Splitting Integrators","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In GeometricIntegrators, basic splitting methods are implemented in IntegratorSplitting, which has two constructors:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"IntegratorSplitting{DT,D}(solutions::Tuple, f::Vector{Int}, c::Vector, Δt)\nIntegratorSplitting(equation::SODE, tableau::AbstractTableauSplitting, Δt)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the first constructor, DT is the data type of the state vector and D the dimension of the system. In the second constructor, this information is extracted from the equation.  The tuple solutions contains functions implementing the flow (exact solution) of the vector fields v_i. The vectors f and c define the actual splitting method: f is a vector of indices of the flows in the split equation to be solved and c is a vector of the same size f that contains the coefficients for each splitting step, i.e., the resulting integrator has the form","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_cs tau^v_fs circ dotsc circ phi_c2 tau^v_f2 circ phi_c1 tau^v_f1 ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the second constructor, these vectors are constructed from the tableau and the equation.","category":"page"},{"location":"integrators/splitting/#Composition-Integrators","page":"Splitting","title":"Composition Integrators","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Fully flexible composition methods are implemented in IntegratorComposition, which can use any ODE integrator implemented in GeometricIntegrators to solve the steps of the splitting. For each step, a different integrator can be chosen as well as the exact solution using IntegratorExactODE, which is a simple wrapper around the exact flow of a splitting step, implementing the general integrator interface.","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"IntegratorComposition has three constructors:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"IntegratorComposition{DT,D}(integrators::Tuple, Δt)\nIntegratorComposition(equation::SODE, constructors::Tuple, tableau::AbstractTableauSplitting, Δt)\nIntegratorComposition(equation::SODE, tableau::AbstractTableauSplitting, Δt)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"In the first constructor, DT is the data type of the state vector and D the dimension of the system. In the second and third constructor, this information is extracted from the equation.  The tuple integrators contains the integrators for each substep. Each integrator is instantiated with appropriately scaled time step size Delta t = c_i tau to match the corresponding splitting scheme. In the second constructor, the tuple constructors contains closures around the constructors for the integrators of each step of the composition, that is functions taking a vector field v_i, the time step Delta t and optional keyword arguments, e.g. for the exact solution or a Runge-Kutta integrator, we have","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"(v::Function, Δt::Number; kwargs...) -> IntegratorExactODE{DT,D}(v, Δt; kwargs...)\n(v::Function, Δt::Number; kwargs...) -> Integrator{DT,D}(v, tableau, Δt; kwargs...)","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The integrators are constructed according to the tableau and time step \\Delta t and passed to the first constructor. The third constructor assumes that the exact solution is used for each splitting step. It thus constructs a composition method that is equivalent to a plain IntegratorSplitting.","category":"page"},{"location":"integrators/splitting/#Splitting-of-Hamiltonian-Systems","page":"Splitting","title":"Splitting of Hamiltonian Systems","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"For Hamiltonian systems, splitting is a simple and versatile technique for the construction of symplectic integrators. Suppose that the Hamiltonian H can be split into the sum of r geq 2 Hamiltonians H_i with 1 leq i leq r, i.e.,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"H (z) = sum limits_i=1^r H_i (z) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"with each Hamiltonian vector field","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"dotz = Omega^-T  nabla H_i (z) ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"explicitly solvable. The exact solution phi_t^H_i of each subsystem provides a symplectic map. As the composition of symplectic maps yields a symplectic map, a symplectic integrator can be obtained by an appropriate composition of the flow maps of each subsystem. A first-order symplectic integrator is obtained from the Lie-Trotter splitting,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_tau^H_1 circ phi_tau^H_2 circ dotsc circ phi_tau^H_k ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Second-order symplectic integrators are obtained from symmetric splittings,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_h2^H_1 circ phi_h2^H_2 circ dotsc circ phi_h2^H_k-1 circ phi_tau^H_k circ phi_h2^H_k-1 circ dotsc circ phi_h2^H_2 circ phi_h2^H_1 ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"or","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = phi_h2^H_k circ phi_h2^H_k-1 circ dotsc circ phi_h2^H_2 circ phi_tau^H_1 circ phi_h2^H_2 circ dotsc circ phi_h2^H_k-1 circ phi_h2^H_k ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Higher order integrators can be constructed by using the Baker-Campbell-Hausdorff formula.","category":"page"},{"location":"integrators/splitting/#Separable-Hamiltonian-Systems","page":"Splitting","title":"Separable Hamiltonian Systems","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"If we have a Hamiltonian of the form H(pq) = T(p) + U(q), we can consider only the subsystem with Hamiltonian U(q),","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ndotq = 0  \ndotp = - nabla U(q) \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"This system can be solved exactly. The exact flow is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"phi^U_t (qp) = beginpmatrix\nq \np - t nabla U(q)\nendpmatrix ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Next, consider the subsystem with Hamiltonian T(p) = tfrac12 p^T M^-1 p, ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ndotq = M^-1 p  \ndotp = 0  \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"This system can be solved exactly as well. The exact flow is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"phi^T_t (qp) = beginpmatrix\nq + t M^-1 p \np\nendpmatrix ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"As phi^U_t and phi^T_t are exact flows of the respective Hamiltonian, they are both symplectic. We see that the compositions of phi^U_t and phi^T_t correspond to the symplectic Euler methods for separable Hamiltonians,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi^A_tau = phi^U_tau circ phi^T_tau  \nvarphi^B_tau = phi^T_tau circ phi^U_tau \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where varphi^A_tau and varphi^B_tau denote the numerical flows of symplectic Euler-A and symplectic Euler-B, respectively. As the Störmer-Verlet methods are compositions of the symplectic Euler methods, they are also splitting methods, corresponding to the compositions","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau^SV1 = varphi^A_h2 circ varphi^B_h2 = phi^U_h2 circ phi^T_tau circ phi^U_h2  \nvarphi_tau^SV2 = varphi^B_h2 circ varphi^A_h2 = phi^T_h2 circ phi^U_tau circ phi^T_h2 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"respectively. This particular splitting is often referred to as Strang splitting [[6], see also [7]].","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Let us note that not all symplectic integrators can be obtained as splitting methods. For the symplectic Euler methods and the Störmer-Verlet methods, this is only possible for separable Hamiltonian systems. For general Hamiltonians, these methods cannot be obtained from any splitting but are nevertheless symplectic.","category":"page"},{"location":"integrators/splitting/#Fourth-Order-Methods","page":"Splitting","title":"Fourth Order Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The general form of a fourth order symplectic integrator for separable Hamiltonian systems is given by","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nq_1 = q_0 + b_1 tau  T_p (p_0)  \np_1 = p_0 - hatb_1 tau  U_q (q_1)  \nq_2 = q_1 + b_2 tau  T_p (p_1)  \np_2 = p_1 - hatb_2 tau  U_q (q_2)  \nq_3 = q_2 + b_3 tau  T_p (p_2)  \np_3 = p_2 - hatb_3 tau  U_q (q_3)  \nq_4 = q_3 + b_4 tau  T_p (p_3)  \np_4 = p_3 - hatb_4 tau  U_q (q_4) \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The quantities (q_0 p_0) are initial values and (q_4 p_4) are the numerical solution after one time step tau. The whole algorithm can be written as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau = \nvarphi_hatb_4 tau^U\ncirc\nvarphi_b_4 tau^T\ncirc\nvarphi_hatb_3 tau^U\ncirc\nvarphi_b_3 tau^T\ncirc\nvarphi_hatb_2 tau^U\ncirc\nvarphi_b_2 tau^T\ncirc\nvarphi_hatb_1 tau^U\ncirc\nvarphi_b_1 tau^T\nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and is therefore immediately seen to be symplectic. Two methods of fourth order are given by","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nb_1 = b_4 = dfrac12 (2 - gamma)  \nb_2 = b_3 = dfrac1-gamma2 (2 - gamma)  \nhatb_1 = hatb_3 = dfrac12 - gamma  \nhatb_2 = - dfracgamma2 - gamma  \nhatb_4 = 0 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nb_1 = 0  \nb_2 = b_4 = dfrac12 - gamma  \nb_3 = dfrac11 - gamma^2  \nhatb_1 = hatb_4 = tfrac16 (2 + gamma + gamma^-1)  \nhatb_2 = hatb_3 = tfrac16 (2 - gamma - gamma^-1) \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where gamma = 2^13. Both methods are explicit and symmetric as either varphi_hatb_4 tau^U or varphi_b_1 tau^T corresponds to the identity.","category":"page"},{"location":"integrators/splitting/#Higher-Order-Methods-by-Composition","page":"Splitting","title":"Higher Order Methods by Composition","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The composition of a one-step symplectic integrator varphi_tau with different step sizes provides a simple way of obtaining higher order schemes. We assume that the initial scheme varphi_tau is symmetric, that is","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau circ varphi_-tau = mathrmid ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"as this simplifies the construction. A symmetric method can always be built by combining a non-symmetric method with its adjoint. If a numerical method varphi_tau is symmetric, it can be used to compose higher order methods by splitting up each timestep into s substeps [[5], [8], [9]],","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = varphi_gamma_s tau circ  circ varphi_gamma_i tau circ  circ varphi_gamma_1 tau ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"where the careful selection of the gamma_i is crucial for the performance of the resulting scheme. In the following, we present some fourth and sixth order composition methods that can be applied in most situations.","category":"page"},{"location":"integrators/splitting/#Fourth-Order-Composition-Methods","page":"Splitting","title":"Fourth Order Composition Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"If varphi_tau is a method of order r, a method hatvarphi_tau of order r+2 is obtained by the composition [[5], Section V.3.2]","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nhatvarphi_tau = varphi_gamma tau circ varphi_(1-2gamma) tau circ varphi_gamma tau \n textwith \ngamma = (2 - 2^1(r+1))^-1  \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Hence, if varphi_tau is of second order, the resulting method hatvarphi_tau will be of fourth order. Note that symmetric methods are always of even order. A method of the same order but with generally smaller errors is obtained by considering five steps","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nhatvarphi_tau = varphi_gamma tau circ varphi_gamma tau circ varphi_(1-4gamma) tau circ varphi_gamma tau circ varphi_gamma tau \n textwith \ngamma = (4 - 4^1(r+1))^-1  \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Multiple application of these compositions yields methods of orders higher than four.","category":"page"},{"location":"integrators/splitting/#Sixth-Order-Composition-Methods","page":"Splitting","title":"Sixth Order Composition Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Higher order compositions can also be constructed directly [[5], Section V.3.2]. A sixth order method with seven substeps is given by","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ngamma_1 = gamma_7 = + 078451361047755726381949763  \ngamma_2 = gamma_6 = + 023557321335935813368479318  \ngamma_3 = gamma_5 = - 117767998417887100694641568  \ngamma_4 = + 131518632068391121888424973 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"but again smaller errors can be achieved by using nine steps","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\ngamma_1 = gamma_9 = + 039216144400731413927925056  \ngamma_2 = gamma_8 = + 033259913678935943859974864  \ngamma_3 = gamma_7 = - 070624617255763935980996482  \ngamma_4 = gamma_6 = + 008221359629355080023149045  \ngamma_5 = + 079854399093482996339895035 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"The computational effort of these high order methods is quite large. Each step requires the solution of a nonlinear system of equations. Given the outstanding performance already second order symplectic integrators are able to deliver, the necessity for such high order methods is rarely found. Nevertheless, if extremely high accuracy is indispensable, think for example of long-time simulations of the solar system, these methods can be applied. Moreover, there exist special methods optimized for such problems.","category":"page"},{"location":"integrators/splitting/#Splitting-Tableaus","page":"Splitting","title":"Splitting Tableaus","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Actualy splitting methods are usually prescribed in one of the following forms.","category":"page"},{"location":"integrators/splitting/#[TableauSplitting](@ref)","page":"Splitting","title":"TableauSplitting","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for general splitting methods for vector fields with two terms v = v_A + v_B, leading to the following integrator:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A ","category":"page"},{"location":"integrators/splitting/#[TableauSplittingNS](@ref)","page":"Splitting","title":"TableauSplittingNS","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for non-symmetric splitting methods [[4], Equation (4.10)]. Here, two flows varphi_tau^A and varphi_tau^B are constructed as the Lie composition of all vector fields in the SODE and its adjoint, respectively, i.e..","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r  \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and the integrator is composed as follows:","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^NS = varphi_b_s tau^B circ varphi_a_s tau^A circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A ","category":"page"},{"location":"integrators/splitting/#[TableauSplittingGS](@ref)","page":"Splitting","title":"TableauSplittingGS","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for symmetric splitting methods with general stages [[4], Equation (4.11)], where again two flows varphi_tau^A and varphi_tau^B are constructed via Lie composition","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"beginaligned\nvarphi_tau^A = varphi_tau^v_1 circ varphi_tau^v_2 circ dotsc circ varphi_tau^v_r-1 circ varphi_tau^v_r  \nvarphi_tau^B = varphi_tau^v_r circ varphi_tau^v_r-1 circ dotsc circ varphi_tau^v_2 circ varphi_tau^v_1 \nendaligned","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"but with an integrator composed as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^GS = varphi_a_1 tau^A circ varphi_b_1 tau^B circ dotsc circ varphi_b_1 tau^B circ varphi_a_1 tau^A ","category":"page"},{"location":"integrators/splitting/#[TableauSplittingSS](@ref)","page":"Splitting","title":"TableauSplittingSS","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Tableau for symmetric splitting methods with symmetric stages [[4], Equation (4.6)]. Here, only one flow varphi_tau^S is constructed via symmetric Strang composition,","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^S = varphi_tau2^v_1 circ varphi_tau2^v_2 circ dotsc circ varphi_tau2^v_r-1 circ varphi_tau2^v_r circ varphi_tau2^v_r circ varphi_tau2^v_r-1 circ dotsc circ varphi_tau2^v_2 circ varphi_tau2^v_1 ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"and composed as","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"varphi_tau^SS = varphi_a_1 tau^S circ varphi_a_2 tau^S circ dotsc circ varphi_a_s tau^S circ dotsc circ varphi_a_2 tau^S circ varphi_a_1 tau^S ","category":"page"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"to obtain an integrator.","category":"page"},{"location":"integrators/splitting/#Implemented-Splitting-Methods","page":"Splitting","title":"Implemented Splitting Methods","text":"","category":"section"},{"location":"integrators/splitting/","page":"Splitting","title":"Splitting","text":"Function Order Method\nLieA 1 Lie-Trotter Splitting A\nLieB 1 Lie-Trotter Splitting B\nStrang 2 Strang / Marchuk Splitting\nMarchuk 2 Strang / Marchuk Splitting\nStrangA 2 Strang / Marchuk Splitting A\nStrangB 2 Strang / Marchuk Splitting B\nMcLachlan2 2 McLachlan's 2nd order symmetric, minimum error composition method\nMcLachlan4 2 McLachlan's 4th order symmetric, minimum error composition method\nTripleJump 4 4th order \"Triple Jump\" composition method\nSuzukiFractal 4 Suzuki's 4th order \"fractal\" composition method","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = GeometricIntegrators","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we try to give an overview of the basic usage of GeometricIntegrators and its main components.","category":"page"},{"location":"tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"GeometricIntegrators.jl can be installed using Julia's built-in package manager in the command line interface by","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ]\n(v1.9) pkg> add GeometricIntegrators","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In a Jupyter notebook, GeometricIntegrators.jl can be installed by explicitly using the Pkg module as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg\nPkg.add(\"GeometricIntegrators\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This will install the library itself as well as all dependencies.","category":"page"},{"location":"tutorial/#Basic-usage","page":"Tutorial","title":"Basic usage","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the simplest cases, the use of GeometricIntegrators.jl requires the construction of two objects, an equation and an integrator. For many standard methods, the integrator is implicitly selected by specifying an equation and a tableau.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Before any use, we need to load GeometricIntegrators,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeometricIntegrators","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then we can create an ODE object for the equation dotx (t) = x(t) with initial condition x(0) = 1, integration time span (0 1) and a time step of Delta t = 01,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"prob = ODEProblem((ẋ, t, x, params) -> ẋ[1] = x[1], (0.0, 1.0), 0.1, [1.0])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"create an integrator for this ODE, using the explicit Euler method","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(prob, ExplicitEuler())","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and compute the solution,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = integrate(prob, int)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Plot and compare with the exact solution","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplot(xlims=[0,1], xlab=\"t\", ylab=\"x(t)\", legend=:bottomright)\nplot!(sol.t, sol.q[:,1], label=\"numeric\")\nplot!(sol.t, exp.(sol.t), label=\"exact\")\nsavefig(\"images/tutorial-ode-1.png\") # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/#Equations","page":"Tutorial","title":"Equations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In GeometricIntegrators.jl we distinguish between three basic types of equations:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ordinary differential equations (ODEs),\ndifferential algebraic equations (DAEs),\nstochastic differential equations (SDEs).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For each type, there are several subtypes","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"standard equations (ODEProblem, DAEProblem, SDEProblem),\nimplicit equations (IODEProblem, IDAEProblem),\npartitioned equations (PODEProblem, PDAEProblem, PSDEProblem),\nHamiltonian equations (HODEProblem, HDAEProblem),\nLagrangian equations (LODEProblem, LDAEProblem),\nsplit equations (SODEProblem, SPDAEProblem, SPSDEProblem).","category":"page"},{"location":"tutorial/#Ordinary-differential-equations","page":"Tutorial","title":"Ordinary differential equations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Consider an ODE of the form","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dotx (t) = v(t x(t)) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where dotx denotes the derivative of x and f the vector field of the equation, which is assumed to depend on both t and x. In the following, we will solve the mathematical pendulum, whose equations are given by","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginpmatrix\ndotx_1 \ndotx_2 \nendpmatrix\n=\nbeginpmatrix\nx_2 \nsin (x_1) \nendpmatrix ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Together with the integration time span (t₀,t₁) and the time step, an ODE defines an ODEProblem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The user needs to specify a function ẋ that computes the vector field and must have the interface","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function ẋ(v, t, x, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params is a NamedTuple of constant parameters on which the vector field may depend.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the mathematical pendulum, this could look as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function ẋ(v, t, x, params)\n    v[1] = x[2]\n    v[2] = sin(x[1])\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"An ODEProblem is instantiated by","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ODEProblem(<vector field>, <time span>, <time step>, <initial conditions>; kwargs...)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"so to create and ODEProblem, one only needs to pass the above function ẋ, a tuple tspan containing the start and end times of the integration, the time step tstep as well as an initial condition:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tspan = (0.0, 10.0)\ntstep = 0.1\nx₀ = [acos(0.4), 0.0]\n\node = ODEProblem(ẋ, tspan, tstep, x₀)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The full constructor would look like","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ode = ODEProblem(ẋ, tspan, tstep, x₀; invariants = NullInvariants(),\n                 parameters = NullParameters(), periodicity = NullPeriodicity())","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where all keyword arguments, namely invariants, parameters and periodicity, are by default initialized to be absent.","category":"page"},{"location":"tutorial/#Partitioned-ordinary-differential-equations","page":"Tutorial","title":"Partitioned ordinary differential equations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The pendulum problem is a Hamiltonian system that can also be expressed as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dotq = fracpartial Hpartial p = p \nhspace3em\ndotp = - fracpartial Hpartial q = sin (q) \nhspace3em\nH (qp) = frac12 p^2 + cos (q) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This structure, namely the partitioning into two sets of variables (qp) instead of x, can be exploited for more efficient integration. Such equations can be defined in terms of a partitioned ODE, where the vector fields are specified separately,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function q̇(v, t, q, p, params)\n    v[1] = p[1]\nend\n\nfunction ṗ(f, t, q, p, params)\n    f[1] = sin(q[1])\nend\n\npode = PODEProblem(q̇, ṗ, (0.0, 25.0), 0.1, [acos(0.4)], [0.0])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first two arguments to the PODE constructor are the functions that determine the vector fields of the equations dotq (t) = v(t q(t) p(t)) and dotp (t) = f(t q(t) p(t)). The third and fourth argument determines the initial conditions of q and p, respectively. The functions defining the vector field have to take four arguments, the current time t, the current solution vectors q and p and the output vector v or f.","category":"page"},{"location":"tutorial/#Integrators","page":"Tutorial","title":"Integrators","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We support a number of standard integrators (geometric and non-geometric) like explicit, implicit and partitioned Runge-Kutta methods, splitting methods and general linear methods (planned).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to instantiate many of the standard integrators, one needs to specify an ODEProblem, a method and a timestep, e.g.,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(ode, ExplicitEuler())","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to run the integrator, the integrate() functions is called, passing an integrator object and the number of time steps to integrate:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = integrate(ode, int)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The integrate function automatically creates an appropriate solution object, that contains the result of the integration.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sol.q[:,1], sol.q[:,2], xlab=\"x(t)\", ylab=\"y(t)\", legend=:none)\nsavefig(\"images/tutorial-ode-2.png\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Observe that the explicit Euler method is not well suited for integrating this system. The solutions drifts away although it should follow closed orbits.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For a Hamiltonian system, defined as a PODE, a different methods might be more appropriate, for example a symplectic Euler method,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = integrate(pode, LobattoIIIAIIIB(2))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This creates a different integrator, which exploits the partitioned structure of the system. The solution return by the integrate step will also be a different solution, adapted to the partitioned system.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sol.q[:,1], sol.p[:,1], xlab=\"q(t)\", ylab=\"p(t)\", legend=:none)\nsavefig(\"images/tutorial-pode-1.png\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Moreover, this method respects the Hamiltonian structure of the system, resulting in closed orbits following the contours of the system's energy.","category":"page"},{"location":"tutorial/#Overview-of-Available-Methods","page":"Tutorial","title":"Overview of Available Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"GeometricIntegrators.jl provides a plethora of geometric integrators as well as non-geometric integrators (mainly for testing and benchmarking purposes). Most integrators can be selected by a simple method type, which also stores parameters. Some integrator families can also be selected by specifying a tableau, that is a Butcher tableau for Runge-Kutta methods, a pair of tableaus for partitioned Runge-Kutta and VPRK methods, or generalizations thereof for SPARK methods. Other integrators, such as Galerkin variational integrators require the specification of a basis and a quadrature rule.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The correct integrator is automatically selected based on the method and problem types by calling","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Integrator(problem, method)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As an example, consider an ODE like the harmonic oscillator, which is included in GeometricEquations.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"prob = harmonic_oscillator_ode()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create an explicit Euler method:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = ExplicitEuler()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And now create an Integrator with the general Integrator constructor:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(prob, method)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We see that we obtained an IntegratorERK, i.e., an explicit Runge-Kutta integrator. If instead we choose the implicit Euler method:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = ImplicitEuler()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"the general Integrator constructor creates a different integrator:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(prob, method)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"namely an IntegratorFIRK, i.e., a fully implicit Runge-Kutta integrator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"GeometricIntegrators automatically detects if a Runge-Kutta tableau is explicit, diagonally implicit or fully implicity and creates the corresponding Integrator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Certain Runge-Kutta method such as Gauß, Radau and Lobatto methods are available for an arbitrary number of stages. Here the number of stages has to be speficied","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(prob, Gauss(1))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Special integrators, such as Vartiational Partitioned Runge-Kutta (VPRK) methods, can be initialised by providing one or two tableaus, that is","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = VPRK(Gauss(1))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"or","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = VPRK(LobattoIIIA(2), LobattoIIIB(2))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For standard tableaus there also exist shortcuts, such as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = VPRKGauss(1)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"or","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = VPRKLobattoIIIAIIIB(2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the purpose of a complete example, consider again the harmonic oscillator:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"prob = harmonic_oscillator_iode()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create a VPRK tableau that uses Gauss-Legendre Runge-Kutta coefficients with two stages:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"method = VPRKGauss(2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If we call the Integrator constructor,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(prob, method)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"we obtain a IntegratorVPRK.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once an integrator is obtained, we can just call the function","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"integrate(problem, integrator)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"to perform the actual integration steps, where ntime defines the number of steps to integrate:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeometricIntegrators\nusing GeometricProblems.HarmonicOscillator\nprob = harmonic_oscillator_ode()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"int = Integrator(prob, ExplicitEuler())\nsol = integrate(prob, int)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The integrate function returns a solution object that stores the solution for each time step. If the solution object is created manually, there exists a function","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"integrate!(integrator, solution)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"that operates on an existing solution.","category":"page"},{"location":"tutorial/#Integrators-for-ODEs","page":"Tutorial","title":"Integrators for ODEs","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The main method types for ODEs currently implemented are Runge-Kutta methods and splitting methods.","category":"page"},{"location":"tutorial/#Runge-Kutta-Methods","page":"Tutorial","title":"Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Any Runge-Kutta method can be selected by the RK method","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rk = RK(tableau)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where tableau is any tableau from RungeKutta.Tableaus. For most tableaus there also exist explicit shortcuts to select the method. These are listed in the following.","category":"page"},{"location":"tutorial/#Explicit-Runge-Kutta-Methods","page":"Tutorial","title":"Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nExplicitEuler 1 Explicit / Forward Euler\nExplicitMidpoint 2 Explicit Midpoint\nHeun2 2 Heun's Method of order two\nHeun3 3 Heun's Method of order three\nRalston2 2 Ralston's Method of order two\nRalston3 3 Ralston's Method of order three\nRunge2 2 Runge's Method\nKutta3 3 Kutta's Method\nRK416 4 Explicit 4th order Runge-Kutta (1/6 rule)\nRK438 4 Explicit 4th order Runge-Kutta (3/8 rule)","category":"page"},{"location":"tutorial/#Diagonally-Implicit-Runge-Kutta-Methods","page":"Tutorial","title":"Diagonally Implicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nCrankNicolson 3 Crank-Nicholson Method\nKraaijevangerSpijker 3 Kraaijevanger & Spijker's Method\nQinZhang 3 Qin & Zhang's Method\nCrouzeix 3 Crouzeix's Method","category":"page"},{"location":"tutorial/#Fully-Implicit-Runge-Kutta-Methods","page":"Tutorial","title":"Fully Implicit Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nImplicitEuler 1 Implicit / Backward Euler\nImplicitMidpoint 2 Implicit Midpoint\nSRK3 4 Symmetric Runge-Kutta s=3","category":"page"},{"location":"tutorial/#Gauß,-Radau-and-Lobatto-Methods","page":"Tutorial","title":"Gauß, Radau and Lobatto Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nGauss 2s Gauss-Legendre\nRadauIA 2s-1 Radau-IA\nRadauIB 2s-1 Radau-IB\nRadauIIA 2s-1 Radau-IIA\nRadauIIB 2s-1 Radau-IIB\nLobattoIII 2s-2 Lobatto-III\nLobattoIIIA 2s-2 Lobatto-IIIA\nLobattoIIIB 2s-2 Lobatto-IIIB\nLobattoIIIC 2s-2 Lobatto-IIIC\nLobattoIIID 2s-2 Lobatto-IIID\nLobattoIIIE 2s-2 Lobatto-IIIE\nLobattoIIIF 2s Lobatto-IIIF\nLobattoIIIF 2s Lobatto-IIIF\nLobattoIIIG 2s Lobatto-IIIG","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"All of these tableaus are generated on the fly and take the number of stages s as parameter.","category":"page"},{"location":"tutorial/#Splitting-Methods","page":"Tutorial","title":"Splitting Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nLieA 1 Lie-Trotter Splitting A\nLieB 1 Lie-Trotter Splitting B\nStrang 2 Strang / Marchuk Splitting\nMarchuk 2 Strang / Marchuk Splitting\nStrangA 2 Strang / Marchuk Splitting A\nStrangB 2 Strang / Marchuk Splitting B\nMcLachlan2 2 McLachlan's 2nd order symmetric, minimum error composition method\nMcLachlan4 2 McLachlan's 4th order symmetric, minimum error composition method\nTripleJump 4 4th order \"Triple Jump\" composition method\nSuzukiFractal 4 Suzuki's 4th order \"fractal\" composition method","category":"page"},{"location":"tutorial/#Integrators-for-partitioned-ODEs","page":"Tutorial","title":"Integrators for partitioned ODEs","text":"","category":"section"},{"location":"tutorial/#Partitioned-Runge-Kutta-Methods","page":"Tutorial","title":"Partitioned Runge-Kutta Methods","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Any partitioned Runge-Kutta method can be selected by the PRK method","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"prk = PRK(tableau)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where tableau is any tableau from RungeKutta.PartitionedTableaus. For most tableaus there also exist explicit shortcuts to select the method. These are listed in the following.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nLobattoIIIAIIIB 2s-2 Lobatto-IIIA-IIIB\nLobattoIIIBIIIA 2s-2 Lobatto-IIIB-IIIA\nLobattoIIIAIIIĀ 2s-2 Lobatto-IIIA-IIIĀ\nLobattoIIIBIIIB̄ 2s-2 Lobatto-IIIB-IIIB̄\nLobattoIIICIIIC̄ 2s-2 Lobatto-IIIC-IIIC̄\nLobattoIIIC̄IIIC 2s-2 Lobatto-IIIC̄-IIIC\nLobattoIIIDIIID̄ 2s-2 Lobatto-IIID-IIID̄\nLobattoIIIEIIIĒ 2s-2 Lobatto-IIIE-IIIĒ\nLobattoIIIFIIIF̄ 2s Lobatto-IIIF-IIIF̄\nLobattoIIIF̄IIIF 2s Lobatto-IIIF̄-IIIF\nLobattoIIIGIIIḠ 2s Lobatto-IIIG-IIIḠ","category":"page"},{"location":"tutorial/#Integrators-for-implicit-ODEs","page":"Tutorial","title":"Integrators for implicit ODEs","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"All implicit Runge-Kutta and partitioned Runge-Kutta methods can also be applied to implicit ODEs.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Order Method\nImplicitEuler 1 Implicit / Backward Euler\nImplicitMidpoint 2 Implicit Midpoint\nSRK3 4 Symmetric Runge-Kutta s=3\n  \nGauss 2s Gauss-Legendre\nRadauIA 2s-1 Radau-IA\nRadauIB 2s-1 Radau-IB\nRadauIIA 2s-1 Radau-IIA\nRadauIIB 2s-1 Radau-IIB\nLobattoIII 2s-2 Lobatto-III\nLobattoIIIA 2s-2 Lobatto-IIIA\nLobattoIIIB 2s-2 Lobatto-IIIB\nLobattoIIIC 2s-2 Lobatto-IIIC\nLobattoIIID 2s-2 Lobatto-IIID\nLobattoIIIE 2s-2 Lobatto-IIIE\nLobattoIIIF 2s Lobatto-IIIF\nLobattoIIIG 2s Lobatto-IIIG\n  \nLobattoIIIAIIIB 2s-2 Lobatto-IIIA-IIIB\nLobattoIIIBIIIA 2s-2 Lobatto-IIIB-IIIA\nLobattoIIIAIIIĀ 2s-2 Lobatto-IIIA-IIIĀ\nLobattoIIIBIIIB̄ 2s-2 Lobatto-IIIB-IIIB̄\nLobattoIIICIIIC̄ 2s-2 Lobatto-IIIC-IIIC̄\nLobattoIIIC̄IIIC 2s-2 Lobatto-IIIC̄-IIIC\nLobattoIIIDIIID̄ 2s-2 Lobatto-IIID-IIID̄\nLobattoIIIEIIIĒ 2s-2 Lobatto-IIIE-IIIĒ\nLobattoIIIFIIIF̄ 2s Lobatto-IIIF-IIIF̄\nLobattoIIIF̄IIIF 2s Lobatto-IIIF̄-IIIF\nLobattoIIIGIIIḠ 2s Lobatto-IIIG-IIIḠ","category":"page"},{"location":"tutorial/#Integrators-for-Lagrangian-ODEs","page":"Tutorial","title":"Integrators for Lagrangian ODEs","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Regular (non-degenerate) Lagragian ODEs can be integrated with Variational Partitioned Runge-Kutta (VPRK) methods or Continuous Galerkin Variational Integrators (CGVI).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Method\nVPRK Variational Partitioned Runge-Kutta integrator\n \nVPRKGauss VPRK integrator with TableauGauss\nVPRKRadauIIA VPRK integrator with TableauRadauIIA\nVPRKRadauIIB VPRK integrator with TableauRadauIIB\nVPRKLobattoIII VPRK integrator with TableauLobattoIII\nVPRKLobattoIIIA VPRK integrator with TableauLobattoIIIA\nVPRKLobattoIIIB VPRK integrator with TableauLobattoIIIB\nVPRKLobattoIIIC VPRK integrator with TableauLobattoIIIC\nVPRKLobattoIIID VPRK integrator with TableauLobattoIIID\nVPRKLobattoIIIE VPRK integrator with TableauLobattoIIIE\nVPRKLobattoIIIF VPRK integrator with TableauLobattoIIIF\nVPRKLobattoIIIG VPRK integrator with TableauLobattoIIIG\nVPRKLobattoIIIAIIIB VPRK integrator with TableauLobattoIIIAIIIB\nVPRKLobattoIIIBIIIA VPRK integrator with TableauLobattoIIIBIIIA\nVPRKLobattoIIIAIIIĀ VPRK integrator with TableauLobattoIIIAIIIĀ\nVPRKLobattoIIIBIIIB̄ VPRK integrator with TableauLobattoIIIBIIIB̄\nVPRKLobattoIIICIIIC̄ VPRK integrator with TableauLobattoIIICIIIC̄\nVPRKLobattoIIIC̄IIIC VPRK integrator with TableauLobattoIIIC̄IIIC\nVPRKLobattoIIIDIIID̄ VPRK integrator with TableauLobattoIIIDIIID̄\nVPRKLobattoIIIEIIIĒ VPRK integrator with TableauLobattoIIIEIIIĒ\nVPRKLobattoIIIFIIIF̄ VPRK integrator with TableauLobattoIIIFIIIF̄\nVPRKLobattoIIIF̄IIIF VPRK integrator with TableauLobattoIIIF̄IIIF\nVPRKLobattoIIIGIIIḠ VPRK integrator with TableauLobattoIIIGIIIḠ","category":"page"},{"location":"tutorial/#Integrators-for-Degenerate-Lagrangian-ODEs","page":"Tutorial","title":"Integrators for Degenerate Lagrangian ODEs","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Degenerate Lagragian ODEs can be integrated with Degenerate Variational Integrators (see also DegenerateVPRK) or Projected Variational Partitioned Runge-Kutta (ProjectedVPRK) methods.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Function Method\nDVIA Symplectic Euler-A Degenerate Variational Integrator\nDVIB Symplectic Euler-B Degenerate Variational Integrator\nCMDVI Midpoint Degenerate Variational Integrator\nCTDVI Trapezoidal Degenerate Variational Integrator\nDegenerateVPRK Variational Partitioned Runge-Kutta integrator for degenerate Lagrangians\nProjectedVPRK Projected Variational Partitioned Runge-Kutta integrator\n \nVPRKpInternal VPRK integrator with projection on internal stages\nVPRKpLegendre VPRK integrator with Legendre projection\nVPRKpMidpoint VPRK integrator with Midpoint projection\nVPRKpSecondary VPRK integrator with projection on secondary constraint\nVPRKpStandard VPRK integrator with standard projection\nVPRKpSymmetric VPRK integrator with symmetric projection\nVPRKpSymplectic VPRK integrator with symplectic projection\nVPRKpVariational VPRK integrator with variational projection\nVPRKpVariationalP VPRK integrator with variational projection on P\nVPRKpVariationalQ VPRK integrator with variational projection on Q","category":"page"},{"location":"tutorial/#Integrators-for-DAEs","page":"Tutorial","title":"Integrators for DAEs","text":"","category":"section"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"","category":"page"},{"location":"#GeometricIntegrators.jl","page":"Home","title":"GeometricIntegrators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia library of geometric integrators for differential equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: PkgEval Status) (Image: CI) (Image: Coverage) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl is a library of geometric integrators for ordinary differential equations, stochastic differential equations and differential algebraic equations in Julia. Its main purpose is the democratization and proliferation of geometric integrators by providing a comprehensive collection of structure-preserving as well as standard algorithms under a unified interface.  GeometricIntegrators.jl can be used either interactively, as computational core in other codes, or from within DifferentialEquations.jl via GeometricIntegratorsDiffEq.jl. It provides both, a high-level interface that requires only very few lines of code to solve an actual problem, and a lean low-level interface that allows for straightforward integration into application codes via the exchange of minimalistic data structures. In both, the library leaves maximum control to the user. While trying to pick sensible defaults, all settings are accessible to and modifiable by the user. Suitable abstraction layers allow to choose between different linear and nonlinear solvers, auto-differentiation packages or custom routines for the computation of Jacobians and the like.","category":"page"},{"location":"#Package-Description","page":"Home","title":"Package Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Differential equations are ubiquitous in science and engineering. Many equations possess geometric features or abstract mathematical structures that need to be preserved in the discretisation in order to obtain reliable simulation results, especially for nonlinear problems and long-time simulations. The preservation of such properties improves stability, bounds global error growth and reduces numerical artefacts. Robust, performant and structure-preserving solvers for different types of differential equations are thus needed across many disciplines. GeometricIntegrators.jl provides such solvers and makes them available for both direct use as well as integration into other codes. Furthermore, the implemented algorithms can also be used within the DifferentialEquations.jl ecosystem [[1]], which is the defacto standard differential equation solver for the Julia programming language [[2]].","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl provides a comprehensive library of geometric integration algorithms as well as some non-geometric algorithms. It collects native Julia implementations of many known methods under a unified interface. Once a problem is implemented in the GeometricIntegators framework, all of its algorithms can immediately be applied and their performance evaluated. This facilitates numerical experiments with a wide variety of algorithms, simplifies benchmarking, and makes it easy to identify the best algorithm for a given problem. The implemented algorithms include explicit, implicit and partitioned Runge-Kutta methods, SPARK methods, splitting methods, symplectic methods and variational integrators. Most methods are implemented in an abstract way that allows for the flexible choice of tableaus, approximation spaces, basis functions, quadrature rules, and thus order of convergence. It also means that adding e.g. a new Runge-Kutta or splitting method merely amounts to adding its tableau. Less standard algorithms can be added by extending the package with custom integrators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As most geometric integrators are not easily combined with time step adaption in a structure-preserving way, GeometricIntegrators.jl does not provide any general infrastructure for adaptive time stepping. Nonetheless, individual integrators can implement their own adaptivity strategies as long as they provide a solution at a predefined, equidistant series of time steps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"One of the original aims of GeometricIntegrators.jl is to serve as a testbed for the development and analysis of novel algorithms. Due to the modular structure and the use of the multiple dispatch paradigm, the library can easily be extended, e.g., towards new algorithms or new types of equations. The library aims at providing efficient implementations of diverse algorithms in order to be able to perform simulations and benchmarks with millions or even billions of time steps that facilitate the study of the long-time behaviour of both numerical algorithms and dynamical systems. The current scope of applications is mainly small- to mid-size systems of differential equations, e.g., systems of ordinary differential equations or semidiscretisations of partial differential equations with a moderate number of degrees of freedom. It is envisaged that in the future GeometricIntegrators.jl will also be able to address larger problems, especially semidiscretisations of partial differential equations in higher dimensions. In particular, this requires interfaces to appropriate iterative and parallel linear solvers, which are still lacking.","category":"page"},{"location":"#Similar-Software","page":"Home","title":"Similar Software","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package closely related to GeometricIntegrators.jl is DifferentialEquations.jl [[1]]. Although serving similar purposes, the scope of the two libraries is rather different. While DifferentialEquations.jl provides a feature-rich ecosystem for the solution of differential equations, the focus of GeometricIntegrators.jl is on algorithms. While DifferentialEquations.jl is based around adaptive time stepping algorithms, GeometricIntegrators.jl focuses on fixed time step methods, given that structure-preservation is not easily combined with time step adaptivity. Therefore both packages are rather complementary, and GeometricIntegrators.jl can in fact be used as backend for DifferentialEquations.jl via GeometricIntegratorsDiffEq.jl.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"tutorial/tutorial.md\",\n         \"problems.md\",\n         \"methods.md\",\n]","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"modules/methods.md\",\n         \"modules/integrators.md\",\n        #\"modules/discontinuities.md\",\n         \"modules/problems.md\",\n         \"modules/equations.md\",\n        #\"modules/simulations.md\",\n         \"modules/solutions.md\",\n         \"modules/rungekutta.md\",\n         \"modules/rungekutta_partitioned.md\",\n         \"modules/spark.md\",\n]","category":"page"},{"location":"#Developer-Documentation","page":"Home","title":"Developer Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"developer/integrators.md\",\n         \"developer/projections.md\",\n         \"developer/code_integration.md\",\n         \"developer/custom_integrators.md\",\n         \"developer/adaptive_time_stepping.md\",\n]","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use GeometricIntegrators.jl in your work, please consider citing it by","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{Kraus:2020:GeometricIntegrators,\n  title={GeometricIntegrators.jl: Geometric Numerical Integration in Julia},\n  author={Kraus, Michael},\n  year={2020},\n  howpublished={\\url{https://github.com/JuliaGNI/GeometricIntegrators.jl}},\n  doi={10.5281/zenodo.3648325}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricIntegrators.jl contains reference implementation for the methods described in the following articles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Michael Kraus. Projected Variational Integrators for Degenerate Lagrangian Systems. arXiv:1708.07356.\nMichael Kraus and Tomasz M. Tyranowski. Variational Integrators for Stochastic Dissipative Hamiltonian Systems. arXiv:1909.07202, Journal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"References for most of the available Runge-Kutta methods can be found in the documentation of RungeKutta.jl.","category":"page"},{"location":"#Background-Material","page":"Home","title":"Background Material","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ernst Hairer and Christian Lubich. Numerical Solution of Ordinary Differential Equations. The Princeton Companion to Applied Mathematics, 293-305, 2015. Princeton University Press. (Author's Web Site)\nErnst Hairer, Christian Lubich and Gerhard Wanner. Geometric Numerical Integration Illustrated by the Störmer–Verlet Method. Acta Numerica 12, 399-450, 2003. (Journal)\nJohn C. Butcher. Gauss Methods. Encyclopedia of Applied and Computational Mathematics, Pages 583-589, 2015. (Article)\nLaurent O. Jay. Lobatto Methods. Encyclopedia of Applied and Computational Mathematics, Pages 817–826, 2015. (Article)\nErnst Hairer and Gerhard Wanner. Radau Methods. Encyclopedia of Applied and Computational Mathematics, Pages 1213-1216, 2015. (Article)","category":"page"},{"location":"#Books-on-Geometric-Numerical-Integration","page":"Home","title":"Books on Geometric Numerical Integration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sergio Blanes, Fernando Casas. A Concise Introduction to Geometric Numerical Integration. CRC Press, 2016. (eBook)\nErnst Hairer, Christian Lubich and Gerhard Wanner. Geometric Numerical Integration. Springer, 2006. (eBook)\nBenedict Leimkuhler and Sebastian Reich. Simulating Hamiltonian Dynamics. Cambridge University Press, 2005. (eBook)\nJesús Maria Sanz-Serna, Manuel P. Calvo. Numerical Hamiltonian Problems. Chapman Hall, 1994.","category":"page"},{"location":"#Books-on-the-Numerical-Integration-of-Differential-Equations","page":"Home","title":"Books on the Numerical Integration of Differential Equations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ernst Hairer, Syvert P. Nørsett and Gerhard Wanner. Solving Ordinary Differential Equations I: Nonstiff Problems. Springer, 1993. (eBook)\nErnst Hairer and Gerhard Wanner. Solving Ordinary Differential Equations II: Stiff and Differential-Algebraic Problems. Springer, 1996. (eBook)\nErnst Hairer, Christian Lubich, Michel Roche. The Numerical Solution of Differential-Algebraic Systems by Runge-Kutta Methods. Springer, 1989. (eBook)\nPeter Deuflhard, Folkmar Bornemann. Scientific Computing with Ordinary Differential Equations. Springer, 2002. (eBook)\nJohn C. Butcher. Numerical Methods for Ordinary Differential Equations. Wiley, 2016. (eBook)","category":"page"}]
}
